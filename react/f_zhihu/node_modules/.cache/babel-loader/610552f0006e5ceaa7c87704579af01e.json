{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag fall-through cases in switch statements.\r\n * @author Matt DuVall <http://mattduvall.com/>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\n/**\r\n * Checks whether or not a given case has a fallthrough comment.\r\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\r\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\r\n * @param {RuleContext} context A rule context which stores comments.\r\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\r\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\r\n */\n\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\n  const sourceCode = context.getSourceCode();\n\n  if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\n    const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\n    const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\n\n    if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\n      return true;\n    }\n  }\n\n  const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\n  return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n/**\r\n * Checks whether or not a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\r\n * Checks whether a node and a token are separated by blank lines\r\n * @param {ASTNode} node The node to check\r\n * @param {Token} token The token to compare against\r\n * @returns {boolean} `true` if there are blank lines between node and token\r\n */\n\n\nfunction hasBlankLinesBetween(node, token) {\n  return token.loc.start.line > node.loc.end.line + 1;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow fallthrough of `case` statements\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-fallthrough\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        commentPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      case: \"Expected a 'break' statement before 'case'.\",\n      default: \"Expected a 'break' statement before 'default'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    let currentCodePath = null;\n    const sourceCode = context.getSourceCode();\n    /*\r\n     * We need to use leading comments of the next SwitchCase node because\r\n     * trailing comments is wrong if semicolons are omitted.\r\n     */\n\n    let fallthroughCase = null;\n    let fallthroughCommentPattern = null;\n\n    if (options.commentPattern) {\n      fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\n    } else {\n      fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n    }\n\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      SwitchCase(node) {\n        /*\r\n         * Checks whether or not there is a fallthrough comment.\r\n         * And reports the previous fallthrough node if that does not exist.\r\n         */\n        if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\n          context.report({\n            messageId: node.test ? \"case\" : \"default\",\n            node\n          });\n        }\n\n        fallthroughCase = null;\n      },\n\n      \"SwitchCase:exit\"(node) {\n        const nextToken = sourceCode.getTokenAfter(node);\n        /*\r\n         * `reachable` meant fall through because statements preceded by\r\n         * `break`, `return`, or `throw` are unreachable.\r\n         * And allows empty cases and the last case.\r\n         */\n\n        if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && node.parent.cases[node.parent.cases.length - 1] !== node) {\n          fallthroughCase = node;\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-fallthrough.js"],"names":["DEFAULT_FALLTHROUGH_COMMENT","hasFallthroughComment","caseWhichFallsThrough","subsequentCase","context","fallthroughCommentPattern","sourceCode","getSourceCode","consequent","length","type","trailingCloseBrace","getLastToken","commentInBlock","getCommentsBefore","pop","test","value","comment","Boolean","isReachable","segment","reachable","hasBlankLinesBetween","node","token","loc","start","line","end","module","exports","meta","docs","description","recommended","url","schema","properties","commentPattern","default","additionalProperties","messages","case","create","options","currentCodePath","fallthroughCase","RegExp","onCodePathStart","codePath","onCodePathEnd","upper","SwitchCase","report","messageId","nextToken","getTokenAfter","currentSegments","some","parent","cases"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag fall-through cases in switch statements.\r\n * @author Matt DuVall <http://mattduvall.com/>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/iu;\r\n\r\n/**\r\n * Checks whether or not a given case has a fallthrough comment.\r\n * @param {ASTNode} caseWhichFallsThrough SwitchCase node which falls through.\r\n * @param {ASTNode} subsequentCase The case after caseWhichFallsThrough.\r\n * @param {RuleContext} context A rule context which stores comments.\r\n * @param {RegExp} fallthroughCommentPattern A pattern to match comment to.\r\n * @returns {boolean} `true` if the case has a valid fallthrough comment.\r\n */\r\nfunction hasFallthroughComment(caseWhichFallsThrough, subsequentCase, context, fallthroughCommentPattern) {\r\n    const sourceCode = context.getSourceCode();\r\n\r\n    if (caseWhichFallsThrough.consequent.length === 1 && caseWhichFallsThrough.consequent[0].type === \"BlockStatement\") {\r\n        const trailingCloseBrace = sourceCode.getLastToken(caseWhichFallsThrough.consequent[0]);\r\n        const commentInBlock = sourceCode.getCommentsBefore(trailingCloseBrace).pop();\r\n\r\n        if (commentInBlock && fallthroughCommentPattern.test(commentInBlock.value)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    const comment = sourceCode.getCommentsBefore(subsequentCase).pop();\r\n\r\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\r\n}\r\n\r\n/**\r\n * Checks whether or not a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n/**\r\n * Checks whether a node and a token are separated by blank lines\r\n * @param {ASTNode} node The node to check\r\n * @param {Token} token The token to compare against\r\n * @returns {boolean} `true` if there are blank lines between node and token\r\n */\r\nfunction hasBlankLinesBetween(node, token) {\r\n    return token.loc.start.line > node.loc.end.line + 1;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow fallthrough of `case` statements\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-fallthrough\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    commentPattern: {\r\n                        type: \"string\",\r\n                        default: \"\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            case: \"Expected a 'break' statement before 'case'.\",\r\n            default: \"Expected a 'break' statement before 'default'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        let currentCodePath = null;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /*\r\n         * We need to use leading comments of the next SwitchCase node because\r\n         * trailing comments is wrong if semicolons are omitted.\r\n         */\r\n        let fallthroughCase = null;\r\n        let fallthroughCommentPattern = null;\r\n\r\n        if (options.commentPattern) {\r\n            fallthroughCommentPattern = new RegExp(options.commentPattern, \"u\");\r\n        } else {\r\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\r\n        }\r\n\r\n        return {\r\n            onCodePathStart(codePath) {\r\n                currentCodePath = codePath;\r\n            },\r\n            onCodePathEnd() {\r\n                currentCodePath = currentCodePath.upper;\r\n            },\r\n\r\n            SwitchCase(node) {\r\n\r\n                /*\r\n                 * Checks whether or not there is a fallthrough comment.\r\n                 * And reports the previous fallthrough node if that does not exist.\r\n                 */\r\n                if (fallthroughCase && !hasFallthroughComment(fallthroughCase, node, context, fallthroughCommentPattern)) {\r\n                    context.report({\r\n                        messageId: node.test ? \"case\" : \"default\",\r\n                        node\r\n                    });\r\n                }\r\n                fallthroughCase = null;\r\n            },\r\n\r\n            \"SwitchCase:exit\"(node) {\r\n                const nextToken = sourceCode.getTokenAfter(node);\r\n\r\n                /*\r\n                 * `reachable` meant fall through because statements preceded by\r\n                 * `break`, `return`, or `throw` are unreachable.\r\n                 * And allows empty cases and the last case.\r\n                 */\r\n                if (currentCodePath.currentSegments.some(isReachable) &&\r\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\r\n                    node.parent.cases[node.parent.cases.length - 1] !== node) {\r\n                    fallthroughCase = node;\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}