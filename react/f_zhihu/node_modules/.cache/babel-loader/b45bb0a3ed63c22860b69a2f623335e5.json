{"ast":null,"code":"/**\r\n * @fileoverview Rule to require braces in arrow function body.\r\n * @author Alberto Rodríguez\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require braces around arrow function bodies\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-body-style\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"never\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            requireReturnForObjectLiteral: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\n      unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\n      unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\n      unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\n      expectedBlock: \"Expected block statement surrounding arrow body.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options;\n    const always = options[0] === \"always\";\n    const asNeeded = !options[0] || options[0] === \"as-needed\";\n    const never = options[0] === \"never\";\n    const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n    /**\r\n     * Checks whether the given node has ASI problem or not.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\r\n     */\n\n    function hasASIProblem(token) {\n      return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\n    }\n    /**\r\n     * Gets the closing parenthesis by the given node.\r\n     * @param {ASTNode} node first node after an opening parenthesis.\r\n     * @returns {Token} The found closing parenthesis token.\r\n     */\n\n\n    function findClosingParen(node) {\n      let nodeToCheck = node;\n\n      while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\n        nodeToCheck = nodeToCheck.parent;\n      }\n\n      return sourceCode.getTokenAfter(nodeToCheck);\n    }\n    /**\r\n     * Check whether the node is inside of a for loop's init\r\n     * @param {ASTNode} node node is inside for loop\r\n     * @returns {boolean} `true` if the node is inside of a for loop, else `false`\r\n     */\n\n\n    function isInsideForLoopInitializer(node) {\n      if (node && node.parent) {\n        if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\n          return true;\n        }\n\n        return isInsideForLoopInitializer(node.parent);\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines whether a arrow function body needs braces\r\n     * @param {ASTNode} node The arrow function node.\r\n     * @returns {void}\r\n     */\n\n\n    function validate(node) {\n      const arrowBody = node.body;\n\n      if (arrowBody.type === \"BlockStatement\") {\n        const blockBody = arrowBody.body;\n\n        if (blockBody.length !== 1 && !never) {\n          return;\n        }\n\n        if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" && blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\n          return;\n        }\n\n        if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\n          let messageId;\n\n          if (blockBody.length === 0) {\n            messageId = \"unexpectedEmptyBlock\";\n          } else if (blockBody.length > 1) {\n            messageId = \"unexpectedOtherBlock\";\n          } else if (blockBody[0].argument === null) {\n            messageId = \"unexpectedSingleBlock\";\n          } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {\n            skip: 1\n          }))) {\n            messageId = \"unexpectedObjectBlock\";\n          } else {\n            messageId = \"unexpectedSingleBlock\";\n          }\n\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId,\n\n            fix(fixer) {\n              const fixes = [];\n\n              if (blockBody.length !== 1 || blockBody[0].type !== \"ReturnStatement\" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {\n                return fixes;\n              }\n\n              const openingBrace = sourceCode.getFirstToken(arrowBody);\n              const closingBrace = sourceCode.getLastToken(arrowBody);\n              const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\n              const lastValueToken = sourceCode.getLastToken(blockBody[0]);\n              const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);\n              /*\r\n               * Remove tokens around the return value.\r\n               * If comments don't exist, remove extra spaces as well.\r\n               */\n\n              if (commentsExist) {\n                fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\n                );\n              } else {\n                fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));\n              }\n              /*\r\n               * If the first token of the return value is `{` or the return value is a sequence expression,\r\n               * enclose the return value by parentheses to avoid syntax error.\r\n               */\n\n\n              if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {\n                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\n                  fixes.push(fixer.insertTextBefore(firstValueToken, \"(\"), fixer.insertTextAfter(lastValueToken, \")\"));\n                }\n              }\n              /*\r\n               * If the last token of the return statement is semicolon, remove it.\r\n               * Non-block arrow body is an expression, not a statement.\r\n               */\n\n\n              if (astUtils.isSemicolonToken(lastValueToken)) {\n                fixes.push(fixer.remove(lastValueToken));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      } else {\n        if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\") {\n          context.report({\n            node,\n            loc: arrowBody.loc,\n            messageId: \"expectedBlock\",\n\n            fix(fixer) {\n              const fixes = [];\n              const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\n              const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {\n                count: 2\n              });\n              const lastToken = sourceCode.getLastToken(node);\n              let parenthesisedObjectLiteral = null;\n\n              if (astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow)) {\n                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\n\n                if (braceNode.type === \"ObjectExpression\") {\n                  parenthesisedObjectLiteral = braceNode;\n                }\n              } // If the value is object literal, remove parentheses which were forced by syntax.\n\n\n              if (parenthesisedObjectLiteral) {\n                const openingParenToken = firstTokenAfterArrow;\n                const openingBraceToken = secondTokenAfterArrow;\n\n                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\n                  fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\n                } else {\n                  // Avoid ASI\n                  fixes.push(fixer.replaceText(openingParenToken, \"{\"), fixer.insertTextBefore(openingBraceToken, \"return \"));\n                } // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\n\n\n                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              } else {\n                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\n                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\n              }\n\n              return fixes;\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      \"BinaryExpression[operator='in']\"() {\n        let info = funcInfo;\n\n        while (info) {\n          info.hasInOperator = true;\n          info = info.upper;\n        }\n      },\n\n      ArrowFunctionExpression() {\n        funcInfo = {\n          upper: funcInfo,\n          hasInOperator: false\n        };\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        validate(node);\n        funcInfo = funcInfo.upper;\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/arrow-body-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","requireReturnForObjectLiteral","additionalProperties","fixable","messages","unexpectedOtherBlock","unexpectedEmptyBlock","unexpectedObjectBlock","unexpectedSingleBlock","expectedBlock","create","context","options","always","asNeeded","never","sourceCode","getSourceCode","funcInfo","hasASIProblem","token","test","value","findClosingParen","node","nodeToCheck","isParenthesised","parent","getTokenAfter","isInsideForLoopInitializer","init","validate","arrowBody","body","blockBody","length","argument","messageId","isOpeningBraceToken","getFirstToken","skip","report","loc","fix","fixer","fixes","openingBrace","closingBrace","getLastToken","firstValueToken","lastValueToken","commentsExist","commentsExistBetween","push","remove","removeRange","range","hasInOperator","insertTextBefore","insertTextAfter","isSemicolonToken","arrowToken","getTokenBefore","isArrowToken","firstTokenAfterArrow","secondTokenAfterArrow","getTokensAfter","count","lastToken","parenthesisedObjectLiteral","isOpeningParenToken","braceNode","getNodeByRangeIndex","openingParenToken","openingBraceToken","isTokenOnSameLine","replaceText","info","upper","ArrowFunctionExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require braces in arrow function body.\r\n * @author Alberto Rodríguez\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require braces around arrow function bodies\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/arrow-body-style\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"never\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 1\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"as-needed\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                requireReturnForObjectLiteral: { type: \"boolean\" }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpectedOtherBlock: \"Unexpected block statement surrounding arrow body.\",\r\n            unexpectedEmptyBlock: \"Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.\",\r\n            unexpectedObjectBlock: \"Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.\",\r\n            unexpectedSingleBlock: \"Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.\",\r\n            expectedBlock: \"Expected block statement surrounding arrow body.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options;\r\n        const always = options[0] === \"always\";\r\n        const asNeeded = !options[0] || options[0] === \"as-needed\";\r\n        const never = options[0] === \"never\";\r\n        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;\r\n        const sourceCode = context.getSourceCode();\r\n        let funcInfo = null;\r\n\r\n        /**\r\n         * Checks whether the given node has ASI problem or not.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} `true` if it changes semantics if `;` or `}` followed by the token are removed.\r\n         */\r\n        function hasASIProblem(token) {\r\n            return token && token.type === \"Punctuator\" && /^[([/`+-]/u.test(token.value);\r\n        }\r\n\r\n        /**\r\n         * Gets the closing parenthesis by the given node.\r\n         * @param {ASTNode} node first node after an opening parenthesis.\r\n         * @returns {Token} The found closing parenthesis token.\r\n         */\r\n        function findClosingParen(node) {\r\n            let nodeToCheck = node;\r\n\r\n            while (!astUtils.isParenthesised(sourceCode, nodeToCheck)) {\r\n                nodeToCheck = nodeToCheck.parent;\r\n            }\r\n            return sourceCode.getTokenAfter(nodeToCheck);\r\n        }\r\n\r\n        /**\r\n         * Check whether the node is inside of a for loop's init\r\n         * @param {ASTNode} node node is inside for loop\r\n         * @returns {boolean} `true` if the node is inside of a for loop, else `false`\r\n         */\r\n        function isInsideForLoopInitializer(node) {\r\n            if (node && node.parent) {\r\n                if (node.parent.type === \"ForStatement\" && node.parent.init === node) {\r\n                    return true;\r\n                }\r\n                return isInsideForLoopInitializer(node.parent);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines whether a arrow function body needs braces\r\n         * @param {ASTNode} node The arrow function node.\r\n         * @returns {void}\r\n         */\r\n        function validate(node) {\r\n            const arrowBody = node.body;\r\n\r\n            if (arrowBody.type === \"BlockStatement\") {\r\n                const blockBody = arrowBody.body;\r\n\r\n                if (blockBody.length !== 1 && !never) {\r\n                    return;\r\n                }\r\n\r\n                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === \"ReturnStatement\" &&\r\n                    blockBody[0].argument && blockBody[0].argument.type === \"ObjectExpression\") {\r\n                    return;\r\n                }\r\n\r\n                if (never || asNeeded && blockBody[0].type === \"ReturnStatement\") {\r\n                    let messageId;\r\n\r\n                    if (blockBody.length === 0) {\r\n                        messageId = \"unexpectedEmptyBlock\";\r\n                    } else if (blockBody.length > 1) {\r\n                        messageId = \"unexpectedOtherBlock\";\r\n                    } else if (blockBody[0].argument === null) {\r\n                        messageId = \"unexpectedSingleBlock\";\r\n                    } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], { skip: 1 }))) {\r\n                        messageId = \"unexpectedObjectBlock\";\r\n                    } else {\r\n                        messageId = \"unexpectedSingleBlock\";\r\n                    }\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: arrowBody.loc,\r\n                        messageId,\r\n                        fix(fixer) {\r\n                            const fixes = [];\r\n\r\n                            if (blockBody.length !== 1 ||\r\n                                blockBody[0].type !== \"ReturnStatement\" ||\r\n                                !blockBody[0].argument ||\r\n                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))\r\n                            ) {\r\n                                return fixes;\r\n                            }\r\n\r\n                            const openingBrace = sourceCode.getFirstToken(arrowBody);\r\n                            const closingBrace = sourceCode.getLastToken(arrowBody);\r\n                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);\r\n                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);\r\n                            const commentsExist =\r\n                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||\r\n                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);\r\n\r\n                            /*\r\n                             * Remove tokens around the return value.\r\n                             * If comments don't exist, remove extra spaces as well.\r\n                             */\r\n                            if (commentsExist) {\r\n                                fixes.push(\r\n                                    fixer.remove(openingBrace),\r\n                                    fixer.remove(closingBrace),\r\n                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword\r\n                                );\r\n                            } else {\r\n                                fixes.push(\r\n                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),\r\n                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])\r\n                                );\r\n                            }\r\n\r\n                            /*\r\n                             * If the first token of the return value is `{` or the return value is a sequence expression,\r\n                             * enclose the return value by parentheses to avoid syntax error.\r\n                             */\r\n                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === \"SequenceExpression\" || (funcInfo.hasInOperator && isInsideForLoopInitializer(node))) {\r\n                                if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {\r\n                                    fixes.push(\r\n                                        fixer.insertTextBefore(firstValueToken, \"(\"),\r\n                                        fixer.insertTextAfter(lastValueToken, \")\")\r\n                                    );\r\n                                }\r\n                            }\r\n\r\n                            /*\r\n                             * If the last token of the return statement is semicolon, remove it.\r\n                             * Non-block arrow body is an expression, not a statement.\r\n                             */\r\n                            if (astUtils.isSemicolonToken(lastValueToken)) {\r\n                                fixes.push(fixer.remove(lastValueToken));\r\n                            }\r\n\r\n                            return fixes;\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === \"ObjectExpression\")) {\r\n                    context.report({\r\n                        node,\r\n                        loc: arrowBody.loc,\r\n                        messageId: \"expectedBlock\",\r\n                        fix(fixer) {\r\n                            const fixes = [];\r\n                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);\r\n                            const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, { count: 2 });\r\n                            const lastToken = sourceCode.getLastToken(node);\r\n\r\n                            let parenthesisedObjectLiteral = null;\r\n\r\n                            if (\r\n                                astUtils.isOpeningParenToken(firstTokenAfterArrow) &&\r\n                                astUtils.isOpeningBraceToken(secondTokenAfterArrow)\r\n                            ) {\r\n                                const braceNode = sourceCode.getNodeByRangeIndex(secondTokenAfterArrow.range[0]);\r\n\r\n                                if (braceNode.type === \"ObjectExpression\") {\r\n                                    parenthesisedObjectLiteral = braceNode;\r\n                                }\r\n                            }\r\n\r\n                            // If the value is object literal, remove parentheses which were forced by syntax.\r\n                            if (parenthesisedObjectLiteral) {\r\n                                const openingParenToken = firstTokenAfterArrow;\r\n                                const openingBraceToken = secondTokenAfterArrow;\r\n\r\n                                if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {\r\n                                    fixes.push(fixer.replaceText(openingParenToken, \"{return \"));\r\n                                } else {\r\n\r\n                                    // Avoid ASI\r\n                                    fixes.push(\r\n                                        fixer.replaceText(openingParenToken, \"{\"),\r\n                                        fixer.insertTextBefore(openingBraceToken, \"return \")\r\n                                    );\r\n                                }\r\n\r\n                                // Closing paren for the object doesn't have to be lastToken, e.g.: () => ({}).foo()\r\n                                fixes.push(fixer.remove(findClosingParen(parenthesisedObjectLiteral)));\r\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\r\n\r\n                            } else {\r\n                                fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, \"{return \"));\r\n                                fixes.push(fixer.insertTextAfter(lastToken, \"}\"));\r\n                            }\r\n\r\n                            return fixes;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"BinaryExpression[operator='in']\"() {\r\n                let info = funcInfo;\r\n\r\n                while (info) {\r\n                    info.hasInOperator = true;\r\n                    info = info.upper;\r\n                }\r\n            },\r\n            ArrowFunctionExpression() {\r\n                funcInfo = {\r\n                    upper: funcInfo,\r\n                    hasInOperator: false\r\n                };\r\n            },\r\n            \"ArrowFunctionExpression:exit\"(node) {\r\n                validate(node);\r\n                funcInfo = funcInfo.upper;\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}