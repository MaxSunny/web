{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow useless backreferences in regular expressions\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst parser = new RegExpParser();\n/**\r\n * Finds the path from the given `regexpp` AST node to the root node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\r\n */\n\nfunction getPathToRoot(node) {\n  const path = [];\n  let current = node;\n\n  do {\n    path.push(current);\n    current = current.parent;\n  } while (current);\n\n  return path;\n}\n/**\r\n * Determines whether the given `regexpp` AST node is a lookaround node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {boolean} `true` if it is a lookaround node.\r\n */\n\n\nfunction isLookaround(node) {\n  return node.type === \"Assertion\" && (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\n}\n/**\r\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {boolean} `true` if it is a negative lookaround node.\r\n */\n\n\nfunction isNegativeLookaround(node) {\n  return isLookaround(node) && node.negate;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow useless backreferences in regular expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-backreference\"\n    },\n    schema: [],\n    messages: {\n      nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\n      forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\n      backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\n      disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\n      intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Checks and reports useless backreferences in the given regular expression.\r\n     * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\r\n     * @param {string} pattern Regular expression pattern.\r\n     * @param {string} flags Regular expression flags.\r\n     * @returns {void}\r\n     */\n    function checkRegex(node, pattern, flags) {\n      let regExpAST;\n\n      try {\n        regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      visitRegExpAST(regExpAST, {\n        onBackreferenceEnter(bref) {\n          const group = bref.resolved,\n                brefPath = getPathToRoot(bref),\n                groupPath = getPathToRoot(group);\n          let messageId = null;\n\n          if (brefPath.includes(group)) {\n            // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\n            messageId = \"nested\";\n          } else {\n            // Start from the root to find the lowest common ancestor.\n            let i = brefPath.length - 1,\n                j = groupPath.length - 1;\n\n            do {\n              i--;\n              j--;\n            } while (brefPath[i] === groupPath[j]);\n\n            const indexOfLowestCommonAncestor = j + 1,\n                  groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\n                  commonPath = groupPath.slice(indexOfLowestCommonAncestor),\n                  lowestCommonLookaround = commonPath.find(isLookaround),\n                  isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\n\n            if (!isMatchingBackward && bref.end <= group.start) {\n              // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\n              messageId = \"forward\";\n            } else if (isMatchingBackward && group.end <= bref.start) {\n              // the opposite of the previous when the regex is matching backward in a lookbehind context.\n              messageId = \"backward\";\n            } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\n              // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\n              messageId = \"disjunctive\";\n            } else if (groupCut.some(isNegativeLookaround)) {\n              // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\n              messageId = \"intoNegativeLookaround\";\n            }\n          }\n\n          if (messageId) {\n            context.report({\n              node,\n              messageId,\n              data: {\n                bref: bref.raw,\n                group: group.raw\n              }\n            });\n          }\n        }\n\n      });\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        const {\n          pattern,\n          flags\n        } = node.regex;\n        checkRegex(node, pattern, flags);\n      },\n\n      Program() {\n        const scope = context.getScope(),\n              tracker = new ReferenceTracker(scope),\n              traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          const [patternNode, flagsNode] = node.arguments,\n                pattern = getStringIfConstant(patternNode, scope),\n                flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            checkRegex(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-backreference.js"],"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","parser","getPathToRoot","node","path","current","push","parent","isLookaround","type","kind","isNegativeLookaround","negate","module","exports","meta","docs","description","recommended","url","schema","messages","nested","forward","backward","disjunctive","intoNegativeLookaround","create","context","checkRegex","pattern","flags","regExpAST","parsePattern","length","includes","onBackreferenceEnter","bref","group","resolved","brefPath","groupPath","messageId","i","j","indexOfLowestCommonAncestor","groupCut","slice","commonPath","lowestCommonLookaround","find","isMatchingBackward","end","start","some","report","data","raw","regex","Program","scope","getScope","tracker","traceMap","RegExp","iterateGlobalReferences","patternNode","flagsNode","arguments"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow useless backreferences in regular expressions\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\r\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst parser = new RegExpParser();\r\n\r\n/**\r\n * Finds the path from the given `regexpp` AST node to the root node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {regexpp.Node[]} Array that starts with the given node and ends with the root node.\r\n */\r\nfunction getPathToRoot(node) {\r\n    const path = [];\r\n    let current = node;\r\n\r\n    do {\r\n        path.push(current);\r\n        current = current.parent;\r\n    } while (current);\r\n\r\n    return path;\r\n}\r\n\r\n/**\r\n * Determines whether the given `regexpp` AST node is a lookaround node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {boolean} `true` if it is a lookaround node.\r\n */\r\nfunction isLookaround(node) {\r\n    return node.type === \"Assertion\" &&\r\n        (node.kind === \"lookahead\" || node.kind === \"lookbehind\");\r\n}\r\n\r\n/**\r\n * Determines whether the given `regexpp` AST node is a negative lookaround node.\r\n * @param {regexpp.Node} node Node.\r\n * @returns {boolean} `true` if it is a negative lookaround node.\r\n */\r\nfunction isNegativeLookaround(node) {\r\n    return isLookaround(node) && node.negate;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow useless backreferences in regular expressions\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-useless-backreference\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            nested: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.\",\r\n            forward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.\",\r\n            backward: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.\",\r\n            disjunctive: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.\",\r\n            intoNegativeLookaround: \"Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Checks and reports useless backreferences in the given regular expression.\r\n         * @param {ASTNode} node Node that represents regular expression. A regex literal or RegExp constructor call.\r\n         * @param {string} pattern Regular expression pattern.\r\n         * @param {string} flags Regular expression flags.\r\n         * @returns {void}\r\n         */\r\n        function checkRegex(node, pattern, flags) {\r\n            let regExpAST;\r\n\r\n            try {\r\n                regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\r\n            } catch {\r\n\r\n                // Ignore regular expressions with syntax errors\r\n                return;\r\n            }\r\n\r\n            visitRegExpAST(regExpAST, {\r\n                onBackreferenceEnter(bref) {\r\n                    const group = bref.resolved,\r\n                        brefPath = getPathToRoot(bref),\r\n                        groupPath = getPathToRoot(group);\r\n                    let messageId = null;\r\n\r\n                    if (brefPath.includes(group)) {\r\n\r\n                        // group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.\r\n                        messageId = \"nested\";\r\n                    } else {\r\n\r\n                        // Start from the root to find the lowest common ancestor.\r\n                        let i = brefPath.length - 1,\r\n                            j = groupPath.length - 1;\r\n\r\n                        do {\r\n                            i--;\r\n                            j--;\r\n                        } while (brefPath[i] === groupPath[j]);\r\n\r\n                        const indexOfLowestCommonAncestor = j + 1,\r\n                            groupCut = groupPath.slice(0, indexOfLowestCommonAncestor),\r\n                            commonPath = groupPath.slice(indexOfLowestCommonAncestor),\r\n                            lowestCommonLookaround = commonPath.find(isLookaround),\r\n                            isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === \"lookbehind\";\r\n\r\n                        if (!isMatchingBackward && bref.end <= group.start) {\r\n\r\n                            // bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.\r\n                            messageId = \"forward\";\r\n                        } else if (isMatchingBackward && group.end <= bref.start) {\r\n\r\n                            // the opposite of the previous when the regex is matching backward in a lookbehind context.\r\n                            messageId = \"backward\";\r\n                        } else if (groupCut[groupCut.length - 1].type === \"Alternative\") {\r\n\r\n                            // group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.\r\n                            messageId = \"disjunctive\";\r\n                        } else if (groupCut.some(isNegativeLookaround)) {\r\n\r\n                            // group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.\r\n                            messageId = \"intoNegativeLookaround\";\r\n                        }\r\n                    }\r\n\r\n                    if (messageId) {\r\n                        context.report({\r\n                            node,\r\n                            messageId,\r\n                            data: {\r\n                                bref: bref.raw,\r\n                                group: group.raw\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            \"Literal[regex]\"(node) {\r\n                const { pattern, flags } = node.regex;\r\n\r\n                checkRegex(node, pattern, flags);\r\n            },\r\n            Program() {\r\n                const scope = context.getScope(),\r\n                    tracker = new ReferenceTracker(scope),\r\n                    traceMap = {\r\n                        RegExp: {\r\n                            [CALL]: true,\r\n                            [CONSTRUCT]: true\r\n                        }\r\n                    };\r\n\r\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\r\n                    const [patternNode, flagsNode] = node.arguments,\r\n                        pattern = getStringIfConstant(patternNode, scope),\r\n                        flags = getStringIfConstant(flagsNode, scope);\r\n\r\n                    if (typeof pattern === \"string\") {\r\n                        checkRegex(node, pattern, flags || \"\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}