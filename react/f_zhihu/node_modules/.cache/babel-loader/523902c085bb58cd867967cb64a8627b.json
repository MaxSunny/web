{"ast":null,"code":"/**\r\n * @fileoverview Enforce newlines between operands of ternary expressions\r\n * @author Kai Cataldo\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce newlines between operands of ternary expressions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/multiline-ternary\"\n    },\n    schema: [{\n      enum: [\"always\", \"always-multiline\", \"never\"]\n    }],\n    messages: {\n      expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\n      expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\n      unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\n      unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\n    },\n    fixable: \"whitespace\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0];\n    const multiline = option !== \"never\";\n    const allowSingleLine = option === \"always-multiline\"; //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      ConditionalExpression(node) {\n        const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\n        const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\n        const firstTokenOfTest = sourceCode.getFirstToken(node);\n        const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\n        const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\n        const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\n        const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\n        const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\n        const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\n        const hasComments = !!sourceCode.getCommentsInside(node).length;\n\n        if (!multiline) {\n          if (!areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"unexpectedTestCons\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\n                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\n\n                if (!areTestAndQuestionOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\n                }\n\n                if (!areQuestionAndConsOnSameLine) {\n                  fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n\n          if (!areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"unexpectedConsAlt\",\n              fix: fixer => {\n                if (hasComments) {\n                  return null;\n                }\n\n                const fixers = [];\n                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\n                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\n\n                if (!areConsAndColonOnSameLine) {\n                  fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\n                }\n\n                if (!areColonAndAltOnSameLine) {\n                  fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\n                }\n\n                return fixers;\n              }\n            });\n          }\n        } else {\n          if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\n            return;\n          }\n\n          if (areTestAndConsequentOnSameLine) {\n            context.report({\n              node: node.test,\n              loc: {\n                start: firstTokenOfTest.loc.start,\n                end: lastTokenOfTest.loc.end\n              },\n              messageId: \"expectedTestCons\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfTest.range[1], questionToken.range[0]], \"\\n\")\n            });\n          }\n\n          if (areConsequentAndAlternateOnSameLine) {\n            context.report({\n              node: node.consequent,\n              loc: {\n                start: firstTokenOfConsequent.loc.start,\n                end: lastTokenOfConsequent.loc.end\n              },\n              messageId: \"expectedConsAlt\",\n              fix: fixer => hasComments ? null : fixer.replaceTextRange([lastTokenOfConsequent.range[1], colonToken.range[0]], \"\\n\")\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/multiline-ternary.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","messages","expectedTestCons","expectedConsAlt","unexpectedTestCons","unexpectedConsAlt","fixable","create","context","sourceCode","getSourceCode","option","options","multiline","allowSingleLine","ConditionalExpression","node","questionToken","getTokenAfter","test","isNotClosingParenToken","colonToken","consequent","firstTokenOfTest","getFirstToken","lastTokenOfTest","getTokenBefore","firstTokenOfConsequent","lastTokenOfConsequent","firstTokenOfAlternate","areTestAndConsequentOnSameLine","isTokenOnSameLine","areConsequentAndAlternateOnSameLine","hasComments","getCommentsInside","length","report","loc","start","end","messageId","fix","fixer","fixers","areTestAndQuestionOnSameLine","areQuestionAndConsOnSameLine","push","removeRange","range","areConsAndColonOnSameLine","areColonAndAltOnSameLine","line","replaceTextRange"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Enforce newlines between operands of ternary expressions\r\n * @author Kai Cataldo\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce newlines between operands of ternary expressions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/multiline-ternary\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"always-multiline\", \"never\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            expectedTestCons: \"Expected newline between test and consequent of ternary expression.\",\r\n            expectedConsAlt: \"Expected newline between consequent and alternate of ternary expression.\",\r\n            unexpectedTestCons: \"Unexpected newline between test and consequent of ternary expression.\",\r\n            unexpectedConsAlt: \"Unexpected newline between consequent and alternate of ternary expression.\"\r\n        },\r\n\r\n        fixable: \"whitespace\"\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const option = context.options[0];\r\n        const multiline = option !== \"never\";\r\n        const allowSingleLine = option === \"always-multiline\";\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            ConditionalExpression(node) {\r\n                const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);\r\n                const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);\r\n\r\n                const firstTokenOfTest = sourceCode.getFirstToken(node);\r\n                const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);\r\n                const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);\r\n                const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);\r\n                const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);\r\n\r\n                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);\r\n                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);\r\n\r\n                const hasComments = !!sourceCode.getCommentsInside(node).length;\r\n\r\n                if (!multiline) {\r\n                    if (!areTestAndConsequentOnSameLine) {\r\n                        context.report({\r\n                            node: node.test,\r\n                            loc: {\r\n                                start: firstTokenOfTest.loc.start,\r\n                                end: lastTokenOfTest.loc.end\r\n                            },\r\n                            messageId: \"unexpectedTestCons\",\r\n                            fix: fixer => {\r\n                                if (hasComments) {\r\n                                    return null;\r\n                                }\r\n                                const fixers = [];\r\n                                const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);\r\n                                const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);\r\n\r\n                                if (!areTestAndQuestionOnSameLine) {\r\n                                    fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));\r\n                                }\r\n                                if (!areQuestionAndConsOnSameLine) {\r\n                                    fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));\r\n                                }\r\n\r\n                                return fixers;\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    if (!areConsequentAndAlternateOnSameLine) {\r\n                        context.report({\r\n                            node: node.consequent,\r\n                            loc: {\r\n                                start: firstTokenOfConsequent.loc.start,\r\n                                end: lastTokenOfConsequent.loc.end\r\n                            },\r\n                            messageId: \"unexpectedConsAlt\",\r\n                            fix: fixer => {\r\n                                if (hasComments) {\r\n                                    return null;\r\n                                }\r\n                                const fixers = [];\r\n                                const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);\r\n                                const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);\r\n\r\n                                if (!areConsAndColonOnSameLine) {\r\n                                    fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));\r\n                                }\r\n                                if (!areColonAndAltOnSameLine) {\r\n                                    fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));\r\n                                }\r\n\r\n                                return fixers;\r\n                            }\r\n                        });\r\n                    }\r\n                } else {\r\n                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) {\r\n                        return;\r\n                    }\r\n\r\n                    if (areTestAndConsequentOnSameLine) {\r\n                        context.report({\r\n                            node: node.test,\r\n                            loc: {\r\n                                start: firstTokenOfTest.loc.start,\r\n                                end: lastTokenOfTest.loc.end\r\n                            },\r\n                            messageId: \"expectedTestCons\",\r\n                            fix: fixer => (hasComments ? null : (\r\n                                fixer.replaceTextRange(\r\n                                    [\r\n                                        lastTokenOfTest.range[1],\r\n                                        questionToken.range[0]\r\n                                    ],\r\n                                    \"\\n\"\r\n                                )\r\n                            ))\r\n                        });\r\n                    }\r\n\r\n                    if (areConsequentAndAlternateOnSameLine) {\r\n                        context.report({\r\n                            node: node.consequent,\r\n                            loc: {\r\n                                start: firstTokenOfConsequent.loc.start,\r\n                                end: lastTokenOfConsequent.loc.end\r\n                            },\r\n                            messageId: \"expectedConsAlt\",\r\n                            fix: (fixer => (hasComments ? null : (\r\n                                fixer.replaceTextRange(\r\n                                    [\r\n                                        lastTokenOfConsequent.range[1],\r\n                                        colonToken.range[0]\r\n                                    ],\r\n                                    \"\\n\"\r\n                                )\r\n                            )))\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}