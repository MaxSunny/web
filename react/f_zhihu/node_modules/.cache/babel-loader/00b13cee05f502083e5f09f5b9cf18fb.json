{"ast":null,"code":"/**\r\n * @fileoverview A rule to disallow the type conversions with shorter notations.\r\n * @author Toru Nagashima\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n/**\r\n * Parses and normalizes an option object.\r\n * @param {Object} options An option object to parse.\r\n * @returns {Object} The parsed and normalized option object.\r\n */\n\nfunction parseOptions(options) {\n  return {\n    boolean: \"boolean\" in options ? options.boolean : true,\n    number: \"number\" in options ? options.number : true,\n    string: \"string\" in options ? options.string : true,\n    disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\n    allow: options.allow || []\n  };\n}\n/**\r\n * Checks whether or not a node is a double logical nigating.\r\n * @param {ASTNode} node An UnaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a double logical nigating.\r\n */\n\n\nfunction isDoubleLogicalNegating(node) {\n  return node.operator === \"!\" && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n}\n/**\r\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\r\n * @param {ASTNode} node An UnaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\r\n */\n\n\nfunction isBinaryNegatingOfIndexOf(node) {\n  if (node.operator !== \"~\") {\n    return false;\n  }\n\n  const callNode = astUtils.skipChainExpression(node.argument);\n  return callNode.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);\n}\n/**\r\n * Checks whether or not a node is a multiplying by one.\r\n * @param {BinaryExpression} node A BinaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a multiplying by one.\r\n */\n\n\nfunction isMultiplyByOne(node) {\n  return node.operator === \"*\" && (node.left.type === \"Literal\" && node.left.value === 1 || node.right.type === \"Literal\" && node.right.value === 1);\n}\n/**\r\n * Checks whether the result of a node is numeric or not\r\n * @param {ASTNode} node The node to test\r\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\r\n */\n\n\nfunction isNumeric(node) {\n  return node.type === \"Literal\" && typeof node.value === \"number\" || node.type === \"CallExpression\" && (node.callee.name === \"Number\" || node.callee.name === \"parseInt\" || node.callee.name === \"parseFloat\");\n}\n/**\r\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\r\n * used from bottom to up since it walks up the BinaryExpression trees using\r\n * node.parent to find the result.\r\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\r\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\r\n */\n\n\nfunction getNonNumericOperand(node) {\n  const left = node.left,\n        right = node.right;\n\n  if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n    return right;\n  }\n\n  if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n    return left;\n  }\n\n  return null;\n}\n/**\r\n * Checks whether an expression evaluates to a string.\r\n * @param {ASTNode} node node that represents the expression to check.\r\n * @returns {boolean} Whether or not the expression evaluates to a string.\r\n */\n\n\nfunction isStringType(node) {\n  return astUtils.isStringLiteral(node) || node.type === \"CallExpression\" && node.callee.type === \"Identifier\" && node.callee.name === \"String\";\n}\n/**\r\n * Checks whether a node is an empty string literal or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} Whether or not the passed in node is an\r\n * empty string literal or not.\r\n */\n\n\nfunction isEmptyString(node) {\n  return astUtils.isStringLiteral(node) && (node.value === \"\" || node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\");\n}\n/**\r\n * Checks whether or not a node is a concatenating with an empty string.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\r\n */\n\n\nfunction isConcatWithEmptyString(node) {\n  return node.operator === \"+\" && (isEmptyString(node.left) && !isStringType(node.right) || isEmptyString(node.right) && !isStringType(node.left));\n}\n/**\r\n * Checks whether or not a node is appended with an empty string.\r\n * @param {ASTNode} node An AssignmentExpression node to check.\r\n * @returns {boolean} Whether or not the node is appended with an empty string.\r\n */\n\n\nfunction isAppendEmptyString(node) {\n  return node.operator === \"+=\" && isEmptyString(node.right);\n}\n/**\r\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\r\n * @param {ASTNode} node The flagged BinaryExpression node to check.\r\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\r\n */\n\n\nfunction getNonEmptyOperand(node) {\n  return isEmptyString(node.left) ? node.right : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow shorthand type conversions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        boolean: {\n          type: \"boolean\",\n          default: true\n        },\n        number: {\n          type: \"boolean\",\n          default: true\n        },\n        string: {\n          type: \"boolean\",\n          default: true\n        },\n        disallowTemplateShorthand: {\n          type: \"boolean\",\n          default: false\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            enum: ALLOWABLE_OPERATORS\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useRecommendation: \"use `{{recommendation}}` instead.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0] || {});\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports an error and autofixes the node\r\n     * @param {ASTNode} node An ast node to report the error on.\r\n     * @param {string} recommendation The recommended code for the issue\r\n     * @param {bool} shouldFix Whether this report should fix the node\r\n     * @returns {void}\r\n     */\n\n    function report(node, recommendation, shouldFix) {\n      context.report({\n        node,\n        messageId: \"useRecommendation\",\n        data: {\n          recommendation\n        },\n\n        fix(fixer) {\n          if (!shouldFix) {\n            return null;\n          }\n\n          const tokenBefore = sourceCode.getTokenBefore(node);\n\n          if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {\n            return fixer.replaceText(node, ` ${recommendation}`);\n          }\n\n          return fixer.replaceText(node, recommendation);\n        }\n\n      });\n    }\n\n    return {\n      UnaryExpression(node) {\n        let operatorAllowed; // !!foo\n\n        operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n          const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\n          report(node, recommendation, true);\n        } // ~foo.indexOf(bar)\n\n\n        operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n\n        if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n          // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\n          const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\n          const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\n          report(node, recommendation, false);\n        } // +foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n          const recommendation = `Number(${sourceCode.getText(node.argument)})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      // Use `:exit` to prevent double reporting\n      \"BinaryExpression:exit\"(node) {\n        let operatorAllowed; // 1 * foo\n\n        operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n        const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n        if (nonNumericOperand) {\n          const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\n          report(node, recommendation, true);\n        } // \"\" + foo\n\n\n        operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n          const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      AssignmentExpression(node) {\n        // foo += \"\"\n        const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n\n        if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\n          const code = sourceCode.getText(getNonEmptyOperand(node));\n          const recommendation = `${code} = String(${code})`;\n          report(node, recommendation, true);\n        }\n      },\n\n      TemplateLiteral(node) {\n        if (!options.disallowTemplateShorthand) {\n          return;\n        } // tag`${foo}`\n\n\n        if (node.parent.type === \"TaggedTemplateExpression\") {\n          return;\n        } // `` or `${foo}${bar}`\n\n\n        if (node.expressions.length !== 1) {\n          return;\n        } //  `prefix${foo}`\n\n\n        if (node.quasis[0].value.cooked !== \"\") {\n          return;\n        } //  `${foo}postfix`\n\n\n        if (node.quasis[1].value.cooked !== \"\") {\n          return;\n        } // if the expression is already a string, then this isn't a coercion\n\n\n        if (isStringType(node.expressions[0])) {\n          return;\n        }\n\n        const code = sourceCode.getText(node.expressions[0]);\n        const recommendation = `String(${code})`;\n        report(node, recommendation, true);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-implicit-coercion.js"],"names":["astUtils","require","INDEX_OF_PATTERN","ALLOWABLE_OPERATORS","parseOptions","options","boolean","number","string","disallowTemplateShorthand","allow","isDoubleLogicalNegating","node","operator","argument","type","isBinaryNegatingOfIndexOf","callNode","skipChainExpression","isSpecificMemberAccess","callee","isMultiplyByOne","left","value","right","isNumeric","name","getNonNumericOperand","isStringType","isStringLiteral","isEmptyString","quasis","length","cooked","isConcatWithEmptyString","isAppendEmptyString","getNonEmptyOperand","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","default","items","enum","uniqueItems","additionalProperties","messages","useRecommendation","create","context","sourceCode","getSourceCode","report","recommendation","shouldFix","messageId","data","fix","fixer","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","replaceText","UnaryExpression","operatorAllowed","indexOf","getText","comparison","nonNumericOperand","AssignmentExpression","code","TemplateLiteral","parent","expressions"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,gBAAgB,GAAG,sBAAzB;AACA,MAAMC,mBAAmB,GAAG,CAAC,GAAD,EAAM,IAAN,EAAY,GAAZ,EAAiB,GAAjB,CAA5B;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAC3B,SAAO;AACHC,IAAAA,OAAO,EAAE,aAAaD,OAAb,GAAuBA,OAAO,CAACC,OAA/B,GAAyC,IAD/C;AAEHC,IAAAA,MAAM,EAAE,YAAYF,OAAZ,GAAsBA,OAAO,CAACE,MAA9B,GAAuC,IAF5C;AAGHC,IAAAA,MAAM,EAAE,YAAYH,OAAZ,GAAsBA,OAAO,CAACG,MAA9B,GAAuC,IAH5C;AAIHC,IAAAA,yBAAyB,EAAE,+BAA+BJ,OAA/B,GAAyCA,OAAO,CAACI,yBAAjD,GAA6E,KAJrG;AAKHC,IAAAA,KAAK,EAAEL,OAAO,CAACK,KAAR,IAAiB;AALrB,GAAP;AAOH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCC,IAAjC,EAAuC;AACnC,SACIA,IAAI,CAACC,QAAL,KAAkB,GAAlB,IACAD,IAAI,CAACE,QAAL,CAAcC,IAAd,KAAuB,iBADvB,IAEAH,IAAI,CAACE,QAAL,CAAcD,QAAd,KAA2B,GAH/B;AAKH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASG,yBAAT,CAAmCJ,IAAnC,EAAyC;AACrC,MAAIA,IAAI,CAACC,QAAL,KAAkB,GAAtB,EAA2B;AACvB,WAAO,KAAP;AACH;;AACD,QAAMI,QAAQ,GAAGjB,QAAQ,CAACkB,mBAAT,CAA6BN,IAAI,CAACE,QAAlC,CAAjB;AAEA,SACIG,QAAQ,CAACF,IAAT,KAAkB,gBAAlB,IACAf,QAAQ,CAACmB,sBAAT,CAAgCF,QAAQ,CAACG,MAAzC,EAAiD,IAAjD,EAAuDlB,gBAAvD,CAFJ;AAIH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASmB,eAAT,CAAyBT,IAAzB,EAA+B;AAC3B,SAAOA,IAAI,CAACC,QAAL,KAAkB,GAAlB,KACHD,IAAI,CAACU,IAAL,CAAUP,IAAV,KAAmB,SAAnB,IAAgCH,IAAI,CAACU,IAAL,CAAUC,KAAV,KAAoB,CAApD,IACAX,IAAI,CAACY,KAAL,CAAWT,IAAX,KAAoB,SAApB,IAAiCH,IAAI,CAACY,KAAL,CAAWD,KAAX,KAAqB,CAFnD,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,SAAT,CAAmBb,IAAnB,EAAyB;AACrB,SACIA,IAAI,CAACG,IAAL,KAAc,SAAd,IAA2B,OAAOH,IAAI,CAACW,KAAZ,KAAsB,QAAjD,IACAX,IAAI,CAACG,IAAL,KAAc,gBAAd,KACIH,IAAI,CAACQ,MAAL,CAAYM,IAAZ,KAAqB,QAArB,IACAd,IAAI,CAACQ,MAAL,CAAYM,IAAZ,KAAqB,UADrB,IAEAd,IAAI,CAACQ,MAAL,CAAYM,IAAZ,KAAqB,YAHzB,CAFJ;AAQH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8Bf,IAA9B,EAAoC;AAChC,QAAMU,IAAI,GAAGV,IAAI,CAACU,IAAlB;AAAA,QACIE,KAAK,GAAGZ,IAAI,CAACY,KADjB;;AAGA,MAAIA,KAAK,CAACT,IAAN,KAAe,kBAAf,IAAqC,CAACU,SAAS,CAACD,KAAD,CAAnD,EAA4D;AACxD,WAAOA,KAAP;AACH;;AAED,MAAIF,IAAI,CAACP,IAAL,KAAc,kBAAd,IAAoC,CAACU,SAAS,CAACH,IAAD,CAAlD,EAA0D;AACtD,WAAOA,IAAP;AACH;;AAED,SAAO,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASM,YAAT,CAAsBhB,IAAtB,EAA4B;AACxB,SAAOZ,QAAQ,CAAC6B,eAAT,CAAyBjB,IAAzB,KAECA,IAAI,CAACG,IAAL,KAAc,gBAAd,IACAH,IAAI,CAACQ,MAAL,CAAYL,IAAZ,KAAqB,YADrB,IAEAH,IAAI,CAACQ,MAAL,CAAYM,IAAZ,KAAqB,QAJ7B;AAMH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAuBlB,IAAvB,EAA6B;AACzB,SAAOZ,QAAQ,CAAC6B,eAAT,CAAyBjB,IAAzB,MAAmCA,IAAI,CAACW,KAAL,KAAe,EAAf,IAAsBX,IAAI,CAACG,IAAL,KAAc,iBAAd,IAAmCH,IAAI,CAACmB,MAAL,CAAYC,MAAZ,KAAuB,CAA1D,IAA+DpB,IAAI,CAACmB,MAAL,CAAY,CAAZ,EAAeR,KAAf,CAAqBU,MAArB,KAAgC,EAAxJ,CAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,uBAAT,CAAiCtB,IAAjC,EAAuC;AACnC,SAAOA,IAAI,CAACC,QAAL,KAAkB,GAAlB,KACFiB,aAAa,CAAClB,IAAI,CAACU,IAAN,CAAb,IAA4B,CAACM,YAAY,CAAChB,IAAI,CAACY,KAAN,CAA1C,IACCM,aAAa,CAAClB,IAAI,CAACY,KAAN,CAAb,IAA6B,CAACI,YAAY,CAAChB,IAAI,CAACU,IAAN,CAFxC,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASa,mBAAT,CAA6BvB,IAA7B,EAAmC;AAC/B,SAAOA,IAAI,CAACC,QAAL,KAAkB,IAAlB,IAA0BiB,aAAa,CAAClB,IAAI,CAACY,KAAN,CAA9C;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASY,kBAAT,CAA4BxB,IAA5B,EAAkC;AAC9B,SAAOkB,aAAa,CAAClB,IAAI,CAACU,IAAN,CAAb,GAA2BV,IAAI,CAACY,KAAhC,GAAwCZ,IAAI,CAACU,IAApD;AACH,C,CAED;AACA;AACA;;AAEA;;;AACAe,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFxB,IAAAA,IAAI,EAAE,YADJ;AAGFyB,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qCADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,OAAO,EAAE,MATP;AAWFC,IAAAA,MAAM,EAAE,CAAC;AACL9B,MAAAA,IAAI,EAAE,QADD;AAEL+B,MAAAA,UAAU,EAAE;AACRxC,QAAAA,OAAO,EAAE;AACLS,UAAAA,IAAI,EAAE,SADD;AAELgC,UAAAA,OAAO,EAAE;AAFJ,SADD;AAKRxC,QAAAA,MAAM,EAAE;AACJQ,UAAAA,IAAI,EAAE,SADF;AAEJgC,UAAAA,OAAO,EAAE;AAFL,SALA;AASRvC,QAAAA,MAAM,EAAE;AACJO,UAAAA,IAAI,EAAE,SADF;AAEJgC,UAAAA,OAAO,EAAE;AAFL,SATA;AAaRtC,QAAAA,yBAAyB,EAAE;AACvBM,UAAAA,IAAI,EAAE,SADiB;AAEvBgC,UAAAA,OAAO,EAAE;AAFc,SAbnB;AAiBRrC,QAAAA,KAAK,EAAE;AACHK,UAAAA,IAAI,EAAE,OADH;AAEHiC,UAAAA,KAAK,EAAE;AACHC,YAAAA,IAAI,EAAE9C;AADH,WAFJ;AAKH+C,UAAAA,WAAW,EAAE;AALV;AAjBC,OAFP;AA2BLC,MAAAA,oBAAoB,EAAE;AA3BjB,KAAD,CAXN;AAyCFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,iBAAiB,EAAE;AADb;AAzCR,GADO;;AA+CbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMlD,OAAO,GAAGD,YAAY,CAACmD,OAAO,CAAClD,OAAR,CAAgB,CAAhB,KAAsB,EAAvB,CAA5B;AACA,UAAMmD,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,aAASC,MAAT,CAAgB9C,IAAhB,EAAsB+C,cAAtB,EAAsCC,SAAtC,EAAiD;AAC7CL,MAAAA,OAAO,CAACG,MAAR,CAAe;AACX9C,QAAAA,IADW;AAEXiD,QAAAA,SAAS,EAAE,mBAFA;AAGXC,QAAAA,IAAI,EAAE;AACFH,UAAAA;AADE,SAHK;;AAMXI,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,cAAI,CAACJ,SAAL,EAAgB;AACZ,mBAAO,IAAP;AACH;;AAED,gBAAMK,WAAW,GAAGT,UAAU,CAACU,cAAX,CAA0BtD,IAA1B,CAApB;;AAEA,cACIqD,WAAW,IACXA,WAAW,CAACE,KAAZ,CAAkB,CAAlB,MAAyBvD,IAAI,CAACuD,KAAL,CAAW,CAAX,CADzB,IAEA,CAACnE,QAAQ,CAACoE,mBAAT,CAA6BH,WAA7B,EAA0CN,cAA1C,CAHL,EAIE;AACE,mBAAOK,KAAK,CAACK,WAAN,CAAkBzD,IAAlB,EAAyB,IAAG+C,cAAe,EAA3C,CAAP;AACH;;AACD,iBAAOK,KAAK,CAACK,WAAN,CAAkBzD,IAAlB,EAAwB+C,cAAxB,CAAP;AACH;;AArBU,OAAf;AAuBH;;AAED,WAAO;AACHW,MAAAA,eAAe,CAAC1D,IAAD,EAAO;AAClB,YAAI2D,eAAJ,CADkB,CAGlB;;AACAA,QAAAA,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,IAAtB,KAA+B,CAAjD;;AACA,YAAI,CAACD,eAAD,IAAoBlE,OAAO,CAACC,OAA5B,IAAuCK,uBAAuB,CAACC,IAAD,CAAlE,EAA0E;AACtE,gBAAM+C,cAAc,GAAI,WAAUH,UAAU,CAACiB,OAAX,CAAmB7D,IAAI,CAACE,QAAL,CAAcA,QAAjC,CAA2C,GAA7E;AAEA4C,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH,SATiB,CAWlB;;;AACAY,QAAAA,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,GAAtB,KAA8B,CAAhD;;AACA,YAAI,CAACD,eAAD,IAAoBlE,OAAO,CAACC,OAA5B,IAAuCU,yBAAyB,CAACJ,IAAD,CAApE,EAA4E;AAExE;AACA,gBAAM8D,UAAU,GAAG9D,IAAI,CAACE,QAAL,CAAcC,IAAd,KAAuB,iBAAvB,GAA2C,MAA3C,GAAoD,QAAvE;AACA,gBAAM4C,cAAc,GAAI,GAAEH,UAAU,CAACiB,OAAX,CAAmB7D,IAAI,CAACE,QAAxB,CAAkC,IAAG4D,UAAW,EAA1E;AAEAhB,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,KAAvB,CAAN;AACH,SApBiB,CAsBlB;;;AACAY,QAAAA,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,GAAtB,KAA8B,CAAhD;;AACA,YAAI,CAACD,eAAD,IAAoBlE,OAAO,CAACE,MAA5B,IAAsCK,IAAI,CAACC,QAAL,KAAkB,GAAxD,IAA+D,CAACY,SAAS,CAACb,IAAI,CAACE,QAAN,CAA7E,EAA8F;AAC1F,gBAAM6C,cAAc,GAAI,UAASH,UAAU,CAACiB,OAAX,CAAmB7D,IAAI,CAACE,QAAxB,CAAkC,GAAnE;AAEA4C,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH;AACJ,OA9BE;;AAgCH;AACA,8BAAwB/C,IAAxB,EAA8B;AAC1B,YAAI2D,eAAJ,CAD0B,CAG1B;;AACAA,QAAAA,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,GAAtB,KAA8B,CAAhD;AACA,cAAMG,iBAAiB,GAAG,CAACJ,eAAD,IAAoBlE,OAAO,CAACE,MAA5B,IAAsCc,eAAe,CAACT,IAAD,CAArD,IAA+De,oBAAoB,CAACf,IAAD,CAA7G;;AAEA,YAAI+D,iBAAJ,EAAuB;AACnB,gBAAMhB,cAAc,GAAI,UAASH,UAAU,CAACiB,OAAX,CAAmBE,iBAAnB,CAAsC,GAAvE;AAEAjB,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH,SAXyB,CAa1B;;;AACAY,QAAAA,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,GAAtB,KAA8B,CAAhD;;AACA,YAAI,CAACD,eAAD,IAAoBlE,OAAO,CAACG,MAA5B,IAAsC0B,uBAAuB,CAACtB,IAAD,CAAjE,EAAyE;AACrE,gBAAM+C,cAAc,GAAI,UAASH,UAAU,CAACiB,OAAX,CAAmBrC,kBAAkB,CAACxB,IAAD,CAArC,CAA6C,GAA9E;AAEA8C,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH;AACJ,OArDE;;AAuDHiB,MAAAA,oBAAoB,CAAChE,IAAD,EAAO;AAEvB;AACA,cAAM2D,eAAe,GAAGlE,OAAO,CAACK,KAAR,CAAc8D,OAAd,CAAsB,GAAtB,KAA8B,CAAtD;;AAEA,YAAI,CAACD,eAAD,IAAoBlE,OAAO,CAACG,MAA5B,IAAsC2B,mBAAmB,CAACvB,IAAD,CAA7D,EAAqE;AACjE,gBAAMiE,IAAI,GAAGrB,UAAU,CAACiB,OAAX,CAAmBrC,kBAAkB,CAACxB,IAAD,CAArC,CAAb;AACA,gBAAM+C,cAAc,GAAI,GAAEkB,IAAK,aAAYA,IAAK,GAAhD;AAEAnB,UAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH;AACJ,OAlEE;;AAoEHmB,MAAAA,eAAe,CAAClE,IAAD,EAAO;AAClB,YAAI,CAACP,OAAO,CAACI,yBAAb,EAAwC;AACpC;AACH,SAHiB,CAKlB;;;AACA,YAAIG,IAAI,CAACmE,MAAL,CAAYhE,IAAZ,KAAqB,0BAAzB,EAAqD;AACjD;AACH,SARiB,CAUlB;;;AACA,YAAIH,IAAI,CAACoE,WAAL,CAAiBhD,MAAjB,KAA4B,CAAhC,EAAmC;AAC/B;AACH,SAbiB,CAgBlB;;;AACA,YAAIpB,IAAI,CAACmB,MAAL,CAAY,CAAZ,EAAeR,KAAf,CAAqBU,MAArB,KAAgC,EAApC,EAAwC;AACpC;AACH,SAnBiB,CAqBlB;;;AACA,YAAIrB,IAAI,CAACmB,MAAL,CAAY,CAAZ,EAAeR,KAAf,CAAqBU,MAArB,KAAgC,EAApC,EAAwC;AACpC;AACH,SAxBiB,CA0BlB;;;AACA,YAAIL,YAAY,CAAChB,IAAI,CAACoE,WAAL,CAAiB,CAAjB,CAAD,CAAhB,EAAuC;AACnC;AACH;;AAED,cAAMH,IAAI,GAAGrB,UAAU,CAACiB,OAAX,CAAmB7D,IAAI,CAACoE,WAAL,CAAiB,CAAjB,CAAnB,CAAb;AACA,cAAMrB,cAAc,GAAI,UAASkB,IAAK,GAAtC;AAEAnB,QAAAA,MAAM,CAAC9C,IAAD,EAAO+C,cAAP,EAAuB,IAAvB,CAAN;AACH;;AAvGE,KAAP;AAyGH;;AA7LY,CAAjB","sourcesContent":["/**\r\n * @fileoverview A rule to disallow the type conversions with shorter notations.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;\r\nconst ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\r\n\r\n/**\r\n * Parses and normalizes an option object.\r\n * @param {Object} options An option object to parse.\r\n * @returns {Object} The parsed and normalized option object.\r\n */\r\nfunction parseOptions(options) {\r\n    return {\r\n        boolean: \"boolean\" in options ? options.boolean : true,\r\n        number: \"number\" in options ? options.number : true,\r\n        string: \"string\" in options ? options.string : true,\r\n        disallowTemplateShorthand: \"disallowTemplateShorthand\" in options ? options.disallowTemplateShorthand : false,\r\n        allow: options.allow || []\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a double logical nigating.\r\n * @param {ASTNode} node An UnaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a double logical nigating.\r\n */\r\nfunction isDoubleLogicalNegating(node) {\r\n    return (\r\n        node.operator === \"!\" &&\r\n        node.argument.type === \"UnaryExpression\" &&\r\n        node.argument.operator === \"!\"\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\r\n * @param {ASTNode} node An UnaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\r\n */\r\nfunction isBinaryNegatingOfIndexOf(node) {\r\n    if (node.operator !== \"~\") {\r\n        return false;\r\n    }\r\n    const callNode = astUtils.skipChainExpression(node.argument);\r\n\r\n    return (\r\n        callNode.type === \"CallExpression\" &&\r\n        astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN)\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a multiplying by one.\r\n * @param {BinaryExpression} node A BinaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a multiplying by one.\r\n */\r\nfunction isMultiplyByOne(node) {\r\n    return node.operator === \"*\" && (\r\n        node.left.type === \"Literal\" && node.left.value === 1 ||\r\n        node.right.type === \"Literal\" && node.right.value === 1\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether the result of a node is numeric or not\r\n * @param {ASTNode} node The node to test\r\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\r\n */\r\nfunction isNumeric(node) {\r\n    return (\r\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\r\n        node.type === \"CallExpression\" && (\r\n            node.callee.name === \"Number\" ||\r\n            node.callee.name === \"parseInt\" ||\r\n            node.callee.name === \"parseFloat\"\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\r\n * used from bottom to up since it walks up the BinaryExpression trees using\r\n * node.parent to find the result.\r\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\r\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\r\n */\r\nfunction getNonNumericOperand(node) {\r\n    const left = node.left,\r\n        right = node.right;\r\n\r\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\r\n        return right;\r\n    }\r\n\r\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\r\n        return left;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks whether an expression evaluates to a string.\r\n * @param {ASTNode} node node that represents the expression to check.\r\n * @returns {boolean} Whether or not the expression evaluates to a string.\r\n */\r\nfunction isStringType(node) {\r\n    return astUtils.isStringLiteral(node) ||\r\n        (\r\n            node.type === \"CallExpression\" &&\r\n            node.callee.type === \"Identifier\" &&\r\n            node.callee.name === \"String\"\r\n        );\r\n}\r\n\r\n/**\r\n * Checks whether a node is an empty string literal or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} Whether or not the passed in node is an\r\n * empty string literal or not.\r\n */\r\nfunction isEmptyString(node) {\r\n    return astUtils.isStringLiteral(node) && (node.value === \"\" || (node.type === \"TemplateLiteral\" && node.quasis.length === 1 && node.quasis[0].value.cooked === \"\"));\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a concatenating with an empty string.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\r\n */\r\nfunction isConcatWithEmptyString(node) {\r\n    return node.operator === \"+\" && (\r\n        (isEmptyString(node.left) && !isStringType(node.right)) ||\r\n        (isEmptyString(node.right) && !isStringType(node.left))\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is appended with an empty string.\r\n * @param {ASTNode} node An AssignmentExpression node to check.\r\n * @returns {boolean} Whether or not the node is appended with an empty string.\r\n */\r\nfunction isAppendEmptyString(node) {\r\n    return node.operator === \"+=\" && isEmptyString(node.right);\r\n}\r\n\r\n/**\r\n * Returns the operand that is not an empty string from a flagged BinaryExpression.\r\n * @param {ASTNode} node The flagged BinaryExpression node to check.\r\n * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.\r\n */\r\nfunction getNonEmptyOperand(node) {\r\n    return isEmptyString(node.left) ? node.right : node.left;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow shorthand type conversions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-implicit-coercion\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                boolean: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                },\r\n                number: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                },\r\n                string: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                },\r\n                disallowTemplateShorthand: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                },\r\n                allow: {\r\n                    type: \"array\",\r\n                    items: {\r\n                        enum: ALLOWABLE_OPERATORS\r\n                    },\r\n                    uniqueItems: true\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            useRecommendation: \"use `{{recommendation}}` instead.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = parseOptions(context.options[0] || {});\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports an error and autofixes the node\r\n         * @param {ASTNode} node An ast node to report the error on.\r\n         * @param {string} recommendation The recommended code for the issue\r\n         * @param {bool} shouldFix Whether this report should fix the node\r\n         * @returns {void}\r\n         */\r\n        function report(node, recommendation, shouldFix) {\r\n            context.report({\r\n                node,\r\n                messageId: \"useRecommendation\",\r\n                data: {\r\n                    recommendation\r\n                },\r\n                fix(fixer) {\r\n                    if (!shouldFix) {\r\n                        return null;\r\n                    }\r\n\r\n                    const tokenBefore = sourceCode.getTokenBefore(node);\r\n\r\n                    if (\r\n                        tokenBefore &&\r\n                        tokenBefore.range[1] === node.range[0] &&\r\n                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)\r\n                    ) {\r\n                        return fixer.replaceText(node, ` ${recommendation}`);\r\n                    }\r\n                    return fixer.replaceText(node, recommendation);\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            UnaryExpression(node) {\r\n                let operatorAllowed;\r\n\r\n                // !!foo\r\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\r\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\r\n                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;\r\n\r\n                    report(node, recommendation, true);\r\n                }\r\n\r\n                // ~foo.indexOf(bar)\r\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\r\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\r\n\r\n                    // `foo?.indexOf(bar) !== -1` will be true (== found) if the `foo` is nullish. So use `>= 0` in that case.\r\n                    const comparison = node.argument.type === \"ChainExpression\" ? \">= 0\" : \"!== -1\";\r\n                    const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;\r\n\r\n                    report(node, recommendation, false);\r\n                }\r\n\r\n                // +foo\r\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\r\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\r\n                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;\r\n\r\n                    report(node, recommendation, true);\r\n                }\r\n            },\r\n\r\n            // Use `:exit` to prevent double reporting\r\n            \"BinaryExpression:exit\"(node) {\r\n                let operatorAllowed;\r\n\r\n                // 1 * foo\r\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\r\n                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\r\n\r\n                if (nonNumericOperand) {\r\n                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;\r\n\r\n                    report(node, recommendation, true);\r\n                }\r\n\r\n                // \"\" + foo\r\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\r\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\r\n                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;\r\n\r\n                    report(node, recommendation, true);\r\n                }\r\n            },\r\n\r\n            AssignmentExpression(node) {\r\n\r\n                // foo += \"\"\r\n                const operatorAllowed = options.allow.indexOf(\"+\") >= 0;\r\n\r\n                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {\r\n                    const code = sourceCode.getText(getNonEmptyOperand(node));\r\n                    const recommendation = `${code} = String(${code})`;\r\n\r\n                    report(node, recommendation, true);\r\n                }\r\n            },\r\n\r\n            TemplateLiteral(node) {\r\n                if (!options.disallowTemplateShorthand) {\r\n                    return;\r\n                }\r\n\r\n                // tag`${foo}`\r\n                if (node.parent.type === \"TaggedTemplateExpression\") {\r\n                    return;\r\n                }\r\n\r\n                // `` or `${foo}${bar}`\r\n                if (node.expressions.length !== 1) {\r\n                    return;\r\n                }\r\n\r\n\r\n                //  `prefix${foo}`\r\n                if (node.quasis[0].value.cooked !== \"\") {\r\n                    return;\r\n                }\r\n\r\n                //  `${foo}postfix`\r\n                if (node.quasis[1].value.cooked !== \"\") {\r\n                    return;\r\n                }\r\n\r\n                // if the expression is already a string, then this isn't a coercion\r\n                if (isStringType(node.expressions[0])) {\r\n                    return;\r\n                }\r\n\r\n                const code = sourceCode.getText(node.expressions[0]);\r\n                const recommendation = `String(${code})`;\r\n\r\n                report(node, recommendation, true);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}