{"ast":null,"code":"/**\r\n * @fileoverview Restrict usage of specified node modules.\r\n * @author Christian Schulz\r\n * @deprecated in ESLint v7.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStrings = {\n  type: \"array\",\n  items: {\n    type: \"string\"\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `require`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-modules\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: {\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStrings\n          },\n          additionalProperties: false\n        },\n        additionalItems: false\n      }]\n    },\n    messages: {\n      defaultMessage: \"'{{name}}' module is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\n      patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\n    }\n  },\n\n  create(context) {\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\n      if (typeof importName === \"string\") {\n        memo[importName] = null;\n      } else {\n        memo[importName.name] = importName.message;\n      }\n\n      return memo;\n    }, {}); // if no imports are restricted we don't need to check\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\n      return {};\n    } // relative paths are supported for this rule\n\n\n    const ig = ignore({\n      allowRelativePaths: true\n    }).add(restrictedPatterns);\n    /**\r\n     * Function to check if a node is a string literal.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} If the node is a string literal.\r\n     */\n\n    function isStringLiteral(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\r\n     * Function to check if a node is a static string template literal.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} If the node is a string template literal.\r\n     */\n\n\n    function isStaticTemplateLiteral(node) {\n      return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n    }\n    /**\r\n     * Function to check if a node is a require call.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} If the node is a require call.\r\n     */\n\n\n    function isRequireCall(node) {\n      return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\n    }\n    /**\r\n     * Extract string from Literal or TemplateLiteral node\r\n     * @param {ASTNode} node The node to extract from\r\n     * @returns {string|null} Extracted string or null if node doesn't represent a string\r\n     */\n\n\n    function getFirstArgumentString(node) {\n      if (isStringLiteral(node)) {\n        return node.value.trim();\n      }\n\n      if (isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked.trim();\n      }\n\n      return null;\n    }\n    /**\r\n     * Report a restricted path.\r\n     * @param {node} node representing the restricted path reference\r\n     * @param {string} name restricted path\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function reportPath(node, name) {\n      const customMessage = restrictedPathMessages[name];\n      const messageId = customMessage ? \"customMessage\" : \"defaultMessage\";\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          customMessage\n        }\n      });\n    }\n    /**\r\n     * Check if the given name is a restricted path name\r\n     * @param {string} name name of a variable\r\n     * @returns {boolean} whether the variable is a restricted path or not\r\n     * @private\r\n     */\n\n\n    function isRestrictedPath(name) {\n      return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\n    }\n\n    return {\n      CallExpression(node) {\n        if (isRequireCall(node)) {\n          // node has arguments\n          if (node.arguments.length) {\n            const name = getFirstArgumentString(node.arguments[0]); // if first argument is a string literal or a static string template literal\n\n            if (name) {\n              // check if argument value is in restricted modules array\n              if (isRestrictedPath(name)) {\n                reportPath(node, name);\n              }\n\n              if (restrictedPatterns.length > 0 && ig.ignores(name)) {\n                context.report({\n                  node,\n                  messageId: \"patternMessage\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-restricted-modules.js"],"names":["ignore","require","arrayOfStrings","type","items","uniqueItems","arrayOfStringsOrObjects","anyOf","properties","name","message","minLength","additionalProperties","required","module","exports","meta","deprecated","replacedBy","docs","description","recommended","url","schema","paths","patterns","additionalItems","messages","defaultMessage","customMessage","patternMessage","create","context","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPatterns","restrictedPathMessages","reduce","memo","importName","keys","length","ig","allowRelativePaths","add","isStringLiteral","node","value","isStaticTemplateLiteral","expressions","isRequireCall","callee","getFirstArgumentString","trim","quasis","cooked","reportPath","messageId","report","data","isRestrictedPath","CallExpression","arguments","ignores"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Restrict usage of specified node modules.\r\n * @author Christian Schulz\r\n * @deprecated in ESLint v7.0.0\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst ignore = require(\"ignore\");\r\n\r\nconst arrayOfStrings = {\r\n    type: \"array\",\r\n    items: { type: \"string\" },\r\n    uniqueItems: true\r\n};\r\n\r\nconst arrayOfStringsOrObjects = {\r\n    type: \"array\",\r\n    items: {\r\n        anyOf: [\r\n            { type: \"string\" },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    name: { type: \"string\" },\r\n                    message: {\r\n                        type: \"string\",\r\n                        minLength: 1\r\n                    }\r\n                },\r\n                additionalProperties: false,\r\n                required: [\"name\"]\r\n            }\r\n        ]\r\n    },\r\n    uniqueItems: true\r\n};\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        deprecated: true,\r\n\r\n        replacedBy: [],\r\n\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow specified modules when loaded by `require`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-restricted-modules\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                arrayOfStringsOrObjects,\r\n                {\r\n                    type: \"array\",\r\n                    items: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            paths: arrayOfStringsOrObjects,\r\n                            patterns: arrayOfStrings\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    additionalItems: false\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            defaultMessage: \"'{{name}}' module is restricted from being used.\",\r\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\r\n            customMessage: \"'{{name}}' module is restricted from being used. {{customMessage}}\",\r\n            patternMessage: \"'{{name}}' module is restricted from being used by a pattern.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = Array.isArray(context.options) ? context.options : [];\r\n        const isPathAndPatternsObject =\r\n            typeof options[0] === \"object\" &&\r\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\r\n\r\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\r\n        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\r\n\r\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {\r\n            if (typeof importName === \"string\") {\r\n                memo[importName] = null;\r\n            } else {\r\n                memo[importName.name] = importName.message;\r\n            }\r\n            return memo;\r\n        }, {});\r\n\r\n        // if no imports are restricted we don't need to check\r\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {\r\n            return {};\r\n        }\r\n\r\n        // relative paths are supported for this rule\r\n        const ig = ignore({ allowRelativePaths: true }).add(restrictedPatterns);\r\n\r\n\r\n        /**\r\n         * Function to check if a node is a string literal.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} If the node is a string literal.\r\n         */\r\n        function isStringLiteral(node) {\r\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\r\n        }\r\n\r\n        /**\r\n         * Function to check if a node is a static string template literal.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} If the node is a string template literal.\r\n         */\r\n        function isStaticTemplateLiteral(node) {\r\n            return node && node.type === \"TemplateLiteral\" && node.expressions.length === 0;\r\n        }\r\n\r\n        /**\r\n         * Function to check if a node is a require call.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} If the node is a require call.\r\n         */\r\n        function isRequireCall(node) {\r\n            return node.callee.type === \"Identifier\" && node.callee.name === \"require\";\r\n        }\r\n\r\n        /**\r\n         * Extract string from Literal or TemplateLiteral node\r\n         * @param {ASTNode} node The node to extract from\r\n         * @returns {string|null} Extracted string or null if node doesn't represent a string\r\n         */\r\n        function getFirstArgumentString(node) {\r\n            if (isStringLiteral(node)) {\r\n                return node.value.trim();\r\n            }\r\n\r\n            if (isStaticTemplateLiteral(node)) {\r\n                return node.quasis[0].value.cooked.trim();\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Report a restricted path.\r\n         * @param {node} node representing the restricted path reference\r\n         * @param {string} name restricted path\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function reportPath(node, name) {\r\n            const customMessage = restrictedPathMessages[name];\r\n            const messageId = customMessage\r\n                ? \"customMessage\"\r\n                : \"defaultMessage\";\r\n\r\n            context.report({\r\n                node,\r\n                messageId,\r\n                data: {\r\n                    name,\r\n                    customMessage\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check if the given name is a restricted path name\r\n         * @param {string} name name of a variable\r\n         * @returns {boolean} whether the variable is a restricted path or not\r\n         * @private\r\n         */\r\n        function isRestrictedPath(name) {\r\n            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);\r\n        }\r\n\r\n        return {\r\n            CallExpression(node) {\r\n                if (isRequireCall(node)) {\r\n\r\n                    // node has arguments\r\n                    if (node.arguments.length) {\r\n                        const name = getFirstArgumentString(node.arguments[0]);\r\n\r\n                        // if first argument is a string literal or a static string template literal\r\n                        if (name) {\r\n\r\n                            // check if argument value is in restricted modules array\r\n                            if (isRestrictedPath(name)) {\r\n                                reportPath(node, name);\r\n                            }\r\n\r\n                            if (restrictedPatterns.length > 0 && ig.ignores(name)) {\r\n                                context.report({\r\n                                    node,\r\n                                    messageId: \"patternMessage\",\r\n                                    data: { name }\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}