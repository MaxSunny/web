{"ast":null,"code":"/**\r\n * @fileoverview Require or disallow newlines around directives.\r\n * @author Kai Cataldo\r\n * @deprecated in ESLint v4.0.0\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newlines around directives\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-directive\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            enum: [\"always\", \"never\"]\n          },\n          after: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 2\n      }]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\n      unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const config = context.options[0] || \"always\";\n    const expectLineBefore = typeof config === \"string\" ? config : config.before;\n    const expectLineAfter = typeof config === \"string\" ? config : config.after; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Check if node is preceded by a blank newline.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\r\n     */\n\n    function hasNewlineBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node, {\n        includeComments: true\n      });\n      const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\n      return node.loc.start.line - tokenLineBefore >= 2;\n    }\n    /**\r\n     * Gets the last token of a node that is on the same line as the rest of the node.\r\n     * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\r\n     * semicolon on a different line.\r\n     * @param {ASTNode} node A directive node\r\n     * @returns {Token} The last token of the node on the line\r\n     */\n\n\n    function getLastTokenOnLine(node) {\n      const lastToken = sourceCode.getLastToken(node);\n      const secondToLastToken = sourceCode.getTokenBefore(lastToken);\n      return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;\n    }\n    /**\r\n     * Check if node is followed by a blank newline.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\r\n     */\n\n\n    function hasNewlineAfter(node) {\n      const lastToken = getLastTokenOnLine(node);\n      const tokenAfter = sourceCode.getTokenAfter(lastToken, {\n        includeComments: true\n      });\n      return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\n    }\n    /**\r\n     * Report errors for newlines around directives.\r\n     * @param {ASTNode} node Node to check.\r\n     * @param {string} location Whether the error was found before or after the directive.\r\n     * @param {boolean} expected Whether or not a newline was expected or unexpected.\r\n     * @returns {void}\r\n     */\n\n\n    function reportError(node, location, expected) {\n      context.report({\n        node,\n        messageId: expected ? \"expected\" : \"unexpected\",\n        data: {\n          value: node.expression.value,\n          location\n        },\n\n        fix(fixer) {\n          const lastToken = getLastTokenOnLine(node);\n\n          if (expected) {\n            return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\n          }\n\n          return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\n        }\n\n      });\n    }\n    /**\r\n     * Check lines around directives in node\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkDirectives(node) {\n      const directives = astUtils.getDirectivePrologue(node);\n\n      if (!directives.length) {\n        return;\n      }\n\n      const firstDirective = directives[0];\n      const leadingComments = sourceCode.getCommentsBefore(firstDirective);\n      /*\r\n       * Only check before the first directive if it is preceded by a comment or if it is at the top of\r\n       * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\r\n       * the file if there are no comments as well as for compatibility with padded-blocks.\r\n       */\n\n      if (leadingComments.length) {\n        if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", true);\n        }\n\n        if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\n          reportError(firstDirective, \"before\", false);\n        }\n      } else if (node.type === \"Program\" && expectLineBefore === \"never\" && !leadingComments.length && hasNewlineBefore(firstDirective)) {\n        reportError(firstDirective, \"before\", false);\n      }\n\n      const lastDirective = directives[directives.length - 1];\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n      /*\r\n       * Do not check after the last directive if the body only\r\n       * contains a directive prologue and isn't followed by a comment to ensure\r\n       * this rule behaves well with padded-blocks.\r\n       */\n\n      if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\n        return;\n      }\n\n      if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", true);\n      }\n\n      if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\n        reportError(lastDirective, \"after\", false);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: checkDirectives,\n      FunctionDeclaration: checkDirectives,\n      FunctionExpression: checkDirectives,\n      ArrowFunctionExpression: checkDirectives\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/lines-around-directive.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","enum","properties","before","after","additionalProperties","minProperties","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","config","options","expectLineBefore","expectLineAfter","hasNewlineBefore","node","tokenBefore","getTokenBefore","includeComments","tokenLineBefore","loc","end","line","start","getLastTokenOnLine","lastToken","getLastToken","secondToLastToken","isSemicolonToken","hasNewlineAfter","tokenAfter","getTokenAfter","reportError","location","report","messageId","data","value","expression","fix","fixer","insertTextBefore","insertTextAfter","removeRange","range","checkDirectives","directives","getDirectivePrologue","length","firstDirective","leadingComments","getCommentsBefore","lastDirective","statements","body","trailingComments","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,gDADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CAAC;AACLC,MAAAA,KAAK,EAAE,CACH;AACIC,QAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADV,OADG,EAIH;AACIP,QAAAA,IAAI,EAAE,QADV;AAEIQ,QAAAA,UAAU,EAAE;AACRC,UAAAA,MAAM,EAAE;AACJF,YAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADF,WADA;AAIRG,UAAAA,KAAK,EAAE;AACHH,YAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADH;AAJC,SAFhB;AAUII,QAAAA,oBAAoB,EAAE,KAV1B;AAWIC,QAAAA,aAAa,EAAE;AAXnB,OAJG;AADF,KAAD,CATN;AA8BFC,IAAAA,OAAO,EAAE,YA9BP;AA+BFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE,wDADJ;AAENC,MAAAA,UAAU,EAAE;AAFN,KA/BR;AAmCFC,IAAAA,UAAU,EAAE,IAnCV;AAoCFC,IAAAA,UAAU,EAAE,CAAC,iCAAD;AApCV,GADO;;AAwCbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AACA,UAAMC,MAAM,GAAGH,OAAO,CAACI,OAAR,CAAgB,CAAhB,KAAsB,QAArC;AACA,UAAMC,gBAAgB,GAAG,OAAOF,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCA,MAAM,CAACd,MAAtE;AACA,UAAMiB,eAAe,GAAG,OAAOH,MAAP,KAAkB,QAAlB,GAA6BA,MAA7B,GAAsCA,MAAM,CAACb,KAArE,CAJY,CAMZ;AACA;AACA;;AAEA;AACR;AACA;AACA;AACA;;AACQ,aAASiB,gBAAT,CAA0BC,IAA1B,EAAgC;AAC5B,YAAMC,WAAW,GAAGR,UAAU,CAACS,cAAX,CAA0BF,IAA1B,EAAgC;AAAEG,QAAAA,eAAe,EAAE;AAAnB,OAAhC,CAApB;AACA,YAAMC,eAAe,GAAGH,WAAW,GAAGA,WAAW,CAACI,GAAZ,CAAgBC,GAAhB,CAAoBC,IAAvB,GAA8B,CAAjE;AAEA,aAAOP,IAAI,CAACK,GAAL,CAASG,KAAT,CAAeD,IAAf,GAAsBH,eAAtB,IAAyC,CAAhD;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASK,kBAAT,CAA4BT,IAA5B,EAAkC;AAC9B,YAAMU,SAAS,GAAGjB,UAAU,CAACkB,YAAX,CAAwBX,IAAxB,CAAlB;AACA,YAAMY,iBAAiB,GAAGnB,UAAU,CAACS,cAAX,CAA0BQ,SAA1B,CAA1B;AAEA,aAAO3C,QAAQ,CAAC8C,gBAAT,CAA0BH,SAA1B,KAAwCA,SAAS,CAACL,GAAV,CAAcG,KAAd,CAAoBD,IAApB,GAA2BK,iBAAiB,CAACP,GAAlB,CAAsBC,GAAtB,CAA0BC,IAA7F,GACDK,iBADC,GAEDF,SAFN;AAGH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASI,eAAT,CAAyBd,IAAzB,EAA+B;AAC3B,YAAMU,SAAS,GAAGD,kBAAkB,CAACT,IAAD,CAApC;AACA,YAAMe,UAAU,GAAGtB,UAAU,CAACuB,aAAX,CAAyBN,SAAzB,EAAoC;AAAEP,QAAAA,eAAe,EAAE;AAAnB,OAApC,CAAnB;AAEA,aAAOY,UAAU,CAACV,GAAX,CAAeG,KAAf,CAAqBD,IAArB,GAA4BG,SAAS,CAACL,GAAV,CAAcC,GAAd,CAAkBC,IAA9C,IAAsD,CAA7D;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASU,WAAT,CAAqBjB,IAArB,EAA2BkB,QAA3B,EAAqC/B,QAArC,EAA+C;AAC3CK,MAAAA,OAAO,CAAC2B,MAAR,CAAe;AACXnB,QAAAA,IADW;AAEXoB,QAAAA,SAAS,EAAEjC,QAAQ,GAAG,UAAH,GAAgB,YAFxB;AAGXkC,QAAAA,IAAI,EAAE;AACFC,UAAAA,KAAK,EAAEtB,IAAI,CAACuB,UAAL,CAAgBD,KADrB;AAEFJ,UAAAA;AAFE,SAHK;;AAOXM,QAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAMf,SAAS,GAAGD,kBAAkB,CAACT,IAAD,CAApC;;AAEA,cAAIb,QAAJ,EAAc;AACV,mBAAO+B,QAAQ,KAAK,QAAb,GAAwBO,KAAK,CAACC,gBAAN,CAAuB1B,IAAvB,EAA6B,IAA7B,CAAxB,GAA6DyB,KAAK,CAACE,eAAN,CAAsBjB,SAAtB,EAAiC,IAAjC,CAApE;AACH;;AACD,iBAAOe,KAAK,CAACG,WAAN,CAAkBV,QAAQ,KAAK,QAAb,GAAwB,CAAClB,IAAI,CAAC6B,KAAL,CAAW,CAAX,IAAgB,CAAjB,EAAoB7B,IAAI,CAAC6B,KAAL,CAAW,CAAX,CAApB,CAAxB,GAA6D,CAACnB,SAAS,CAACmB,KAAV,CAAgB,CAAhB,CAAD,EAAqBnB,SAAS,CAACmB,KAAV,CAAgB,CAAhB,IAAqB,CAA1C,CAA/E,CAAP;AACH;;AAdU,OAAf;AAgBH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,eAAT,CAAyB9B,IAAzB,EAA+B;AAC3B,YAAM+B,UAAU,GAAGhE,QAAQ,CAACiE,oBAAT,CAA8BhC,IAA9B,CAAnB;;AAEA,UAAI,CAAC+B,UAAU,CAACE,MAAhB,EAAwB;AACpB;AACH;;AAED,YAAMC,cAAc,GAAGH,UAAU,CAAC,CAAD,CAAjC;AACA,YAAMI,eAAe,GAAG1C,UAAU,CAAC2C,iBAAX,CAA6BF,cAA7B,CAAxB;AAEA;AACZ;AACA;AACA;AACA;;AACY,UAAIC,eAAe,CAACF,MAApB,EAA4B;AACxB,YAAIpC,gBAAgB,KAAK,QAArB,IAAiC,CAACE,gBAAgB,CAACmC,cAAD,CAAtD,EAAwE;AACpEjB,UAAAA,WAAW,CAACiB,cAAD,EAAiB,QAAjB,EAA2B,IAA3B,CAAX;AACH;;AAED,YAAIrC,gBAAgB,KAAK,OAArB,IAAgCE,gBAAgB,CAACmC,cAAD,CAApD,EAAsE;AAClEjB,UAAAA,WAAW,CAACiB,cAAD,EAAiB,QAAjB,EAA2B,KAA3B,CAAX;AACH;AACJ,OARD,MAQO,IACHlC,IAAI,CAAC5B,IAAL,KAAc,SAAd,IACAyB,gBAAgB,KAAK,OADrB,IAEA,CAACsC,eAAe,CAACF,MAFjB,IAGAlC,gBAAgB,CAACmC,cAAD,CAJb,EAKL;AACEjB,QAAAA,WAAW,CAACiB,cAAD,EAAiB,QAAjB,EAA2B,KAA3B,CAAX;AACH;;AAED,YAAMG,aAAa,GAAGN,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAAhC;AACA,YAAMK,UAAU,GAAGtC,IAAI,CAAC5B,IAAL,KAAc,SAAd,GAA0B4B,IAAI,CAACuC,IAA/B,GAAsCvC,IAAI,CAACuC,IAAL,CAAUA,IAAnE;AAEA;AACZ;AACA;AACA;AACA;;AACY,UAAIF,aAAa,KAAKC,UAAU,CAACA,UAAU,CAACL,MAAX,GAAoB,CAArB,CAA5B,IAAuD,CAACI,aAAa,CAACG,gBAA1E,EAA4F;AACxF;AACH;;AAED,UAAI1C,eAAe,KAAK,QAApB,IAAgC,CAACgB,eAAe,CAACuB,aAAD,CAApD,EAAqE;AACjEpB,QAAAA,WAAW,CAACoB,aAAD,EAAgB,OAAhB,EAAyB,IAAzB,CAAX;AACH;;AAED,UAAIvC,eAAe,KAAK,OAApB,IAA+BgB,eAAe,CAACuB,aAAD,CAAlD,EAAmE;AAC/DpB,QAAAA,WAAW,CAACoB,aAAD,EAAgB,OAAhB,EAAyB,KAAzB,CAAX;AACH;AACJ,KApIW,CAsIZ;AACA;AACA;;;AAEA,WAAO;AACHI,MAAAA,OAAO,EAAEX,eADN;AAEHY,MAAAA,mBAAmB,EAAEZ,eAFlB;AAGHa,MAAAA,kBAAkB,EAAEb,eAHjB;AAIHc,MAAAA,uBAAuB,EAAEd;AAJtB,KAAP;AAMH;;AAxLY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Require or disallow newlines around directives.\r\n * @author Kai Cataldo\r\n * @deprecated in ESLint v4.0.0\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow newlines around directives\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/lines-around-directive\"\r\n        },\r\n\r\n        schema: [{\r\n            oneOf: [\r\n                {\r\n                    enum: [\"always\", \"never\"]\r\n                },\r\n                {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        before: {\r\n                            enum: [\"always\", \"never\"]\r\n                        },\r\n                        after: {\r\n                            enum: [\"always\", \"never\"]\r\n                        }\r\n                    },\r\n                    additionalProperties: false,\r\n                    minProperties: 2\r\n                }\r\n            ]\r\n        }],\r\n\r\n        fixable: \"whitespace\",\r\n        messages: {\r\n            expected: \"Expected newline {{location}} \\\"{{value}}\\\" directive.\",\r\n            unexpected: \"Unexpected newline {{location}} \\\"{{value}}\\\" directive.\"\r\n        },\r\n        deprecated: true,\r\n        replacedBy: [\"padding-line-between-statements\"]\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const config = context.options[0] || \"always\";\r\n        const expectLineBefore = typeof config === \"string\" ? config : config.before;\r\n        const expectLineAfter = typeof config === \"string\" ? config : config.after;\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Check if node is preceded by a blank newline.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.\r\n         */\r\n        function hasNewlineBefore(node) {\r\n            const tokenBefore = sourceCode.getTokenBefore(node, { includeComments: true });\r\n            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;\r\n\r\n            return node.loc.start.line - tokenLineBefore >= 2;\r\n        }\r\n\r\n        /**\r\n         * Gets the last token of a node that is on the same line as the rest of the node.\r\n         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing\r\n         * semicolon on a different line.\r\n         * @param {ASTNode} node A directive node\r\n         * @returns {Token} The last token of the node on the line\r\n         */\r\n        function getLastTokenOnLine(node) {\r\n            const lastToken = sourceCode.getLastToken(node);\r\n            const secondToLastToken = sourceCode.getTokenBefore(lastToken);\r\n\r\n            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line\r\n                ? secondToLastToken\r\n                : lastToken;\r\n        }\r\n\r\n        /**\r\n         * Check if node is followed by a blank newline.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.\r\n         */\r\n        function hasNewlineAfter(node) {\r\n            const lastToken = getLastTokenOnLine(node);\r\n            const tokenAfter = sourceCode.getTokenAfter(lastToken, { includeComments: true });\r\n\r\n            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;\r\n        }\r\n\r\n        /**\r\n         * Report errors for newlines around directives.\r\n         * @param {ASTNode} node Node to check.\r\n         * @param {string} location Whether the error was found before or after the directive.\r\n         * @param {boolean} expected Whether or not a newline was expected or unexpected.\r\n         * @returns {void}\r\n         */\r\n        function reportError(node, location, expected) {\r\n            context.report({\r\n                node,\r\n                messageId: expected ? \"expected\" : \"unexpected\",\r\n                data: {\r\n                    value: node.expression.value,\r\n                    location\r\n                },\r\n                fix(fixer) {\r\n                    const lastToken = getLastTokenOnLine(node);\r\n\r\n                    if (expected) {\r\n                        return location === \"before\" ? fixer.insertTextBefore(node, \"\\n\") : fixer.insertTextAfter(lastToken, \"\\n\");\r\n                    }\r\n                    return fixer.removeRange(location === \"before\" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check lines around directives in node\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkDirectives(node) {\r\n            const directives = astUtils.getDirectivePrologue(node);\r\n\r\n            if (!directives.length) {\r\n                return;\r\n            }\r\n\r\n            const firstDirective = directives[0];\r\n            const leadingComments = sourceCode.getCommentsBefore(firstDirective);\r\n\r\n            /*\r\n             * Only check before the first directive if it is preceded by a comment or if it is at the top of\r\n             * the file and expectLineBefore is set to \"never\". This is to not force a newline at the top of\r\n             * the file if there are no comments as well as for compatibility with padded-blocks.\r\n             */\r\n            if (leadingComments.length) {\r\n                if (expectLineBefore === \"always\" && !hasNewlineBefore(firstDirective)) {\r\n                    reportError(firstDirective, \"before\", true);\r\n                }\r\n\r\n                if (expectLineBefore === \"never\" && hasNewlineBefore(firstDirective)) {\r\n                    reportError(firstDirective, \"before\", false);\r\n                }\r\n            } else if (\r\n                node.type === \"Program\" &&\r\n                expectLineBefore === \"never\" &&\r\n                !leadingComments.length &&\r\n                hasNewlineBefore(firstDirective)\r\n            ) {\r\n                reportError(firstDirective, \"before\", false);\r\n            }\r\n\r\n            const lastDirective = directives[directives.length - 1];\r\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\r\n\r\n            /*\r\n             * Do not check after the last directive if the body only\r\n             * contains a directive prologue and isn't followed by a comment to ensure\r\n             * this rule behaves well with padded-blocks.\r\n             */\r\n            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {\r\n                return;\r\n            }\r\n\r\n            if (expectLineAfter === \"always\" && !hasNewlineAfter(lastDirective)) {\r\n                reportError(lastDirective, \"after\", true);\r\n            }\r\n\r\n            if (expectLineAfter === \"never\" && hasNewlineAfter(lastDirective)) {\r\n                reportError(lastDirective, \"after\", false);\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: checkDirectives,\r\n            FunctionDeclaration: checkDirectives,\r\n            FunctionExpression: checkDirectives,\r\n            ArrowFunctionExpression: checkDirectives\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}