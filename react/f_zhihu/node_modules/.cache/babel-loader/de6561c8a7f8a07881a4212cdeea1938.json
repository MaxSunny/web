{"ast":null,"code":"/**\r\n * @fileoverview Rule to control usage of strict mode directives.\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\r\n * statements.\r\n * @param {ASTNode[]} statements Statements in the program or function body.\r\n * @returns {ASTNode[]} All of the Use Strict Directives.\r\n */\n\n\nfunction getUseStrictDirectives(statements) {\n  const directives = [];\n\n  for (let i = 0; i < statements.length; i++) {\n    const statement = statements[i];\n\n    if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && statement.expression.value === \"use strict\") {\n      directives[i] = statement;\n    } else {\n      break;\n    }\n  }\n\n  return directives;\n}\n/**\r\n * Checks whether a given parameter is a simple parameter.\r\n * @param {ASTNode} node A pattern node to check.\r\n * @returns {boolean} `true` if the node is an Identifier node.\r\n */\n\n\nfunction isSimpleParameter(node) {\n  return node.type === \"Identifier\";\n}\n/**\r\n * Checks whether a given parameter list is a simple parameter list.\r\n * @param {ASTNode[]} params A parameter list to check.\r\n * @returns {boolean} `true` if the every parameter is an Identifier node.\r\n */\n\n\nfunction isSimpleParameterList(params) {\n  return params.every(isSimpleParameter);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow strict mode directives\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/strict\"\n    },\n    schema: [{\n      enum: [\"never\", \"global\", \"function\", \"safe\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      function: \"Use the function form of 'use strict'.\",\n      global: \"Use the global form of 'use strict'.\",\n      multiple: \"Multiple 'use strict' directives.\",\n      never: \"Strict mode is not permitted.\",\n      unnecessary: \"Unnecessary 'use strict' directive.\",\n      module: \"'use strict' is unnecessary inside of modules.\",\n      implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\n      unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\n      nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\n      wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\n    }\n  },\n\n  create(context) {\n    const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\n          scopes = [],\n          classScopes = [];\n    let mode = context.options[0] || \"safe\";\n\n    if (ecmaFeatures.impliedStrict) {\n      mode = \"implied\";\n    } else if (mode === \"safe\") {\n      mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\n    }\n    /**\r\n     * Determines whether a reported error should be fixed, depending on the error type.\r\n     * @param {string} errorType The type of error\r\n     * @returns {boolean} `true` if the reported error should be fixed\r\n     */\n\n\n    function shouldFix(errorType) {\n      return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\n    }\n    /**\r\n     * Gets a fixer function to remove a given 'use strict' directive.\r\n     * @param {ASTNode} node The directive that should be removed\r\n     * @returns {Function} A fixer function\r\n     */\n\n\n    function getFixFunction(node) {\n      return fixer => fixer.remove(node);\n    }\n    /**\r\n     * Report a slice of an array of nodes with a given message.\r\n     * @param {ASTNode[]} nodes Nodes.\r\n     * @param {string} start Index to start from.\r\n     * @param {string} end Index to end before.\r\n     * @param {string} messageId Message to display.\r\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n     * @returns {void}\r\n     */\n\n\n    function reportSlice(nodes, start, end, messageId, fix) {\n      nodes.slice(start, end).forEach(node => {\n        context.report({\n          node,\n          messageId,\n          fix: fix ? getFixFunction(node) : null\n        });\n      });\n    }\n    /**\r\n     * Report all nodes in an array with a given message.\r\n     * @param {ASTNode[]} nodes Nodes.\r\n     * @param {string} messageId Message id to display.\r\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n     * @returns {void}\r\n     */\n\n\n    function reportAll(nodes, messageId, fix) {\n      reportSlice(nodes, 0, nodes.length, messageId, fix);\n    }\n    /**\r\n     * Report all nodes in an array, except the first, with a given message.\r\n     * @param {ASTNode[]} nodes Nodes.\r\n     * @param {string} messageId Message id to display.\r\n     * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n     * @returns {void}\r\n     */\n\n\n    function reportAllExceptFirst(nodes, messageId, fix) {\n      reportSlice(nodes, 1, nodes.length, messageId, fix);\n    }\n    /**\r\n     * Entering a function in 'function' mode pushes a new nested scope onto the\r\n     * stack. The new scope is true if the nested function is strict mode code.\r\n     * @param {ASTNode} node The function declaration or expression.\r\n     * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\r\n     * @returns {void}\r\n     */\n\n\n    function enterFunctionInFunctionMode(node, useStrictDirectives) {\n      const isInClass = classScopes.length > 0,\n            isParentGlobal = scopes.length === 0 && classScopes.length === 0,\n            isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\n            isStrict = useStrictDirectives.length > 0;\n\n      if (isStrict) {\n        if (!isSimpleParameterList(node.params)) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n        } else if (isParentStrict) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessary\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        } else if (isInClass) {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"unnecessaryInClasses\",\n            fix: getFixFunction(useStrictDirectives[0])\n          });\n        }\n\n        reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n      } else if (isParentGlobal) {\n        if (isSimpleParameterList(node.params)) {\n          context.report({\n            node,\n            messageId: \"function\"\n          });\n        } else {\n          context.report({\n            node,\n            messageId: \"wrap\",\n            data: {\n              name: astUtils.getFunctionNameWithKind(node)\n            }\n          });\n        }\n      }\n\n      scopes.push(isParentStrict || isStrict);\n    }\n    /**\r\n     * Exiting a function in 'function' mode pops its scope off the stack.\r\n     * @returns {void}\r\n     */\n\n\n    function exitFunctionInFunctionMode() {\n      scopes.pop();\n    }\n    /**\r\n     * Enter a function and either:\r\n     * - Push a new nested scope onto the stack (in 'function' mode).\r\n     * - Report all the Use Strict Directives (in the other modes).\r\n     * @param {ASTNode} node The function declaration or expression.\r\n     * @returns {void}\r\n     */\n\n\n    function enterFunction(node) {\n      const isBlock = node.body.type === \"BlockStatement\",\n            useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];\n\n      if (mode === \"function\") {\n        enterFunctionInFunctionMode(node, useStrictDirectives);\n      } else if (useStrictDirectives.length > 0) {\n        if (isSimpleParameterList(node.params)) {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        } else {\n          context.report({\n            node: useStrictDirectives[0],\n            messageId: \"nonSimpleParameterList\"\n          });\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        }\n      }\n    }\n\n    const rule = {\n      Program(node) {\n        const useStrictDirectives = getUseStrictDirectives(node.body);\n\n        if (node.sourceType === \"module\") {\n          mode = \"module\";\n        }\n\n        if (mode === \"global\") {\n          if (node.body.length > 0 && useStrictDirectives.length === 0) {\n            context.report({\n              node,\n              messageId: \"global\"\n            });\n          }\n\n          reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\n        } else {\n          reportAll(useStrictDirectives, mode, shouldFix(mode));\n        }\n      },\n\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      ArrowFunctionExpression: enterFunction\n    };\n\n    if (mode === \"function\") {\n      Object.assign(rule, {\n        // Inside of class bodies are always strict mode.\n        ClassBody() {\n          classScopes.push(true);\n        },\n\n        \"ClassBody:exit\"() {\n          classScopes.pop();\n        },\n\n        \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\n        \"FunctionExpression:exit\": exitFunctionInFunctionMode,\n        \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\n      });\n    }\n\n    return rule;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/strict.js"],"names":["astUtils","require","getUseStrictDirectives","statements","directives","i","length","statement","type","expression","value","isSimpleParameter","node","isSimpleParameterList","params","every","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","function","global","multiple","never","unnecessary","implied","unnecessaryInClasses","nonSimpleParameterList","wrap","create","context","ecmaFeatures","parserOptions","scopes","classScopes","mode","options","impliedStrict","globalReturn","shouldFix","errorType","getFixFunction","fixer","remove","reportSlice","nodes","start","end","messageId","fix","slice","forEach","report","reportAll","reportAllExceptFirst","enterFunctionInFunctionMode","useStrictDirectives","isInClass","isParentGlobal","isParentStrict","isStrict","data","name","getFunctionNameWithKind","push","exitFunctionInFunctionMode","pop","enterFunction","isBlock","body","rule","Program","sourceType","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","Object","assign","ClassBody"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to control usage of strict mode directives.\r\n * @author Brandon Mills\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets all of the Use Strict Directives in the Directive Prologue of a group of\r\n * statements.\r\n * @param {ASTNode[]} statements Statements in the program or function body.\r\n * @returns {ASTNode[]} All of the Use Strict Directives.\r\n */\r\nfunction getUseStrictDirectives(statements) {\r\n    const directives = [];\r\n\r\n    for (let i = 0; i < statements.length; i++) {\r\n        const statement = statements[i];\r\n\r\n        if (\r\n            statement.type === \"ExpressionStatement\" &&\r\n            statement.expression.type === \"Literal\" &&\r\n            statement.expression.value === \"use strict\"\r\n        ) {\r\n            directives[i] = statement;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return directives;\r\n}\r\n\r\n/**\r\n * Checks whether a given parameter is a simple parameter.\r\n * @param {ASTNode} node A pattern node to check.\r\n * @returns {boolean} `true` if the node is an Identifier node.\r\n */\r\nfunction isSimpleParameter(node) {\r\n    return node.type === \"Identifier\";\r\n}\r\n\r\n/**\r\n * Checks whether a given parameter list is a simple parameter list.\r\n * @param {ASTNode[]} params A parameter list to check.\r\n * @returns {boolean} `true` if the every parameter is an Identifier node.\r\n */\r\nfunction isSimpleParameterList(params) {\r\n    return params.every(isSimpleParameter);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require or disallow strict mode directives\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/strict\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"never\", \"global\", \"function\", \"safe\"]\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            function: \"Use the function form of 'use strict'.\",\r\n            global: \"Use the global form of 'use strict'.\",\r\n            multiple: \"Multiple 'use strict' directives.\",\r\n            never: \"Strict mode is not permitted.\",\r\n            unnecessary: \"Unnecessary 'use strict' directive.\",\r\n            module: \"'use strict' is unnecessary inside of modules.\",\r\n            implied: \"'use strict' is unnecessary when implied strict mode is enabled.\",\r\n            unnecessaryInClasses: \"'use strict' is unnecessary inside of classes.\",\r\n            nonSimpleParameterList: \"'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.\",\r\n            wrap: \"Wrap {{name}} in a function with 'use strict' directive.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},\r\n            scopes = [],\r\n            classScopes = [];\r\n        let mode = context.options[0] || \"safe\";\r\n\r\n        if (ecmaFeatures.impliedStrict) {\r\n            mode = \"implied\";\r\n        } else if (mode === \"safe\") {\r\n            mode = ecmaFeatures.globalReturn ? \"global\" : \"function\";\r\n        }\r\n\r\n        /**\r\n         * Determines whether a reported error should be fixed, depending on the error type.\r\n         * @param {string} errorType The type of error\r\n         * @returns {boolean} `true` if the reported error should be fixed\r\n         */\r\n        function shouldFix(errorType) {\r\n            return errorType === \"multiple\" || errorType === \"unnecessary\" || errorType === \"module\" || errorType === \"implied\" || errorType === \"unnecessaryInClasses\";\r\n        }\r\n\r\n        /**\r\n         * Gets a fixer function to remove a given 'use strict' directive.\r\n         * @param {ASTNode} node The directive that should be removed\r\n         * @returns {Function} A fixer function\r\n         */\r\n        function getFixFunction(node) {\r\n            return fixer => fixer.remove(node);\r\n        }\r\n\r\n        /**\r\n         * Report a slice of an array of nodes with a given message.\r\n         * @param {ASTNode[]} nodes Nodes.\r\n         * @param {string} start Index to start from.\r\n         * @param {string} end Index to end before.\r\n         * @param {string} messageId Message to display.\r\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n         * @returns {void}\r\n         */\r\n        function reportSlice(nodes, start, end, messageId, fix) {\r\n            nodes.slice(start, end).forEach(node => {\r\n                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null });\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Report all nodes in an array with a given message.\r\n         * @param {ASTNode[]} nodes Nodes.\r\n         * @param {string} messageId Message id to display.\r\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n         * @returns {void}\r\n         */\r\n        function reportAll(nodes, messageId, fix) {\r\n            reportSlice(nodes, 0, nodes.length, messageId, fix);\r\n        }\r\n\r\n        /**\r\n         * Report all nodes in an array, except the first, with a given message.\r\n         * @param {ASTNode[]} nodes Nodes.\r\n         * @param {string} messageId Message id to display.\r\n         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)\r\n         * @returns {void}\r\n         */\r\n        function reportAllExceptFirst(nodes, messageId, fix) {\r\n            reportSlice(nodes, 1, nodes.length, messageId, fix);\r\n        }\r\n\r\n        /**\r\n         * Entering a function in 'function' mode pushes a new nested scope onto the\r\n         * stack. The new scope is true if the nested function is strict mode code.\r\n         * @param {ASTNode} node The function declaration or expression.\r\n         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.\r\n         * @returns {void}\r\n         */\r\n        function enterFunctionInFunctionMode(node, useStrictDirectives) {\r\n            const isInClass = classScopes.length > 0,\r\n                isParentGlobal = scopes.length === 0 && classScopes.length === 0,\r\n                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],\r\n                isStrict = useStrictDirectives.length > 0;\r\n\r\n            if (isStrict) {\r\n                if (!isSimpleParameterList(node.params)) {\r\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\r\n                } else if (isParentStrict) {\r\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessary\", fix: getFixFunction(useStrictDirectives[0]) });\r\n                } else if (isInClass) {\r\n                    context.report({ node: useStrictDirectives[0], messageId: \"unnecessaryInClasses\", fix: getFixFunction(useStrictDirectives[0]) });\r\n                }\r\n\r\n                reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\r\n            } else if (isParentGlobal) {\r\n                if (isSimpleParameterList(node.params)) {\r\n                    context.report({ node, messageId: \"function\" });\r\n                } else {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"wrap\",\r\n                        data: { name: astUtils.getFunctionNameWithKind(node) }\r\n                    });\r\n                }\r\n            }\r\n\r\n            scopes.push(isParentStrict || isStrict);\r\n        }\r\n\r\n        /**\r\n         * Exiting a function in 'function' mode pops its scope off the stack.\r\n         * @returns {void}\r\n         */\r\n        function exitFunctionInFunctionMode() {\r\n            scopes.pop();\r\n        }\r\n\r\n        /**\r\n         * Enter a function and either:\r\n         * - Push a new nested scope onto the stack (in 'function' mode).\r\n         * - Report all the Use Strict Directives (in the other modes).\r\n         * @param {ASTNode} node The function declaration or expression.\r\n         * @returns {void}\r\n         */\r\n        function enterFunction(node) {\r\n            const isBlock = node.body.type === \"BlockStatement\",\r\n                useStrictDirectives = isBlock\r\n                    ? getUseStrictDirectives(node.body.body) : [];\r\n\r\n            if (mode === \"function\") {\r\n                enterFunctionInFunctionMode(node, useStrictDirectives);\r\n            } else if (useStrictDirectives.length > 0) {\r\n                if (isSimpleParameterList(node.params)) {\r\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\r\n                } else {\r\n                    context.report({ node: useStrictDirectives[0], messageId: \"nonSimpleParameterList\" });\r\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\r\n                }\r\n            }\r\n        }\r\n\r\n        const rule = {\r\n            Program(node) {\r\n                const useStrictDirectives = getUseStrictDirectives(node.body);\r\n\r\n                if (node.sourceType === \"module\") {\r\n                    mode = \"module\";\r\n                }\r\n\r\n                if (mode === \"global\") {\r\n                    if (node.body.length > 0 && useStrictDirectives.length === 0) {\r\n                        context.report({ node, messageId: \"global\" });\r\n                    }\r\n                    reportAllExceptFirst(useStrictDirectives, \"multiple\", true);\r\n                } else {\r\n                    reportAll(useStrictDirectives, mode, shouldFix(mode));\r\n                }\r\n            },\r\n            FunctionDeclaration: enterFunction,\r\n            FunctionExpression: enterFunction,\r\n            ArrowFunctionExpression: enterFunction\r\n        };\r\n\r\n        if (mode === \"function\") {\r\n            Object.assign(rule, {\r\n\r\n                // Inside of class bodies are always strict mode.\r\n                ClassBody() {\r\n                    classScopes.push(true);\r\n                },\r\n                \"ClassBody:exit\"() {\r\n                    classScopes.pop();\r\n                },\r\n\r\n                \"FunctionDeclaration:exit\": exitFunctionInFunctionMode,\r\n                \"FunctionExpression:exit\": exitFunctionInFunctionMode,\r\n                \"ArrowFunctionExpression:exit\": exitFunctionInFunctionMode\r\n            });\r\n        }\r\n\r\n        return rule;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}