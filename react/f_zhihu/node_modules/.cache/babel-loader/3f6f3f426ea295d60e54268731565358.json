{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use constant conditions\r\n * @author Christian Schulz <http://rndm.de>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow constant expressions in conditions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-constant-condition\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        checkLoops: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"Unexpected constant condition.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          checkLoops = options.checkLoops !== false,\n          loopSetStack = [];\n    let loopsInCurrentScope = new Set(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Returns literal's value converted to the Boolean type\r\n     * @param {ASTNode} node any `Literal` node\r\n     * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\r\n     *  `null` when it cannot be determined.\r\n     */\n\n    function getBooleanValue(node) {\n      if (node.value === null) {\n        /*\r\n         * it might be a null literal or bigint/regex literal in unsupported environments .\r\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\r\n         * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\r\n         */\n        if (node.raw === \"null\") {\n          return false;\n        } // regex is always truthy\n\n\n        if (typeof node.regex === \"object\") {\n          return true;\n        }\n\n        return null;\n      }\n\n      return !!node.value;\n    }\n    /**\r\n     * Checks if a branch node of LogicalExpression short circuits the whole condition\r\n     * @param {ASTNode} node The branch of main condition which needs to be checked\r\n     * @param {string} operator The operator of the main LogicalExpression.\r\n     * @returns {boolean} true when condition short circuits whole condition\r\n     */\n\n\n    function isLogicalIdentity(node, operator) {\n      switch (node.type) {\n        case \"Literal\":\n          return operator === \"||\" && getBooleanValue(node) === true || operator === \"&&\" && getBooleanValue(node) === false;\n\n        case \"UnaryExpression\":\n          return operator === \"&&\" && node.operator === \"void\";\n\n        case \"LogicalExpression\":\n          /*\r\n           * handles `a && false || b`\r\n           * `false` is an identity element of `&&` but not `||`\r\n           */\n          return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));\n\n        case \"AssignmentExpression\":\n          return [\"||=\", \"&&=\"].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);\n        // no default\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks if an identifier is a reference to a global variable.\r\n     * @param {ASTNode} node An identifier node to check.\r\n     * @returns {boolean} `true` if the identifier is a reference to a global variable.\r\n     */\n\n\n    function isReferenceToGlobalVariable(node) {\n      const scope = context.getScope();\n      const reference = scope.references.find(ref => ref.identifier === node);\n      return Boolean(reference && reference.resolved && reference.resolved.scope.type === \"global\" && reference.resolved.defs.length === 0);\n    }\n    /**\r\n     * Checks if a node has a constant truthiness value.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @param {boolean} inBooleanPosition `true` if checking the test of a\r\n     * condition. `false` in all other cases. When `false`, checks if -- for\r\n     * both string and number -- if coerced to that type, the value will\r\n     * be constant.\r\n     * @returns {Bool} true when node's truthiness is constant\r\n     * @private\r\n     */\n\n\n    function isConstant(node, inBooleanPosition) {\n      // node.elements can return null values in the case of sparse arrays ex. [,]\n      if (!node) {\n        return true;\n      }\n\n      switch (node.type) {\n        case \"Literal\":\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n          return true;\n\n        case \"ClassExpression\":\n        case \"ObjectExpression\":\n          /**\r\n           * In theory objects like:\r\n           *\r\n           * `{toString: () => a}`\r\n           * `{valueOf: () => a}`\r\n           *\r\n           * Or a classes like:\r\n           *\r\n           * `class { static toString() { return a } }`\r\n           * `class { static valueOf() { return a } }`\r\n           *\r\n           * Are not constant verifiably when `inBooleanPosition` is\r\n           * false, but it's an edge case we've opted not to handle.\r\n           */\n          return true;\n\n        case \"TemplateLiteral\":\n          return inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length) || node.expressions.every(exp => isConstant(exp, false));\n\n        case \"ArrayExpression\":\n          {\n            if (!inBooleanPosition) {\n              return node.elements.every(element => isConstant(element, false));\n            }\n\n            return true;\n          }\n\n        case \"UnaryExpression\":\n          if (node.operator === \"void\" || node.operator === \"typeof\" && inBooleanPosition) {\n            return true;\n          }\n\n          if (node.operator === \"!\") {\n            return isConstant(node.argument, true);\n          }\n\n          return isConstant(node.argument, false);\n\n        case \"BinaryExpression\":\n          return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== \"in\";\n\n        case \"LogicalExpression\":\n          {\n            const isLeftConstant = isConstant(node.left, inBooleanPosition);\n            const isRightConstant = isConstant(node.right, inBooleanPosition);\n            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);\n            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);\n            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;\n          }\n\n        case \"NewExpression\":\n          return inBooleanPosition;\n\n        case \"AssignmentExpression\":\n          if (node.operator === \"=\") {\n            return isConstant(node.right, inBooleanPosition);\n          }\n\n          if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\n            return isLogicalIdentity(node.right, node.operator.slice(0, -1));\n          }\n\n          return false;\n\n        case \"SequenceExpression\":\n          return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\n\n        case \"SpreadElement\":\n          return isConstant(node.argument, inBooleanPosition);\n\n        case \"CallExpression\":\n          if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\") {\n            if (node.arguments.length === 0 || isConstant(node.arguments[0], true)) {\n              return isReferenceToGlobalVariable(node.callee);\n            }\n          }\n\n          return false;\n\n        case \"Identifier\":\n          return node.name === \"undefined\" && isReferenceToGlobalVariable(node);\n        // no default\n      }\n\n      return false;\n    }\n    /**\r\n     * Tracks when the given node contains a constant condition.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function trackConstantConditionLoop(node) {\n      if (node.test && isConstant(node.test, true)) {\n        loopsInCurrentScope.add(node);\n      }\n    }\n    /**\r\n     * Reports when the set contains the given constant condition node\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkConstantConditionLoopInSet(node) {\n      if (loopsInCurrentScope.has(node)) {\n        loopsInCurrentScope.delete(node);\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n    /**\r\n     * Reports when the given node contains a constant condition.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function reportIfConstant(node) {\n      if (node.test && isConstant(node.test, true)) {\n        context.report({\n          node: node.test,\n          messageId: \"unexpected\"\n        });\n      }\n    }\n    /**\r\n     * Stores current set of constant loops in loopSetStack temporarily\r\n     * and uses a new set to track constant loops\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function enterFunction() {\n      loopSetStack.push(loopsInCurrentScope);\n      loopsInCurrentScope = new Set();\n    }\n    /**\r\n     * Reports when the set still contains stored constant conditions\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function exitFunction() {\n      loopsInCurrentScope = loopSetStack.pop();\n    }\n    /**\r\n     * Checks node when checkLoops option is enabled\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkLoop(node) {\n      if (checkLoops) {\n        trackConstantConditionLoop(node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ConditionalExpression: reportIfConstant,\n      IfStatement: reportIfConstant,\n      WhileStatement: checkLoop,\n      \"WhileStatement:exit\": checkConstantConditionLoopInSet,\n      DoWhileStatement: checkLoop,\n      \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\n      ForStatement: checkLoop,\n      \"ForStatement > .test\": node => checkLoop(node.parent),\n      \"ForStatement:exit\": checkConstantConditionLoopInSet,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      YieldExpression: () => loopsInCurrentScope.clear()\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-constant-condition.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","checkLoops","default","additionalProperties","messages","unexpected","create","context","options","loopSetStack","loopsInCurrentScope","Set","getBooleanValue","node","value","raw","regex","isLogicalIdentity","operator","left","right","includes","slice","isReferenceToGlobalVariable","scope","getScope","reference","references","find","ref","identifier","Boolean","resolved","defs","length","isConstant","inBooleanPosition","quasis","some","quasi","cooked","expressions","every","exp","elements","element","argument","isLeftConstant","isRightConstant","isLeftShortCircuit","isRightShortCircuit","callee","name","arguments","trackConstantConditionLoop","test","add","checkConstantConditionLoopInSet","has","delete","report","messageId","reportIfConstant","enterFunction","push","exitFunction","pop","checkLoop","ConditionalExpression","IfStatement","WhileStatement","DoWhileStatement","ForStatement","parent","FunctionDeclaration","FunctionExpression","YieldExpression","clear"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use constant conditions\r\n * @author Christian Schulz <http://rndm.de>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow constant expressions in conditions\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-constant-condition\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    checkLoops: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected constant condition.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {},\r\n            checkLoops = options.checkLoops !== false,\r\n            loopSetStack = [];\r\n\r\n        let loopsInCurrentScope = new Set();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Returns literal's value converted to the Boolean type\r\n         * @param {ASTNode} node any `Literal` node\r\n         * @returns {boolean | null} `true` when node is truthy, `false` when node is falsy,\r\n         *  `null` when it cannot be determined.\r\n         */\r\n        function getBooleanValue(node) {\r\n            if (node.value === null) {\r\n\r\n                /*\r\n                 * it might be a null literal or bigint/regex literal in unsupported environments .\r\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es5.md#regexpliteral\r\n                 * https://github.com/estree/estree/blob/14df8a024956ea289bd55b9c2226a1d5b8a473ee/es2020.md#bigintliteral\r\n                 */\r\n\r\n                if (node.raw === \"null\") {\r\n                    return false;\r\n                }\r\n\r\n                // regex is always truthy\r\n                if (typeof node.regex === \"object\") {\r\n                    return true;\r\n                }\r\n\r\n                return null;\r\n            }\r\n\r\n            return !!node.value;\r\n        }\r\n\r\n        /**\r\n         * Checks if a branch node of LogicalExpression short circuits the whole condition\r\n         * @param {ASTNode} node The branch of main condition which needs to be checked\r\n         * @param {string} operator The operator of the main LogicalExpression.\r\n         * @returns {boolean} true when condition short circuits whole condition\r\n         */\r\n        function isLogicalIdentity(node, operator) {\r\n            switch (node.type) {\r\n                case \"Literal\":\r\n                    return (operator === \"||\" && getBooleanValue(node) === true) ||\r\n                           (operator === \"&&\" && getBooleanValue(node) === false);\r\n\r\n                case \"UnaryExpression\":\r\n                    return (operator === \"&&\" && node.operator === \"void\");\r\n\r\n                case \"LogicalExpression\":\r\n\r\n                    /*\r\n                     * handles `a && false || b`\r\n                     * `false` is an identity element of `&&` but not `||`\r\n                     */\r\n                    return operator === node.operator &&\r\n                             (\r\n                                 isLogicalIdentity(node.left, operator) ||\r\n                                 isLogicalIdentity(node.right, operator)\r\n                             );\r\n\r\n                case \"AssignmentExpression\":\r\n                    return [\"||=\", \"&&=\"].includes(node.operator) &&\r\n                        operator === node.operator.slice(0, -1) &&\r\n                        isLogicalIdentity(node.right, operator);\r\n\r\n                // no default\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if an identifier is a reference to a global variable.\r\n         * @param {ASTNode} node An identifier node to check.\r\n         * @returns {boolean} `true` if the identifier is a reference to a global variable.\r\n         */\r\n        function isReferenceToGlobalVariable(node) {\r\n            const scope = context.getScope();\r\n            const reference = scope.references.find(ref => ref.identifier === node);\r\n\r\n            return Boolean(\r\n                reference &&\r\n                reference.resolved &&\r\n                reference.resolved.scope.type === \"global\" &&\r\n                reference.resolved.defs.length === 0\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks if a node has a constant truthiness value.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @param {boolean} inBooleanPosition `true` if checking the test of a\r\n         * condition. `false` in all other cases. When `false`, checks if -- for\r\n         * both string and number -- if coerced to that type, the value will\r\n         * be constant.\r\n         * @returns {Bool} true when node's truthiness is constant\r\n         * @private\r\n         */\r\n        function isConstant(node, inBooleanPosition) {\r\n\r\n            // node.elements can return null values in the case of sparse arrays ex. [,]\r\n            if (!node) {\r\n                return true;\r\n            }\r\n            switch (node.type) {\r\n                case \"Literal\":\r\n                case \"ArrowFunctionExpression\":\r\n                case \"FunctionExpression\":\r\n                    return true;\r\n                case \"ClassExpression\":\r\n                case \"ObjectExpression\":\r\n\r\n                    /**\r\n                     * In theory objects like:\r\n                     *\r\n                     * `{toString: () => a}`\r\n                     * `{valueOf: () => a}`\r\n                     *\r\n                     * Or a classes like:\r\n                     *\r\n                     * `class { static toString() { return a } }`\r\n                     * `class { static valueOf() { return a } }`\r\n                     *\r\n                     * Are not constant verifiably when `inBooleanPosition` is\r\n                     * false, but it's an edge case we've opted not to handle.\r\n                     */\r\n                    return true;\r\n                case \"TemplateLiteral\":\r\n                    return (inBooleanPosition && node.quasis.some(quasi => quasi.value.cooked.length)) ||\r\n                        node.expressions.every(exp => isConstant(exp, false));\r\n\r\n                case \"ArrayExpression\": {\r\n                    if (!inBooleanPosition) {\r\n                        return node.elements.every(element => isConstant(element, false));\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                case \"UnaryExpression\":\r\n                    if (\r\n                        node.operator === \"void\" ||\r\n                        node.operator === \"typeof\" && inBooleanPosition\r\n                    ) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (node.operator === \"!\") {\r\n                        return isConstant(node.argument, true);\r\n                    }\r\n\r\n                    return isConstant(node.argument, false);\r\n\r\n                case \"BinaryExpression\":\r\n                    return isConstant(node.left, false) &&\r\n                            isConstant(node.right, false) &&\r\n                            node.operator !== \"in\";\r\n\r\n                case \"LogicalExpression\": {\r\n                    const isLeftConstant = isConstant(node.left, inBooleanPosition);\r\n                    const isRightConstant = isConstant(node.right, inBooleanPosition);\r\n                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));\r\n                    const isRightShortCircuit = (inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator));\r\n\r\n                    return (isLeftConstant && isRightConstant) ||\r\n                        isLeftShortCircuit ||\r\n                        isRightShortCircuit;\r\n                }\r\n                case \"NewExpression\":\r\n                    return inBooleanPosition;\r\n                case \"AssignmentExpression\":\r\n                    if (node.operator === \"=\") {\r\n                        return isConstant(node.right, inBooleanPosition);\r\n                    }\r\n\r\n                    if ([\"||=\", \"&&=\"].includes(node.operator) && inBooleanPosition) {\r\n                        return isLogicalIdentity(node.right, node.operator.slice(0, -1));\r\n                    }\r\n\r\n                    return false;\r\n\r\n                case \"SequenceExpression\":\r\n                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);\r\n                case \"SpreadElement\":\r\n                    return isConstant(node.argument, inBooleanPosition);\r\n                case \"CallExpression\":\r\n                    if (node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\") {\r\n                        if (node.arguments.length === 0 || isConstant(node.arguments[0], true)) {\r\n                            return isReferenceToGlobalVariable(node.callee);\r\n                        }\r\n                    }\r\n                    return false;\r\n                case \"Identifier\":\r\n                    return node.name === \"undefined\" && isReferenceToGlobalVariable(node);\r\n\r\n                // no default\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Tracks when the given node contains a constant condition.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function trackConstantConditionLoop(node) {\r\n            if (node.test && isConstant(node.test, true)) {\r\n                loopsInCurrentScope.add(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports when the set contains the given constant condition node\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkConstantConditionLoopInSet(node) {\r\n            if (loopsInCurrentScope.has(node)) {\r\n                loopsInCurrentScope.delete(node);\r\n                context.report({ node: node.test, messageId: \"unexpected\" });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports when the given node contains a constant condition.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function reportIfConstant(node) {\r\n            if (node.test && isConstant(node.test, true)) {\r\n                context.report({ node: node.test, messageId: \"unexpected\" });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Stores current set of constant loops in loopSetStack temporarily\r\n         * and uses a new set to track constant loops\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function enterFunction() {\r\n            loopSetStack.push(loopsInCurrentScope);\r\n            loopsInCurrentScope = new Set();\r\n        }\r\n\r\n        /**\r\n         * Reports when the set still contains stored constant conditions\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function exitFunction() {\r\n            loopsInCurrentScope = loopSetStack.pop();\r\n        }\r\n\r\n        /**\r\n         * Checks node when checkLoops option is enabled\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkLoop(node) {\r\n            if (checkLoops) {\r\n                trackConstantConditionLoop(node);\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            ConditionalExpression: reportIfConstant,\r\n            IfStatement: reportIfConstant,\r\n            WhileStatement: checkLoop,\r\n            \"WhileStatement:exit\": checkConstantConditionLoopInSet,\r\n            DoWhileStatement: checkLoop,\r\n            \"DoWhileStatement:exit\": checkConstantConditionLoopInSet,\r\n            ForStatement: checkLoop,\r\n            \"ForStatement > .test\": node => checkLoop(node.parent),\r\n            \"ForStatement:exit\": checkConstantConditionLoopInSet,\r\n            FunctionDeclaration: enterFunction,\r\n            \"FunctionDeclaration:exit\": exitFunction,\r\n            FunctionExpression: enterFunction,\r\n            \"FunctionExpression:exit\": exitFunction,\r\n            YieldExpression: () => loopsInCurrentScope.clear()\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}