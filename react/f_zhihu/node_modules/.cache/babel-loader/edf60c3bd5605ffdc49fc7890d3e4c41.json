{"ast":null,"code":"/**\r\n * @fileoverview Config Comment Parser\r\n * @author Nicholas C. Zakas\r\n */\n\n/* eslint class-methods-use-this: off -- Methods desired on instance */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst levn = require(\"levn\"),\n      {\n  Legacy: {\n    ConfigOps\n  }\n} = require(\"@eslint/eslintrc/universal\");\n\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * Object to parse ESLint configuration comments inside JavaScript files.\r\n * @name ConfigCommentParser\r\n */\n\n\nmodule.exports = class ConfigCommentParser {\n  /**\r\n   * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\r\n   * whitespace. Used for \"global\" and \"exported\" comments.\r\n   * @param {string} string The string to parse.\r\n   * @param {Comment} comment The comment node which has the string.\r\n   * @returns {Object} Result map object of names and string values, or null values if no value was provided\r\n   */\n  parseStringConfig(string, comment) {\n    debug(\"Parsing String config\");\n    const items = {}; // Collapse whitespace around `:` and `,` to make parsing easier\n\n    const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\n    trimmedString.split(/\\s|,+/u).forEach(name => {\n      if (!name) {\n        return;\n      } // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\n\n\n      const [key, value = null] = name.split(\":\");\n      items[key] = {\n        value,\n        comment\n      };\n    });\n    return items;\n  }\n  /**\r\n   * Parses a JSON-like config.\r\n   * @param {string} string The string to parse.\r\n   * @param {Object} location Start line and column of comments for potential error message.\r\n   * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\r\n   */\n\n\n  parseJsonConfig(string, location) {\n    debug(\"Parsing JSON config\");\n    let items = {}; // Parses a JSON-like comment by the same way as parsing CLI option.\n\n    try {\n      items = levn.parse(\"Object\", string) || {}; // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n      // Also, commaless notations have invalid severity:\n      //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n      // Should ignore that case as well.\n\n      if (ConfigOps.isEverySeverityValid(items)) {\n        return {\n          success: true,\n          config: items\n        };\n      }\n    } catch {\n      debug(\"Levn parsing failed; falling back to manual parsing.\"); // ignore to parse the string by a fallback.\n    }\n    /*\r\n     * Optionator cannot parse commaless notations.\r\n     * But we are supporting that. So this is a fallback for that.\r\n     */\n\n\n    items = {};\n    const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\n\n    try {\n      items = JSON.parse(`{${normalizedString}}`);\n    } catch (ex) {\n      debug(\"Manual parsing failed.\");\n      return {\n        success: false,\n        error: {\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\n          line: location.start.line,\n          column: location.start.column + 1\n        }\n      };\n    }\n\n    return {\n      success: true,\n      config: items\n    };\n  }\n  /**\r\n   * Parses a config of values separated by comma.\r\n   * @param {string} string The string to parse.\r\n   * @returns {Object} Result map of values and true values\r\n   */\n\n\n  parseListConfig(string) {\n    debug(\"Parsing list config\");\n    const items = {}; // Collapse whitespace around commas\n\n    string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\n      const trimmedName = name.trim();\n\n      if (trimmedName) {\n        items[trimmedName] = true;\n      }\n    });\n    return items;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/config-comment-parser.js"],"names":["levn","require","Legacy","ConfigOps","debug","module","exports","ConfigCommentParser","parseStringConfig","string","comment","items","trimmedString","replace","split","forEach","name","key","value","parseJsonConfig","location","parse","isEverySeverityValid","success","config","normalizedString","JSON","ex","error","ruleId","fatal","severity","message","line","start","column","parseListConfig","trimmedName","trim"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;AAAA,MACI;AACIC,EAAAA,MAAM,EAAE;AACJC,IAAAA;AADI;AADZ,IAIIF,OAAO,CAAC,4BAAD,CALf;;AAOA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAAP,CAAiB,8BAAjB,CAAd,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,MAAMC,mBAAN,CAA0B;AAEvC;AACJ;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,iBAAiB,CAACC,MAAD,EAASC,OAAT,EAAkB;AAC/BN,IAAAA,KAAK,CAAC,uBAAD,CAAL;AAEA,UAAMO,KAAK,GAAG,EAAd,CAH+B,CAK/B;;AACA,UAAMC,aAAa,GAAGH,MAAM,CAACI,OAAP,CAAe,gBAAf,EAAiC,IAAjC,CAAtB;AAEAD,IAAAA,aAAa,CAACE,KAAd,CAAoB,QAApB,EAA8BC,OAA9B,CAAsCC,IAAI,IAAI;AAC1C,UAAI,CAACA,IAAL,EAAW;AACP;AACH,OAHyC,CAK1C;;;AACA,YAAM,CAACC,GAAD,EAAMC,KAAK,GAAG,IAAd,IAAsBF,IAAI,CAACF,KAAL,CAAW,GAAX,CAA5B;AAEAH,MAAAA,KAAK,CAACM,GAAD,CAAL,GAAa;AAAEC,QAAAA,KAAF;AAASR,QAAAA;AAAT,OAAb;AACH,KATD;AAUA,WAAOC,KAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIQ,EAAAA,eAAe,CAACV,MAAD,EAASW,QAAT,EAAmB;AAC9BhB,IAAAA,KAAK,CAAC,qBAAD,CAAL;AAEA,QAAIO,KAAK,GAAG,EAAZ,CAH8B,CAK9B;;AACA,QAAI;AACAA,MAAAA,KAAK,GAAGX,IAAI,CAACqB,KAAL,CAAW,QAAX,EAAqBZ,MAArB,KAAgC,EAAxC,CADA,CAGA;AACA;AACA;AACA;;AACA,UAAIN,SAAS,CAACmB,oBAAV,CAA+BX,KAA/B,CAAJ,EAA2C;AACvC,eAAO;AACHY,UAAAA,OAAO,EAAE,IADN;AAEHC,UAAAA,MAAM,EAAEb;AAFL,SAAP;AAIH;AACJ,KAbD,CAaE,MAAM;AAEJP,MAAAA,KAAK,CAAC,sDAAD,CAAL,CAFI,CAIJ;AACH;AAED;AACR;AACA;AACA;;;AACQO,IAAAA,KAAK,GAAG,EAAR;AACA,UAAMc,gBAAgB,GAAGhB,MAAM,CAACI,OAAP,CAAe,qBAAf,EAAsC,SAAtC,EAAiDA,OAAjD,CAAyD,qBAAzD,EAAgF,KAAhF,CAAzB;;AAEA,QAAI;AACAF,MAAAA,KAAK,GAAGe,IAAI,CAACL,KAAL,CAAY,IAAGI,gBAAiB,GAAhC,CAAR;AACH,KAFD,CAEE,OAAOE,EAAP,EAAW;AACTvB,MAAAA,KAAK,CAAC,wBAAD,CAAL;AAEA,aAAO;AACHmB,QAAAA,OAAO,EAAE,KADN;AAEHK,QAAAA,KAAK,EAAE;AACHC,UAAAA,MAAM,EAAE,IADL;AAEHC,UAAAA,KAAK,EAAE,IAFJ;AAGHC,UAAAA,QAAQ,EAAE,CAHP;AAIHC,UAAAA,OAAO,EAAG,8BAA6BP,gBAAiB,MAAKE,EAAE,CAACK,OAAQ,EAJrE;AAKHC,UAAAA,IAAI,EAAEb,QAAQ,CAACc,KAAT,CAAeD,IALlB;AAMHE,UAAAA,MAAM,EAAEf,QAAQ,CAACc,KAAT,CAAeC,MAAf,GAAwB;AAN7B;AAFJ,OAAP;AAYH;;AAED,WAAO;AACHZ,MAAAA,OAAO,EAAE,IADN;AAEHC,MAAAA,MAAM,EAAEb;AAFL,KAAP;AAIH;AAED;AACJ;AACA;AACA;AACA;;;AACIyB,EAAAA,eAAe,CAAC3B,MAAD,EAAS;AACpBL,IAAAA,KAAK,CAAC,qBAAD,CAAL;AAEA,UAAMO,KAAK,GAAG,EAAd,CAHoB,CAKpB;;AACAF,IAAAA,MAAM,CAACI,OAAP,CAAe,WAAf,EAA4B,GAA5B,EAAiCC,KAAjC,CAAuC,KAAvC,EAA8CC,OAA9C,CAAsDC,IAAI,IAAI;AAC1D,YAAMqB,WAAW,GAAGrB,IAAI,CAACsB,IAAL,EAApB;;AAEA,UAAID,WAAJ,EAAiB;AACb1B,QAAAA,KAAK,CAAC0B,WAAD,CAAL,GAAqB,IAArB;AACH;AACJ,KAND;AAOA,WAAO1B,KAAP;AACH;;AAjHsC,CAA3C","sourcesContent":["/**\r\n * @fileoverview Config Comment Parser\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n/* eslint class-methods-use-this: off -- Methods desired on instance */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst levn = require(\"levn\"),\r\n    {\r\n        Legacy: {\r\n            ConfigOps\r\n        }\r\n    } = require(\"@eslint/eslintrc/universal\");\r\n\r\nconst debug = require(\"debug\")(\"eslint:config-comment-parser\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Object to parse ESLint configuration comments inside JavaScript files.\r\n * @name ConfigCommentParser\r\n */\r\nmodule.exports = class ConfigCommentParser {\r\n\r\n    /**\r\n     * Parses a list of \"name:string_value\" or/and \"name\" options divided by comma or\r\n     * whitespace. Used for \"global\" and \"exported\" comments.\r\n     * @param {string} string The string to parse.\r\n     * @param {Comment} comment The comment node which has the string.\r\n     * @returns {Object} Result map object of names and string values, or null values if no value was provided\r\n     */\r\n    parseStringConfig(string, comment) {\r\n        debug(\"Parsing String config\");\r\n\r\n        const items = {};\r\n\r\n        // Collapse whitespace around `:` and `,` to make parsing easier\r\n        const trimmedString = string.replace(/\\s*([:,])\\s*/gu, \"$1\");\r\n\r\n        trimmedString.split(/\\s|,+/u).forEach(name => {\r\n            if (!name) {\r\n                return;\r\n            }\r\n\r\n            // value defaults to null (if not provided), e.g: \"foo\" => [\"foo\", null]\r\n            const [key, value = null] = name.split(\":\");\r\n\r\n            items[key] = { value, comment };\r\n        });\r\n        return items;\r\n    }\r\n\r\n    /**\r\n     * Parses a JSON-like config.\r\n     * @param {string} string The string to parse.\r\n     * @param {Object} location Start line and column of comments for potential error message.\r\n     * @returns {({success: true, config: Object}|{success: false, error: Problem})} Result map object\r\n     */\r\n    parseJsonConfig(string, location) {\r\n        debug(\"Parsing JSON config\");\r\n\r\n        let items = {};\r\n\r\n        // Parses a JSON-like comment by the same way as parsing CLI option.\r\n        try {\r\n            items = levn.parse(\"Object\", string) || {};\r\n\r\n            // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\r\n            // Also, commaless notations have invalid severity:\r\n            //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\r\n            // Should ignore that case as well.\r\n            if (ConfigOps.isEverySeverityValid(items)) {\r\n                return {\r\n                    success: true,\r\n                    config: items\r\n                };\r\n            }\r\n        } catch {\r\n\r\n            debug(\"Levn parsing failed; falling back to manual parsing.\");\r\n\r\n            // ignore to parse the string by a fallback.\r\n        }\r\n\r\n        /*\r\n         * Optionator cannot parse commaless notations.\r\n         * But we are supporting that. So this is a fallback for that.\r\n         */\r\n        items = {};\r\n        const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/u, \"$1,\");\r\n\r\n        try {\r\n            items = JSON.parse(`{${normalizedString}}`);\r\n        } catch (ex) {\r\n            debug(\"Manual parsing failed.\");\r\n\r\n            return {\r\n                success: false,\r\n                error: {\r\n                    ruleId: null,\r\n                    fatal: true,\r\n                    severity: 2,\r\n                    message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,\r\n                    line: location.start.line,\r\n                    column: location.start.column + 1\r\n                }\r\n            };\r\n\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            config: items\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Parses a config of values separated by comma.\r\n     * @param {string} string The string to parse.\r\n     * @returns {Object} Result map of values and true values\r\n     */\r\n    parseListConfig(string) {\r\n        debug(\"Parsing list config\");\r\n\r\n        const items = {};\r\n\r\n        // Collapse whitespace around commas\r\n        string.replace(/\\s*,\\s*/gu, \",\").split(/,+/u).forEach(name => {\r\n            const trimmedName = name.trim();\r\n\r\n            if (trimmedName) {\r\n                items[trimmedName] = true;\r\n            }\r\n        });\r\n        return items;\r\n    }\r\n\r\n};\r\n"]},"metadata":{},"sourceType":"script"}