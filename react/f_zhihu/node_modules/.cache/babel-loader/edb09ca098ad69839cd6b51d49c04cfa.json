{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\r\n * @author Stephen Murray <spmurrayzzz>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\nconst NODE_DESCRIPTIONS = {\n  DoWhileStatement: \"a 'do...while' statement\",\n  ForStatement: \"a 'for' statement\",\n  IfStatement: \"an 'if' statement\",\n  WhileStatement: \"a 'while' statement\"\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignment operators in conditional expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-cond-assign\"\n    },\n    schema: [{\n      enum: [\"except-parens\", \"always\"]\n    }],\n    messages: {\n      unexpected: \"Unexpected assignment within {{type}}.\",\n      // must match JSHint's error message\n      missing: \"Expected a conditional expression and instead saw an assignment.\"\n    }\n  },\n\n  create(context) {\n    const prohibitAssign = context.options[0] || \"except-parens\";\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Check whether an AST node is the test expression for a conditional statement.\r\n     * @param {!Object} node The node to test.\r\n     * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\r\n     */\n\n    function isConditionalTestExpression(node) {\n      return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;\n    }\n    /**\r\n     * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\r\n     * @param {!Object} node The node to use at the start of the search.\r\n     * @returns {?Object} The closest ancestor node that represents a conditional statement.\r\n     */\n\n\n    function findConditionalAncestor(node) {\n      let currentAncestor = node;\n\n      do {\n        if (isConditionalTestExpression(currentAncestor)) {\n          return currentAncestor.parent;\n        }\n      } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\n\n      return null;\n    }\n    /**\r\n     * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\r\n     * @param {!Object} node The node to test.\r\n     * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\r\n     */\n\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n    /**\r\n     * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\r\n     * @param {!Object} node The node for the conditional statement.\r\n     * @returns {void}\r\n     */\n\n\n    function testForAssign(node) {\n      if (node.test && node.test.type === \"AssignmentExpression\" && (node.type === \"ForStatement\" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {\n        context.report({\n          node: node.test,\n          messageId: \"missing\"\n        });\n      }\n    }\n    /**\r\n     * Check whether an assignment expression is descended from a conditional statement's test expression.\r\n     * @param {!Object} node The node for the assignment expression.\r\n     * @returns {void}\r\n     */\n\n\n    function testForConditionalAncestor(node) {\n      const ancestor = findConditionalAncestor(node);\n\n      if (ancestor) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n          }\n        });\n      }\n    }\n\n    if (prohibitAssign === \"always\") {\n      return {\n        AssignmentExpression: testForConditionalAncestor\n      };\n    }\n\n    return {\n      DoWhileStatement: testForAssign,\n      ForStatement: testForAssign,\n      IfStatement: testForAssign,\n      WhileStatement: testForAssign,\n      ConditionalExpression: testForAssign\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-cond-assign.js"],"names":["astUtils","require","TEST_CONDITION_PARENT_TYPES","Set","NODE_DESCRIPTIONS","DoWhileStatement","ForStatement","IfStatement","WhileStatement","module","exports","meta","type","docs","description","recommended","url","schema","enum","messages","unexpected","missing","create","context","prohibitAssign","options","sourceCode","getSourceCode","isConditionalTestExpression","node","parent","has","test","findConditionalAncestor","currentAncestor","isFunction","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isParenthesised","isOpeningParenToken","range","isClosingParenToken","testForAssign","report","messageId","testForConditionalAncestor","ancestor","data","AssignmentExpression","ConditionalExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\r\n * @author Stephen Murray <spmurrayzzz>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst TEST_CONDITION_PARENT_TYPES = new Set([\"IfStatement\", \"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ConditionalExpression\"]);\r\n\r\nconst NODE_DESCRIPTIONS = {\r\n    DoWhileStatement: \"a 'do...while' statement\",\r\n    ForStatement: \"a 'for' statement\",\r\n    IfStatement: \"an 'if' statement\",\r\n    WhileStatement: \"a 'while' statement\"\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow assignment operators in conditional expressions\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-cond-assign\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"except-parens\", \"always\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected assignment within {{type}}.\",\r\n\r\n            // must match JSHint's error message\r\n            missing: \"Expected a conditional expression and instead saw an assignment.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const prohibitAssign = (context.options[0] || \"except-parens\");\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Check whether an AST node is the test expression for a conditional statement.\r\n         * @param {!Object} node The node to test.\r\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\r\n         */\r\n        function isConditionalTestExpression(node) {\r\n            return node.parent &&\r\n                TEST_CONDITION_PARENT_TYPES.has(node.parent.type) &&\r\n                node === node.parent.test;\r\n        }\r\n\r\n        /**\r\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\r\n         * @param {!Object} node The node to use at the start of the search.\r\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\r\n         */\r\n        function findConditionalAncestor(node) {\r\n            let currentAncestor = node;\r\n\r\n            do {\r\n                if (isConditionalTestExpression(currentAncestor)) {\r\n                    return currentAncestor.parent;\r\n                }\r\n            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\r\n         * @param {!Object} node The node to test.\r\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\r\n         */\r\n        function isParenthesisedTwice(node) {\r\n            const previousToken = sourceCode.getTokenBefore(node, 1),\r\n                nextToken = sourceCode.getTokenAfter(node, 1);\r\n\r\n            return astUtils.isParenthesised(sourceCode, node) &&\r\n                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\r\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\r\n        }\r\n\r\n        /**\r\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\r\n         * @param {!Object} node The node for the conditional statement.\r\n         * @returns {void}\r\n         */\r\n        function testForAssign(node) {\r\n            if (node.test &&\r\n                (node.test.type === \"AssignmentExpression\") &&\r\n                (node.type === \"ForStatement\"\r\n                    ? !astUtils.isParenthesised(sourceCode, node.test)\r\n                    : !isParenthesisedTwice(node.test)\r\n                )\r\n            ) {\r\n\r\n                context.report({\r\n                    node: node.test,\r\n                    messageId: \"missing\"\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\r\n         * @param {!Object} node The node for the assignment expression.\r\n         * @returns {void}\r\n         */\r\n        function testForConditionalAncestor(node) {\r\n            const ancestor = findConditionalAncestor(node);\r\n\r\n            if (ancestor) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpected\",\r\n                    data: {\r\n                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (prohibitAssign === \"always\") {\r\n            return {\r\n                AssignmentExpression: testForConditionalAncestor\r\n            };\r\n        }\r\n\r\n        return {\r\n            DoWhileStatement: testForAssign,\r\n            ForStatement: testForAssign,\r\n            IfStatement: testForAssign,\r\n            WhileStatement: testForAssign,\r\n            ConditionalExpression: testForAssign\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}