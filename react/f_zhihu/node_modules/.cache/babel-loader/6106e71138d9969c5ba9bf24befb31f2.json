{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar path = _interopDefault(require('path'));\n\nvar minimatch = _interopDefault(require('minimatch'));\n\nvar createDebug = _interopDefault(require('debug'));\n\nvar objectSchema = require('@humanwhocodes/object-schema');\n/**\r\n * @fileoverview ConfigSchema\r\n * @author Nicholas C. Zakas\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Assets that a given value is an array.\r\n * @param {*} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the value is not an array. \r\n */\n\n\nfunction assertIsArray(value) {\n  if (!Array.isArray(value)) {\n    throw new TypeError('Expected value to be an array.');\n  }\n}\n/**\r\n * Assets that a given value is an array containing only strings and functions.\r\n * @param {*} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the value is not an array of strings and functions.\r\n */\n\n\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\n  assertIsArray(value);\n\n  if (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\n    throw new TypeError('Expected array to only contain strings.');\n  }\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\r\n * The base schema that every ConfigArray uses.\r\n * @type Object\r\n */\n\n\nconst baseSchema = Object.freeze({\n  name: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate(value) {\n      if (typeof value !== 'string') {\n        throw new TypeError('Property must be a string.');\n      }\n    }\n\n  },\n  files: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate(value) {\n      // first check if it's an array\n      assertIsArray(value); // then check each member\n\n      value.forEach(item => {\n        if (Array.isArray(item)) {\n          assertIsArrayOfStringsAndFunctions(item);\n        } else if (typeof item !== 'string' && typeof item !== 'function') {\n          throw new TypeError('Items must be a string, a function, or an array of strings and functions.');\n        }\n      });\n    }\n\n  },\n  ignores: {\n    required: false,\n\n    merge() {\n      return undefined;\n    },\n\n    validate: assertIsArrayOfStringsAndFunctions\n  }\n});\n/**\r\n * @fileoverview ConfigArray\r\n * @author Nicholas C. Zakas\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst debug = createDebug('@hwc/config-array');\nconst MINIMATCH_OPTIONS = {\n  matchBase: true,\n  dot: true\n};\nconst CONFIG_TYPES = new Set(['array', 'function']);\n/**\r\n * Shorthand for checking if a value is a string.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} True if a string, false if not. \r\n */\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n/**\r\n * Normalizes a `ConfigArray` by flattening it and executing any functions\r\n * that are found inside.\r\n * @param {Array} items The items in a `ConfigArray`.\r\n * @param {Object} context The context object to pass into any function\r\n *      found.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {Promise<Array>} A flattened array containing only config objects.\r\n * @throws {TypeError} When a config function returns a function.\r\n */\n\n\nasync function normalize(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n\n  async function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n\n        item = item(context);\n\n        if (item.then) {\n          item = await item;\n        }\n      }\n\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n  /*\r\n   * Async iterables cannot be used with the spread operator, so we need to manually\r\n   * create the array to return.\r\n   */\n\n\n  const asyncIterable = await flatTraverse(items);\n  const configs = [];\n\n  for await (const config of asyncIterable) {\n    configs.push(config);\n  }\n\n  return configs;\n}\n/**\r\n * Normalizes a `ConfigArray` by flattening it and executing any functions\r\n * that are found inside.\r\n * @param {Array} items The items in a `ConfigArray`.\r\n * @param {Object} context The context object to pass into any function\r\n *      found.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {Array} A flattened array containing only config objects.\r\n * @throws {TypeError} When a config function returns a function.\r\n */\n\n\nfunction normalizeSync(items, context, extraConfigTypes) {\n  const allowFunctions = extraConfigTypes.includes('function');\n  const allowArrays = extraConfigTypes.includes('array');\n\n  function* flatTraverse(array) {\n    for (let item of array) {\n      if (typeof item === 'function') {\n        if (!allowFunctions) {\n          throw new TypeError('Unexpected function.');\n        }\n\n        item = item(context);\n\n        if (item.then) {\n          throw new TypeError('Async config functions are not supported.');\n        }\n      }\n\n      if (Array.isArray(item)) {\n        if (!allowArrays) {\n          throw new TypeError('Unexpected array.');\n        }\n\n        yield* flatTraverse(item);\n      } else if (typeof item === 'function') {\n        throw new TypeError('A config function can only return an object or array.');\n      } else {\n        yield item;\n      }\n    }\n  }\n\n  return [...flatTraverse(items)];\n}\n/**\r\n * Determines if a given file path should be ignored based on the given\r\n * matcher.\r\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \r\n * @param {string} filePath The absolute path of the file to check.\r\n * @param {string} relativeFilePath The relative path of the file to check.\r\n * @returns {boolean} True if the path should be ignored and false if not.\r\n */\n\n\nfunction shouldIgnoreFilePath(ignores, filePath, relativeFilePath) {\n  let shouldIgnore = false;\n\n  for (const matcher of ignores) {\n    if (typeof matcher === 'function') {\n      shouldIgnore = shouldIgnore || matcher(filePath);\n      continue;\n    }\n    /*\r\n     * If there's a negated pattern, that means anything matching\r\n     * must NOT be ignored. To do that, we need to use the `flipNegate`\r\n     * option for minimatch to check if the filepath matches the\r\n     * pattern specified after the !, and if that result is true,\r\n     * then we return false immediately because this file should\r\n     * never be ignored.\r\n     */\n\n\n    if (matcher.startsWith('!')) {\n      /*\r\n       * The file must already be ignored in order to apply a negated\r\n       * pattern, because negated patterns simply remove files that\r\n       * would already be ignored.\r\n       */\n      if (shouldIgnore && minimatch(relativeFilePath, matcher, { ...MINIMATCH_OPTIONS,\n        flipNegate: true\n      })) {\n        return false;\n      }\n    } else {\n      shouldIgnore = shouldIgnore || minimatch(relativeFilePath, matcher, MINIMATCH_OPTIONS);\n    }\n  }\n\n  return shouldIgnore;\n}\n/**\r\n * Determines if a given file path is matched by a config. If the config\r\n * has no `files` field, then it matches; otherwise, if a `files` field\r\n * is present then we match the globs in `files` and exclude any globs in\r\n * `ignores`.\r\n * @param {string} filePath The absolute file path to check.\r\n * @param {Object} config The config object to check.\r\n * @returns {boolean} True if the file path is matched by the config,\r\n *      false if not.\r\n */\n\n\nfunction pathMatches(filePath, basePath, config) {\n  // a config without `files` field always match\n  if (!config.files) {\n    return true;\n  }\n  /*\r\n   * For both files and ignores, functions are passed the absolute\r\n   * file path while strings are compared against the relative\r\n   * file path.\r\n   */\n\n\n  const relativeFilePath = path.relative(basePath, filePath); // if files isn't an array, throw an error\n\n  if (!Array.isArray(config.files) || config.files.length === 0) {\n    throw new TypeError('The files key must be a non-empty array.');\n  } // match both strings and functions\n\n\n  const match = pattern => {\n    if (isString(pattern)) {\n      return minimatch(relativeFilePath, pattern, MINIMATCH_OPTIONS);\n    }\n\n    if (typeof pattern === 'function') {\n      return pattern(filePath);\n    }\n\n    throw new TypeError(`Unexpected matcher type ${pattern}.`);\n  }; // check for all matches to config.files\n\n\n  let filePathMatchesPattern = config.files.some(pattern => {\n    if (Array.isArray(pattern)) {\n      return pattern.every(match);\n    }\n\n    return match(pattern);\n  });\n  /*\r\n   * If the file path matches the config.files patterns, then check to see\r\n   * if there are any files to ignore.\r\n   */\n\n  if (filePathMatchesPattern && config.ignores) {\n    filePathMatchesPattern = !shouldIgnoreFilePath(config.ignores, filePath, relativeFilePath);\n  }\n\n  return filePathMatchesPattern;\n}\n/**\r\n * Ensures that a ConfigArray has been normalized.\r\n * @param {ConfigArray} configArray The ConfigArray to check. \r\n * @returns {void}\r\n * @throws {Error} When the `ConfigArray` is not normalized.\r\n */\n\n\nfunction assertNormalized(configArray) {\n  // TODO: Throw more verbose error\n  if (!configArray.isNormalized()) {\n    throw new Error('ConfigArray must be normalized to perform this operation.');\n  }\n}\n/**\r\n * Ensures that config types are valid.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {void}\r\n * @throws {Error} When the config types array is invalid.\r\n */\n\n\nfunction assertExtraConfigTypes(extraConfigTypes) {\n  if (extraConfigTypes.length > 2) {\n    throw new TypeError('configTypes must be an array with at most two items.');\n  }\n\n  for (const configType of extraConfigTypes) {\n    if (!CONFIG_TYPES.has(configType)) {\n      throw new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\n    }\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nconst ConfigArraySymbol = {\n  isNormalized: Symbol('isNormalized'),\n  configCache: Symbol('configCache'),\n  schema: Symbol('schema'),\n  finalizeConfig: Symbol('finalizeConfig'),\n  preprocessConfig: Symbol('preprocessConfig')\n}; // used to store calculate data for faster lookup\n\nconst dataCache = new WeakMap();\n/**\r\n * Represents an array of config objects and provides method for working with\r\n * those config objects.\r\n */\n\nclass ConfigArray extends Array {\n  /**\r\n   * Creates a new instance of ConfigArray.\r\n   * @param {Iterable|Function|Object} configs An iterable yielding config\r\n   *      objects, or a config function, or a config object.\r\n   * @param {string} [options.basePath=\"\"] The path of the config file\r\n   * @param {boolean} [options.normalized=false] Flag indicating if the\r\n   *      configs have already been normalized.\r\n   * @param {Object} [options.schema] The additional schema \r\n   *      definitions to use for the ConfigArray schema.\r\n   * @param {Array<string>} [options.configTypes] List of config types supported.\r\n   */\n  constructor(configs) {\n    let {\n      basePath = '',\n      normalized = false,\n      schema: customSchema,\n      extraConfigTypes = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    /**\r\n    * Tracks if the array has been normalized.\r\n    * @property isNormalized\r\n    * @type boolean\r\n    * @private\r\n    */\n\n    this[ConfigArraySymbol.isNormalized] = normalized;\n    /**\r\n    * The schema used for validating and merging configs.\r\n    * @property schema\r\n    * @type ObjectSchema\r\n    * @private\r\n    */\n\n    this[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema({ ...customSchema,\n      ...baseSchema\n    });\n    /**\r\n    * The path of the config file that this array was loaded from.\r\n    * This is used to calculate filename matches.\r\n    * @property basePath\r\n    * @type string\r\n    */\n\n    this.basePath = basePath;\n    assertExtraConfigTypes(extraConfigTypes);\n    /**\r\n    * The supported config types.\r\n    * @property configTypes\r\n    * @type Array<string>\r\n    */\n\n    this.extraConfigTypes = Object.freeze([...extraConfigTypes]);\n    /**\r\n    * A cache to store calculated configs for faster repeat lookup.\r\n    * @property configCache\r\n    * @type Map\r\n    * @private\r\n    */\n\n    this[ConfigArraySymbol.configCache] = new Map(); // init cache\n\n    dataCache.set(this, {}); // load the configs into this array\n\n    if (Array.isArray(configs)) {\n      this.push(...configs);\n    } else {\n      this.push(configs);\n    }\n  }\n  /**\r\n  \t * Prevent normal array methods from creating a new `ConfigArray` instance.\r\n  \t * This is to ensure that methods such as `slice()` won't try to create a \r\n  \t * new instance of `ConfigArray` behind the scenes as doing so may throw\r\n  \t * an error due to the different constructor signature.\r\n  \t * @returns {Function} The `Array` constructor.\r\n  \t */\n\n\n  static get [Symbol.species]() {\n    return Array;\n  }\n  /**\r\n  \t * Returns the `files` globs from every config object in the array.\r\n  \t * This can be used to determine which files will be matched by a\r\n  \t * config array or to use as a glob pattern when no patterns are provided\r\n  \t * for a command line interface.\r\n  \t * @returns {Array<string|Function>} An array of matchers.\r\n  \t */\n\n\n  get files() {\n    assertNormalized(this); // if this data has been cached, retrieve it\n\n    const cache = dataCache.get(this);\n\n    if (cache.files) {\n      return cache.files;\n    } // otherwise calculate it\n\n\n    const result = [];\n\n    for (const config of this) {\n      if (config.files) {\n        config.files.forEach(filePattern => {\n          result.push(filePattern);\n        });\n      }\n    } // store result\n\n\n    cache.files = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n  /**\r\n  \t * Returns ignore matchers that should always be ignored regardless of\r\n  \t * the matching `files` fields in any configs. This is necessary to mimic\r\n  \t * the behavior of things like .gitignore and .eslintignore, allowing a\r\n  \t * globbing operation to be faster.\r\n  \t * @returns {string[]} An array of string patterns and functions to be ignored.\r\n  \t */\n\n\n  get ignores() {\n    assertNormalized(this); // if this data has been cached, retrieve it\n\n    const cache = dataCache.get(this);\n\n    if (cache.ignores) {\n      return cache.ignores;\n    } // otherwise calculate it\n\n\n    const result = [];\n\n    for (const config of this) {\n      if (config.ignores && !config.files) {\n        result.push(...config.ignores);\n      }\n    } // store result\n\n\n    cache.ignores = result;\n    dataCache.set(this, cache);\n    return result;\n  }\n  /**\r\n  \t * Indicates if the config array has been normalized.\r\n  \t * @returns {boolean} True if the config array is normalized, false if not.\r\n  \t */\n\n\n  isNormalized() {\n    return this[ConfigArraySymbol.isNormalized];\n  }\n  /**\r\n  \t * Normalizes a config array by flattening embedded arrays and executing\r\n  \t * config functions.\r\n  \t * @param {ConfigContext} context The context object for config functions.\r\n  \t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\r\n  \t */\n\n\n  async normalize() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isNormalized()) {\n      const normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\n      this[ConfigArraySymbol.isNormalized] = true; // prevent further changes\n\n      Object.freeze(this);\n    }\n\n    return this;\n  }\n  /**\r\n  \t * Normalizes a config array by flattening embedded arrays and executing\r\n  \t * config functions.\r\n  \t * @param {ConfigContext} context The context object for config functions.\r\n  \t * @returns {ConfigArray} The current ConfigArray instance.\r\n  \t */\n\n\n  normalizeSync() {\n    let context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isNormalized()) {\n      const normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\n      this.length = 0;\n      this.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig]));\n      this[ConfigArraySymbol.isNormalized] = true; // prevent further changes\n\n      Object.freeze(this);\n    }\n\n    return this;\n  }\n  /**\r\n  \t * Finalizes the state of a config before being cached and returned by\r\n  \t * `getConfig()`. Does nothing by default but is provided to be\r\n  \t * overridden by subclasses as necessary.\r\n  \t * @param {Object} config The config to finalize.\r\n  \t * @returns {Object} The finalized config.\r\n  \t */\n\n\n  [ConfigArraySymbol.finalizeConfig](config) {\n    return config;\n  }\n  /**\r\n  \t * Preprocesses a config during the normalization process. This is the\r\n  \t * method to override if you want to convert an array item before it is\r\n  \t * validated for the first time. For example, if you want to replace a\r\n  \t * string with an object, this is the method to override.\r\n  \t * @param {Object} config The config to preprocess.\r\n  \t * @returns {Object} The config to use in place of the argument.\r\n  \t */\n\n\n  [ConfigArraySymbol.preprocessConfig](config) {\n    return config;\n  }\n  /**\r\n  \t * Returns the config object for a given file path.\r\n  \t * @param {string} filePath The complete path of a file to get a config for.\r\n  \t * @returns {Object} The config object for this file.\r\n  \t */\n\n\n  getConfig(filePath) {\n    assertNormalized(this); // first check the cache to avoid duplicate work\n\n    let finalConfig = this[ConfigArraySymbol.configCache].get(filePath);\n\n    if (finalConfig) {\n      return finalConfig;\n    } // TODO: Maybe move elsewhere?\n\n\n    const relativeFilePath = path.relative(this.basePath, filePath);\n\n    if (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\n      // cache and return result - finalConfig is undefined at this point\n      this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n      return finalConfig;\n    } // filePath isn't automatically ignored, so try to construct config\n\n\n    const matchingConfigs = [];\n\n    for (const config of this) {\n      if (pathMatches(filePath, this.basePath, config)) {\n        debug(`Matching config found for ${filePath}`);\n        matchingConfigs.push(config);\n      } else {\n        debug(`No matching config found for ${filePath}`);\n      }\n    } // if matching both files and ignores, there will be no config to create\n\n\n    if (matchingConfigs.length === 0) {\n      // cache and return result - finalConfig is undefined at this point\n      this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n      return finalConfig;\n    } // otherwise construct the config\n\n\n    finalConfig = matchingConfigs.reduce((result, config) => {\n      return this[ConfigArraySymbol.schema].merge(result, config);\n    }, {}, this);\n    finalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\n    this[ConfigArraySymbol.configCache].set(filePath, finalConfig);\n    return finalConfig;\n  }\n  /**\r\n  \t * Determines if the given filepath is ignored based on the configs.\r\n  \t * @param {string} filePath The complete path of a file to check.\r\n  \t * @returns {boolean} True if the path is ignored, false if not.\r\n  \t */\n\n\n  isIgnored(filePath) {\n    return this.getConfig(filePath) === undefined;\n  }\n\n}\n\nexports.ConfigArray = ConfigArray;\nexports.ConfigArraySymbol = ConfigArraySymbol;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/@humanwhocodes/config-array/api.js"],"names":["Object","defineProperty","exports","value","_interopDefault","ex","path","require","minimatch","createDebug","objectSchema","assertIsArray","Array","isArray","TypeError","assertIsArrayOfStringsAndFunctions","name","some","item","baseSchema","freeze","required","merge","undefined","validate","files","forEach","ignores","debug","MINIMATCH_OPTIONS","matchBase","dot","CONFIG_TYPES","Set","isString","normalize","items","context","extraConfigTypes","allowFunctions","includes","allowArrays","flatTraverse","array","then","asyncIterable","configs","config","push","normalizeSync","shouldIgnoreFilePath","filePath","relativeFilePath","shouldIgnore","matcher","startsWith","flipNegate","pathMatches","basePath","relative","length","match","pattern","filePathMatchesPattern","every","assertNormalized","configArray","isNormalized","Error","assertExtraConfigTypes","configType","has","ConfigArraySymbol","Symbol","configCache","schema","finalizeConfig","preprocessConfig","dataCache","WeakMap","ConfigArray","constructor","normalized","customSchema","ObjectSchema","Map","set","species","cache","get","result","filePattern","normalizedConfigs","map","bind","getConfig","finalConfig","matchingConfigs","reduce","isIgnored"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\r\n\r\nvar path = _interopDefault(require('path'));\r\nvar minimatch = _interopDefault(require('minimatch'));\r\nvar createDebug = _interopDefault(require('debug'));\r\nvar objectSchema = require('@humanwhocodes/object-schema');\r\n\r\n/**\r\n * @fileoverview ConfigSchema\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Assets that a given value is an array.\r\n * @param {*} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the value is not an array. \r\n */\r\nfunction assertIsArray(value) {\r\n\tif (!Array.isArray(value)) {\r\n\t\tthrow new TypeError('Expected value to be an array.');\r\n\t}\r\n}\r\n\r\n/**\r\n * Assets that a given value is an array containing only strings and functions.\r\n * @param {*} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} When the value is not an array of strings and functions.\r\n */\r\nfunction assertIsArrayOfStringsAndFunctions(value, name) {\r\n\tassertIsArray(value);\r\n\r\n\tif (value.some(item => typeof item !== 'string' && typeof item !== 'function')) {\r\n\t\tthrow new TypeError('Expected array to only contain strings.');\r\n\t}\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Exports\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * The base schema that every ConfigArray uses.\r\n * @type Object\r\n */\r\nconst baseSchema = Object.freeze({\r\n\tname: {\r\n\t\trequired: false,\r\n\t\tmerge() {\r\n\t\t\treturn undefined;\r\n\t\t},\r\n\t\tvalidate(value) {\r\n\t\t\tif (typeof value !== 'string') {\r\n\t\t\t\tthrow new TypeError('Property must be a string.');\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tfiles: {\r\n\t\trequired: false,\r\n\t\tmerge() {\r\n\t\t\treturn undefined;\r\n\t\t},\r\n\t\tvalidate(value) {\r\n\r\n\t\t\t// first check if it's an array\r\n\t\t\tassertIsArray(value);\r\n\r\n\t\t\t// then check each member\r\n\t\t\tvalue.forEach(item => {\r\n\t\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\t\tassertIsArrayOfStringsAndFunctions(item);\r\n\t\t\t\t} else if (typeof item !== 'string' && typeof item !== 'function') {\r\n\t\t\t\t\tthrow new TypeError('Items must be a string, a function, or an array of strings and functions.');\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t},\r\n\tignores: {\r\n\t\trequired: false,\r\n\t\tmerge() {\r\n\t\t\treturn undefined;\r\n\t\t},\r\n\t\tvalidate: assertIsArrayOfStringsAndFunctions\r\n\t}\r\n});\r\n\r\n/**\r\n * @fileoverview ConfigArray\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst debug = createDebug('@hwc/config-array');\r\n\r\nconst MINIMATCH_OPTIONS = {\r\n\tmatchBase: true,\r\n\tdot: true\r\n};\r\n\r\nconst CONFIG_TYPES = new Set(['array', 'function']);\r\n\r\n/**\r\n * Shorthand for checking if a value is a string.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} True if a string, false if not. \r\n */\r\nfunction isString(value) {\r\n\treturn typeof value === 'string';\r\n}\r\n\r\n/**\r\n * Normalizes a `ConfigArray` by flattening it and executing any functions\r\n * that are found inside.\r\n * @param {Array} items The items in a `ConfigArray`.\r\n * @param {Object} context The context object to pass into any function\r\n *      found.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {Promise<Array>} A flattened array containing only config objects.\r\n * @throws {TypeError} When a config function returns a function.\r\n */\r\nasync function normalize(items, context, extraConfigTypes) {\r\n\r\n\tconst allowFunctions = extraConfigTypes.includes('function');\r\n\tconst allowArrays = extraConfigTypes.includes('array');\r\n\r\n\tasync function *flatTraverse(array) {\r\n\t\tfor (let item of array) {\r\n\t\t\tif (typeof item === 'function') {\r\n\t\t\t\tif (!allowFunctions) {\r\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\titem = item(context);\r\n\t\t\t\tif (item.then) {\r\n\t\t\t\t\titem = await item;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(item)) {\r\n\t\t\t\tif (!allowArrays) {\r\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\r\n\t\t\t\t}\r\n\t\t\t\tyield * flatTraverse(item);\r\n\t\t\t} else if (typeof item === 'function') {\r\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\r\n\t\t\t} else {\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * Async iterables cannot be used with the spread operator, so we need to manually\r\n\t * create the array to return.\r\n\t */\r\n\tconst asyncIterable = await flatTraverse(items);\r\n\tconst configs = [];\r\n\r\n\tfor await (const config of asyncIterable) {\r\n\t\tconfigs.push(config);\r\n\t}\r\n\r\n\treturn configs;\r\n}\r\n\r\n/**\r\n * Normalizes a `ConfigArray` by flattening it and executing any functions\r\n * that are found inside.\r\n * @param {Array} items The items in a `ConfigArray`.\r\n * @param {Object} context The context object to pass into any function\r\n *      found.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {Array} A flattened array containing only config objects.\r\n * @throws {TypeError} When a config function returns a function.\r\n */\r\nfunction normalizeSync(items, context, extraConfigTypes) {\r\n\r\n\tconst allowFunctions = extraConfigTypes.includes('function');\r\n\tconst allowArrays = extraConfigTypes.includes('array');\r\n\r\n\tfunction *flatTraverse(array) {\r\n\t\tfor (let item of array) {\r\n\t\t\tif (typeof item === 'function') {\r\n\r\n\t\t\t\tif (!allowFunctions) {\r\n\t\t\t\t\tthrow new TypeError('Unexpected function.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\titem = item(context);\r\n\t\t\t\tif (item.then) {\r\n\t\t\t\t\tthrow new TypeError('Async config functions are not supported.');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(item)) {\r\n\r\n\t\t\t\tif (!allowArrays) {\r\n\t\t\t\t\tthrow new TypeError('Unexpected array.');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tyield * flatTraverse(item);\r\n\t\t\t} else if (typeof item === 'function') {\r\n\t\t\t\tthrow new TypeError('A config function can only return an object or array.');\r\n\t\t\t} else {\r\n\t\t\t\tyield item;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn [...flatTraverse(items)];\r\n}\r\n\r\n/**\r\n * Determines if a given file path should be ignored based on the given\r\n * matcher.\r\n * @param {Array<string|() => boolean>} ignores The ignore patterns to check. \r\n * @param {string} filePath The absolute path of the file to check.\r\n * @param {string} relativeFilePath The relative path of the file to check.\r\n * @returns {boolean} True if the path should be ignored and false if not.\r\n */\r\nfunction shouldIgnoreFilePath(ignores, filePath, relativeFilePath) {\r\n\r\n\tlet shouldIgnore = false;\r\n\r\n\tfor (const matcher of ignores) {\r\n\r\n\t\tif (typeof matcher === 'function') {\r\n\t\t\tshouldIgnore = shouldIgnore || matcher(filePath);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If there's a negated pattern, that means anything matching\r\n\t\t * must NOT be ignored. To do that, we need to use the `flipNegate`\r\n\t\t * option for minimatch to check if the filepath matches the\r\n\t\t * pattern specified after the !, and if that result is true,\r\n\t\t * then we return false immediately because this file should\r\n\t\t * never be ignored.\r\n\t\t */\r\n\t\tif (matcher.startsWith('!')) {\r\n\r\n\t\t\t/*\r\n\t\t\t * The file must already be ignored in order to apply a negated\r\n\t\t\t * pattern, because negated patterns simply remove files that\r\n\t\t\t * would already be ignored.\r\n\t\t\t */\r\n\t\t\tif (shouldIgnore &&\r\n\t\t\t\tminimatch(relativeFilePath, matcher, {\r\n\t\t\t\t\t...MINIMATCH_OPTIONS,\r\n\t\t\t\t\tflipNegate: true\r\n\t\t\t\t})) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tshouldIgnore = shouldIgnore || minimatch(relativeFilePath, matcher, MINIMATCH_OPTIONS);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn shouldIgnore;\r\n}\r\n\r\n/**\r\n * Determines if a given file path is matched by a config. If the config\r\n * has no `files` field, then it matches; otherwise, if a `files` field\r\n * is present then we match the globs in `files` and exclude any globs in\r\n * `ignores`.\r\n * @param {string} filePath The absolute file path to check.\r\n * @param {Object} config The config object to check.\r\n * @returns {boolean} True if the file path is matched by the config,\r\n *      false if not.\r\n */\r\nfunction pathMatches(filePath, basePath, config) {\r\n\r\n\t// a config without `files` field always match\r\n\tif (!config.files) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/*\r\n\t * For both files and ignores, functions are passed the absolute\r\n\t * file path while strings are compared against the relative\r\n\t * file path.\r\n\t */\r\n\tconst relativeFilePath = path.relative(basePath, filePath);\r\n\r\n\t// if files isn't an array, throw an error\r\n\tif (!Array.isArray(config.files) || config.files.length === 0) {\r\n\t\tthrow new TypeError('The files key must be a non-empty array.');\r\n\t}\r\n\r\n\t// match both strings and functions\r\n\tconst match = pattern => {\r\n\r\n\t\tif (isString(pattern)) {\r\n\t\t\treturn minimatch(relativeFilePath, pattern, MINIMATCH_OPTIONS);\r\n\t\t}\r\n\r\n\t\tif (typeof pattern === 'function') {\r\n\t\t\treturn pattern(filePath);\r\n\t\t}\r\n\r\n\t\tthrow new TypeError(`Unexpected matcher type ${pattern}.`);\r\n\t};\r\n\r\n\t// check for all matches to config.files\r\n\tlet filePathMatchesPattern = config.files.some(pattern => {\r\n\t\tif (Array.isArray(pattern)) {\r\n\t\t\treturn pattern.every(match);\r\n\t\t}\r\n\r\n\t\treturn match(pattern);\r\n\t});\r\n\r\n\t/*\r\n\t * If the file path matches the config.files patterns, then check to see\r\n\t * if there are any files to ignore.\r\n\t */\r\n\tif (filePathMatchesPattern && config.ignores) {\r\n\t\tfilePathMatchesPattern = !shouldIgnoreFilePath(config.ignores, filePath, relativeFilePath);\r\n\t}\r\n\r\n\treturn filePathMatchesPattern;\r\n}\r\n\r\n/**\r\n * Ensures that a ConfigArray has been normalized.\r\n * @param {ConfigArray} configArray The ConfigArray to check. \r\n * @returns {void}\r\n * @throws {Error} When the `ConfigArray` is not normalized.\r\n */\r\nfunction assertNormalized(configArray) {\r\n\t// TODO: Throw more verbose error\r\n\tif (!configArray.isNormalized()) {\r\n\t\tthrow new Error('ConfigArray must be normalized to perform this operation.');\r\n\t}\r\n}\r\n\r\n/**\r\n * Ensures that config types are valid.\r\n * @param {Array<string>} extraConfigTypes The config types to check.\r\n * @returns {void}\r\n * @throws {Error} When the config types array is invalid.\r\n */\r\nfunction assertExtraConfigTypes(extraConfigTypes) {\r\n\tif (extraConfigTypes.length > 2) {\r\n\t\tthrow new TypeError('configTypes must be an array with at most two items.');\r\n\t}\r\n\r\n\tfor (const configType of extraConfigTypes) {\r\n\t\tif (!CONFIG_TYPES.has(configType)) {\r\n\t\t\tthrow new TypeError(`Unexpected config type \"${configType}\" found. Expected one of: \"object\", \"array\", \"function\".`);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nconst ConfigArraySymbol = {\r\n\tisNormalized: Symbol('isNormalized'),\r\n\tconfigCache: Symbol('configCache'),\r\n\tschema: Symbol('schema'),\r\n\tfinalizeConfig: Symbol('finalizeConfig'),\r\n\tpreprocessConfig: Symbol('preprocessConfig')\r\n};\r\n\r\n// used to store calculate data for faster lookup\r\nconst dataCache = new WeakMap();\r\n\r\n/**\r\n * Represents an array of config objects and provides method for working with\r\n * those config objects.\r\n */\r\nclass ConfigArray extends Array {\r\n\r\n\t/**\r\n\t * Creates a new instance of ConfigArray.\r\n\t * @param {Iterable|Function|Object} configs An iterable yielding config\r\n\t *      objects, or a config function, or a config object.\r\n\t * @param {string} [options.basePath=\"\"] The path of the config file\r\n\t * @param {boolean} [options.normalized=false] Flag indicating if the\r\n\t *      configs have already been normalized.\r\n\t * @param {Object} [options.schema] The additional schema \r\n\t *      definitions to use for the ConfigArray schema.\r\n\t * @param {Array<string>} [options.configTypes] List of config types supported.\r\n\t */\r\n\tconstructor(configs,\r\n\t{\r\n\t\tbasePath = '',\r\n\t\tnormalized = false,\r\n\t\tschema: customSchema,\r\n\t\textraConfigTypes = []\r\n\t} = {}\r\n) {\r\n\t\tsuper();\r\n\r\n\t\t/**\r\n\t * Tracks if the array has been normalized.\r\n\t * @property isNormalized\r\n\t * @type boolean\r\n\t * @private\r\n\t */\r\n\t\tthis[ConfigArraySymbol.isNormalized] = normalized;\r\n\r\n\t\t/**\r\n\t * The schema used for validating and merging configs.\r\n\t * @property schema\r\n\t * @type ObjectSchema\r\n\t * @private\r\n\t */\r\n\t\tthis[ConfigArraySymbol.schema] = new objectSchema.ObjectSchema({\r\n\t\t\t...customSchema,\r\n\t\t\t...baseSchema\r\n\t\t});\r\n\r\n\t\t/**\r\n\t * The path of the config file that this array was loaded from.\r\n\t * This is used to calculate filename matches.\r\n\t * @property basePath\r\n\t * @type string\r\n\t */\r\n\t\tthis.basePath = basePath;\r\n\r\n\t\tassertExtraConfigTypes(extraConfigTypes);\r\n\r\n\t\t/**\r\n\t * The supported config types.\r\n\t * @property configTypes\r\n\t * @type Array<string>\r\n\t */\r\n\t\tthis.extraConfigTypes = Object.freeze([...extraConfigTypes]);\r\n\r\n\t\t/**\r\n\t * A cache to store calculated configs for faster repeat lookup.\r\n\t * @property configCache\r\n\t * @type Map\r\n\t * @private\r\n\t */\r\n\t\tthis[ConfigArraySymbol.configCache] = new Map();\r\n\r\n\t\t// init cache\r\n\t\tdataCache.set(this, {});\r\n\r\n\t\t// load the configs into this array\r\n\t\tif (Array.isArray(configs)) {\r\n\t\tthis.push(...configs);\r\n\t\t} else {\r\n\t\tthis.push(configs);\r\n\t\t}\r\n\r\n\t}\r\n\r\n/**\r\n\t * Prevent normal array methods from creating a new `ConfigArray` instance.\r\n\t * This is to ensure that methods such as `slice()` won't try to create a \r\n\t * new instance of `ConfigArray` behind the scenes as doing so may throw\r\n\t * an error due to the different constructor signature.\r\n\t * @returns {Function} The `Array` constructor.\r\n\t */\r\nstatic get [Symbol.species]() {\r\n\treturn Array;\r\n}\r\n\r\n/**\r\n\t * Returns the `files` globs from every config object in the array.\r\n\t * This can be used to determine which files will be matched by a\r\n\t * config array or to use as a glob pattern when no patterns are provided\r\n\t * for a command line interface.\r\n\t * @returns {Array<string|Function>} An array of matchers.\r\n\t */\r\nget files() {\r\n\r\n\tassertNormalized(this);\r\n\r\n\t// if this data has been cached, retrieve it\r\n\tconst cache = dataCache.get(this);\r\n\r\n\tif (cache.files) {\r\n\t\treturn cache.files;\r\n\t}\r\n\r\n\t// otherwise calculate it\r\n\r\n\tconst result = [];\r\n\r\n\tfor (const config of this) {\r\n\t\tif (config.files) {\r\n\t\t\tconfig.files.forEach(filePattern => {\r\n\t\t\t\tresult.push(filePattern);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// store result\r\n\tcache.files = result;\r\n\tdataCache.set(this, cache);\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n\t * Returns ignore matchers that should always be ignored regardless of\r\n\t * the matching `files` fields in any configs. This is necessary to mimic\r\n\t * the behavior of things like .gitignore and .eslintignore, allowing a\r\n\t * globbing operation to be faster.\r\n\t * @returns {string[]} An array of string patterns and functions to be ignored.\r\n\t */\r\nget ignores() {\r\n\r\n\tassertNormalized(this);\r\n\r\n\t// if this data has been cached, retrieve it\r\n\tconst cache = dataCache.get(this);\r\n\r\n\tif (cache.ignores) {\r\n\t\treturn cache.ignores;\r\n\t}\r\n\r\n\t// otherwise calculate it\r\n\r\n\tconst result = [];\r\n\r\n\tfor (const config of this) {\r\n\t\tif (config.ignores && !config.files) {\r\n\t\t\tresult.push(...config.ignores);\r\n\t\t}\r\n\t}\r\n\r\n\t// store result\r\n\tcache.ignores = result;\r\n\tdataCache.set(this, cache);\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n\t * Indicates if the config array has been normalized.\r\n\t * @returns {boolean} True if the config array is normalized, false if not.\r\n\t */\r\nisNormalized() {\r\n\treturn this[ConfigArraySymbol.isNormalized];\r\n}\r\n\r\n/**\r\n\t * Normalizes a config array by flattening embedded arrays and executing\r\n\t * config functions.\r\n\t * @param {ConfigContext} context The context object for config functions.\r\n\t * @returns {Promise<ConfigArray>} The current ConfigArray instance.\r\n\t */\r\nasync normalize(context = {}) {\r\n\r\n\tif (!this.isNormalized()) {\r\n\t\tconst normalizedConfigs = await normalize(this, context, this.extraConfigTypes);\r\n\t\tthis.length = 0;\r\n\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig].bind(this)));\r\n\t\tthis[ConfigArraySymbol.isNormalized] = true;\r\n\r\n\t\t// prevent further changes\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\n/**\r\n\t * Normalizes a config array by flattening embedded arrays and executing\r\n\t * config functions.\r\n\t * @param {ConfigContext} context The context object for config functions.\r\n\t * @returns {ConfigArray} The current ConfigArray instance.\r\n\t */\r\nnormalizeSync(context = {}) {\r\n\r\n\tif (!this.isNormalized()) {\r\n\t\tconst normalizedConfigs = normalizeSync(this, context, this.extraConfigTypes);\r\n\t\tthis.length = 0;\r\n\t\tthis.push(...normalizedConfigs.map(this[ConfigArraySymbol.preprocessConfig]));\r\n\t\tthis[ConfigArraySymbol.isNormalized] = true;\r\n\r\n\t\t// prevent further changes\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\treturn this;\r\n}\r\n\r\n/**\r\n\t * Finalizes the state of a config before being cached and returned by\r\n\t * `getConfig()`. Does nothing by default but is provided to be\r\n\t * overridden by subclasses as necessary.\r\n\t * @param {Object} config The config to finalize.\r\n\t * @returns {Object} The finalized config.\r\n\t */\r\n[ConfigArraySymbol.finalizeConfig](config) {\r\n\treturn config;\r\n}\r\n\r\n/**\r\n\t * Preprocesses a config during the normalization process. This is the\r\n\t * method to override if you want to convert an array item before it is\r\n\t * validated for the first time. For example, if you want to replace a\r\n\t * string with an object, this is the method to override.\r\n\t * @param {Object} config The config to preprocess.\r\n\t * @returns {Object} The config to use in place of the argument.\r\n\t */\r\n[ConfigArraySymbol.preprocessConfig](config) {\r\n\treturn config;\r\n}\r\n\r\n/**\r\n\t * Returns the config object for a given file path.\r\n\t * @param {string} filePath The complete path of a file to get a config for.\r\n\t * @returns {Object} The config object for this file.\r\n\t */\r\ngetConfig(filePath) {\r\n\r\n\tassertNormalized(this);\r\n\r\n\t// first check the cache to avoid duplicate work\r\n\tlet finalConfig = this[ConfigArraySymbol.configCache].get(filePath);\r\n\r\n\tif (finalConfig) {\r\n\t\treturn finalConfig;\r\n\t}\r\n\r\n\t// TODO: Maybe move elsewhere?\r\n\tconst relativeFilePath = path.relative(this.basePath, filePath);\r\n\r\n\tif (shouldIgnoreFilePath(this.ignores, filePath, relativeFilePath)) {\r\n\r\n\t\t// cache and return result - finalConfig is undefined at this point\r\n\t\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\r\n\t\treturn finalConfig;\r\n\t}\r\n\r\n\t// filePath isn't automatically ignored, so try to construct config\r\n\r\n\tconst matchingConfigs = [];\r\n\r\n\tfor (const config of this) {\r\n\t\tif (pathMatches(filePath, this.basePath, config)) {\r\n\t\t\tdebug(`Matching config found for ${filePath}`);\r\n\t\t\tmatchingConfigs.push(config);\r\n\t\t} else {\r\n\t\t\tdebug(`No matching config found for ${filePath}`);\r\n\t\t}\r\n\t}\r\n\r\n\t// if matching both files and ignores, there will be no config to create\r\n\tif (matchingConfigs.length === 0) {\r\n\t\t// cache and return result - finalConfig is undefined at this point\r\n\t\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\r\n\t\treturn finalConfig;\r\n\t}\r\n\r\n\t// otherwise construct the config\r\n\r\n\tfinalConfig = matchingConfigs.reduce((result, config) => {\r\n\t\treturn this[ConfigArraySymbol.schema].merge(result, config);\r\n\t}, {}, this);\r\n\r\n\tfinalConfig = this[ConfigArraySymbol.finalizeConfig](finalConfig);\r\n\r\n\tthis[ConfigArraySymbol.configCache].set(filePath, finalConfig);\r\n\r\n\treturn finalConfig;\r\n}\r\n\r\n/**\r\n\t * Determines if the given filepath is ignored based on the configs.\r\n\t * @param {string} filePath The complete path of a file to check.\r\n\t * @returns {boolean} True if the path is ignored, false if not.\r\n\t */\r\nisIgnored(filePath) {\r\n\treturn this.getConfig(filePath) === undefined;\r\n}\r\n\r\n}\r\n\r\nexports.ConfigArray = ConfigArray;\r\nexports.ConfigArraySymbol = ConfigArraySymbol;\r\n"]},"metadata":{},"sourceType":"script"}