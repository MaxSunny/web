{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag dangling underscores in variable declarations.\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow dangling underscores in identifiers\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-underscore-dangle\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        allowAfterThis: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterSuper: {\n          type: \"boolean\",\n          default: false\n        },\n        allowAfterThisConstructor: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceInMethodNames: {\n          type: \"boolean\",\n          default: false\n        },\n        allowFunctionParams: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const ALLOWED_VARIABLES = options.allow ? options.allow : [];\n    const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\n    const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\n    const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\n    const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\n    const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true; //-------------------------------------------------------------------------\n    // Helpers\n    //-------------------------------------------------------------------------\n\n    /**\r\n     * Check if identifier is present inside the allowed option\r\n     * @param {string} identifier name of the node\r\n     * @returns {boolean} true if its is present\r\n     * @private\r\n     */\n\n    function isAllowed(identifier) {\n      return ALLOWED_VARIABLES.some(ident => ident === identifier);\n    }\n    /**\r\n     * Check if identifier has a dangling underscore\r\n     * @param {string} identifier name of the node\r\n     * @returns {boolean} true if its is present\r\n     * @private\r\n     */\n\n\n    function hasDanglingUnderscore(identifier) {\n      const len = identifier.length;\n      return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\n    }\n    /**\r\n     * Check if identifier is a special case member expression\r\n     * @param {string} identifier name of the node\r\n     * @returns {boolean} true if its is a special case\r\n     * @private\r\n     */\n\n\n    function isSpecialCaseIdentifierForMemberExpression(identifier) {\n      return identifier === \"__proto__\";\n    }\n    /**\r\n     * Check if identifier is a special case variable expression\r\n     * @param {string} identifier name of the node\r\n     * @returns {boolean} true if its is a special case\r\n     * @private\r\n     */\n\n\n    function isSpecialCaseIdentifierInVariableExpression(identifier) {\n      // Checks for the underscore library usage here\n      return identifier === \"_\";\n    }\n    /**\r\n     * Check if a node is a member reference of this.constructor\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {boolean} true if it is a reference on this.constructor\r\n     * @private\r\n     */\n\n\n    function isThisConstructorReference(node) {\n      return node.object.type === \"MemberExpression\" && node.object.property.name === \"constructor\" && node.object.object.type === \"ThisExpression\";\n    }\n    /**\r\n     * Check if function parameter has a dangling underscore.\r\n     * @param {ASTNode} node function node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForDanglingUnderscoreInFunctionParameters(node) {\n      if (!allowFunctionParams) {\n        node.params.forEach(param => {\n          const {\n            type\n          } = param;\n          let nodeToCheck;\n\n          if (type === \"RestElement\") {\n            nodeToCheck = param.argument;\n          } else if (type === \"AssignmentPattern\") {\n            nodeToCheck = param.left;\n          } else {\n            nodeToCheck = param;\n          }\n\n          if (nodeToCheck.type === \"Identifier\") {\n            const identifier = nodeToCheck.name;\n\n            if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n              context.report({\n                node: param,\n                messageId: \"unexpectedUnderscore\",\n                data: {\n                  identifier\n                }\n              });\n            }\n          }\n        });\n      }\n    }\n    /**\r\n     * Check if function has a dangling underscore\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForDanglingUnderscoreInFunction(node) {\n      if (node.type === \"FunctionDeclaration\" && node.id) {\n        const identifier = node.id.name;\n\n        if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n          context.report({\n            node,\n            messageId: \"unexpectedUnderscore\",\n            data: {\n              identifier\n            }\n          });\n        }\n      }\n\n      checkForDanglingUnderscoreInFunctionParameters(node);\n    }\n    /**\r\n     * Check if variable expression has a dangling underscore\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForDanglingUnderscoreInVariableExpression(node) {\n      const identifier = node.id.name;\n\n      if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier\n          }\n        });\n      }\n    }\n    /**\r\n     * Check if member expression has a dangling underscore\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForDanglingUnderscoreInMemberExpression(node) {\n      const identifier = node.property.name,\n            isMemberOfThis = node.object.type === \"ThisExpression\",\n            isMemberOfSuper = node.object.type === \"Super\",\n            isMemberOfThisConstructor = isThisConstructorReference(node);\n\n      if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier\n          }\n        });\n      }\n    }\n    /**\r\n     * Check if method declaration or method property has a dangling underscore\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForDanglingUnderscoreInMethod(node) {\n      const identifier = node.key.name;\n      const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\n\n      if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\n        context.report({\n          node,\n          messageId: \"unexpectedUnderscore\",\n          data: {\n            identifier: node.key.type === \"PrivateIdentifier\" ? `#${identifier}` : identifier\n          }\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      FunctionDeclaration: checkForDanglingUnderscoreInFunction,\n      VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\n      MemberExpression: checkForDanglingUnderscoreInMemberExpression,\n      MethodDefinition: checkForDanglingUnderscoreInMethod,\n      PropertyDefinition: checkForDanglingUnderscoreInMethod,\n      Property: checkForDanglingUnderscoreInMethod,\n      FunctionExpression: checkForDanglingUnderscoreInFunction,\n      ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-underscore-dangle.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","allow","items","allowAfterThis","default","allowAfterSuper","allowAfterThisConstructor","enforceInMethodNames","allowFunctionParams","additionalProperties","messages","unexpectedUnderscore","create","context","options","ALLOWED_VARIABLES","isAllowed","identifier","some","ident","hasDanglingUnderscore","len","length","isSpecialCaseIdentifierForMemberExpression","isSpecialCaseIdentifierInVariableExpression","isThisConstructorReference","node","object","property","name","checkForDanglingUnderscoreInFunctionParameters","params","forEach","param","nodeToCheck","argument","left","report","messageId","data","checkForDanglingUnderscoreInFunction","id","checkForDanglingUnderscoreInVariableExpression","checkForDanglingUnderscoreInMemberExpression","isMemberOfThis","isMemberOfSuper","isMemberOfThisConstructor","checkForDanglingUnderscoreInMethod","key","isMethod","method","FunctionDeclaration","VariableDeclarator","MemberExpression","MethodDefinition","PropertyDefinition","Property","FunctionExpression","ArrowFunctionExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag dangling underscores in variable declarations.\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow dangling underscores in identifiers\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-underscore-dangle\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allow: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    allowAfterThis: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowAfterSuper: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowAfterThisConstructor: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    enforceInMethodNames: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowFunctionParams: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedUnderscore: \"Unexpected dangling '_' in '{{identifier}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0] || {};\r\n        const ALLOWED_VARIABLES = options.allow ? options.allow : [];\r\n        const allowAfterThis = typeof options.allowAfterThis !== \"undefined\" ? options.allowAfterThis : false;\r\n        const allowAfterSuper = typeof options.allowAfterSuper !== \"undefined\" ? options.allowAfterSuper : false;\r\n        const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== \"undefined\" ? options.allowAfterThisConstructor : false;\r\n        const enforceInMethodNames = typeof options.enforceInMethodNames !== \"undefined\" ? options.enforceInMethodNames : false;\r\n        const allowFunctionParams = typeof options.allowFunctionParams !== \"undefined\" ? options.allowFunctionParams : true;\r\n\r\n        //-------------------------------------------------------------------------\r\n        // Helpers\r\n        //-------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Check if identifier is present inside the allowed option\r\n         * @param {string} identifier name of the node\r\n         * @returns {boolean} true if its is present\r\n         * @private\r\n         */\r\n        function isAllowed(identifier) {\r\n            return ALLOWED_VARIABLES.some(ident => ident === identifier);\r\n        }\r\n\r\n        /**\r\n         * Check if identifier has a dangling underscore\r\n         * @param {string} identifier name of the node\r\n         * @returns {boolean} true if its is present\r\n         * @private\r\n         */\r\n        function hasDanglingUnderscore(identifier) {\r\n            const len = identifier.length;\r\n\r\n            return identifier !== \"_\" && (identifier[0] === \"_\" || identifier[len - 1] === \"_\");\r\n        }\r\n\r\n        /**\r\n         * Check if identifier is a special case member expression\r\n         * @param {string} identifier name of the node\r\n         * @returns {boolean} true if its is a special case\r\n         * @private\r\n         */\r\n        function isSpecialCaseIdentifierForMemberExpression(identifier) {\r\n            return identifier === \"__proto__\";\r\n        }\r\n\r\n        /**\r\n         * Check if identifier is a special case variable expression\r\n         * @param {string} identifier name of the node\r\n         * @returns {boolean} true if its is a special case\r\n         * @private\r\n         */\r\n        function isSpecialCaseIdentifierInVariableExpression(identifier) {\r\n\r\n            // Checks for the underscore library usage here\r\n            return identifier === \"_\";\r\n        }\r\n\r\n        /**\r\n         * Check if a node is a member reference of this.constructor\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {boolean} true if it is a reference on this.constructor\r\n         * @private\r\n         */\r\n        function isThisConstructorReference(node) {\r\n            return node.object.type === \"MemberExpression\" &&\r\n                node.object.property.name === \"constructor\" &&\r\n                node.object.object.type === \"ThisExpression\";\r\n        }\r\n\r\n        /**\r\n         * Check if function parameter has a dangling underscore.\r\n         * @param {ASTNode} node function node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForDanglingUnderscoreInFunctionParameters(node) {\r\n            if (!allowFunctionParams) {\r\n                node.params.forEach(param => {\r\n                    const { type } = param;\r\n                    let nodeToCheck;\r\n\r\n                    if (type === \"RestElement\") {\r\n                        nodeToCheck = param.argument;\r\n                    } else if (type === \"AssignmentPattern\") {\r\n                        nodeToCheck = param.left;\r\n                    } else {\r\n                        nodeToCheck = param;\r\n                    }\r\n\r\n                    if (nodeToCheck.type === \"Identifier\") {\r\n                        const identifier = nodeToCheck.name;\r\n\r\n                        if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\r\n                            context.report({\r\n                                node: param,\r\n                                messageId: \"unexpectedUnderscore\",\r\n                                data: {\r\n                                    identifier\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if function has a dangling underscore\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForDanglingUnderscoreInFunction(node) {\r\n            if (node.type === \"FunctionDeclaration\" && node.id) {\r\n                const identifier = node.id.name;\r\n\r\n                if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedUnderscore\",\r\n                        data: {\r\n                            identifier\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            checkForDanglingUnderscoreInFunctionParameters(node);\r\n        }\r\n\r\n        /**\r\n         * Check if variable expression has a dangling underscore\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForDanglingUnderscoreInVariableExpression(node) {\r\n            const identifier = node.id.name;\r\n\r\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\r\n                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpectedUnderscore\",\r\n                    data: {\r\n                        identifier\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if member expression has a dangling underscore\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForDanglingUnderscoreInMemberExpression(node) {\r\n            const identifier = node.property.name,\r\n                isMemberOfThis = node.object.type === \"ThisExpression\",\r\n                isMemberOfSuper = node.object.type === \"Super\",\r\n                isMemberOfThisConstructor = isThisConstructorReference(node);\r\n\r\n            if (typeof identifier !== \"undefined\" && hasDanglingUnderscore(identifier) &&\r\n                !(isMemberOfThis && allowAfterThis) &&\r\n                !(isMemberOfSuper && allowAfterSuper) &&\r\n                !(isMemberOfThisConstructor && allowAfterThisConstructor) &&\r\n                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpectedUnderscore\",\r\n                    data: {\r\n                        identifier\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if method declaration or method property has a dangling underscore\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForDanglingUnderscoreInMethod(node) {\r\n            const identifier = node.key.name;\r\n            const isMethod = node.type === \"MethodDefinition\" || node.type === \"Property\" && node.method;\r\n\r\n            if (typeof identifier !== \"undefined\" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpectedUnderscore\",\r\n                    data: {\r\n                        identifier: node.key.type === \"PrivateIdentifier\"\r\n                            ? `#${identifier}`\r\n                            : identifier\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            FunctionDeclaration: checkForDanglingUnderscoreInFunction,\r\n            VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,\r\n            MemberExpression: checkForDanglingUnderscoreInMemberExpression,\r\n            MethodDefinition: checkForDanglingUnderscoreInMethod,\r\n            PropertyDefinition: checkForDanglingUnderscoreInMethod,\r\n            Property: checkForDanglingUnderscoreInMethod,\r\n            FunctionExpression: checkForDanglingUnderscoreInFunction,\r\n            ArrowFunctionExpression: checkForDanglingUnderscoreInFunction\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}