{"ast":null,"code":"/**\r\n * @fileoverview Rule to require parens in arrow function arguments.\r\n * @author Jxck\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines if the given arrow function has block body.\r\n * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n * @returns {boolean} `true` if the function has block body.\r\n */\n\n\nfunction hasBlockBody(node) {\n  return node.body.type === \"BlockStatement\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around arrow function arguments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/arrow-parens\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }, {\n      type: \"object\",\n      properties: {\n        requireForBlockBody: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedParens: \"Unexpected parentheses around single function argument.\",\n      expectedParens: \"Expected parentheses around arrow function argument.\",\n      unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\n      expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\n    }\n  },\n\n  create(context) {\n    const asNeeded = context.options[0] === \"as-needed\";\n    const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Finds opening paren of parameters for the given arrow function, if it exists.\r\n     * It is assumed that the given arrow function has exactly one parameter.\r\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n     * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\r\n     */\n\n    function findOpeningParenOfParams(node) {\n      const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\n\n      if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {\n        return tokenBeforeParams;\n      }\n\n      return null;\n    }\n    /**\r\n     * Finds closing paren of parameters for the given arrow function.\r\n     * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\r\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n     * @returns {Token} the closing paren of parameters.\r\n     */\n\n\n    function getClosingParenOfParams(node) {\n      return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\n    }\n    /**\r\n     * Determines whether the given arrow function has comments inside parens of parameters.\r\n     * It is assumed that the given arrow function has parens of parameters.\r\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n     * @param {Token} openingParen Opening paren of parameters.\r\n     * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\r\n     */\n\n\n    function hasCommentsInParensOfParams(node, openingParen) {\n      return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\n    }\n    /**\r\n     * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\r\n     * in which case it will be assumed that the existing parens of parameters are necessary.\r\n     * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\r\n     * Example: <T>(a) => b\r\n     * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n     * @param {Token} openingParen Opening paren of parameters.\r\n     * @returns {boolean} `true` if the function has at least one unexpected token.\r\n     */\n\n\n    function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\n      const expectedCount = node.async ? 1 : 0;\n      return sourceCode.getFirstToken(node, {\n        skip: expectedCount\n      }) !== openingParen;\n    }\n\n    return {\n      \"ArrowFunctionExpression[params.length=1]\"(node) {\n        const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\n        const openingParen = findOpeningParenOfParams(node);\n        const hasParens = openingParen !== null;\n        const [param] = node.params;\n\n        if (shouldHaveParens && !hasParens) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              yield fixer.insertTextBefore(param, \"(\");\n              yield fixer.insertTextAfter(param, \")\");\n            }\n\n          });\n        }\n\n        if (!shouldHaveParens && hasParens && param.type === \"Identifier\" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {\n          context.report({\n            node,\n            messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\n            loc: param.loc,\n\n            *fix(fixer) {\n              const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\n              const closingParen = getClosingParenOfParams(node);\n\n              if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {\n                yield fixer.insertTextBefore(openingParen, \" \");\n              } // remove parens, whitespace inside parens, and possible trailing comma\n\n\n              yield fixer.removeRange([openingParen.range[0], param.range[0]]);\n              yield fixer.removeRange([param.range[1], closingParen.range[1]]);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/arrow-parens.js"],"names":["astUtils","require","hasBlockBody","node","body","type","module","exports","meta","docs","description","recommended","url","fixable","schema","enum","properties","requireForBlockBody","default","additionalProperties","messages","unexpectedParens","expectedParens","unexpectedParensInline","expectedParensBlock","create","context","asNeeded","options","sourceCode","getSourceCode","findOpeningParenOfParams","tokenBeforeParams","getTokenBefore","params","isOpeningParenToken","range","getClosingParenOfParams","getTokenAfter","isClosingParenToken","hasCommentsInParensOfParams","openingParen","commentsExistBetween","hasUnexpectedTokensBeforeOpeningParen","expectedCount","async","getFirstToken","skip","shouldHaveParens","hasParens","param","report","messageId","loc","fix","fixer","insertTextBefore","insertTextAfter","typeAnnotation","returnType","tokenBeforeOpeningParen","closingParen","canTokensBeAdjacent","removeRange"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require parens in arrow function arguments.\r\n * @author Jxck\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if the given arrow function has block body.\r\n * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n * @returns {boolean} `true` if the function has block body.\r\n */\r\nfunction hasBlockBody(node) {\r\n    return node.body.type === \"BlockStatement\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require parentheses around arrow function arguments\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/arrow-parens\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"as-needed\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    requireForBlockBody: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedParens: \"Unexpected parentheses around single function argument.\",\r\n            expectedParens: \"Expected parentheses around arrow function argument.\",\r\n\r\n            unexpectedParensInline: \"Unexpected parentheses around single function argument having a body with no curly braces.\",\r\n            expectedParensBlock: \"Expected parentheses around arrow function argument having a body with curly braces.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const asNeeded = context.options[0] === \"as-needed\";\r\n        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Finds opening paren of parameters for the given arrow function, if it exists.\r\n         * It is assumed that the given arrow function has exactly one parameter.\r\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n         * @returns {Token|null} the opening paren, or `null` if the given arrow function doesn't have parens of parameters.\r\n         */\r\n        function findOpeningParenOfParams(node) {\r\n            const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);\r\n\r\n            if (\r\n                tokenBeforeParams &&\r\n                astUtils.isOpeningParenToken(tokenBeforeParams) &&\r\n                node.range[0] <= tokenBeforeParams.range[0]\r\n            ) {\r\n                return tokenBeforeParams;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Finds closing paren of parameters for the given arrow function.\r\n         * It is assumed that the given arrow function has parens of parameters and that it has exactly one parameter.\r\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n         * @returns {Token} the closing paren of parameters.\r\n         */\r\n        function getClosingParenOfParams(node) {\r\n            return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given arrow function has comments inside parens of parameters.\r\n         * It is assumed that the given arrow function has parens of parameters.\r\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n         * @param {Token} openingParen Opening paren of parameters.\r\n         * @returns {boolean} `true` if the function has at least one comment inside of parens of parameters.\r\n         */\r\n        function hasCommentsInParensOfParams(node, openingParen) {\r\n            return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given arrow function has unexpected tokens before opening paren of parameters,\r\n         * in which case it will be assumed that the existing parens of parameters are necessary.\r\n         * Only tokens within the range of the arrow function (tokens that are part of the arrow function) are taken into account.\r\n         * Example: <T>(a) => b\r\n         * @param {ASTNode} node `ArrowFunctionExpression` node.\r\n         * @param {Token} openingParen Opening paren of parameters.\r\n         * @returns {boolean} `true` if the function has at least one unexpected token.\r\n         */\r\n        function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {\r\n            const expectedCount = node.async ? 1 : 0;\r\n\r\n            return sourceCode.getFirstToken(node, { skip: expectedCount }) !== openingParen;\r\n        }\r\n\r\n        return {\r\n            \"ArrowFunctionExpression[params.length=1]\"(node) {\r\n                const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);\r\n                const openingParen = findOpeningParenOfParams(node);\r\n                const hasParens = openingParen !== null;\r\n                const [param] = node.params;\r\n\r\n                if (shouldHaveParens && !hasParens) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: requireForBlockBody ? \"expectedParensBlock\" : \"expectedParens\",\r\n                        loc: param.loc,\r\n                        *fix(fixer) {\r\n                            yield fixer.insertTextBefore(param, \"(\");\r\n                            yield fixer.insertTextAfter(param, \")\");\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (\r\n                    !shouldHaveParens &&\r\n                    hasParens &&\r\n                    param.type === \"Identifier\" &&\r\n                    !param.typeAnnotation &&\r\n                    !node.returnType &&\r\n                    !hasCommentsInParensOfParams(node, openingParen) &&\r\n                    !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)\r\n                ) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: requireForBlockBody ? \"unexpectedParensInline\" : \"unexpectedParens\",\r\n                        loc: param.loc,\r\n                        *fix(fixer) {\r\n                            const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);\r\n                            const closingParen = getClosingParenOfParams(node);\r\n\r\n                            if (\r\n                                tokenBeforeOpeningParen &&\r\n                                tokenBeforeOpeningParen.range[1] === openingParen.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))\r\n                            ) {\r\n                                yield fixer.insertTextBefore(openingParen, \" \");\r\n                            }\r\n\r\n                            // remove parens, whitespace inside parens, and possible trailing comma\r\n                            yield fixer.removeRange([openingParen.range[0], param.range[0]]);\r\n                            yield fixer.removeRange([param.range[1], closingParen.range[1]]);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}