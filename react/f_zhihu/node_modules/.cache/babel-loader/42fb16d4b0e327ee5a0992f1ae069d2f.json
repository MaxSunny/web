{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\r\n * @author Annie Zhang, Henry Zhu\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst radixMap = new Map([[2, {\n  system: \"binary\",\n  literalPrefix: \"0b\"\n}], [8, {\n  system: \"octal\",\n  literalPrefix: \"0o\"\n}], [16, {\n  system: \"hexadecimal\",\n  literalPrefix: \"0x\"\n}]]);\n/**\r\n * Checks to see if a CallExpression's callee node is `parseInt` or\r\n * `Number.parseInt`.\r\n * @param {ASTNode} calleeNode The callee node to evaluate.\r\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\r\n * false otherwise.\r\n */\n\nfunction isParseInt(calleeNode) {\n  return astUtils.isSpecificId(calleeNode, \"parseInt\") || astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\");\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\n    },\n    schema: [],\n    messages: {\n      useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\n    },\n    fixable: \"code\"\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n    return {\n      \"CallExpression[arguments.length=2]\"(node) {\n        const [strNode, radixNode] = node.arguments,\n              str = astUtils.getStaticStringValue(strNode),\n              radix = radixNode.value;\n\n        if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === \"Literal\" && typeof radix === \"number\" && radixMap.has(radix) && isParseInt(node.callee)) {\n          const {\n            system,\n            literalPrefix\n          } = radixMap.get(radix);\n          context.report({\n            node,\n            messageId: \"useLiteral\",\n            data: {\n              system,\n              functionName: sourceCode.getText(node.callee)\n            },\n\n            fix(fixer) {\n              if (sourceCode.getCommentsInside(node).length) {\n                return null;\n              }\n\n              const replacement = `${literalPrefix}${str}`;\n\n              if (+replacement !== parseInt(str, radix)) {\n                /*\r\n                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\r\n                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\r\n                 *\r\n                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\r\n                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\r\n                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\r\n                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\r\n                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\r\n                 * so the autofix would be invalid:\r\n                 *\r\n                 *   parseInt(\"1_1\", 2) // === 1\r\n                 *   0b1_1 // === 3\r\n                 */\n                return null;\n              }\n\n              const tokenBefore = sourceCode.getTokenBefore(node),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n              let prefix = \"\",\n                  suffix = \"\";\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                prefix = \" \";\n              }\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {\n                suffix = \" \";\n              }\n\n              return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-numeric-literals.js"],"names":["astUtils","require","radixMap","Map","system","literalPrefix","isParseInt","calleeNode","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","messages","useLiteral","fixable","create","context","sourceCode","getSourceCode","node","strNode","radixNode","arguments","str","getStaticStringValue","radix","value","isStringLiteral","has","callee","get","report","messageId","data","functionName","getText","fix","fixer","getCommentsInside","length","replacement","parseInt","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","prefix","suffix","range","canTokensBeAdjacent","replaceText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals\r\n * @author Annie Zhang, Henry Zhu\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst radixMap = new Map([\r\n    [2, { system: \"binary\", literalPrefix: \"0b\" }],\r\n    [8, { system: \"octal\", literalPrefix: \"0o\" }],\r\n    [16, { system: \"hexadecimal\", literalPrefix: \"0x\" }]\r\n]);\r\n\r\n/**\r\n * Checks to see if a CallExpression's callee node is `parseInt` or\r\n * `Number.parseInt`.\r\n * @param {ASTNode} calleeNode The callee node to evaluate.\r\n * @returns {boolean} True if the callee is `parseInt` or `Number.parseInt`,\r\n * false otherwise.\r\n */\r\nfunction isParseInt(calleeNode) {\r\n    return (\r\n        astUtils.isSpecificId(calleeNode, \"parseInt\") ||\r\n        astUtils.isSpecificMemberAccess(calleeNode, \"Number\", \"parseInt\")\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-numeric-literals\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            useLiteral: \"Use {{system}} literals instead of {{functionName}}().\"\r\n        },\r\n\r\n        fixable: \"code\"\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            \"CallExpression[arguments.length=2]\"(node) {\r\n                const [strNode, radixNode] = node.arguments,\r\n                    str = astUtils.getStaticStringValue(strNode),\r\n                    radix = radixNode.value;\r\n\r\n                if (\r\n                    str !== null &&\r\n                    astUtils.isStringLiteral(strNode) &&\r\n                    radixNode.type === \"Literal\" &&\r\n                    typeof radix === \"number\" &&\r\n                    radixMap.has(radix) &&\r\n                    isParseInt(node.callee)\r\n                ) {\r\n\r\n                    const { system, literalPrefix } = radixMap.get(radix);\r\n\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"useLiteral\",\r\n                        data: {\r\n                            system,\r\n                            functionName: sourceCode.getText(node.callee)\r\n                        },\r\n                        fix(fixer) {\r\n                            if (sourceCode.getCommentsInside(node).length) {\r\n                                return null;\r\n                            }\r\n\r\n                            const replacement = `${literalPrefix}${str}`;\r\n\r\n                            if (+replacement !== parseInt(str, radix)) {\r\n\r\n                                /*\r\n                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),\r\n                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.\r\n                                 *\r\n                                 * If `str` had numeric separators, `+replacement` will evaluate to `NaN` because unary `+`\r\n                                 * per the specification doesn't support numeric separators. Thus, the above condition will be `true`\r\n                                 * (`NaN !== anything` is always `true`) regardless of the `parseInt(str, radix)` value.\r\n                                 * Consequently, no autofixes will be made. This is correct behavior because `parseInt` also\r\n                                 * doesn't support numeric separators, but it does parse part of the string before the first `_`,\r\n                                 * so the autofix would be invalid:\r\n                                 *\r\n                                 *   parseInt(\"1_1\", 2) // === 1\r\n                                 *   0b1_1 // === 3\r\n                                 */\r\n                                return null;\r\n                            }\r\n\r\n                            const tokenBefore = sourceCode.getTokenBefore(node),\r\n                                tokenAfter = sourceCode.getTokenAfter(node);\r\n                            let prefix = \"\",\r\n                                suffix = \"\";\r\n\r\n                            if (\r\n                                tokenBefore &&\r\n                                tokenBefore.range[1] === node.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\r\n                            ) {\r\n                                prefix = \" \";\r\n                            }\r\n\r\n                            if (\r\n                                tokenAfter &&\r\n                                node.range[1] === tokenAfter.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(replacement, tokenAfter)\r\n                            ) {\r\n                                suffix = \" \";\r\n                            }\r\n\r\n                            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}