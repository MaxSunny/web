{"ast":null,"code":"/**\r\n * @fileoverview Restrict usage of duplicate imports.\r\n * @author Simen Bekkhus\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\nconst NAMESPACE_TYPES = [\"ImportNamespaceSpecifier\", \"ExportNamespaceSpecifier\"]; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\r\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\r\n * @param {string} importExportType An import/export type to check.\r\n * @param {string} type Can be \"named\" or \"namespace\"\r\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\r\n */\n\nfunction isImportExportSpecifier(importExportType, type) {\n  const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\n  return arrayToCheck.includes(importExportType);\n}\n/**\r\n * Return the type of (import|export).\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string} The type of the (import|export).\r\n */\n\n\nfunction getImportExportType(node) {\n  if (node.specifiers && node.specifiers.length > 0) {\n    const nodeSpecifiers = node.specifiers;\n    const index = nodeSpecifiers.findIndex(_ref => {\n      let {\n        type\n      } = _ref;\n      return isImportExportSpecifier(type, \"named\") || isImportExportSpecifier(type, \"namespace\");\n    });\n    const i = index > -1 ? index : 0;\n    return nodeSpecifiers[i].type;\n  }\n\n  if (node.type === \"ExportAllDeclaration\") {\n    if (node.exported) {\n      return \"ExportNamespaceSpecifier\";\n    }\n\n    return \"ExportAll\";\n  }\n\n  return \"SideEffectImport\";\n}\n/**\r\n * Returns a boolean indicates if two (import|export) can be merged\r\n * @param {ASTNode} node1 A node to check.\r\n * @param {ASTNode} node2 A node to check.\r\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\r\n */\n\n\nfunction isImportExportCanBeMerged(node1, node2) {\n  const importExportType1 = getImportExportType(node1);\n  const importExportType2 = getImportExportType(node2);\n\n  if (importExportType1 === \"ExportAll\" && importExportType2 !== \"ExportAll\" && importExportType2 !== \"SideEffectImport\" || importExportType1 !== \"ExportAll\" && importExportType1 !== \"SideEffectImport\" && importExportType2 === \"ExportAll\") {\n    return false;\n  }\n\n  if (isImportExportSpecifier(importExportType1, \"namespace\") && isImportExportSpecifier(importExportType2, \"named\") || isImportExportSpecifier(importExportType2, \"namespace\") && isImportExportSpecifier(importExportType1, \"named\")) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Returns a boolean if we should report (import|export).\r\n * @param {ASTNode} node A node to be reported or not.\r\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\r\n * @returns {boolean} True if the (import|export) should be reported.\r\n */\n\n\nfunction shouldReportImportExport(node, previousNodes) {\n  let i = 0;\n\n  while (i < previousNodes.length) {\n    if (isImportExportCanBeMerged(node, previousNodes[i])) {\n      return true;\n    }\n\n    i++;\n  }\n\n  return false;\n}\n/**\r\n * Returns array contains only nodes with declarations types equal to type.\r\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\r\n * @param {string} type Declaration type.\r\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\r\n */\n\n\nfunction getNodesByDeclarationType(nodes, type) {\n  return nodes.filter(_ref2 => {\n    let {\n      declarationType\n    } = _ref2;\n    return declarationType === type;\n  }).map(_ref3 => {\n    let {\n      node\n    } = _ref3;\n    return node;\n  });\n}\n/**\r\n * Returns the name of the module imported or re-exported.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string} The name of the module, or empty string if no name.\r\n */\n\n\nfunction getModule(node) {\n  if (node && node.source && node.source.value) {\n    return node.source.value.trim();\n  }\n\n  return \"\";\n}\n/**\r\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\r\n * @param {RuleContext} context The ESLint rule context object.\r\n * @param {ASTNode} node A node to get.\r\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\r\n * @param {string} declarationType A declaration type can be an import or export.\r\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\r\n * @returns {void} No return value.\r\n */\n\n\nfunction checkAndReport(context, node, modules, declarationType, includeExports) {\n  const module = getModule(node);\n\n  if (modules.has(module)) {\n    const previousNodes = modules.get(module);\n    const messagesIds = [];\n    const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\n    let exportNodes;\n\n    if (includeExports) {\n      exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\n    }\n\n    if (declarationType === \"import\") {\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"import\");\n      }\n\n      if (includeExports) {\n        if (shouldReportImportExport(node, exportNodes)) {\n          messagesIds.push(\"importAs\");\n        }\n      }\n    } else if (declarationType === \"export\") {\n      if (shouldReportImportExport(node, exportNodes)) {\n        messagesIds.push(\"export\");\n      }\n\n      if (shouldReportImportExport(node, importNodes)) {\n        messagesIds.push(\"exportAs\");\n      }\n    }\n\n    messagesIds.forEach(messageId => context.report({\n      node,\n      messageId,\n      data: {\n        module\n      }\n    }));\n  }\n}\n/**\r\n * @callback nodeCallback\r\n * @param {ASTNode} node A node to handle.\r\n */\n\n/**\r\n * Returns a function handling the (imports|exports) of a given file\r\n * @param {RuleContext} context The ESLint rule context object.\r\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\r\n * @param {string} declarationType A declaration type can be an import or export.\r\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\r\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\r\n */\n\n\nfunction handleImportsExports(context, modules, declarationType, includeExports) {\n  return function (node) {\n    const module = getModule(node);\n\n    if (module) {\n      checkAndReport(context, node, modules, declarationType, includeExports);\n      const currentNode = {\n        node,\n        declarationType\n      };\n      let nodes = [currentNode];\n\n      if (modules.has(module)) {\n        const previousNodes = modules.get(module);\n        nodes = [...previousNodes, currentNode];\n      }\n\n      modules.set(module, nodes);\n    }\n  };\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate module imports\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        includeExports: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      import: \"'{{module}}' import is duplicated.\",\n      importAs: \"'{{module}}' import is duplicated as export.\",\n      export: \"'{{module}}' export is duplicated.\",\n      exportAs: \"'{{module}}' export is duplicated as import.\"\n    }\n  },\n\n  create(context) {\n    const includeExports = (context.options[0] || {}).includeExports,\n          modules = new Map();\n    const handlers = {\n      ImportDeclaration: handleImportsExports(context, modules, \"import\", includeExports)\n    };\n\n    if (includeExports) {\n      handlers.ExportNamedDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n      handlers.ExportAllDeclaration = handleImportsExports(context, modules, \"export\", includeExports);\n    }\n\n    return handlers;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-duplicate-imports.js"],"names":["NAMED_TYPES","NAMESPACE_TYPES","isImportExportSpecifier","importExportType","type","arrayToCheck","includes","getImportExportType","node","specifiers","length","nodeSpecifiers","index","findIndex","i","exported","isImportExportCanBeMerged","node1","node2","importExportType1","importExportType2","shouldReportImportExport","previousNodes","getNodesByDeclarationType","nodes","filter","declarationType","map","getModule","source","value","trim","checkAndReport","context","modules","includeExports","module","has","get","messagesIds","importNodes","exportNodes","push","forEach","messageId","report","data","handleImportsExports","currentNode","set","exports","meta","docs","description","recommended","url","schema","properties","default","additionalProperties","messages","import","importAs","export","exportAs","create","options","Map","handlers","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Restrict usage of duplicate imports.\r\n * @author Simen Bekkhus\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst NAMED_TYPES = [\"ImportSpecifier\", \"ExportSpecifier\"];\r\nconst NAMESPACE_TYPES = [\r\n    \"ImportNamespaceSpecifier\",\r\n    \"ExportNamespaceSpecifier\"\r\n];\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).\r\n * @param {string} importExportType An import/export type to check.\r\n * @param {string} type Can be \"named\" or \"namespace\"\r\n * @returns {boolean} True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.\r\n */\r\nfunction isImportExportSpecifier(importExportType, type) {\r\n    const arrayToCheck = type === \"named\" ? NAMED_TYPES : NAMESPACE_TYPES;\r\n\r\n    return arrayToCheck.includes(importExportType);\r\n}\r\n\r\n/**\r\n * Return the type of (import|export).\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string} The type of the (import|export).\r\n */\r\nfunction getImportExportType(node) {\r\n    if (node.specifiers && node.specifiers.length > 0) {\r\n        const nodeSpecifiers = node.specifiers;\r\n        const index = nodeSpecifiers.findIndex(\r\n            ({ type }) =>\r\n                isImportExportSpecifier(type, \"named\") ||\r\n                isImportExportSpecifier(type, \"namespace\")\r\n        );\r\n        const i = index > -1 ? index : 0;\r\n\r\n        return nodeSpecifiers[i].type;\r\n    }\r\n    if (node.type === \"ExportAllDeclaration\") {\r\n        if (node.exported) {\r\n            return \"ExportNamespaceSpecifier\";\r\n        }\r\n        return \"ExportAll\";\r\n    }\r\n    return \"SideEffectImport\";\r\n}\r\n\r\n/**\r\n * Returns a boolean indicates if two (import|export) can be merged\r\n * @param {ASTNode} node1 A node to check.\r\n * @param {ASTNode} node2 A node to check.\r\n * @returns {boolean} True if two (import|export) can be merged, false if they can't.\r\n */\r\nfunction isImportExportCanBeMerged(node1, node2) {\r\n    const importExportType1 = getImportExportType(node1);\r\n    const importExportType2 = getImportExportType(node2);\r\n\r\n    if (\r\n        (importExportType1 === \"ExportAll\" &&\r\n            importExportType2 !== \"ExportAll\" &&\r\n            importExportType2 !== \"SideEffectImport\") ||\r\n        (importExportType1 !== \"ExportAll\" &&\r\n            importExportType1 !== \"SideEffectImport\" &&\r\n            importExportType2 === \"ExportAll\")\r\n    ) {\r\n        return false;\r\n    }\r\n    if (\r\n        (isImportExportSpecifier(importExportType1, \"namespace\") &&\r\n            isImportExportSpecifier(importExportType2, \"named\")) ||\r\n        (isImportExportSpecifier(importExportType2, \"namespace\") &&\r\n            isImportExportSpecifier(importExportType1, \"named\"))\r\n    ) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Returns a boolean if we should report (import|export).\r\n * @param {ASTNode} node A node to be reported or not.\r\n * @param {[ASTNode]} previousNodes An array contains previous nodes of the module imported or exported.\r\n * @returns {boolean} True if the (import|export) should be reported.\r\n */\r\nfunction shouldReportImportExport(node, previousNodes) {\r\n    let i = 0;\r\n\r\n    while (i < previousNodes.length) {\r\n        if (isImportExportCanBeMerged(node, previousNodes[i])) {\r\n            return true;\r\n        }\r\n        i++;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Returns array contains only nodes with declarations types equal to type.\r\n * @param {[{node: ASTNode, declarationType: string}]} nodes An array contains objects, each object contains a node and a declaration type.\r\n * @param {string} type Declaration type.\r\n * @returns {[ASTNode]} An array contains only nodes with declarations types equal to type.\r\n */\r\nfunction getNodesByDeclarationType(nodes, type) {\r\n    return nodes\r\n        .filter(({ declarationType }) => declarationType === type)\r\n        .map(({ node }) => node);\r\n}\r\n\r\n/**\r\n * Returns the name of the module imported or re-exported.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string} The name of the module, or empty string if no name.\r\n */\r\nfunction getModule(node) {\r\n    if (node && node.source && node.source.value) {\r\n        return node.source.value.trim();\r\n    }\r\n    return \"\";\r\n}\r\n\r\n/**\r\n * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.\r\n * @param {RuleContext} context The ESLint rule context object.\r\n * @param {ASTNode} node A node to get.\r\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\r\n * @param {string} declarationType A declaration type can be an import or export.\r\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\r\n * @returns {void} No return value.\r\n */\r\nfunction checkAndReport(\r\n    context,\r\n    node,\r\n    modules,\r\n    declarationType,\r\n    includeExports\r\n) {\r\n    const module = getModule(node);\r\n\r\n    if (modules.has(module)) {\r\n        const previousNodes = modules.get(module);\r\n        const messagesIds = [];\r\n        const importNodes = getNodesByDeclarationType(previousNodes, \"import\");\r\n        let exportNodes;\r\n\r\n        if (includeExports) {\r\n            exportNodes = getNodesByDeclarationType(previousNodes, \"export\");\r\n        }\r\n        if (declarationType === \"import\") {\r\n            if (shouldReportImportExport(node, importNodes)) {\r\n                messagesIds.push(\"import\");\r\n            }\r\n            if (includeExports) {\r\n                if (shouldReportImportExport(node, exportNodes)) {\r\n                    messagesIds.push(\"importAs\");\r\n                }\r\n            }\r\n        } else if (declarationType === \"export\") {\r\n            if (shouldReportImportExport(node, exportNodes)) {\r\n                messagesIds.push(\"export\");\r\n            }\r\n            if (shouldReportImportExport(node, importNodes)) {\r\n                messagesIds.push(\"exportAs\");\r\n            }\r\n        }\r\n        messagesIds.forEach(messageId =>\r\n            context.report({\r\n                node,\r\n                messageId,\r\n                data: {\r\n                    module\r\n                }\r\n            }));\r\n    }\r\n}\r\n\r\n/**\r\n * @callback nodeCallback\r\n * @param {ASTNode} node A node to handle.\r\n */\r\n\r\n/**\r\n * Returns a function handling the (imports|exports) of a given file\r\n * @param {RuleContext} context The ESLint rule context object.\r\n * @param {Map} modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.\r\n * @param {string} declarationType A declaration type can be an import or export.\r\n * @param {boolean} includeExports Whether or not to check for exports in addition to imports.\r\n * @returns {nodeCallback} A function passed to ESLint to handle the statement.\r\n */\r\nfunction handleImportsExports(\r\n    context,\r\n    modules,\r\n    declarationType,\r\n    includeExports\r\n) {\r\n    return function(node) {\r\n        const module = getModule(node);\r\n\r\n        if (module) {\r\n            checkAndReport(\r\n                context,\r\n                node,\r\n                modules,\r\n                declarationType,\r\n                includeExports\r\n            );\r\n            const currentNode = { node, declarationType };\r\n            let nodes = [currentNode];\r\n\r\n            if (modules.has(module)) {\r\n                const previousNodes = modules.get(module);\r\n\r\n                nodes = [...previousNodes, currentNode];\r\n            }\r\n            modules.set(module, nodes);\r\n        }\r\n    };\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow duplicate module imports\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-duplicate-imports\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    includeExports: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            import: \"'{{module}}' import is duplicated.\",\r\n            importAs: \"'{{module}}' import is duplicated as export.\",\r\n            export: \"'{{module}}' export is duplicated.\",\r\n            exportAs: \"'{{module}}' export is duplicated as import.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const includeExports = (context.options[0] || {}).includeExports,\r\n            modules = new Map();\r\n        const handlers = {\r\n            ImportDeclaration: handleImportsExports(\r\n                context,\r\n                modules,\r\n                \"import\",\r\n                includeExports\r\n            )\r\n        };\r\n\r\n        if (includeExports) {\r\n            handlers.ExportNamedDeclaration = handleImportsExports(\r\n                context,\r\n                modules,\r\n                \"export\",\r\n                includeExports\r\n            );\r\n            handlers.ExportAllDeclaration = handleImportsExports(\r\n                context,\r\n                modules,\r\n                \"export\",\r\n                includeExports\r\n            );\r\n        }\r\n        return handlers;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}