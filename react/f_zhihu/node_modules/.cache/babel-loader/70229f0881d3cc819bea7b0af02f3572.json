{"ast":null,"code":"/**\r\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\r\n * @author Kevin Partington\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\n      WHITESPACE = /\\s/gu,\n      MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\n\n/*\r\n * Base schema body for defining the basic capitalization rule, ignorePattern,\r\n * and ignoreInlineComments values.\r\n * This can be used in a few different ways in the actual schema.\r\n */\n\nconst SCHEMA_BODY = {\n  type: \"object\",\n  properties: {\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreInlineComments: {\n      type: \"boolean\"\n    },\n    ignoreConsecutiveComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst DEFAULTS = {\n  ignorePattern: \"\",\n  ignoreInlineComments: false,\n  ignoreConsecutiveComments: false\n};\n/**\r\n * Get normalized options for either block or line comments from the given\r\n * user-provided options.\r\n * - If the user-provided options is just a string, returns a normalized\r\n *   set of options using default values for all other options.\r\n * - If the user-provided options is an object, then a normalized option\r\n *   set is returned. Options specified in overrides will take priority\r\n *   over options specified in the main options object, which will in\r\n *   turn take priority over the rule's defaults.\r\n * @param {Object|string} rawOptions The user-provided options.\r\n * @param {string} which Either \"line\" or \"block\".\r\n * @returns {Object} The normalized options.\r\n */\n\nfunction getNormalizedOptions(rawOptions, which) {\n  return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\n}\n/**\r\n * Get normalized options for block and line comments.\r\n * @param {Object|string} rawOptions The user-provided options.\r\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\r\n * normalized options objects.\r\n */\n\n\nfunction getAllNormalizedOptions() {\n  let rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    Line: getNormalizedOptions(rawOptions, \"line\"),\n    Block: getNormalizedOptions(rawOptions, \"block\")\n  };\n}\n/**\r\n * Creates a regular expression for each ignorePattern defined in the rule\r\n * options.\r\n *\r\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\r\n * @param {Object} normalizedOptions The normalized rule options.\r\n * @returns {void}\r\n */\n\n\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\n  Object.keys(normalizedOptions).forEach(key => {\n    const ignorePatternStr = normalizedOptions[key].ignorePattern;\n\n    if (ignorePatternStr) {\n      const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\n      normalizedOptions[key].ignorePatternRegExp = regExp;\n    }\n  });\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce or disallow capitalization of the first letter of a comment\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/capitalized-comments\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      oneOf: [SCHEMA_BODY, {\n        type: \"object\",\n        properties: {\n          line: SCHEMA_BODY,\n          block: SCHEMA_BODY\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\n      unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\n    }\n  },\n\n  create(context) {\n    const capitalize = context.options[0] || \"always\",\n          normalizedOptions = getAllNormalizedOptions(context.options[1]),\n          sourceCode = context.getSourceCode();\n    createRegExpForIgnorePatterns(normalizedOptions); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\r\n     * Checks whether a comment is an inline comment.\r\n     *\r\n     * For the purpose of this rule, a comment is inline if:\r\n     * 1. The comment is preceded by a token on the same line; and\r\n     * 2. The command is followed by a token on the same line.\r\n     *\r\n     * Note that the comment itself need not be single-line!\r\n     *\r\n     * Also, it follows from this definition that only block comments can\r\n     * be considered as possibly inline. This is because line comments\r\n     * would consume any following tokens on the same line as the comment.\r\n     * @param {ASTNode} comment The comment node to check.\r\n     * @returns {boolean} True if the comment is an inline comment, false\r\n     * otherwise.\r\n     */\n\n    function isInlineComment(comment) {\n      const previousToken = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      }),\n            nextToken = sourceCode.getTokenAfter(comment, {\n        includeComments: true\n      });\n      return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);\n    }\n    /**\r\n     * Determine if a comment follows another comment.\r\n     * @param {ASTNode} comment The comment to check.\r\n     * @returns {boolean} True if the comment follows a valid comment.\r\n     */\n\n\n    function isConsecutiveComment(comment) {\n      const previousTokenOrComment = sourceCode.getTokenBefore(comment, {\n        includeComments: true\n      });\n      return Boolean(previousTokenOrComment && [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1);\n    }\n    /**\r\n     * Check a comment to determine if it is valid for this rule.\r\n     * @param {ASTNode} comment The comment node to process.\r\n     * @param {Object} options The options for checking this comment.\r\n     * @returns {boolean} True if the comment is valid, false otherwise.\r\n     */\n\n\n    function isCommentValid(comment, options) {\n      // 1. Check for default ignore pattern.\n      if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\n        return true;\n      } // 2. Check for custom ignore pattern.\n\n\n      const commentWithoutAsterisks = comment.value.replace(/\\*/gu, \"\");\n\n      if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\n        return true;\n      } // 3. Check for inline comments.\n\n\n      if (options.ignoreInlineComments && isInlineComment(comment)) {\n        return true;\n      } // 4. Is this a consecutive comment (and are we tolerating those)?\n\n\n      if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\n        return true;\n      } // 5. Does the comment start with a possible URL?\n\n\n      if (MAYBE_URL.test(commentWithoutAsterisks)) {\n        return true;\n      } // 6. Is the initial word character a letter?\n\n\n      const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, \"\");\n\n      if (commentWordCharsOnly.length === 0) {\n        return true;\n      }\n\n      const firstWordChar = commentWordCharsOnly[0];\n\n      if (!LETTER_PATTERN.test(firstWordChar)) {\n        return true;\n      } // 7. Check the case of the initial word character.\n\n\n      const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\n            isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\n\n      if (capitalize === \"always\" && isLowercase) {\n        return false;\n      }\n\n      if (capitalize === \"never\" && isUppercase) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Process a comment to determine if it needs to be reported.\r\n     * @param {ASTNode} comment The comment node to process.\r\n     * @returns {void}\r\n     */\n\n\n    function processComment(comment) {\n      const options = normalizedOptions[comment.type],\n            commentValid = isCommentValid(comment, options);\n\n      if (!commentValid) {\n        const messageId = capitalize === \"always\" ? \"unexpectedLowercaseComment\" : \"unexpectedUppercaseComment\";\n        context.report({\n          node: null,\n          // Intentionally using loc instead\n          loc: comment.loc,\n          messageId,\n\n          fix(fixer) {\n            const match = comment.value.match(LETTER_PATTERN);\n            return fixer.replaceTextRange( // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\n            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/capitalized-comments.js"],"names":["LETTER_PATTERN","require","astUtils","DEFAULT_IGNORE_PATTERN","COMMENTS_IGNORE_PATTERN","WHITESPACE","MAYBE_URL","SCHEMA_BODY","type","properties","ignorePattern","ignoreInlineComments","ignoreConsecutiveComments","additionalProperties","DEFAULTS","getNormalizedOptions","rawOptions","which","Object","assign","getAllNormalizedOptions","Line","Block","createRegExpForIgnorePatterns","normalizedOptions","keys","forEach","key","ignorePatternStr","regExp","RegExp","ignorePatternRegExp","module","exports","meta","docs","description","recommended","url","fixable","schema","enum","oneOf","line","block","messages","unexpectedLowercaseComment","unexpectedUppercaseComment","create","context","capitalize","options","sourceCode","getSourceCode","isInlineComment","comment","previousToken","getTokenBefore","includeComments","nextToken","getTokenAfter","Boolean","loc","start","end","isConsecutiveComment","previousTokenOrComment","indexOf","isCommentValid","test","value","commentWithoutAsterisks","replace","commentWordCharsOnly","length","firstWordChar","isUppercase","toLocaleLowerCase","isLowercase","toLocaleUpperCase","processComment","commentValid","messageId","report","node","fix","fixer","match","replaceTextRange","range","index","Program","comments","getAllComments","filter","token"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview enforce or disallow capitalization of the first letter of a comment\r\n * @author Kevin Partington\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst LETTER_PATTERN = require(\"./utils/patterns/letters\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,\r\n    WHITESPACE = /\\s/gu,\r\n    MAYBE_URL = /^\\s*[^:/?#\\s]+:\\/\\/[^?#]/u; // TODO: Combine w/ max-len pattern?\r\n\r\n/*\r\n * Base schema body for defining the basic capitalization rule, ignorePattern,\r\n * and ignoreInlineComments values.\r\n * This can be used in a few different ways in the actual schema.\r\n */\r\nconst SCHEMA_BODY = {\r\n    type: \"object\",\r\n    properties: {\r\n        ignorePattern: {\r\n            type: \"string\"\r\n        },\r\n        ignoreInlineComments: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreConsecutiveComments: {\r\n            type: \"boolean\"\r\n        }\r\n    },\r\n    additionalProperties: false\r\n};\r\nconst DEFAULTS = {\r\n    ignorePattern: \"\",\r\n    ignoreInlineComments: false,\r\n    ignoreConsecutiveComments: false\r\n};\r\n\r\n/**\r\n * Get normalized options for either block or line comments from the given\r\n * user-provided options.\r\n * - If the user-provided options is just a string, returns a normalized\r\n *   set of options using default values for all other options.\r\n * - If the user-provided options is an object, then a normalized option\r\n *   set is returned. Options specified in overrides will take priority\r\n *   over options specified in the main options object, which will in\r\n *   turn take priority over the rule's defaults.\r\n * @param {Object|string} rawOptions The user-provided options.\r\n * @param {string} which Either \"line\" or \"block\".\r\n * @returns {Object} The normalized options.\r\n */\r\nfunction getNormalizedOptions(rawOptions, which) {\r\n    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);\r\n}\r\n\r\n/**\r\n * Get normalized options for block and line comments.\r\n * @param {Object|string} rawOptions The user-provided options.\r\n * @returns {Object} An object with \"Line\" and \"Block\" keys and corresponding\r\n * normalized options objects.\r\n */\r\nfunction getAllNormalizedOptions(rawOptions = {}) {\r\n    return {\r\n        Line: getNormalizedOptions(rawOptions, \"line\"),\r\n        Block: getNormalizedOptions(rawOptions, \"block\")\r\n    };\r\n}\r\n\r\n/**\r\n * Creates a regular expression for each ignorePattern defined in the rule\r\n * options.\r\n *\r\n * This is done in order to avoid invoking the RegExp constructor repeatedly.\r\n * @param {Object} normalizedOptions The normalized rule options.\r\n * @returns {void}\r\n */\r\nfunction createRegExpForIgnorePatterns(normalizedOptions) {\r\n    Object.keys(normalizedOptions).forEach(key => {\r\n        const ignorePatternStr = normalizedOptions[key].ignorePattern;\r\n\r\n        if (ignorePatternStr) {\r\n            const regExp = RegExp(`^\\\\s*(?:${ignorePatternStr})`, \"u\");\r\n\r\n            normalizedOptions[key].ignorePatternRegExp = regExp;\r\n        }\r\n    });\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce or disallow capitalization of the first letter of a comment\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/capitalized-comments\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            { enum: [\"always\", \"never\"] },\r\n            {\r\n                oneOf: [\r\n                    SCHEMA_BODY,\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            line: SCHEMA_BODY,\r\n                            block: SCHEMA_BODY\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedLowercaseComment: \"Comments should not begin with a lowercase character.\",\r\n            unexpectedUppercaseComment: \"Comments should not begin with an uppercase character.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const capitalize = context.options[0] || \"always\",\r\n            normalizedOptions = getAllNormalizedOptions(context.options[1]),\r\n            sourceCode = context.getSourceCode();\r\n\r\n        createRegExpForIgnorePatterns(normalizedOptions);\r\n\r\n        //----------------------------------------------------------------------\r\n        // Helpers\r\n        //----------------------------------------------------------------------\r\n\r\n        /**\r\n         * Checks whether a comment is an inline comment.\r\n         *\r\n         * For the purpose of this rule, a comment is inline if:\r\n         * 1. The comment is preceded by a token on the same line; and\r\n         * 2. The command is followed by a token on the same line.\r\n         *\r\n         * Note that the comment itself need not be single-line!\r\n         *\r\n         * Also, it follows from this definition that only block comments can\r\n         * be considered as possibly inline. This is because line comments\r\n         * would consume any following tokens on the same line as the comment.\r\n         * @param {ASTNode} comment The comment node to check.\r\n         * @returns {boolean} True if the comment is an inline comment, false\r\n         * otherwise.\r\n         */\r\n        function isInlineComment(comment) {\r\n            const previousToken = sourceCode.getTokenBefore(comment, { includeComments: true }),\r\n                nextToken = sourceCode.getTokenAfter(comment, { includeComments: true });\r\n\r\n            return Boolean(\r\n                previousToken &&\r\n                nextToken &&\r\n                comment.loc.start.line === previousToken.loc.end.line &&\r\n                comment.loc.end.line === nextToken.loc.start.line\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Determine if a comment follows another comment.\r\n         * @param {ASTNode} comment The comment to check.\r\n         * @returns {boolean} True if the comment follows a valid comment.\r\n         */\r\n        function isConsecutiveComment(comment) {\r\n            const previousTokenOrComment = sourceCode.getTokenBefore(comment, { includeComments: true });\r\n\r\n            return Boolean(\r\n                previousTokenOrComment &&\r\n                [\"Block\", \"Line\"].indexOf(previousTokenOrComment.type) !== -1\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check a comment to determine if it is valid for this rule.\r\n         * @param {ASTNode} comment The comment node to process.\r\n         * @param {Object} options The options for checking this comment.\r\n         * @returns {boolean} True if the comment is valid, false otherwise.\r\n         */\r\n        function isCommentValid(comment, options) {\r\n\r\n            // 1. Check for default ignore pattern.\r\n            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {\r\n                return true;\r\n            }\r\n\r\n            // 2. Check for custom ignore pattern.\r\n            const commentWithoutAsterisks = comment.value\r\n                .replace(/\\*/gu, \"\");\r\n\r\n            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {\r\n                return true;\r\n            }\r\n\r\n            // 3. Check for inline comments.\r\n            if (options.ignoreInlineComments && isInlineComment(comment)) {\r\n                return true;\r\n            }\r\n\r\n            // 4. Is this a consecutive comment (and are we tolerating those)?\r\n            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {\r\n                return true;\r\n            }\r\n\r\n            // 5. Does the comment start with a possible URL?\r\n            if (MAYBE_URL.test(commentWithoutAsterisks)) {\r\n                return true;\r\n            }\r\n\r\n            // 6. Is the initial word character a letter?\r\n            const commentWordCharsOnly = commentWithoutAsterisks\r\n                .replace(WHITESPACE, \"\");\r\n\r\n            if (commentWordCharsOnly.length === 0) {\r\n                return true;\r\n            }\r\n\r\n            const firstWordChar = commentWordCharsOnly[0];\r\n\r\n            if (!LETTER_PATTERN.test(firstWordChar)) {\r\n                return true;\r\n            }\r\n\r\n            // 7. Check the case of the initial word character.\r\n            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),\r\n                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();\r\n\r\n            if (capitalize === \"always\" && isLowercase) {\r\n                return false;\r\n            }\r\n            if (capitalize === \"never\" && isUppercase) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Process a comment to determine if it needs to be reported.\r\n         * @param {ASTNode} comment The comment node to process.\r\n         * @returns {void}\r\n         */\r\n        function processComment(comment) {\r\n            const options = normalizedOptions[comment.type],\r\n                commentValid = isCommentValid(comment, options);\r\n\r\n            if (!commentValid) {\r\n                const messageId = capitalize === \"always\"\r\n                    ? \"unexpectedLowercaseComment\"\r\n                    : \"unexpectedUppercaseComment\";\r\n\r\n                context.report({\r\n                    node: null, // Intentionally using loc instead\r\n                    loc: comment.loc,\r\n                    messageId,\r\n                    fix(fixer) {\r\n                        const match = comment.value.match(LETTER_PATTERN);\r\n\r\n                        return fixer.replaceTextRange(\r\n\r\n                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)\r\n                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],\r\n                            capitalize === \"always\" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()\r\n                        );\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n\r\n        return {\r\n            Program() {\r\n                const comments = sourceCode.getAllComments();\r\n\r\n                comments.filter(token => token.type !== \"Shebang\").forEach(processComment);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}