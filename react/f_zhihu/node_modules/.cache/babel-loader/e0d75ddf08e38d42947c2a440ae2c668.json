{"ast":null,"code":"/**\r\n * @fileoverview A class to manage state of generating a code path.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathSegment = require(\"./code-path-segment\"),\n      ForkContext = require(\"./fork-context\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Adds given segments into the `dest` array.\r\n * If the `others` array does not includes the given segments, adds to the `all`\r\n * array as well.\r\n *\r\n * This adds only reachable and used segments.\r\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\r\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\r\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\r\n * @param {CodePathSegment[]} segments Segments to add.\r\n * @returns {void}\r\n */\n\n\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n  for (let i = 0; i < segments.length; ++i) {\n    const segment = segments[i];\n    dest.push(segment);\n\n    if (others.indexOf(segment) === -1) {\n      all.push(segment);\n    }\n  }\n}\n/**\r\n * Gets a loop-context for a `continue` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @param {string} label The label of a `continue` statement.\r\n * @returns {LoopContext} A loop-context for a `continue` statement.\r\n */\n\n\nfunction getContinueContext(state, label) {\n  if (!label) {\n    return state.loopContext;\n  }\n\n  let context = state.loopContext;\n\n  while (context) {\n    if (context.label === label) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* istanbul ignore next: foolproof (syntax error) */\n\n\n  return null;\n}\n/**\r\n * Gets a context for a `break` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @param {string} label The label of a `break` statement.\r\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\r\n */\n\n\nfunction getBreakContext(state, label) {\n  let context = state.breakContext;\n\n  while (context) {\n    if (label ? context.label === label : context.breakable) {\n      return context;\n    }\n\n    context = context.upper;\n  }\n  /* istanbul ignore next: foolproof (syntax error) */\n\n\n  return null;\n}\n/**\r\n * Gets a context for a `return` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @returns {TryContext|CodePathState} A context for a `return` statement.\r\n */\n\n\nfunction getReturnContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.hasFinalizer && context.position !== \"finally\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\r\n * Gets a context for a `throw` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\r\n */\n\n\nfunction getThrowContext(state) {\n  let context = state.tryContext;\n\n  while (context) {\n    if (context.position === \"try\" || context.hasFinalizer && context.position === \"catch\") {\n      return context;\n    }\n\n    context = context.upper;\n  }\n\n  return state;\n}\n/**\r\n * Removes a given element from a given array.\r\n * @param {any[]} xs An array to remove the specific element.\r\n * @param {any} x An element to be removed.\r\n * @returns {void}\r\n */\n\n\nfunction remove(xs, x) {\n  xs.splice(xs.indexOf(x), 1);\n}\n/**\r\n * Disconnect given segments.\r\n *\r\n * This is used in a process for switch statements.\r\n * If there is the \"default\" chunk before other cases, the order is different\r\n * between node's and running's.\r\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\r\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\r\n * @returns {void}\r\n */\n\n\nfunction removeConnection(prevSegments, nextSegments) {\n  for (let i = 0; i < prevSegments.length; ++i) {\n    const prevSegment = prevSegments[i];\n    const nextSegment = nextSegments[i];\n    remove(prevSegment.nextSegments, nextSegment);\n    remove(prevSegment.allNextSegments, nextSegment);\n    remove(nextSegment.prevSegments, prevSegment);\n    remove(nextSegment.allPrevSegments, prevSegment);\n  }\n}\n/**\r\n * Creates looping path.\r\n * @param {CodePathState} state The instance.\r\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\r\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\r\n * @returns {void}\r\n */\n\n\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\n  const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\n  const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\n  const end = Math.min(fromSegments.length, toSegments.length);\n\n  for (let i = 0; i < end; ++i) {\n    const fromSegment = fromSegments[i];\n    const toSegment = toSegments[i];\n\n    if (toSegment.reachable) {\n      fromSegment.nextSegments.push(toSegment);\n    }\n\n    if (fromSegment.reachable) {\n      toSegment.prevSegments.push(fromSegment);\n    }\n\n    fromSegment.allNextSegments.push(toSegment);\n    toSegment.allPrevSegments.push(fromSegment);\n\n    if (toSegment.allPrevSegments.length >= 2) {\n      CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n    }\n\n    state.notifyLooped(fromSegment, toSegment);\n  }\n}\n/**\r\n * Finalizes segments of `test` chunk of a ForStatement.\r\n *\r\n * - Adds `false` paths to paths which are leaving from the loop.\r\n * - Sets `true` paths to paths which go to the body.\r\n * @param {LoopContext} context A loop context to modify.\r\n * @param {ChoiceContext} choiceContext A choice context of this loop.\r\n * @param {CodePathSegment[]} head The current head paths.\r\n * @returns {void}\r\n */\n\n\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n  if (!choiceContext.processed) {\n    choiceContext.trueForkContext.add(head);\n    choiceContext.falseForkContext.add(head);\n    choiceContext.qqForkContext.add(head);\n  }\n\n  if (context.test !== true) {\n    context.brokenForkContext.addAll(choiceContext.falseForkContext);\n  }\n\n  context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * A class which manages state to analyze code paths.\r\n */\n\n\nclass CodePathState {\n  /**\r\n   * @param {IdGenerator} idGenerator An id generator to generate id for code\r\n   *   path segments.\r\n   * @param {Function} onLooped A callback function to notify looping.\r\n   */\n  constructor(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = ForkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n    this.chainContext = null;\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0]; // returnedSegments and thrownSegments push elements into finalSegments also.\n\n    const final = this.finalSegments = [];\n    const returned = this.returnedForkContext = [];\n    const thrown = this.thrownForkContext = [];\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n  }\n  /**\r\n   * The head segments.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get headSegments() {\n    return this.forkContext.head;\n  }\n  /**\r\n   * The parent forking context.\r\n   * This is used for the root of new forks.\r\n   * @type {ForkContext}\r\n   */\n\n\n  get parentForkContext() {\n    const current = this.forkContext;\n    return current && current.upper;\n  }\n  /**\r\n   * Creates and stacks new forking context.\r\n   * @param {boolean} forkLeavingPath A flag which shows being in a\r\n   *   \"finally\" block.\r\n   * @returns {ForkContext} The created context.\r\n   */\n\n\n  pushForkContext(forkLeavingPath) {\n    this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);\n    return this.forkContext;\n  }\n  /**\r\n   * Pops and merges the last forking context.\r\n   * @returns {ForkContext} The last context.\r\n   */\n\n\n  popForkContext() {\n    const lastContext = this.forkContext;\n    this.forkContext = lastContext.upper;\n    this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n    return lastContext;\n  }\n  /**\r\n   * Creates a new path.\r\n   * @returns {void}\r\n   */\n\n\n  forkPath() {\n    this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n  }\n  /**\r\n   * Creates a bypass path.\r\n   * This is used for such as IfStatement which does not have \"else\" chunk.\r\n   * @returns {void}\r\n   */\n\n\n  forkBypassPath() {\n    this.forkContext.add(this.parentForkContext.head);\n  } //--------------------------------------------------------------------------\n  // ConditionalExpression, LogicalExpression, IfStatement\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\r\n   * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\r\n   *\r\n   * LogicalExpressions have cases that it goes different paths between the\r\n   * `true` case and the `false` case.\r\n   *\r\n   * For Example:\r\n   *\r\n   *     if (a || b) {\r\n   *         foo();\r\n   *     } else {\r\n   *         bar();\r\n   *     }\r\n   *\r\n   * In this case, `b` is evaluated always in the code path of the `else`\r\n   * block, but it's not so in the code path of the `if` block.\r\n   * So there are 3 paths.\r\n   *\r\n   *     a -> foo();\r\n   *     a -> b -> foo();\r\n   *     a -> b -> bar();\r\n   * @param {string} kind A kind string.\r\n   *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\r\n   *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\r\n   *   Otherwise, this is `\"loop\"`.\r\n   * @param {boolean} isForkingAsResult A flag that shows that goes different\r\n   *   paths between `true` and `false`.\r\n   * @returns {void}\r\n   */\n\n\n  pushChoiceContext(kind, isForkingAsResult) {\n    this.choiceContext = {\n      upper: this.choiceContext,\n      kind,\n      isForkingAsResult,\n      trueForkContext: ForkContext.newEmpty(this.forkContext),\n      falseForkContext: ForkContext.newEmpty(this.forkContext),\n      qqForkContext: ForkContext.newEmpty(this.forkContext),\n      processed: false\n    };\n  }\n  /**\r\n   * Pops the last choice context and finalizes it.\r\n   * @throws {Error} (Unreachable.)\r\n   * @returns {ChoiceContext} The popped context.\r\n   */\n\n\n  popChoiceContext() {\n    const context = this.choiceContext;\n    this.choiceContext = context.upper;\n    const forkContext = this.forkContext;\n    const headSegments = forkContext.head;\n\n    switch (context.kind) {\n      case \"&&\":\n      case \"||\":\n      case \"??\":\n        /*\r\n         * If any result were not transferred from child contexts,\r\n         * this sets the head segments to both cases.\r\n         * The head segments are the path of the right-hand operand.\r\n         */\n        if (!context.processed) {\n          context.trueForkContext.add(headSegments);\n          context.falseForkContext.add(headSegments);\n          context.qqForkContext.add(headSegments);\n        }\n        /*\r\n         * Transfers results to upper context if this context is in\r\n         * test chunk.\r\n         */\n\n\n        if (context.isForkingAsResult) {\n          const parentContext = this.choiceContext;\n          parentContext.trueForkContext.addAll(context.trueForkContext);\n          parentContext.falseForkContext.addAll(context.falseForkContext);\n          parentContext.qqForkContext.addAll(context.qqForkContext);\n          parentContext.processed = true;\n          return context;\n        }\n\n        break;\n\n      case \"test\":\n        if (!context.processed) {\n          /*\r\n           * The head segments are the path of the `if` block here.\r\n           * Updates the `true` path with the end of the `if` block.\r\n           */\n          context.trueForkContext.clear();\n          context.trueForkContext.add(headSegments);\n        } else {\n          /*\r\n           * The head segments are the path of the `else` block here.\r\n           * Updates the `false` path with the end of the `else`\r\n           * block.\r\n           */\n          context.falseForkContext.clear();\n          context.falseForkContext.add(headSegments);\n        }\n\n        break;\n\n      case \"loop\":\n        /*\r\n         * Loops are addressed in popLoopContext().\r\n         * This is called from popLoopContext().\r\n         */\n        return context;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Merges all paths.\n\n\n    const prevForkContext = context.trueForkContext;\n    prevForkContext.addAll(context.falseForkContext);\n    forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n    return context;\n  }\n  /**\r\n   * Makes a code path segment of the right-hand operand of a logical\r\n   * expression.\r\n   * @throws {Error} (Unreachable.)\r\n   * @returns {void}\r\n   */\n\n\n  makeLogicalRight() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (context.processed) {\n      /*\r\n       * This got segments already from the child choice context.\r\n       * Creates the next path from own true/false fork context.\r\n       */\n      let prevForkContext;\n\n      switch (context.kind) {\n        case \"&&\":\n          // if true then go to the right-hand side.\n          prevForkContext = context.trueForkContext;\n          break;\n\n        case \"||\":\n          // if false then go to the right-hand side.\n          prevForkContext = context.falseForkContext;\n          break;\n\n        case \"??\":\n          // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\n          prevForkContext = context.qqForkContext;\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n      prevForkContext.clear();\n      context.processed = false;\n    } else {\n      /*\r\n       * This did not get segments from the child choice context.\r\n       * So addresses the head segments.\r\n       * The head segments are the path of the left-hand operand.\r\n       */\n      switch (context.kind) {\n        case \"&&\":\n          // the false path can short-circuit.\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        case \"||\":\n          // the true path can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          break;\n\n        case \"??\":\n          // both can short-circuit.\n          context.trueForkContext.add(forkContext.head);\n          context.falseForkContext.add(forkContext.head);\n          break;\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n\n      forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    }\n  }\n  /**\r\n   * Makes a code path segment of the `if` block.\r\n   * @returns {void}\r\n   */\n\n\n  makeIfConsequent() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\r\n     * If any result were not transferred from child contexts,\r\n     * this sets the head segments to both cases.\r\n     * The head segments are the path of the test expression.\r\n     */\n\n    if (!context.processed) {\n      context.trueForkContext.add(forkContext.head);\n      context.falseForkContext.add(forkContext.head);\n      context.qqForkContext.add(forkContext.head);\n    }\n\n    context.processed = false; // Creates new path from the `true` case.\n\n    forkContext.replaceHead(context.trueForkContext.makeNext(0, -1));\n  }\n  /**\r\n   * Makes a code path segment of the `else` block.\r\n   * @returns {void}\r\n   */\n\n\n  makeIfAlternate() {\n    const context = this.choiceContext;\n    const forkContext = this.forkContext;\n    /*\r\n     * The head segments are the path of the `if` block.\r\n     * Updates the `true` path with the end of the `if` block.\r\n     */\n\n    context.trueForkContext.clear();\n    context.trueForkContext.add(forkContext.head);\n    context.processed = true; // Creates new path from the `false` case.\n\n    forkContext.replaceHead(context.falseForkContext.makeNext(0, -1));\n  } //--------------------------------------------------------------------------\n  // ChainExpression\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Push a new `ChainExpression` context to the stack.\r\n   * This method is called on entering to each `ChainExpression` node.\r\n   * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\r\n   * @returns {void}\r\n   */\n\n\n  pushChainContext() {\n    this.chainContext = {\n      upper: this.chainContext,\n      countChoiceContexts: 0\n    };\n  }\n  /**\r\n   * Pop a `ChainExpression` context from the stack.\r\n   * This method is called on exiting from each `ChainExpression` node.\r\n   * This merges all forks of the last optional chaining.\r\n   * @returns {void}\r\n   */\n\n\n  popChainContext() {\n    const context = this.chainContext;\n    this.chainContext = context.upper; // pop all choice contexts of this.\n\n    for (let i = context.countChoiceContexts; i > 0; --i) {\n      this.popChoiceContext();\n    }\n  }\n  /**\r\n   * Create a choice context for optional access.\r\n   * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\r\n   * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\r\n   * @returns {void}\r\n   */\n\n\n  makeOptionalNode() {\n    if (this.chainContext) {\n      this.chainContext.countChoiceContexts += 1;\n      this.pushChoiceContext(\"??\", false);\n    }\n  }\n  /**\r\n   * Create a fork.\r\n   * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\r\n   * @returns {void}\r\n   */\n\n\n  makeOptionalRight() {\n    if (this.chainContext) {\n      this.makeLogicalRight();\n    }\n  } //--------------------------------------------------------------------------\n  // SwitchStatement\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Creates a context object of SwitchStatement and stacks it.\r\n   * @param {boolean} hasCase `true` if the switch statement has one or more\r\n   *   case parts.\r\n   * @param {string|null} label The label text.\r\n   * @returns {void}\r\n   */\n\n\n  pushSwitchContext(hasCase, label) {\n    this.switchContext = {\n      upper: this.switchContext,\n      hasCase,\n      defaultSegments: null,\n      defaultBodySegments: null,\n      foundDefault: false,\n      lastIsDefault: false,\n      countForks: 0\n    };\n    this.pushBreakContext(true, label);\n  }\n  /**\r\n   * Pops the last context of SwitchStatement and finalizes it.\r\n   *\r\n   * - Disposes all forking stack for `case` and `default`.\r\n   * - Creates the next code path segment from `context.brokenForkContext`.\r\n   * - If the last `SwitchCase` node is not a `default` part, creates a path\r\n   *   to the `default` body.\r\n   * @returns {void}\r\n   */\n\n\n  popSwitchContext() {\n    const context = this.switchContext;\n    this.switchContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext;\n\n    if (context.countForks === 0) {\n      /*\r\n       * When there is only one `default` chunk and there is one or more\r\n       * `break` statements, even if forks are nothing, it needs to merge\r\n       * those.\r\n       */\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.makeNext(-1, -1));\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n\n      return;\n    }\n\n    const lastSegments = forkContext.head;\n    this.forkBypassPath();\n    const lastCaseSegments = forkContext.head;\n    /*\r\n     * `brokenForkContext` is used to make the next segment.\r\n     * It must add the last segment into `brokenForkContext`.\r\n     */\n\n    brokenForkContext.add(lastSegments);\n    /*\r\n     * A path which is failed in all case test should be connected to path\r\n     * of `default` chunk.\r\n     */\n\n    if (!context.lastIsDefault) {\n      if (context.defaultBodySegments) {\n        /*\r\n         * Remove a link from `default` label to its chunk.\r\n         * It's false route.\r\n         */\n        removeConnection(context.defaultSegments, context.defaultBodySegments);\n        makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n      } else {\n        /*\r\n         * It handles the last case body as broken if `default` chunk\r\n         * does not exist.\r\n         */\n        brokenForkContext.add(lastCaseSegments);\n      }\n    } // Pops the segment context stack until the entry segment.\n\n\n    for (let i = 0; i < context.countForks; ++i) {\n      this.forkContext = this.forkContext.upper;\n    }\n    /*\r\n     * Creates a path from all brokenForkContext paths.\r\n     * This is a path after switch statement.\r\n     */\n\n\n    this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n  }\n  /**\r\n   * Makes a code path segment for a `SwitchCase` node.\r\n   * @param {boolean} isEmpty `true` if the body is empty.\r\n   * @param {boolean} isDefault `true` if the body is the default case.\r\n   * @returns {void}\r\n   */\n\n\n  makeSwitchCaseBody(isEmpty, isDefault) {\n    const context = this.switchContext;\n\n    if (!context.hasCase) {\n      return;\n    }\n    /*\r\n     * Merge forks.\r\n     * The parent fork context has two segments.\r\n     * Those are from the current case and the body of the previous case.\r\n     */\n\n\n    const parentForkContext = this.forkContext;\n    const forkContext = this.pushForkContext();\n    forkContext.add(parentForkContext.makeNext(0, -1));\n    /*\r\n     * Save `default` chunk info.\r\n     * If the `default` label is not at the last, we must make a path from\r\n     * the last `case` to the `default` chunk.\r\n     */\n\n    if (isDefault) {\n      context.defaultSegments = parentForkContext.head;\n\n      if (isEmpty) {\n        context.foundDefault = true;\n      } else {\n        context.defaultBodySegments = forkContext.head;\n      }\n    } else {\n      if (!isEmpty && context.foundDefault) {\n        context.foundDefault = false;\n        context.defaultBodySegments = forkContext.head;\n      }\n    }\n\n    context.lastIsDefault = isDefault;\n    context.countForks += 1;\n  } //--------------------------------------------------------------------------\n  // TryStatement\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Creates a context object of TryStatement and stacks it.\r\n   * @param {boolean} hasFinalizer `true` if the try statement has a\r\n   *   `finally` block.\r\n   * @returns {void}\r\n   */\n\n\n  pushTryContext(hasFinalizer) {\n    this.tryContext = {\n      upper: this.tryContext,\n      position: \"try\",\n      hasFinalizer,\n      returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,\n      thrownForkContext: ForkContext.newEmpty(this.forkContext),\n      lastOfTryIsReachable: false,\n      lastOfCatchIsReachable: false\n    };\n  }\n  /**\r\n   * Pops the last context of TryStatement and finalizes it.\r\n   * @returns {void}\r\n   */\n\n\n  popTryContext() {\n    const context = this.tryContext;\n    this.tryContext = context.upper;\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block merely.\n      this.popForkContext();\n      return;\n    }\n    /*\r\n     * The following process is executed only when there is the `finally`\r\n     * block.\r\n     */\n\n\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n\n    if (returned.empty && thrown.empty) {\n      return;\n    } // Separate head to normal paths and leaving paths.\n\n\n    const headSegments = this.forkContext.head;\n    this.forkContext = this.forkContext.upper;\n    const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n    const leavingSegments = headSegments.slice(headSegments.length / 2 | 0); // Forwards the leaving path to upper contexts.\n\n    if (!returned.empty) {\n      getReturnContext(this).returnedForkContext.add(leavingSegments);\n    }\n\n    if (!thrown.empty) {\n      getThrowContext(this).thrownForkContext.add(leavingSegments);\n    } // Sets the normal path as the next.\n\n\n    this.forkContext.replaceHead(normalSegments);\n    /*\r\n     * If both paths of the `try` block and the `catch` block are\r\n     * unreachable, the next path becomes unreachable as well.\r\n     */\n\n    if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n      this.forkContext.makeUnreachable();\n    }\n  }\n  /**\r\n   * Makes a code path segment for a `catch` block.\r\n   * @returns {void}\r\n   */\n\n\n  makeCatchBlock() {\n    const context = this.tryContext;\n    const forkContext = this.forkContext;\n    const thrown = context.thrownForkContext; // Update state.\n\n    context.position = \"catch\";\n    context.thrownForkContext = ForkContext.newEmpty(forkContext);\n    context.lastOfTryIsReachable = forkContext.reachable; // Merge thrown paths.\n\n    thrown.add(forkContext.head);\n    const thrownSegments = thrown.makeNext(0, -1); // Fork to a bypass and the merged thrown path.\n\n    this.pushForkContext();\n    this.forkBypassPath();\n    this.forkContext.add(thrownSegments);\n  }\n  /**\r\n   * Makes a code path segment for a `finally` block.\r\n   *\r\n   * In the `finally` block, parallel paths are created. The parallel paths\r\n   * are used as leaving-paths. The leaving-paths are paths from `return`\r\n   * statements and `throw` statements in a `try` block or a `catch` block.\r\n   * @returns {void}\r\n   */\n\n\n  makeFinallyBlock() {\n    const context = this.tryContext;\n    let forkContext = this.forkContext;\n    const returned = context.returnedForkContext;\n    const thrown = context.thrownForkContext;\n    const headOfLeavingSegments = forkContext.head; // Update state.\n\n    if (context.position === \"catch\") {\n      // Merges two paths from the `try` block and `catch` block.\n      this.popForkContext();\n      forkContext = this.forkContext;\n      context.lastOfCatchIsReachable = forkContext.reachable;\n    } else {\n      context.lastOfTryIsReachable = forkContext.reachable;\n    }\n\n    context.position = \"finally\";\n\n    if (returned.empty && thrown.empty) {\n      // This path does not leave.\n      return;\n    }\n    /*\r\n     * Create a parallel segment from merging returned and thrown.\r\n     * This segment will leave at the end of this finally block.\r\n     */\n\n\n    const segments = forkContext.makeNext(-1, -1);\n\n    for (let i = 0; i < forkContext.count; ++i) {\n      const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n      for (let j = 0; j < returned.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n      }\n\n      for (let j = 0; j < thrown.segmentsList.length; ++j) {\n        prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n      }\n\n      segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));\n    }\n\n    this.pushForkContext(true);\n    this.forkContext.add(segments);\n  }\n  /**\r\n   * Makes a code path segment from the first throwable node to the `catch`\r\n   * block or the `finally` block.\r\n   * @returns {void}\r\n   */\n\n\n  makeFirstThrowablePathInTryBlock() {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getThrowContext(this);\n\n    if (context === this || context.position !== \"try\" || !context.thrownForkContext.empty) {\n      return;\n    }\n\n    context.thrownForkContext.add(forkContext.head);\n    forkContext.replaceHead(forkContext.makeNext(-1, -1));\n  } //--------------------------------------------------------------------------\n  // Loop Statements\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Creates a context object of a loop statement and stacks it.\r\n   * @param {string} type The type of the node which was triggered. One of\r\n   *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\r\n   *   and `ForStatement`.\r\n   * @param {string|null} label A label of the node which was triggered.\r\n   * @throws {Error} (Unreachable - unknown type.)\r\n   * @returns {void}\r\n   */\n\n\n  pushLoopContext(type, label) {\n    const forkContext = this.forkContext;\n    const breakContext = this.pushBreakContext(true, label);\n\n    switch (type) {\n      case \"WhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"DoWhileStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          entrySegments: null,\n          continueForkContext: ForkContext.newEmpty(forkContext),\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForStatement\":\n        this.pushChoiceContext(\"loop\", false);\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          test: void 0,\n          endOfInitSegments: null,\n          testSegments: null,\n          endOfTestSegments: null,\n          updateSegments: null,\n          endOfUpdateSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        this.loopContext = {\n          upper: this.loopContext,\n          type,\n          label,\n          prevSegments: null,\n          leftSegments: null,\n          endOfLeftSegments: null,\n          continueDestSegments: null,\n          brokenForkContext: breakContext.brokenForkContext\n        };\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(`unknown type: \"${type}\"`);\n    }\n  }\n  /**\r\n   * Pops the last context of a loop statement and finalizes it.\r\n   * @throws {Error} (Unreachable - unknown type.)\r\n   * @returns {void}\r\n   */\n\n\n  popLoopContext() {\n    const context = this.loopContext;\n    this.loopContext = context.upper;\n    const forkContext = this.forkContext;\n    const brokenForkContext = this.popBreakContext().brokenForkContext; // Creates a looped path.\n\n    switch (context.type) {\n      case \"WhileStatement\":\n      case \"ForStatement\":\n        this.popChoiceContext();\n        makeLooped(this, forkContext.head, context.continueDestSegments);\n        break;\n\n      case \"DoWhileStatement\":\n        {\n          const choiceContext = this.popChoiceContext();\n\n          if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n          }\n\n          if (context.test !== true) {\n            brokenForkContext.addAll(choiceContext.falseForkContext);\n          } // `true` paths go to looping.\n\n\n          const segmentsList = choiceContext.trueForkContext.segmentsList;\n\n          for (let i = 0; i < segmentsList.length; ++i) {\n            makeLooped(this, segmentsList[i], context.entrySegments);\n          }\n\n          break;\n        }\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        brokenForkContext.add(forkContext.head);\n        makeLooped(this, forkContext.head, context.leftSegments);\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error(\"unreachable\");\n    } // Go next.\n\n\n    if (brokenForkContext.empty) {\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    } else {\n      forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    }\n  }\n  /**\r\n   * Makes a code path segment for the test part of a WhileStatement.\r\n   * @param {boolean|undefined} test The test value (only when constant).\r\n   * @returns {void}\r\n   */\n\n\n  makeWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const testSegments = forkContext.makeNext(0, -1); // Update state.\n\n    context.test = test;\n    context.continueDestSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\r\n   * Makes a code path segment for the body part of a WhileStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeWhileBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext;\n\n    if (!choiceContext.processed) {\n      choiceContext.trueForkContext.add(forkContext.head);\n      choiceContext.falseForkContext.add(forkContext.head);\n    } // Update state.\n\n\n    if (context.test !== true) {\n      context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n\n    forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n  }\n  /**\r\n   * Makes a code path segment for the body part of a DoWhileStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeDoWhileBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const bodySegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.entrySegments = bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\r\n   * Makes a code path segment for the test part of a DoWhileStatement.\r\n   * @param {boolean|undefined} test The test value (only when constant).\r\n   * @returns {void}\r\n   */\n\n\n  makeDoWhileTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    context.test = test; // Creates paths of `continue` statements.\n\n    if (!context.continueForkContext.empty) {\n      context.continueForkContext.add(forkContext.head);\n      const testSegments = context.continueForkContext.makeNext(0, -1);\n      forkContext.replaceHead(testSegments);\n    }\n  }\n  /**\r\n   * Makes a code path segment for the test part of a ForStatement.\r\n   * @param {boolean|undefined} test The test value (only when constant).\r\n   * @returns {void}\r\n   */\n\n\n  makeForTest(test) {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const endOfInitSegments = forkContext.head;\n    const testSegments = forkContext.makeNext(-1, -1); // Update state.\n\n    context.test = test;\n    context.endOfInitSegments = endOfInitSegments;\n    context.continueDestSegments = context.testSegments = testSegments;\n    forkContext.replaceHead(testSegments);\n  }\n  /**\r\n   * Makes a code path segment for the update part of a ForStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeForUpdate() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Make the next paths of the test.\n\n    if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    } // Update state.\n\n\n    const updateSegments = forkContext.makeDisconnected(-1, -1);\n    context.continueDestSegments = context.updateSegments = updateSegments;\n    forkContext.replaceHead(updateSegments);\n  }\n  /**\r\n   * Makes a code path segment for the body part of a ForStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeForBody() {\n    const context = this.loopContext;\n    const choiceContext = this.choiceContext;\n    const forkContext = this.forkContext; // Update state.\n\n    if (context.updateSegments) {\n      context.endOfUpdateSegments = forkContext.head; // `update` -> `test`\n\n      if (context.testSegments) {\n        makeLooped(this, context.endOfUpdateSegments, context.testSegments);\n      }\n    } else if (context.testSegments) {\n      finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);\n    } else {\n      context.endOfInitSegments = forkContext.head;\n    }\n\n    let bodySegments = context.endOfTestSegments;\n\n    if (!bodySegments) {\n      /*\r\n       * If there is not the `test` part, the `body` path comes from the\r\n       * `init` part and the `update` part.\r\n       */\n      const prevForkContext = ForkContext.newEmpty(forkContext);\n      prevForkContext.add(context.endOfInitSegments);\n\n      if (context.endOfUpdateSegments) {\n        prevForkContext.add(context.endOfUpdateSegments);\n      }\n\n      bodySegments = prevForkContext.makeNext(0, -1);\n    }\n\n    context.continueDestSegments = context.continueDestSegments || bodySegments;\n    forkContext.replaceHead(bodySegments);\n  }\n  /**\r\n   * Makes a code path segment for the left part of a ForInStatement and a\r\n   * ForOfStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeForInOfLeft() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const leftSegments = forkContext.makeDisconnected(-1, -1); // Update state.\n\n    context.prevSegments = forkContext.head;\n    context.leftSegments = context.continueDestSegments = leftSegments;\n    forkContext.replaceHead(leftSegments);\n  }\n  /**\r\n   * Makes a code path segment for the right part of a ForInStatement and a\r\n   * ForOfStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeForInOfRight() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.prevSegments);\n    const rightSegments = temp.makeNext(-1, -1); // Update state.\n\n    context.endOfLeftSegments = forkContext.head;\n    forkContext.replaceHead(rightSegments);\n  }\n  /**\r\n   * Makes a code path segment for the body part of a ForInStatement and a\r\n   * ForOfStatement.\r\n   * @returns {void}\r\n   */\n\n\n  makeForInOfBody() {\n    const context = this.loopContext;\n    const forkContext = this.forkContext;\n    const temp = ForkContext.newEmpty(forkContext);\n    temp.add(context.endOfLeftSegments);\n    const bodySegments = temp.makeNext(-1, -1); // Make a path: `right` -> `left`.\n\n    makeLooped(this, forkContext.head, context.leftSegments); // Update state.\n\n    context.brokenForkContext.add(forkContext.head);\n    forkContext.replaceHead(bodySegments);\n  } //--------------------------------------------------------------------------\n  // Control Statements\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Creates new context for BreakStatement.\r\n   * @param {boolean} breakable The flag to indicate it can break by\r\n   *      an unlabeled BreakStatement.\r\n   * @param {string|null} label The label of this context.\r\n   * @returns {Object} The new context.\r\n   */\n\n\n  pushBreakContext(breakable, label) {\n    this.breakContext = {\n      upper: this.breakContext,\n      breakable,\n      label,\n      brokenForkContext: ForkContext.newEmpty(this.forkContext)\n    };\n    return this.breakContext;\n  }\n  /**\r\n   * Removes the top item of the break context stack.\r\n   * @returns {Object} The removed context.\r\n   */\n\n\n  popBreakContext() {\n    const context = this.breakContext;\n    const forkContext = this.forkContext;\n    this.breakContext = context.upper; // Process this context here for other than switches and loops.\n\n    if (!context.breakable) {\n      const brokenForkContext = context.brokenForkContext;\n\n      if (!brokenForkContext.empty) {\n        brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n      }\n    }\n\n    return context;\n  }\n  /**\r\n   * Makes a path for a `break` statement.\r\n   *\r\n   * It registers the head segment to a context of `break`.\r\n   * It makes new unreachable segment, then it set the head with the segment.\r\n   * @param {string} label A label of the break statement.\r\n   * @returns {void}\r\n   */\n\n\n  makeBreak(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getBreakContext(this, label);\n    /* istanbul ignore else: foolproof (syntax error) */\n\n    if (context) {\n      context.brokenForkContext.add(forkContext.head);\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\r\n   * Makes a path for a `continue` statement.\r\n   *\r\n   * It makes a looping path.\r\n   * It makes new unreachable segment, then it set the head with the segment.\r\n   * @param {string} label A label of the continue statement.\r\n   * @returns {void}\r\n   */\n\n\n  makeContinue(label) {\n    const forkContext = this.forkContext;\n\n    if (!forkContext.reachable) {\n      return;\n    }\n\n    const context = getContinueContext(this, label);\n    /* istanbul ignore else: foolproof (syntax error) */\n\n    if (context) {\n      if (context.continueDestSegments) {\n        makeLooped(this, forkContext.head, context.continueDestSegments); // If the context is a for-in/of loop, this effects a break also.\n\n        if (context.type === \"ForInStatement\" || context.type === \"ForOfStatement\") {\n          context.brokenForkContext.add(forkContext.head);\n        }\n      } else {\n        context.continueForkContext.add(forkContext.head);\n      }\n    }\n\n    forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n  }\n  /**\r\n   * Makes a path for a `return` statement.\r\n   *\r\n   * It registers the head segment to a context of `return`.\r\n   * It makes new unreachable segment, then it set the head with the segment.\r\n   * @returns {void}\r\n   */\n\n\n  makeReturn() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getReturnContext(this).returnedForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\r\n   * Makes a path for a `throw` statement.\r\n   *\r\n   * It registers the head segment to a context of `throw`.\r\n   * It makes new unreachable segment, then it set the head with the segment.\r\n   * @returns {void}\r\n   */\n\n\n  makeThrow() {\n    const forkContext = this.forkContext;\n\n    if (forkContext.reachable) {\n      getThrowContext(this).thrownForkContext.add(forkContext.head);\n      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    }\n  }\n  /**\r\n   * Makes the final path.\r\n   * @returns {void}\r\n   */\n\n\n  makeFinal() {\n    const segments = this.currentSegments;\n\n    if (segments.length > 0 && segments[0].reachable) {\n      this.returnedForkContext.add(segments);\n    }\n  }\n\n}\n\nmodule.exports = CodePathState;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js"],"names":["CodePathSegment","require","ForkContext","addToReturnedOrThrown","dest","others","all","segments","i","length","segment","push","indexOf","getContinueContext","state","label","loopContext","context","upper","getBreakContext","breakContext","breakable","getReturnContext","tryContext","hasFinalizer","position","getThrowContext","remove","xs","x","splice","removeConnection","prevSegments","nextSegments","prevSegment","nextSegment","allNextSegments","allPrevSegments","makeLooped","unflattenedFromSegments","unflattenedToSegments","fromSegments","flattenUnusedSegments","toSegments","end","Math","min","fromSegment","toSegment","reachable","markPrevSegmentAsLooped","notifyLooped","finalizeTestSegmentsOfFor","choiceContext","head","processed","trueForkContext","add","falseForkContext","qqForkContext","test","brokenForkContext","addAll","endOfTestSegments","makeNext","CodePathState","constructor","idGenerator","onLooped","forkContext","newRoot","switchContext","chainContext","currentSegments","initialSegment","final","finalSegments","returned","returnedForkContext","thrown","thrownForkContext","bind","headSegments","parentForkContext","current","pushForkContext","forkLeavingPath","newEmpty","popForkContext","lastContext","replaceHead","forkPath","forkBypassPath","pushChoiceContext","kind","isForkingAsResult","popChoiceContext","parentContext","clear","Error","prevForkContext","makeLogicalRight","makeIfConsequent","makeIfAlternate","pushChainContext","countChoiceContexts","popChainContext","makeOptionalNode","makeOptionalRight","pushSwitchContext","hasCase","defaultSegments","defaultBodySegments","foundDefault","lastIsDefault","countForks","pushBreakContext","popSwitchContext","popBreakContext","empty","lastSegments","lastCaseSegments","makeSwitchCaseBody","isEmpty","isDefault","pushTryContext","lastOfTryIsReachable","lastOfCatchIsReachable","popTryContext","normalSegments","slice","leavingSegments","makeUnreachable","makeCatchBlock","thrownSegments","makeFinallyBlock","headOfLeavingSegments","count","prevSegsOfLeavingSegment","j","segmentsList","newNext","next","makeFirstThrowablePathInTryBlock","pushLoopContext","type","continueDestSegments","entrySegments","continueForkContext","endOfInitSegments","testSegments","updateSegments","endOfUpdateSegments","leftSegments","endOfLeftSegments","popLoopContext","makeWhileTest","makeWhileBody","makeDoWhileBody","bodySegments","makeDoWhileTest","makeForTest","makeForUpdate","makeDisconnected","makeForBody","makeForInOfLeft","makeForInOfRight","temp","rightSegments","makeForInOfBody","makeBreak","makeContinue","makeReturn","makeThrow","makeFinal","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A class to manage state of generating a code path.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst CodePathSegment = require(\"./code-path-segment\"),\r\n    ForkContext = require(\"./fork-context\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Adds given segments into the `dest` array.\r\n * If the `others` array does not includes the given segments, adds to the `all`\r\n * array as well.\r\n *\r\n * This adds only reachable and used segments.\r\n * @param {CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).\r\n * @param {CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).\r\n * @param {CodePathSegment[]} all The unified destination array (`finalSegments`).\r\n * @param {CodePathSegment[]} segments Segments to add.\r\n * @returns {void}\r\n */\r\nfunction addToReturnedOrThrown(dest, others, all, segments) {\r\n    for (let i = 0; i < segments.length; ++i) {\r\n        const segment = segments[i];\r\n\r\n        dest.push(segment);\r\n        if (others.indexOf(segment) === -1) {\r\n            all.push(segment);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Gets a loop-context for a `continue` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @param {string} label The label of a `continue` statement.\r\n * @returns {LoopContext} A loop-context for a `continue` statement.\r\n */\r\nfunction getContinueContext(state, label) {\r\n    if (!label) {\r\n        return state.loopContext;\r\n    }\r\n\r\n    let context = state.loopContext;\r\n\r\n    while (context) {\r\n        if (context.label === label) {\r\n            return context;\r\n        }\r\n        context = context.upper;\r\n    }\r\n\r\n    /* istanbul ignore next: foolproof (syntax error) */\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets a context for a `break` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @param {string} label The label of a `break` statement.\r\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\r\n */\r\nfunction getBreakContext(state, label) {\r\n    let context = state.breakContext;\r\n\r\n    while (context) {\r\n        if (label ? context.label === label : context.breakable) {\r\n            return context;\r\n        }\r\n        context = context.upper;\r\n    }\r\n\r\n    /* istanbul ignore next: foolproof (syntax error) */\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets a context for a `return` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @returns {TryContext|CodePathState} A context for a `return` statement.\r\n */\r\nfunction getReturnContext(state) {\r\n    let context = state.tryContext;\r\n\r\n    while (context) {\r\n        if (context.hasFinalizer && context.position !== \"finally\") {\r\n            return context;\r\n        }\r\n        context = context.upper;\r\n    }\r\n\r\n    return state;\r\n}\r\n\r\n/**\r\n * Gets a context for a `throw` statement.\r\n * @param {CodePathState} state A state to get.\r\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\r\n */\r\nfunction getThrowContext(state) {\r\n    let context = state.tryContext;\r\n\r\n    while (context) {\r\n        if (context.position === \"try\" ||\r\n            (context.hasFinalizer && context.position === \"catch\")\r\n        ) {\r\n            return context;\r\n        }\r\n        context = context.upper;\r\n    }\r\n\r\n    return state;\r\n}\r\n\r\n/**\r\n * Removes a given element from a given array.\r\n * @param {any[]} xs An array to remove the specific element.\r\n * @param {any} x An element to be removed.\r\n * @returns {void}\r\n */\r\nfunction remove(xs, x) {\r\n    xs.splice(xs.indexOf(x), 1);\r\n}\r\n\r\n/**\r\n * Disconnect given segments.\r\n *\r\n * This is used in a process for switch statements.\r\n * If there is the \"default\" chunk before other cases, the order is different\r\n * between node's and running's.\r\n * @param {CodePathSegment[]} prevSegments Forward segments to disconnect.\r\n * @param {CodePathSegment[]} nextSegments Backward segments to disconnect.\r\n * @returns {void}\r\n */\r\nfunction removeConnection(prevSegments, nextSegments) {\r\n    for (let i = 0; i < prevSegments.length; ++i) {\r\n        const prevSegment = prevSegments[i];\r\n        const nextSegment = nextSegments[i];\r\n\r\n        remove(prevSegment.nextSegments, nextSegment);\r\n        remove(prevSegment.allNextSegments, nextSegment);\r\n        remove(nextSegment.prevSegments, prevSegment);\r\n        remove(nextSegment.allPrevSegments, prevSegment);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates looping path.\r\n * @param {CodePathState} state The instance.\r\n * @param {CodePathSegment[]} unflattenedFromSegments Segments which are source.\r\n * @param {CodePathSegment[]} unflattenedToSegments Segments which are destination.\r\n * @returns {void}\r\n */\r\nfunction makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {\r\n    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);\r\n    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);\r\n\r\n    const end = Math.min(fromSegments.length, toSegments.length);\r\n\r\n    for (let i = 0; i < end; ++i) {\r\n        const fromSegment = fromSegments[i];\r\n        const toSegment = toSegments[i];\r\n\r\n        if (toSegment.reachable) {\r\n            fromSegment.nextSegments.push(toSegment);\r\n        }\r\n        if (fromSegment.reachable) {\r\n            toSegment.prevSegments.push(fromSegment);\r\n        }\r\n        fromSegment.allNextSegments.push(toSegment);\r\n        toSegment.allPrevSegments.push(fromSegment);\r\n\r\n        if (toSegment.allPrevSegments.length >= 2) {\r\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\r\n        }\r\n\r\n        state.notifyLooped(fromSegment, toSegment);\r\n    }\r\n}\r\n\r\n/**\r\n * Finalizes segments of `test` chunk of a ForStatement.\r\n *\r\n * - Adds `false` paths to paths which are leaving from the loop.\r\n * - Sets `true` paths to paths which go to the body.\r\n * @param {LoopContext} context A loop context to modify.\r\n * @param {ChoiceContext} choiceContext A choice context of this loop.\r\n * @param {CodePathSegment[]} head The current head paths.\r\n * @returns {void}\r\n */\r\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\r\n    if (!choiceContext.processed) {\r\n        choiceContext.trueForkContext.add(head);\r\n        choiceContext.falseForkContext.add(head);\r\n        choiceContext.qqForkContext.add(head);\r\n    }\r\n\r\n    if (context.test !== true) {\r\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\r\n    }\r\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * A class which manages state to analyze code paths.\r\n */\r\nclass CodePathState {\r\n\r\n    /**\r\n     * @param {IdGenerator} idGenerator An id generator to generate id for code\r\n     *   path segments.\r\n     * @param {Function} onLooped A callback function to notify looping.\r\n     */\r\n    constructor(idGenerator, onLooped) {\r\n        this.idGenerator = idGenerator;\r\n        this.notifyLooped = onLooped;\r\n        this.forkContext = ForkContext.newRoot(idGenerator);\r\n        this.choiceContext = null;\r\n        this.switchContext = null;\r\n        this.tryContext = null;\r\n        this.loopContext = null;\r\n        this.breakContext = null;\r\n        this.chainContext = null;\r\n\r\n        this.currentSegments = [];\r\n        this.initialSegment = this.forkContext.head[0];\r\n\r\n        // returnedSegments and thrownSegments push elements into finalSegments also.\r\n        const final = this.finalSegments = [];\r\n        const returned = this.returnedForkContext = [];\r\n        const thrown = this.thrownForkContext = [];\r\n\r\n        returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\r\n        thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\r\n    }\r\n\r\n    /**\r\n     * The head segments.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get headSegments() {\r\n        return this.forkContext.head;\r\n    }\r\n\r\n    /**\r\n     * The parent forking context.\r\n     * This is used for the root of new forks.\r\n     * @type {ForkContext}\r\n     */\r\n    get parentForkContext() {\r\n        const current = this.forkContext;\r\n\r\n        return current && current.upper;\r\n    }\r\n\r\n    /**\r\n     * Creates and stacks new forking context.\r\n     * @param {boolean} forkLeavingPath A flag which shows being in a\r\n     *   \"finally\" block.\r\n     * @returns {ForkContext} The created context.\r\n     */\r\n    pushForkContext(forkLeavingPath) {\r\n        this.forkContext = ForkContext.newEmpty(\r\n            this.forkContext,\r\n            forkLeavingPath\r\n        );\r\n\r\n        return this.forkContext;\r\n    }\r\n\r\n    /**\r\n     * Pops and merges the last forking context.\r\n     * @returns {ForkContext} The last context.\r\n     */\r\n    popForkContext() {\r\n        const lastContext = this.forkContext;\r\n\r\n        this.forkContext = lastContext.upper;\r\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\r\n\r\n        return lastContext;\r\n    }\r\n\r\n    /**\r\n     * Creates a new path.\r\n     * @returns {void}\r\n     */\r\n    forkPath() {\r\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\r\n    }\r\n\r\n    /**\r\n     * Creates a bypass path.\r\n     * This is used for such as IfStatement which does not have \"else\" chunk.\r\n     * @returns {void}\r\n     */\r\n    forkBypassPath() {\r\n        this.forkContext.add(this.parentForkContext.head);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // ConditionalExpression, LogicalExpression, IfStatement\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),\r\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\r\n     *\r\n     * LogicalExpressions have cases that it goes different paths between the\r\n     * `true` case and the `false` case.\r\n     *\r\n     * For Example:\r\n     *\r\n     *     if (a || b) {\r\n     *         foo();\r\n     *     } else {\r\n     *         bar();\r\n     *     }\r\n     *\r\n     * In this case, `b` is evaluated always in the code path of the `else`\r\n     * block, but it's not so in the code path of the `if` block.\r\n     * So there are 3 paths.\r\n     *\r\n     *     a -> foo();\r\n     *     a -> b -> foo();\r\n     *     a -> b -> bar();\r\n     * @param {string} kind A kind string.\r\n     *   If the new context is LogicalExpression's or AssignmentExpression's, this is `\"&&\"` or `\"||\"` or `\"??\"`.\r\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\r\n     *   Otherwise, this is `\"loop\"`.\r\n     * @param {boolean} isForkingAsResult A flag that shows that goes different\r\n     *   paths between `true` and `false`.\r\n     * @returns {void}\r\n     */\r\n    pushChoiceContext(kind, isForkingAsResult) {\r\n        this.choiceContext = {\r\n            upper: this.choiceContext,\r\n            kind,\r\n            isForkingAsResult,\r\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\r\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\r\n            qqForkContext: ForkContext.newEmpty(this.forkContext),\r\n            processed: false\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Pops the last choice context and finalizes it.\r\n     * @throws {Error} (Unreachable.)\r\n     * @returns {ChoiceContext} The popped context.\r\n     */\r\n    popChoiceContext() {\r\n        const context = this.choiceContext;\r\n\r\n        this.choiceContext = context.upper;\r\n\r\n        const forkContext = this.forkContext;\r\n        const headSegments = forkContext.head;\r\n\r\n        switch (context.kind) {\r\n            case \"&&\":\r\n            case \"||\":\r\n            case \"??\":\r\n\r\n                /*\r\n                 * If any result were not transferred from child contexts,\r\n                 * this sets the head segments to both cases.\r\n                 * The head segments are the path of the right-hand operand.\r\n                 */\r\n                if (!context.processed) {\r\n                    context.trueForkContext.add(headSegments);\r\n                    context.falseForkContext.add(headSegments);\r\n                    context.qqForkContext.add(headSegments);\r\n                }\r\n\r\n                /*\r\n                 * Transfers results to upper context if this context is in\r\n                 * test chunk.\r\n                 */\r\n                if (context.isForkingAsResult) {\r\n                    const parentContext = this.choiceContext;\r\n\r\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\r\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\r\n                    parentContext.qqForkContext.addAll(context.qqForkContext);\r\n                    parentContext.processed = true;\r\n\r\n                    return context;\r\n                }\r\n\r\n                break;\r\n\r\n            case \"test\":\r\n                if (!context.processed) {\r\n\r\n                    /*\r\n                     * The head segments are the path of the `if` block here.\r\n                     * Updates the `true` path with the end of the `if` block.\r\n                     */\r\n                    context.trueForkContext.clear();\r\n                    context.trueForkContext.add(headSegments);\r\n                } else {\r\n\r\n                    /*\r\n                     * The head segments are the path of the `else` block here.\r\n                     * Updates the `false` path with the end of the `else`\r\n                     * block.\r\n                     */\r\n                    context.falseForkContext.clear();\r\n                    context.falseForkContext.add(headSegments);\r\n                }\r\n\r\n                break;\r\n\r\n            case \"loop\":\r\n\r\n                /*\r\n                 * Loops are addressed in popLoopContext().\r\n                 * This is called from popLoopContext().\r\n                 */\r\n                return context;\r\n\r\n            /* istanbul ignore next */\r\n            default:\r\n                throw new Error(\"unreachable\");\r\n        }\r\n\r\n        // Merges all paths.\r\n        const prevForkContext = context.trueForkContext;\r\n\r\n        prevForkContext.addAll(context.falseForkContext);\r\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\r\n\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment of the right-hand operand of a logical\r\n     * expression.\r\n     * @throws {Error} (Unreachable.)\r\n     * @returns {void}\r\n     */\r\n    makeLogicalRight() {\r\n        const context = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        if (context.processed) {\r\n\r\n            /*\r\n             * This got segments already from the child choice context.\r\n             * Creates the next path from own true/false fork context.\r\n             */\r\n            let prevForkContext;\r\n\r\n            switch (context.kind) {\r\n                case \"&&\": // if true then go to the right-hand side.\r\n                    prevForkContext = context.trueForkContext;\r\n                    break;\r\n                case \"||\": // if false then go to the right-hand side.\r\n                    prevForkContext = context.falseForkContext;\r\n                    break;\r\n                case \"??\": // Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's qqForkContext.\r\n                    prevForkContext = context.qqForkContext;\r\n                    break;\r\n                default:\r\n                    throw new Error(\"unreachable\");\r\n            }\r\n\r\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\r\n            prevForkContext.clear();\r\n            context.processed = false;\r\n        } else {\r\n\r\n            /*\r\n             * This did not get segments from the child choice context.\r\n             * So addresses the head segments.\r\n             * The head segments are the path of the left-hand operand.\r\n             */\r\n            switch (context.kind) {\r\n                case \"&&\": // the false path can short-circuit.\r\n                    context.falseForkContext.add(forkContext.head);\r\n                    break;\r\n                case \"||\": // the true path can short-circuit.\r\n                    context.trueForkContext.add(forkContext.head);\r\n                    break;\r\n                case \"??\": // both can short-circuit.\r\n                    context.trueForkContext.add(forkContext.head);\r\n                    context.falseForkContext.add(forkContext.head);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"unreachable\");\r\n            }\r\n\r\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment of the `if` block.\r\n     * @returns {void}\r\n     */\r\n    makeIfConsequent() {\r\n        const context = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        /*\r\n         * If any result were not transferred from child contexts,\r\n         * this sets the head segments to both cases.\r\n         * The head segments are the path of the test expression.\r\n         */\r\n        if (!context.processed) {\r\n            context.trueForkContext.add(forkContext.head);\r\n            context.falseForkContext.add(forkContext.head);\r\n            context.qqForkContext.add(forkContext.head);\r\n        }\r\n\r\n        context.processed = false;\r\n\r\n        // Creates new path from the `true` case.\r\n        forkContext.replaceHead(\r\n            context.trueForkContext.makeNext(0, -1)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment of the `else` block.\r\n     * @returns {void}\r\n     */\r\n    makeIfAlternate() {\r\n        const context = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        /*\r\n         * The head segments are the path of the `if` block.\r\n         * Updates the `true` path with the end of the `if` block.\r\n         */\r\n        context.trueForkContext.clear();\r\n        context.trueForkContext.add(forkContext.head);\r\n        context.processed = true;\r\n\r\n        // Creates new path from the `false` case.\r\n        forkContext.replaceHead(\r\n            context.falseForkContext.makeNext(0, -1)\r\n        );\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // ChainExpression\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Push a new `ChainExpression` context to the stack.\r\n     * This method is called on entering to each `ChainExpression` node.\r\n     * This context is used to count forking in the optional chain then merge them on the exiting from the `ChainExpression` node.\r\n     * @returns {void}\r\n     */\r\n    pushChainContext() {\r\n        this.chainContext = {\r\n            upper: this.chainContext,\r\n            countChoiceContexts: 0\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Pop a `ChainExpression` context from the stack.\r\n     * This method is called on exiting from each `ChainExpression` node.\r\n     * This merges all forks of the last optional chaining.\r\n     * @returns {void}\r\n     */\r\n    popChainContext() {\r\n        const context = this.chainContext;\r\n\r\n        this.chainContext = context.upper;\r\n\r\n        // pop all choice contexts of this.\r\n        for (let i = context.countChoiceContexts; i > 0; --i) {\r\n            this.popChoiceContext();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a choice context for optional access.\r\n     * This method is called on entering to each `(Call|Member)Expression[optional=true]` node.\r\n     * This creates a choice context as similar to `LogicalExpression[operator=\"??\"]` node.\r\n     * @returns {void}\r\n     */\r\n    makeOptionalNode() {\r\n        if (this.chainContext) {\r\n            this.chainContext.countChoiceContexts += 1;\r\n            this.pushChoiceContext(\"??\", false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a fork.\r\n     * This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.\r\n     * @returns {void}\r\n     */\r\n    makeOptionalRight() {\r\n        if (this.chainContext) {\r\n            this.makeLogicalRight();\r\n        }\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // SwitchStatement\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a context object of SwitchStatement and stacks it.\r\n     * @param {boolean} hasCase `true` if the switch statement has one or more\r\n     *   case parts.\r\n     * @param {string|null} label The label text.\r\n     * @returns {void}\r\n     */\r\n    pushSwitchContext(hasCase, label) {\r\n        this.switchContext = {\r\n            upper: this.switchContext,\r\n            hasCase,\r\n            defaultSegments: null,\r\n            defaultBodySegments: null,\r\n            foundDefault: false,\r\n            lastIsDefault: false,\r\n            countForks: 0\r\n        };\r\n\r\n        this.pushBreakContext(true, label);\r\n    }\r\n\r\n    /**\r\n     * Pops the last context of SwitchStatement and finalizes it.\r\n     *\r\n     * - Disposes all forking stack for `case` and `default`.\r\n     * - Creates the next code path segment from `context.brokenForkContext`.\r\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\r\n     *   to the `default` body.\r\n     * @returns {void}\r\n     */\r\n    popSwitchContext() {\r\n        const context = this.switchContext;\r\n\r\n        this.switchContext = context.upper;\r\n\r\n        const forkContext = this.forkContext;\r\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\r\n\r\n        if (context.countForks === 0) {\r\n\r\n            /*\r\n             * When there is only one `default` chunk and there is one or more\r\n             * `break` statements, even if forks are nothing, it needs to merge\r\n             * those.\r\n             */\r\n            if (!brokenForkContext.empty) {\r\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\r\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        const lastSegments = forkContext.head;\r\n\r\n        this.forkBypassPath();\r\n        const lastCaseSegments = forkContext.head;\r\n\r\n        /*\r\n         * `brokenForkContext` is used to make the next segment.\r\n         * It must add the last segment into `brokenForkContext`.\r\n         */\r\n        brokenForkContext.add(lastSegments);\r\n\r\n        /*\r\n         * A path which is failed in all case test should be connected to path\r\n         * of `default` chunk.\r\n         */\r\n        if (!context.lastIsDefault) {\r\n            if (context.defaultBodySegments) {\r\n\r\n                /*\r\n                 * Remove a link from `default` label to its chunk.\r\n                 * It's false route.\r\n                 */\r\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\r\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\r\n            } else {\r\n\r\n                /*\r\n                 * It handles the last case body as broken if `default` chunk\r\n                 * does not exist.\r\n                 */\r\n                brokenForkContext.add(lastCaseSegments);\r\n            }\r\n        }\r\n\r\n        // Pops the segment context stack until the entry segment.\r\n        for (let i = 0; i < context.countForks; ++i) {\r\n            this.forkContext = this.forkContext.upper;\r\n        }\r\n\r\n        /*\r\n         * Creates a path from all brokenForkContext paths.\r\n         * This is a path after switch statement.\r\n         */\r\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for a `SwitchCase` node.\r\n     * @param {boolean} isEmpty `true` if the body is empty.\r\n     * @param {boolean} isDefault `true` if the body is the default case.\r\n     * @returns {void}\r\n     */\r\n    makeSwitchCaseBody(isEmpty, isDefault) {\r\n        const context = this.switchContext;\r\n\r\n        if (!context.hasCase) {\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * Merge forks.\r\n         * The parent fork context has two segments.\r\n         * Those are from the current case and the body of the previous case.\r\n         */\r\n        const parentForkContext = this.forkContext;\r\n        const forkContext = this.pushForkContext();\r\n\r\n        forkContext.add(parentForkContext.makeNext(0, -1));\r\n\r\n        /*\r\n         * Save `default` chunk info.\r\n         * If the `default` label is not at the last, we must make a path from\r\n         * the last `case` to the `default` chunk.\r\n         */\r\n        if (isDefault) {\r\n            context.defaultSegments = parentForkContext.head;\r\n            if (isEmpty) {\r\n                context.foundDefault = true;\r\n            } else {\r\n                context.defaultBodySegments = forkContext.head;\r\n            }\r\n        } else {\r\n            if (!isEmpty && context.foundDefault) {\r\n                context.foundDefault = false;\r\n                context.defaultBodySegments = forkContext.head;\r\n            }\r\n        }\r\n\r\n        context.lastIsDefault = isDefault;\r\n        context.countForks += 1;\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // TryStatement\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a context object of TryStatement and stacks it.\r\n     * @param {boolean} hasFinalizer `true` if the try statement has a\r\n     *   `finally` block.\r\n     * @returns {void}\r\n     */\r\n    pushTryContext(hasFinalizer) {\r\n        this.tryContext = {\r\n            upper: this.tryContext,\r\n            position: \"try\",\r\n            hasFinalizer,\r\n\r\n            returnedForkContext: hasFinalizer\r\n                ? ForkContext.newEmpty(this.forkContext)\r\n                : null,\r\n\r\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\r\n            lastOfTryIsReachable: false,\r\n            lastOfCatchIsReachable: false\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Pops the last context of TryStatement and finalizes it.\r\n     * @returns {void}\r\n     */\r\n    popTryContext() {\r\n        const context = this.tryContext;\r\n\r\n        this.tryContext = context.upper;\r\n\r\n        if (context.position === \"catch\") {\r\n\r\n            // Merges two paths from the `try` block and `catch` block merely.\r\n            this.popForkContext();\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * The following process is executed only when there is the `finally`\r\n         * block.\r\n         */\r\n\r\n        const returned = context.returnedForkContext;\r\n        const thrown = context.thrownForkContext;\r\n\r\n        if (returned.empty && thrown.empty) {\r\n            return;\r\n        }\r\n\r\n        // Separate head to normal paths and leaving paths.\r\n        const headSegments = this.forkContext.head;\r\n\r\n        this.forkContext = this.forkContext.upper;\r\n        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\r\n        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\r\n\r\n        // Forwards the leaving path to upper contexts.\r\n        if (!returned.empty) {\r\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\r\n        }\r\n        if (!thrown.empty) {\r\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\r\n        }\r\n\r\n        // Sets the normal path as the next.\r\n        this.forkContext.replaceHead(normalSegments);\r\n\r\n        /*\r\n         * If both paths of the `try` block and the `catch` block are\r\n         * unreachable, the next path becomes unreachable as well.\r\n         */\r\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\r\n            this.forkContext.makeUnreachable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for a `catch` block.\r\n     * @returns {void}\r\n     */\r\n    makeCatchBlock() {\r\n        const context = this.tryContext;\r\n        const forkContext = this.forkContext;\r\n        const thrown = context.thrownForkContext;\r\n\r\n        // Update state.\r\n        context.position = \"catch\";\r\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\r\n        context.lastOfTryIsReachable = forkContext.reachable;\r\n\r\n        // Merge thrown paths.\r\n        thrown.add(forkContext.head);\r\n        const thrownSegments = thrown.makeNext(0, -1);\r\n\r\n        // Fork to a bypass and the merged thrown path.\r\n        this.pushForkContext();\r\n        this.forkBypassPath();\r\n        this.forkContext.add(thrownSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for a `finally` block.\r\n     *\r\n     * In the `finally` block, parallel paths are created. The parallel paths\r\n     * are used as leaving-paths. The leaving-paths are paths from `return`\r\n     * statements and `throw` statements in a `try` block or a `catch` block.\r\n     * @returns {void}\r\n     */\r\n    makeFinallyBlock() {\r\n        const context = this.tryContext;\r\n        let forkContext = this.forkContext;\r\n        const returned = context.returnedForkContext;\r\n        const thrown = context.thrownForkContext;\r\n        const headOfLeavingSegments = forkContext.head;\r\n\r\n        // Update state.\r\n        if (context.position === \"catch\") {\r\n\r\n            // Merges two paths from the `try` block and `catch` block.\r\n            this.popForkContext();\r\n            forkContext = this.forkContext;\r\n\r\n            context.lastOfCatchIsReachable = forkContext.reachable;\r\n        } else {\r\n            context.lastOfTryIsReachable = forkContext.reachable;\r\n        }\r\n        context.position = \"finally\";\r\n\r\n        if (returned.empty && thrown.empty) {\r\n\r\n            // This path does not leave.\r\n            return;\r\n        }\r\n\r\n        /*\r\n         * Create a parallel segment from merging returned and thrown.\r\n         * This segment will leave at the end of this finally block.\r\n         */\r\n        const segments = forkContext.makeNext(-1, -1);\r\n\r\n        for (let i = 0; i < forkContext.count; ++i) {\r\n            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\r\n\r\n            for (let j = 0; j < returned.segmentsList.length; ++j) {\r\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\r\n            }\r\n            for (let j = 0; j < thrown.segmentsList.length; ++j) {\r\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\r\n            }\r\n\r\n            segments.push(\r\n                CodePathSegment.newNext(\r\n                    this.idGenerator.next(),\r\n                    prevSegsOfLeavingSegment\r\n                )\r\n            );\r\n        }\r\n\r\n        this.pushForkContext(true);\r\n        this.forkContext.add(segments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment from the first throwable node to the `catch`\r\n     * block or the `finally` block.\r\n     * @returns {void}\r\n     */\r\n    makeFirstThrowablePathInTryBlock() {\r\n        const forkContext = this.forkContext;\r\n\r\n        if (!forkContext.reachable) {\r\n            return;\r\n        }\r\n\r\n        const context = getThrowContext(this);\r\n\r\n        if (context === this ||\r\n            context.position !== \"try\" ||\r\n            !context.thrownForkContext.empty\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        context.thrownForkContext.add(forkContext.head);\r\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Loop Statements\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a context object of a loop statement and stacks it.\r\n     * @param {string} type The type of the node which was triggered. One of\r\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\r\n     *   and `ForStatement`.\r\n     * @param {string|null} label A label of the node which was triggered.\r\n     * @throws {Error} (Unreachable - unknown type.)\r\n     * @returns {void}\r\n     */\r\n    pushLoopContext(type, label) {\r\n        const forkContext = this.forkContext;\r\n        const breakContext = this.pushBreakContext(true, label);\r\n\r\n        switch (type) {\r\n            case \"WhileStatement\":\r\n                this.pushChoiceContext(\"loop\", false);\r\n                this.loopContext = {\r\n                    upper: this.loopContext,\r\n                    type,\r\n                    label,\r\n                    test: void 0,\r\n                    continueDestSegments: null,\r\n                    brokenForkContext: breakContext.brokenForkContext\r\n                };\r\n                break;\r\n\r\n            case \"DoWhileStatement\":\r\n                this.pushChoiceContext(\"loop\", false);\r\n                this.loopContext = {\r\n                    upper: this.loopContext,\r\n                    type,\r\n                    label,\r\n                    test: void 0,\r\n                    entrySegments: null,\r\n                    continueForkContext: ForkContext.newEmpty(forkContext),\r\n                    brokenForkContext: breakContext.brokenForkContext\r\n                };\r\n                break;\r\n\r\n            case \"ForStatement\":\r\n                this.pushChoiceContext(\"loop\", false);\r\n                this.loopContext = {\r\n                    upper: this.loopContext,\r\n                    type,\r\n                    label,\r\n                    test: void 0,\r\n                    endOfInitSegments: null,\r\n                    testSegments: null,\r\n                    endOfTestSegments: null,\r\n                    updateSegments: null,\r\n                    endOfUpdateSegments: null,\r\n                    continueDestSegments: null,\r\n                    brokenForkContext: breakContext.brokenForkContext\r\n                };\r\n                break;\r\n\r\n            case \"ForInStatement\":\r\n            case \"ForOfStatement\":\r\n                this.loopContext = {\r\n                    upper: this.loopContext,\r\n                    type,\r\n                    label,\r\n                    prevSegments: null,\r\n                    leftSegments: null,\r\n                    endOfLeftSegments: null,\r\n                    continueDestSegments: null,\r\n                    brokenForkContext: breakContext.brokenForkContext\r\n                };\r\n                break;\r\n\r\n            /* istanbul ignore next */\r\n            default:\r\n                throw new Error(`unknown type: \"${type}\"`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pops the last context of a loop statement and finalizes it.\r\n     * @throws {Error} (Unreachable - unknown type.)\r\n     * @returns {void}\r\n     */\r\n    popLoopContext() {\r\n        const context = this.loopContext;\r\n\r\n        this.loopContext = context.upper;\r\n\r\n        const forkContext = this.forkContext;\r\n        const brokenForkContext = this.popBreakContext().brokenForkContext;\r\n\r\n        // Creates a looped path.\r\n        switch (context.type) {\r\n            case \"WhileStatement\":\r\n            case \"ForStatement\":\r\n                this.popChoiceContext();\r\n                makeLooped(\r\n                    this,\r\n                    forkContext.head,\r\n                    context.continueDestSegments\r\n                );\r\n                break;\r\n\r\n            case \"DoWhileStatement\": {\r\n                const choiceContext = this.popChoiceContext();\r\n\r\n                if (!choiceContext.processed) {\r\n                    choiceContext.trueForkContext.add(forkContext.head);\r\n                    choiceContext.falseForkContext.add(forkContext.head);\r\n                }\r\n                if (context.test !== true) {\r\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\r\n                }\r\n\r\n                // `true` paths go to looping.\r\n                const segmentsList = choiceContext.trueForkContext.segmentsList;\r\n\r\n                for (let i = 0; i < segmentsList.length; ++i) {\r\n                    makeLooped(\r\n                        this,\r\n                        segmentsList[i],\r\n                        context.entrySegments\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n\r\n            case \"ForInStatement\":\r\n            case \"ForOfStatement\":\r\n                brokenForkContext.add(forkContext.head);\r\n                makeLooped(\r\n                    this,\r\n                    forkContext.head,\r\n                    context.leftSegments\r\n                );\r\n                break;\r\n\r\n            /* istanbul ignore next */\r\n            default:\r\n                throw new Error(\"unreachable\");\r\n        }\r\n\r\n        // Go next.\r\n        if (brokenForkContext.empty) {\r\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\r\n        } else {\r\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the test part of a WhileStatement.\r\n     * @param {boolean|undefined} test The test value (only when constant).\r\n     * @returns {void}\r\n     */\r\n    makeWhileTest(test) {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const testSegments = forkContext.makeNext(0, -1);\r\n\r\n        // Update state.\r\n        context.test = test;\r\n        context.continueDestSegments = testSegments;\r\n        forkContext.replaceHead(testSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the body part of a WhileStatement.\r\n     * @returns {void}\r\n     */\r\n    makeWhileBody() {\r\n        const context = this.loopContext;\r\n        const choiceContext = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        if (!choiceContext.processed) {\r\n            choiceContext.trueForkContext.add(forkContext.head);\r\n            choiceContext.falseForkContext.add(forkContext.head);\r\n        }\r\n\r\n        // Update state.\r\n        if (context.test !== true) {\r\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\r\n        }\r\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the body part of a DoWhileStatement.\r\n     * @returns {void}\r\n     */\r\n    makeDoWhileBody() {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const bodySegments = forkContext.makeNext(-1, -1);\r\n\r\n        // Update state.\r\n        context.entrySegments = bodySegments;\r\n        forkContext.replaceHead(bodySegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the test part of a DoWhileStatement.\r\n     * @param {boolean|undefined} test The test value (only when constant).\r\n     * @returns {void}\r\n     */\r\n    makeDoWhileTest(test) {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        context.test = test;\r\n\r\n        // Creates paths of `continue` statements.\r\n        if (!context.continueForkContext.empty) {\r\n            context.continueForkContext.add(forkContext.head);\r\n            const testSegments = context.continueForkContext.makeNext(0, -1);\r\n\r\n            forkContext.replaceHead(testSegments);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the test part of a ForStatement.\r\n     * @param {boolean|undefined} test The test value (only when constant).\r\n     * @returns {void}\r\n     */\r\n    makeForTest(test) {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const endOfInitSegments = forkContext.head;\r\n        const testSegments = forkContext.makeNext(-1, -1);\r\n\r\n        // Update state.\r\n        context.test = test;\r\n        context.endOfInitSegments = endOfInitSegments;\r\n        context.continueDestSegments = context.testSegments = testSegments;\r\n        forkContext.replaceHead(testSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the update part of a ForStatement.\r\n     * @returns {void}\r\n     */\r\n    makeForUpdate() {\r\n        const context = this.loopContext;\r\n        const choiceContext = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        // Make the next paths of the test.\r\n        if (context.testSegments) {\r\n            finalizeTestSegmentsOfFor(\r\n                context,\r\n                choiceContext,\r\n                forkContext.head\r\n            );\r\n        } else {\r\n            context.endOfInitSegments = forkContext.head;\r\n        }\r\n\r\n        // Update state.\r\n        const updateSegments = forkContext.makeDisconnected(-1, -1);\r\n\r\n        context.continueDestSegments = context.updateSegments = updateSegments;\r\n        forkContext.replaceHead(updateSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the body part of a ForStatement.\r\n     * @returns {void}\r\n     */\r\n    makeForBody() {\r\n        const context = this.loopContext;\r\n        const choiceContext = this.choiceContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        // Update state.\r\n        if (context.updateSegments) {\r\n            context.endOfUpdateSegments = forkContext.head;\r\n\r\n            // `update` -> `test`\r\n            if (context.testSegments) {\r\n                makeLooped(\r\n                    this,\r\n                    context.endOfUpdateSegments,\r\n                    context.testSegments\r\n                );\r\n            }\r\n        } else if (context.testSegments) {\r\n            finalizeTestSegmentsOfFor(\r\n                context,\r\n                choiceContext,\r\n                forkContext.head\r\n            );\r\n        } else {\r\n            context.endOfInitSegments = forkContext.head;\r\n        }\r\n\r\n        let bodySegments = context.endOfTestSegments;\r\n\r\n        if (!bodySegments) {\r\n\r\n            /*\r\n             * If there is not the `test` part, the `body` path comes from the\r\n             * `init` part and the `update` part.\r\n             */\r\n            const prevForkContext = ForkContext.newEmpty(forkContext);\r\n\r\n            prevForkContext.add(context.endOfInitSegments);\r\n            if (context.endOfUpdateSegments) {\r\n                prevForkContext.add(context.endOfUpdateSegments);\r\n            }\r\n\r\n            bodySegments = prevForkContext.makeNext(0, -1);\r\n        }\r\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\r\n        forkContext.replaceHead(bodySegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the left part of a ForInStatement and a\r\n     * ForOfStatement.\r\n     * @returns {void}\r\n     */\r\n    makeForInOfLeft() {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const leftSegments = forkContext.makeDisconnected(-1, -1);\r\n\r\n        // Update state.\r\n        context.prevSegments = forkContext.head;\r\n        context.leftSegments = context.continueDestSegments = leftSegments;\r\n        forkContext.replaceHead(leftSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the right part of a ForInStatement and a\r\n     * ForOfStatement.\r\n     * @returns {void}\r\n     */\r\n    makeForInOfRight() {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const temp = ForkContext.newEmpty(forkContext);\r\n\r\n        temp.add(context.prevSegments);\r\n        const rightSegments = temp.makeNext(-1, -1);\r\n\r\n        // Update state.\r\n        context.endOfLeftSegments = forkContext.head;\r\n        forkContext.replaceHead(rightSegments);\r\n    }\r\n\r\n    /**\r\n     * Makes a code path segment for the body part of a ForInStatement and a\r\n     * ForOfStatement.\r\n     * @returns {void}\r\n     */\r\n    makeForInOfBody() {\r\n        const context = this.loopContext;\r\n        const forkContext = this.forkContext;\r\n        const temp = ForkContext.newEmpty(forkContext);\r\n\r\n        temp.add(context.endOfLeftSegments);\r\n        const bodySegments = temp.makeNext(-1, -1);\r\n\r\n        // Make a path: `right` -> `left`.\r\n        makeLooped(this, forkContext.head, context.leftSegments);\r\n\r\n        // Update state.\r\n        context.brokenForkContext.add(forkContext.head);\r\n        forkContext.replaceHead(bodySegments);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Control Statements\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates new context for BreakStatement.\r\n     * @param {boolean} breakable The flag to indicate it can break by\r\n     *      an unlabeled BreakStatement.\r\n     * @param {string|null} label The label of this context.\r\n     * @returns {Object} The new context.\r\n     */\r\n    pushBreakContext(breakable, label) {\r\n        this.breakContext = {\r\n            upper: this.breakContext,\r\n            breakable,\r\n            label,\r\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\r\n        };\r\n        return this.breakContext;\r\n    }\r\n\r\n    /**\r\n     * Removes the top item of the break context stack.\r\n     * @returns {Object} The removed context.\r\n     */\r\n    popBreakContext() {\r\n        const context = this.breakContext;\r\n        const forkContext = this.forkContext;\r\n\r\n        this.breakContext = context.upper;\r\n\r\n        // Process this context here for other than switches and loops.\r\n        if (!context.breakable) {\r\n            const brokenForkContext = context.brokenForkContext;\r\n\r\n            if (!brokenForkContext.empty) {\r\n                brokenForkContext.add(forkContext.head);\r\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\r\n            }\r\n        }\r\n\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Makes a path for a `break` statement.\r\n     *\r\n     * It registers the head segment to a context of `break`.\r\n     * It makes new unreachable segment, then it set the head with the segment.\r\n     * @param {string} label A label of the break statement.\r\n     * @returns {void}\r\n     */\r\n    makeBreak(label) {\r\n        const forkContext = this.forkContext;\r\n\r\n        if (!forkContext.reachable) {\r\n            return;\r\n        }\r\n\r\n        const context = getBreakContext(this, label);\r\n\r\n        /* istanbul ignore else: foolproof (syntax error) */\r\n        if (context) {\r\n            context.brokenForkContext.add(forkContext.head);\r\n        }\r\n\r\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\r\n    }\r\n\r\n    /**\r\n     * Makes a path for a `continue` statement.\r\n     *\r\n     * It makes a looping path.\r\n     * It makes new unreachable segment, then it set the head with the segment.\r\n     * @param {string} label A label of the continue statement.\r\n     * @returns {void}\r\n     */\r\n    makeContinue(label) {\r\n        const forkContext = this.forkContext;\r\n\r\n        if (!forkContext.reachable) {\r\n            return;\r\n        }\r\n\r\n        const context = getContinueContext(this, label);\r\n\r\n        /* istanbul ignore else: foolproof (syntax error) */\r\n        if (context) {\r\n            if (context.continueDestSegments) {\r\n                makeLooped(this, forkContext.head, context.continueDestSegments);\r\n\r\n                // If the context is a for-in/of loop, this effects a break also.\r\n                if (context.type === \"ForInStatement\" ||\r\n                    context.type === \"ForOfStatement\"\r\n                ) {\r\n                    context.brokenForkContext.add(forkContext.head);\r\n                }\r\n            } else {\r\n                context.continueForkContext.add(forkContext.head);\r\n            }\r\n        }\r\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\r\n    }\r\n\r\n    /**\r\n     * Makes a path for a `return` statement.\r\n     *\r\n     * It registers the head segment to a context of `return`.\r\n     * It makes new unreachable segment, then it set the head with the segment.\r\n     * @returns {void}\r\n     */\r\n    makeReturn() {\r\n        const forkContext = this.forkContext;\r\n\r\n        if (forkContext.reachable) {\r\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\r\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a path for a `throw` statement.\r\n     *\r\n     * It registers the head segment to a context of `throw`.\r\n     * It makes new unreachable segment, then it set the head with the segment.\r\n     * @returns {void}\r\n     */\r\n    makeThrow() {\r\n        const forkContext = this.forkContext;\r\n\r\n        if (forkContext.reachable) {\r\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\r\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes the final path.\r\n     * @returns {void}\r\n     */\r\n    makeFinal() {\r\n        const segments = this.currentSegments;\r\n\r\n        if (segments.length > 0 && segments[0].reachable) {\r\n            this.returnedForkContext.add(segments);\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = CodePathState;\r\n"]},"metadata":{},"sourceType":"script"}