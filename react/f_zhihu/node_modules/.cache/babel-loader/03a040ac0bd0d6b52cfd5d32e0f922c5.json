{"ast":null,"code":"/**\r\n * @fileoverview Rule to require or disallow line breaks inside braces.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n// Schema objects.\n\n\nconst OPTION_VALUE = {\n  oneOf: [{\n    enum: [\"always\", \"never\"]\n  }, {\n    type: \"object\",\n    properties: {\n      multiline: {\n        type: \"boolean\"\n      },\n      minProperties: {\n        type: \"integer\",\n        minimum: 0\n      },\n      consistent: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false,\n    minProperties: 1\n  }]\n};\n/**\r\n * Normalizes a given option value.\r\n * @param {string|Object|undefined} value An option value to parse.\r\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\r\n */\n\nfunction normalizeOptionValue(value) {\n  let multiline = false;\n  let minProperties = Number.POSITIVE_INFINITY;\n  let consistent = false;\n\n  if (value) {\n    if (value === \"always\") {\n      minProperties = 0;\n    } else if (value === \"never\") {\n      minProperties = Number.POSITIVE_INFINITY;\n    } else {\n      multiline = Boolean(value.multiline);\n      minProperties = value.minProperties || Number.POSITIVE_INFINITY;\n      consistent = Boolean(value.consistent);\n    }\n  } else {\n    consistent = true;\n  }\n\n  return {\n    multiline,\n    minProperties,\n    consistent\n  };\n}\n/**\r\n * Checks if a value is an object.\r\n * @param {any} value The value to check\r\n * @returns {boolean} `true` if the value is an object, otherwise `false`\r\n */\n\n\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n/**\r\n * Checks if an option is a node-specific option\r\n * @param {any} option The option to check\r\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\r\n */\n\n\nfunction isNodeSpecificOption(option) {\n  return isObject(option) || typeof option === \"string\";\n}\n/**\r\n * Normalizes a given option value.\r\n * @param {string|Object|undefined} options An option value to parse.\r\n * @returns {{\r\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\r\n * }} Normalized option object.\r\n */\n\n\nfunction normalizeOptions(options) {\n  if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\n    return {\n      ObjectExpression: normalizeOptionValue(options.ObjectExpression),\n      ObjectPattern: normalizeOptionValue(options.ObjectPattern),\n      ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\n      ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\n    };\n  }\n\n  const value = normalizeOptionValue(options);\n  return {\n    ObjectExpression: value,\n    ObjectPattern: value,\n    ImportDeclaration: value,\n    ExportNamedDeclaration: value\n  };\n}\n/**\r\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\r\n * node needs to be checked for missing line breaks\r\n * @param {ASTNode} node Node under inspection\r\n * @param {Object} options option specific to node type\r\n * @param {Token} first First object property\r\n * @param {Token} last Last object property\r\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\r\n */\n\n\nfunction areLineBreaksRequired(node, options, first, last) {\n  let objectProperties;\n\n  if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\n    objectProperties = node.properties;\n  } else {\n    // is ImportDeclaration or ExportNamedDeclaration\n    objectProperties = node.specifiers.filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\n  }\n\n  return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks after opening and before closing braces\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-curly-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [OPTION_VALUE, {\n        type: \"object\",\n        properties: {\n          ObjectExpression: OPTION_VALUE,\n          ObjectPattern: OPTION_VALUE,\n          ImportDeclaration: OPTION_VALUE,\n          ExportDeclaration: OPTION_VALUE\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }],\n    messages: {\n      unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\n      unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\n      expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\n      expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const normalizedOptions = normalizeOptions(context.options[0]);\n    /**\r\n     * Reports a given node if it violated this rule.\r\n     * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\r\n     * @returns {void}\r\n     */\n\n    function check(node) {\n      const options = normalizedOptions[node.type];\n\n      if (node.type === \"ImportDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\") || node.type === \"ExportNamedDeclaration\" && !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\")) {\n        return;\n      }\n\n      const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\n      let closeBrace;\n\n      if (node.typeAnnotation) {\n        closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\n      } else {\n        closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\n      }\n\n      let first = sourceCode.getTokenAfter(openBrace, {\n        includeComments: true\n      });\n      let last = sourceCode.getTokenBefore(closeBrace, {\n        includeComments: true\n      });\n      const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\n      const hasCommentsFirstToken = astUtils.isCommentToken(first);\n      const hasCommentsLastToken = astUtils.isCommentToken(last);\n      /*\r\n       * Use tokens or comments to check multiline or not.\r\n       * But use only tokens to check whether line breaks are needed.\r\n       * This allows:\r\n       *     var obj = { // eslint-disable-line foo\r\n       *         a: 1\r\n       *     }\r\n       */\n\n      first = sourceCode.getTokenAfter(openBrace);\n      last = sourceCode.getTokenBefore(closeBrace);\n\n      if (needsLineBreaks) {\n        if (astUtils.isTokenOnSameLine(openBrace, first)) {\n          context.report({\n            messageId: \"expectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.insertTextAfter(openBrace, \"\\n\");\n            }\n\n          });\n        }\n\n        if (astUtils.isTokenOnSameLine(last, closeBrace)) {\n          context.report({\n            messageId: \"expectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.insertTextBefore(closeBrace, \"\\n\");\n            }\n\n          });\n        }\n      } else {\n        const consistent = options.consistent;\n        const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\n        const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\n\n        if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakAfterOpeningBrace\",\n            node,\n            loc: openBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsFirstToken) {\n                return null;\n              }\n\n              return fixer.removeRange([openBrace.range[1], first.range[0]]);\n            }\n\n          });\n        }\n\n        if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {\n          context.report({\n            messageId: \"unexpectedLinebreakBeforeClosingBrace\",\n            node,\n            loc: closeBrace.loc,\n\n            fix(fixer) {\n              if (hasCommentsLastToken) {\n                return null;\n              }\n\n              return fixer.removeRange([last.range[1], closeBrace.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n\n    return {\n      ObjectExpression: check,\n      ObjectPattern: check,\n      ImportDeclaration: check,\n      ExportNamedDeclaration: check\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/object-curly-newline.js"],"names":["astUtils","require","OPTION_VALUE","oneOf","enum","type","properties","multiline","minProperties","minimum","consistent","additionalProperties","normalizeOptionValue","value","Number","POSITIVE_INFINITY","Boolean","isObject","isNodeSpecificOption","option","normalizeOptions","options","Object","values","some","ObjectExpression","ObjectPattern","ImportDeclaration","ExportNamedDeclaration","ExportDeclaration","areLineBreaksRequired","node","first","last","objectProperties","specifiers","filter","s","length","loc","start","line","end","module","exports","meta","docs","description","recommended","url","fixable","schema","messages","unexpectedLinebreakBeforeClosingBrace","unexpectedLinebreakAfterOpeningBrace","expectedLinebreakBeforeClosingBrace","expectedLinebreakAfterOpeningBrace","create","context","sourceCode","getSourceCode","normalizedOptions","check","specifier","openBrace","getFirstToken","token","closeBrace","typeAnnotation","getTokenBefore","getLastToken","getTokenAfter","includeComments","needsLineBreaks","hasCommentsFirstToken","isCommentToken","hasCommentsLastToken","isTokenOnSameLine","report","messageId","fix","fixer","insertTextAfter","insertTextBefore","hasLineBreakBetweenOpenBraceAndFirst","hasLineBreakBetweenCloseBraceAndLast","removeRange","range"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require or disallow line breaks inside braces.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n// Schema objects.\r\nconst OPTION_VALUE = {\r\n    oneOf: [\r\n        {\r\n            enum: [\"always\", \"never\"]\r\n        },\r\n        {\r\n            type: \"object\",\r\n            properties: {\r\n                multiline: {\r\n                    type: \"boolean\"\r\n                },\r\n                minProperties: {\r\n                    type: \"integer\",\r\n                    minimum: 0\r\n                },\r\n                consistent: {\r\n                    type: \"boolean\"\r\n                }\r\n            },\r\n            additionalProperties: false,\r\n            minProperties: 1\r\n        }\r\n    ]\r\n};\r\n\r\n/**\r\n * Normalizes a given option value.\r\n * @param {string|Object|undefined} value An option value to parse.\r\n * @returns {{multiline: boolean, minProperties: number, consistent: boolean}} Normalized option object.\r\n */\r\nfunction normalizeOptionValue(value) {\r\n    let multiline = false;\r\n    let minProperties = Number.POSITIVE_INFINITY;\r\n    let consistent = false;\r\n\r\n    if (value) {\r\n        if (value === \"always\") {\r\n            minProperties = 0;\r\n        } else if (value === \"never\") {\r\n            minProperties = Number.POSITIVE_INFINITY;\r\n        } else {\r\n            multiline = Boolean(value.multiline);\r\n            minProperties = value.minProperties || Number.POSITIVE_INFINITY;\r\n            consistent = Boolean(value.consistent);\r\n        }\r\n    } else {\r\n        consistent = true;\r\n    }\r\n\r\n    return { multiline, minProperties, consistent };\r\n}\r\n\r\n/**\r\n * Checks if a value is an object.\r\n * @param {any} value The value to check\r\n * @returns {boolean} `true` if the value is an object, otherwise `false`\r\n */\r\nfunction isObject(value) {\r\n    return typeof value === \"object\" && value !== null;\r\n}\r\n\r\n/**\r\n * Checks if an option is a node-specific option\r\n * @param {any} option The option to check\r\n * @returns {boolean} `true` if the option is node-specific, otherwise `false`\r\n */\r\nfunction isNodeSpecificOption(option) {\r\n    return isObject(option) || typeof option === \"string\";\r\n}\r\n\r\n/**\r\n * Normalizes a given option value.\r\n * @param {string|Object|undefined} options An option value to parse.\r\n * @returns {{\r\n *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean},\r\n *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean}\r\n * }} Normalized option object.\r\n */\r\nfunction normalizeOptions(options) {\r\n    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {\r\n        return {\r\n            ObjectExpression: normalizeOptionValue(options.ObjectExpression),\r\n            ObjectPattern: normalizeOptionValue(options.ObjectPattern),\r\n            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),\r\n            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)\r\n        };\r\n    }\r\n\r\n    const value = normalizeOptionValue(options);\r\n\r\n    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value };\r\n}\r\n\r\n/**\r\n * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration\r\n * node needs to be checked for missing line breaks\r\n * @param {ASTNode} node Node under inspection\r\n * @param {Object} options option specific to node type\r\n * @param {Token} first First object property\r\n * @param {Token} last Last object property\r\n * @returns {boolean} `true` if node needs to be checked for missing line breaks\r\n */\r\nfunction areLineBreaksRequired(node, options, first, last) {\r\n    let objectProperties;\r\n\r\n    if (node.type === \"ObjectExpression\" || node.type === \"ObjectPattern\") {\r\n        objectProperties = node.properties;\r\n    } else {\r\n\r\n        // is ImportDeclaration or ExportNamedDeclaration\r\n        objectProperties = node.specifiers\r\n            .filter(s => s.type === \"ImportSpecifier\" || s.type === \"ExportSpecifier\");\r\n    }\r\n\r\n    return objectProperties.length >= options.minProperties ||\r\n        (\r\n            options.multiline &&\r\n            objectProperties.length > 0 &&\r\n            first.loc.start.line !== last.loc.end.line\r\n        );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent line breaks after opening and before closing braces\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/object-curly-newline\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    OPTION_VALUE,\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            ObjectExpression: OPTION_VALUE,\r\n                            ObjectPattern: OPTION_VALUE,\r\n                            ImportDeclaration: OPTION_VALUE,\r\n                            ExportDeclaration: OPTION_VALUE\r\n                        },\r\n                        additionalProperties: false,\r\n                        minProperties: 1\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedLinebreakBeforeClosingBrace: \"Unexpected line break before this closing brace.\",\r\n            unexpectedLinebreakAfterOpeningBrace: \"Unexpected line break after this opening brace.\",\r\n            expectedLinebreakBeforeClosingBrace: \"Expected a line break before this closing brace.\",\r\n            expectedLinebreakAfterOpeningBrace: \"Expected a line break after this opening brace.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const normalizedOptions = normalizeOptions(context.options[0]);\r\n\r\n        /**\r\n         * Reports a given node if it violated this rule.\r\n         * @param {ASTNode} node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.\r\n         * @returns {void}\r\n         */\r\n        function check(node) {\r\n            const options = normalizedOptions[node.type];\r\n\r\n            if (\r\n                (node.type === \"ImportDeclaration\" &&\r\n                    !node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) ||\r\n                (node.type === \"ExportNamedDeclaration\" &&\r\n                    !node.specifiers.some(specifier => specifier.type === \"ExportSpecifier\"))\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            const openBrace = sourceCode.getFirstToken(node, token => token.value === \"{\");\r\n\r\n            let closeBrace;\r\n\r\n            if (node.typeAnnotation) {\r\n                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);\r\n            } else {\r\n                closeBrace = sourceCode.getLastToken(node, token => token.value === \"}\");\r\n            }\r\n\r\n            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true });\r\n            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true });\r\n\r\n            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);\r\n\r\n            const hasCommentsFirstToken = astUtils.isCommentToken(first);\r\n            const hasCommentsLastToken = astUtils.isCommentToken(last);\r\n\r\n            /*\r\n             * Use tokens or comments to check multiline or not.\r\n             * But use only tokens to check whether line breaks are needed.\r\n             * This allows:\r\n             *     var obj = { // eslint-disable-line foo\r\n             *         a: 1\r\n             *     }\r\n             */\r\n            first = sourceCode.getTokenAfter(openBrace);\r\n            last = sourceCode.getTokenBefore(closeBrace);\r\n\r\n            if (needsLineBreaks) {\r\n                if (astUtils.isTokenOnSameLine(openBrace, first)) {\r\n                    context.report({\r\n                        messageId: \"expectedLinebreakAfterOpeningBrace\",\r\n                        node,\r\n                        loc: openBrace.loc,\r\n                        fix(fixer) {\r\n                            if (hasCommentsFirstToken) {\r\n                                return null;\r\n                            }\r\n\r\n                            return fixer.insertTextAfter(openBrace, \"\\n\");\r\n                        }\r\n                    });\r\n                }\r\n                if (astUtils.isTokenOnSameLine(last, closeBrace)) {\r\n                    context.report({\r\n                        messageId: \"expectedLinebreakBeforeClosingBrace\",\r\n                        node,\r\n                        loc: closeBrace.loc,\r\n                        fix(fixer) {\r\n                            if (hasCommentsLastToken) {\r\n                                return null;\r\n                            }\r\n\r\n                            return fixer.insertTextBefore(closeBrace, \"\\n\");\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                const consistent = options.consistent;\r\n                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);\r\n                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);\r\n\r\n                if (\r\n                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||\r\n                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)\r\n                ) {\r\n                    context.report({\r\n                        messageId: \"unexpectedLinebreakAfterOpeningBrace\",\r\n                        node,\r\n                        loc: openBrace.loc,\r\n                        fix(fixer) {\r\n                            if (hasCommentsFirstToken) {\r\n                                return null;\r\n                            }\r\n\r\n                            return fixer.removeRange([\r\n                                openBrace.range[1],\r\n                                first.range[0]\r\n                            ]);\r\n                        }\r\n                    });\r\n                }\r\n                if (\r\n                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||\r\n                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)\r\n                ) {\r\n                    context.report({\r\n                        messageId: \"unexpectedLinebreakBeforeClosingBrace\",\r\n                        node,\r\n                        loc: closeBrace.loc,\r\n                        fix(fixer) {\r\n                            if (hasCommentsLastToken) {\r\n                                return null;\r\n                            }\r\n\r\n                            return fixer.removeRange([\r\n                                last.range[1],\r\n                                closeBrace.range[0]\r\n                            ]);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            ObjectExpression: check,\r\n            ObjectPattern: check,\r\n            ImportDeclaration: check,\r\n            ExportNamedDeclaration: check\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}