{"ast":null,"code":"/**\r\n * @fileoverview Rule to require object keys to be sorted\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      naturalCompare = require(\"natural-compare\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets the property name of the given `Property` node.\r\n *\r\n * - If the property's key is an `Identifier` node, this returns the key's name\r\n *   whether it's a computed property or not.\r\n * - If the property has a static name, this returns the static name.\r\n * - Otherwise, this returns null.\r\n * @param {ASTNode} node The `Property` node to get.\r\n * @returns {string|null} The property name or null.\r\n * @private\r\n */\n\n\nfunction getPropertyName(node) {\n  const staticName = astUtils.getStaticPropertyName(node);\n\n  if (staticName !== null) {\n    return staticName;\n  }\n\n  return node.key.name || null;\n}\n/**\r\n * Functions which check that the given 2 names are in specific order.\r\n *\r\n * Postfix `I` is meant insensitive.\r\n * Postfix `N` is meant natural.\r\n * @private\r\n */\n\n\nconst isValidOrders = {\n  asc(a, b) {\n    return a <= b;\n  },\n\n  ascI(a, b) {\n    return a.toLowerCase() <= b.toLowerCase();\n  },\n\n  ascN(a, b) {\n    return naturalCompare(a, b) <= 0;\n  },\n\n  ascIN(a, b) {\n    return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\n  },\n\n  desc(a, b) {\n    return isValidOrders.asc(b, a);\n  },\n\n  descI(a, b) {\n    return isValidOrders.ascI(b, a);\n  },\n\n  descN(a, b) {\n    return isValidOrders.ascN(b, a);\n  },\n\n  descIN(a, b) {\n    return isValidOrders.ascIN(b, a);\n  }\n\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require object keys to be sorted\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-keys\"\n    },\n    schema: [{\n      enum: [\"asc\", \"desc\"]\n    }, {\n      type: \"object\",\n      properties: {\n        caseSensitive: {\n          type: \"boolean\",\n          default: true\n        },\n        natural: {\n          type: \"boolean\",\n          default: false\n        },\n        minKeys: {\n          type: \"integer\",\n          minimum: 2,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\n    }\n  },\n\n  create(context) {\n    // Parse options.\n    const order = context.options[0] || \"asc\";\n    const options = context.options[1];\n    const insensitive = options && options.caseSensitive === false;\n    const natural = options && options.natural;\n    const minKeys = options && options.minKeys;\n    const isValidOrder = isValidOrders[order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")]; // The stack to save the previous property's name for each object literals.\n\n    let stack = null;\n    return {\n      ObjectExpression(node) {\n        stack = {\n          upper: stack,\n          prevName: null,\n          numKeys: node.properties.length\n        };\n      },\n\n      \"ObjectExpression:exit\"() {\n        stack = stack.upper;\n      },\n\n      SpreadElement(node) {\n        if (node.parent.type === \"ObjectExpression\") {\n          stack.prevName = null;\n        }\n      },\n\n      Property(node) {\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        }\n\n        const prevName = stack.prevName;\n        const numKeys = stack.numKeys;\n        const thisName = getPropertyName(node);\n\n        if (thisName !== null) {\n          stack.prevName = thisName;\n        }\n\n        if (prevName === null || thisName === null || numKeys < minKeys) {\n          return;\n        }\n\n        if (!isValidOrder(prevName, thisName)) {\n          context.report({\n            node,\n            loc: node.key.loc,\n            messageId: \"sortKeys\",\n            data: {\n              thisName,\n              prevName,\n              order,\n              insensitive: insensitive ? \"insensitive \" : \"\",\n              natural: natural ? \"natural \" : \"\"\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/sort-keys.js"],"names":["astUtils","require","naturalCompare","getPropertyName","node","staticName","getStaticPropertyName","key","name","isValidOrders","asc","a","b","ascI","toLowerCase","ascN","ascIN","desc","descI","descN","descIN","module","exports","meta","type","docs","description","recommended","url","schema","enum","properties","caseSensitive","default","natural","minKeys","minimum","additionalProperties","messages","sortKeys","create","context","order","options","insensitive","isValidOrder","stack","ObjectExpression","upper","prevName","numKeys","length","SpreadElement","parent","Property","thisName","report","loc","messageId","data"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require object keys to be sorted\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\"),\r\n    naturalCompare = require(\"natural-compare\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets the property name of the given `Property` node.\r\n *\r\n * - If the property's key is an `Identifier` node, this returns the key's name\r\n *   whether it's a computed property or not.\r\n * - If the property has a static name, this returns the static name.\r\n * - Otherwise, this returns null.\r\n * @param {ASTNode} node The `Property` node to get.\r\n * @returns {string|null} The property name or null.\r\n * @private\r\n */\r\nfunction getPropertyName(node) {\r\n    const staticName = astUtils.getStaticPropertyName(node);\r\n\r\n    if (staticName !== null) {\r\n        return staticName;\r\n    }\r\n\r\n    return node.key.name || null;\r\n}\r\n\r\n/**\r\n * Functions which check that the given 2 names are in specific order.\r\n *\r\n * Postfix `I` is meant insensitive.\r\n * Postfix `N` is meant natural.\r\n * @private\r\n */\r\nconst isValidOrders = {\r\n    asc(a, b) {\r\n        return a <= b;\r\n    },\r\n    ascI(a, b) {\r\n        return a.toLowerCase() <= b.toLowerCase();\r\n    },\r\n    ascN(a, b) {\r\n        return naturalCompare(a, b) <= 0;\r\n    },\r\n    ascIN(a, b) {\r\n        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;\r\n    },\r\n    desc(a, b) {\r\n        return isValidOrders.asc(b, a);\r\n    },\r\n    descI(a, b) {\r\n        return isValidOrders.ascI(b, a);\r\n    },\r\n    descN(a, b) {\r\n        return isValidOrders.ascN(b, a);\r\n    },\r\n    descIN(a, b) {\r\n        return isValidOrders.ascIN(b, a);\r\n    }\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require object keys to be sorted\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/sort-keys\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"asc\", \"desc\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    caseSensitive: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    natural: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    minKeys: {\r\n                        type: \"integer\",\r\n                        minimum: 2,\r\n                        default: 2\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            sortKeys: \"Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        // Parse options.\r\n        const order = context.options[0] || \"asc\";\r\n        const options = context.options[1];\r\n        const insensitive = options && options.caseSensitive === false;\r\n        const natural = options && options.natural;\r\n        const minKeys = options && options.minKeys;\r\n        const isValidOrder = isValidOrders[\r\n            order + (insensitive ? \"I\" : \"\") + (natural ? \"N\" : \"\")\r\n        ];\r\n\r\n        // The stack to save the previous property's name for each object literals.\r\n        let stack = null;\r\n\r\n        return {\r\n            ObjectExpression(node) {\r\n                stack = {\r\n                    upper: stack,\r\n                    prevName: null,\r\n                    numKeys: node.properties.length\r\n                };\r\n            },\r\n\r\n            \"ObjectExpression:exit\"() {\r\n                stack = stack.upper;\r\n            },\r\n\r\n            SpreadElement(node) {\r\n                if (node.parent.type === \"ObjectExpression\") {\r\n                    stack.prevName = null;\r\n                }\r\n            },\r\n\r\n            Property(node) {\r\n                if (node.parent.type === \"ObjectPattern\") {\r\n                    return;\r\n                }\r\n\r\n                const prevName = stack.prevName;\r\n                const numKeys = stack.numKeys;\r\n                const thisName = getPropertyName(node);\r\n\r\n                if (thisName !== null) {\r\n                    stack.prevName = thisName;\r\n                }\r\n\r\n                if (prevName === null || thisName === null || numKeys < minKeys) {\r\n                    return;\r\n                }\r\n\r\n                if (!isValidOrder(prevName, thisName)) {\r\n                    context.report({\r\n                        node,\r\n                        loc: node.key.loc,\r\n                        messageId: \"sortKeys\",\r\n                        data: {\r\n                            thisName,\r\n                            prevName,\r\n                            order,\r\n                            insensitive: insensitive ? \"insensitive \" : \"\",\r\n                            natural: natural ? \"natural \" : \"\"\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}