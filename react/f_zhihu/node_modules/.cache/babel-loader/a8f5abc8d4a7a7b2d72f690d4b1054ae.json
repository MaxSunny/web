{"ast":null,"code":"/**\r\n * @fileoverview Disallows or enforces spaces inside of parentheses.\r\n * @author Jonathan Rajavuori\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing inside parentheses\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-in-parens\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingOpeningSpace: \"There must be a space after this paren.\",\n      missingClosingSpace: \"There must be a space before this paren.\",\n      rejectedOpeningSpace: \"There should be no space after this paren.\",\n      rejectedClosingSpace: \"There should be no space before this paren.\"\n    }\n  },\n\n  create(context) {\n    const ALWAYS = context.options[0] === \"always\",\n          exceptionsArrayOptions = context.options[1] && context.options[1].exceptions || [],\n          options = {};\n    let exceptions;\n\n    if (exceptionsArrayOptions.length) {\n      options.braceException = exceptionsArrayOptions.includes(\"{}\");\n      options.bracketException = exceptionsArrayOptions.includes(\"[]\");\n      options.parenException = exceptionsArrayOptions.includes(\"()\");\n      options.empty = exceptionsArrayOptions.includes(\"empty\");\n    }\n    /**\r\n     * Produces an object with the opener and closer exception values\r\n     * @returns {Object} `openers` and `closers` exception values\r\n     * @private\r\n     */\n\n\n    function getExceptions() {\n      const openers = [],\n            closers = [];\n\n      if (options.braceException) {\n        openers.push(\"{\");\n        closers.push(\"}\");\n      }\n\n      if (options.bracketException) {\n        openers.push(\"[\");\n        closers.push(\"]\");\n      }\n\n      if (options.parenException) {\n        openers.push(\"(\");\n        closers.push(\")\");\n      }\n\n      if (options.empty) {\n        openers.push(\")\");\n        closers.push(\"(\");\n      }\n\n      return {\n        openers,\n        closers\n      };\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Determines if a token is one of the exceptions for the opener paren\r\n     * @param {Object} token The token to check\r\n     * @returns {boolean} True if the token is one of the exceptions for the opener paren\r\n     */\n\n    function isOpenerException(token) {\n      return exceptions.openers.includes(token.value);\n    }\n    /**\r\n     * Determines if a token is one of the exceptions for the closer paren\r\n     * @param {Object} token The token to check\r\n     * @returns {boolean} True if the token is one of the exceptions for the closer paren\r\n     */\n\n\n    function isCloserException(token) {\n      return exceptions.closers.includes(token.value);\n    }\n    /**\r\n     * Determines if an opening paren is immediately followed by a required space\r\n     * @param {Object} openingParenToken The paren token\r\n     * @param {Object} tokenAfterOpeningParen The token after it\r\n     * @returns {boolean} True if the opening paren is missing a required space\r\n     */\n\n\n    function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return isOpenerException(tokenAfterOpeningParen);\n    }\n    /**\r\n     * Determines if an opening paren is immediately followed by a disallowed space\r\n     * @param {Object} openingParenToken The paren token\r\n     * @param {Object} tokenAfterOpeningParen The token after it\r\n     * @returns {boolean} True if the opening paren has a disallowed space\r\n     */\n\n\n    function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\n      if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (tokenAfterOpeningParen.type === \"Line\") {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isOpenerException(tokenAfterOpeningParen);\n      }\n\n      return !isOpenerException(tokenAfterOpeningParen);\n    }\n    /**\r\n     * Determines if a closing paren is immediately preceded by a required space\r\n     * @param {Object} tokenBeforeClosingParen The token before the paren\r\n     * @param {Object} closingParenToken The paren token\r\n     * @returns {boolean} True if the closing paren is missing a required space\r\n     */\n\n\n    function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return !isCloserException(tokenBeforeClosingParen);\n      }\n\n      return isCloserException(tokenBeforeClosingParen);\n    }\n    /**\r\n     * Determines if a closer paren is immediately preceded by a disallowed space\r\n     * @param {Object} tokenBeforeClosingParen The token before the paren\r\n     * @param {Object} closingParenToken The paren token\r\n     * @returns {boolean} True if the closing paren has a disallowed space\r\n     */\n\n\n    function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\n      if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\n        return false;\n      }\n\n      if (ALWAYS) {\n        return isCloserException(tokenBeforeClosingParen);\n      }\n\n      return !isCloserException(tokenBeforeClosingParen);\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkParenSpaces(node) {\n        exceptions = getExceptions();\n        const tokens = sourceCode.tokensAndComments;\n        tokens.forEach((token, i) => {\n          const prevToken = tokens[i - 1];\n          const nextToken = tokens[i + 1]; // if token is not an opening or closing paren token, do nothing\n\n          if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\n            return;\n          } // if token is an opening paren and is not followed by a required space\n\n\n          if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextAfter(token, \" \");\n              }\n\n            });\n          } // if token is an opening paren and is followed by a disallowed space\n\n\n          if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\n            context.report({\n              node,\n              loc: {\n                start: token.loc.end,\n                end: nextToken.loc.start\n              },\n              messageId: \"rejectedOpeningSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([token.range[1], nextToken.range[0]]);\n              }\n\n            });\n          } // if token is a closing paren and is not preceded by a required space\n\n\n          if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: token.loc,\n              messageId: \"missingClosingSpace\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          } // if token is a closing paren and is preceded by a disallowed space\n\n\n          if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\n            context.report({\n              node,\n              loc: {\n                start: prevToken.loc.end,\n                end: token.loc.start\n              },\n              messageId: \"rejectedClosingSpace\",\n\n              fix(fixer) {\n                return fixer.removeRange([prevToken.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        });\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/space-in-parens.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","properties","exceptions","items","uniqueItems","additionalProperties","messages","missingOpeningSpace","missingClosingSpace","rejectedOpeningSpace","rejectedClosingSpace","create","context","ALWAYS","options","exceptionsArrayOptions","length","braceException","includes","bracketException","parenException","empty","getExceptions","openers","closers","push","sourceCode","getSourceCode","isOpenerException","token","value","isCloserException","openerMissingSpace","openingParenToken","tokenAfterOpeningParen","isSpaceBetweenTokens","isClosingParenToken","openerRejectsSpace","isTokenOnSameLine","closerMissingSpace","tokenBeforeClosingParen","closingParenToken","isOpeningParenToken","closerRejectsSpace","Program","checkParenSpaces","node","tokens","tokensAndComments","forEach","i","prevToken","nextToken","report","loc","messageId","fix","fixer","insertTextAfter","start","end","removeRange","range","insertTextBefore"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallows or enforces spaces inside of parentheses.\r\n * @author Jonathan Rajavuori\r\n */\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing inside parentheses\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/space-in-parens\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptions: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            enum: [\"{}\", \"[]\", \"()\", \"empty\"]\r\n                        },\r\n                        uniqueItems: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            missingOpeningSpace: \"There must be a space after this paren.\",\r\n            missingClosingSpace: \"There must be a space before this paren.\",\r\n            rejectedOpeningSpace: \"There should be no space after this paren.\",\r\n            rejectedClosingSpace: \"There should be no space before this paren.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const ALWAYS = context.options[0] === \"always\",\r\n            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],\r\n            options = {};\r\n\r\n        let exceptions;\r\n\r\n        if (exceptionsArrayOptions.length) {\r\n            options.braceException = exceptionsArrayOptions.includes(\"{}\");\r\n            options.bracketException = exceptionsArrayOptions.includes(\"[]\");\r\n            options.parenException = exceptionsArrayOptions.includes(\"()\");\r\n            options.empty = exceptionsArrayOptions.includes(\"empty\");\r\n        }\r\n\r\n        /**\r\n         * Produces an object with the opener and closer exception values\r\n         * @returns {Object} `openers` and `closers` exception values\r\n         * @private\r\n         */\r\n        function getExceptions() {\r\n            const openers = [],\r\n                closers = [];\r\n\r\n            if (options.braceException) {\r\n                openers.push(\"{\");\r\n                closers.push(\"}\");\r\n            }\r\n\r\n            if (options.bracketException) {\r\n                openers.push(\"[\");\r\n                closers.push(\"]\");\r\n            }\r\n\r\n            if (options.parenException) {\r\n                openers.push(\"(\");\r\n                closers.push(\")\");\r\n            }\r\n\r\n            if (options.empty) {\r\n                openers.push(\")\");\r\n                closers.push(\"(\");\r\n            }\r\n\r\n            return {\r\n                openers,\r\n                closers\r\n            };\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Determines if a token is one of the exceptions for the opener paren\r\n         * @param {Object} token The token to check\r\n         * @returns {boolean} True if the token is one of the exceptions for the opener paren\r\n         */\r\n        function isOpenerException(token) {\r\n            return exceptions.openers.includes(token.value);\r\n        }\r\n\r\n        /**\r\n         * Determines if a token is one of the exceptions for the closer paren\r\n         * @param {Object} token The token to check\r\n         * @returns {boolean} True if the token is one of the exceptions for the closer paren\r\n         */\r\n        function isCloserException(token) {\r\n            return exceptions.closers.includes(token.value);\r\n        }\r\n\r\n        /**\r\n         * Determines if an opening paren is immediately followed by a required space\r\n         * @param {Object} openingParenToken The paren token\r\n         * @param {Object} tokenAfterOpeningParen The token after it\r\n         * @returns {boolean} True if the opening paren is missing a required space\r\n         */\r\n        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {\r\n            if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\r\n                return false;\r\n            }\r\n\r\n            if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {\r\n                return false;\r\n            }\r\n\r\n            if (ALWAYS) {\r\n                return !isOpenerException(tokenAfterOpeningParen);\r\n            }\r\n            return isOpenerException(tokenAfterOpeningParen);\r\n        }\r\n\r\n        /**\r\n         * Determines if an opening paren is immediately followed by a disallowed space\r\n         * @param {Object} openingParenToken The paren token\r\n         * @param {Object} tokenAfterOpeningParen The token after it\r\n         * @returns {boolean} True if the opening paren has a disallowed space\r\n         */\r\n        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {\r\n            if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {\r\n                return false;\r\n            }\r\n\r\n            if (tokenAfterOpeningParen.type === \"Line\") {\r\n                return false;\r\n            }\r\n\r\n            if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {\r\n                return false;\r\n            }\r\n\r\n            if (ALWAYS) {\r\n                return isOpenerException(tokenAfterOpeningParen);\r\n            }\r\n            return !isOpenerException(tokenAfterOpeningParen);\r\n        }\r\n\r\n        /**\r\n         * Determines if a closing paren is immediately preceded by a required space\r\n         * @param {Object} tokenBeforeClosingParen The token before the paren\r\n         * @param {Object} closingParenToken The paren token\r\n         * @returns {boolean} True if the closing paren is missing a required space\r\n         */\r\n        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {\r\n            if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\r\n                return false;\r\n            }\r\n\r\n            if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {\r\n                return false;\r\n            }\r\n\r\n            if (ALWAYS) {\r\n                return !isCloserException(tokenBeforeClosingParen);\r\n            }\r\n            return isCloserException(tokenBeforeClosingParen);\r\n        }\r\n\r\n        /**\r\n         * Determines if a closer paren is immediately preceded by a disallowed space\r\n         * @param {Object} tokenBeforeClosingParen The token before the paren\r\n         * @param {Object} closingParenToken The paren token\r\n         * @returns {boolean} True if the closing paren has a disallowed space\r\n         */\r\n        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {\r\n            if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {\r\n                return false;\r\n            }\r\n\r\n            if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {\r\n                return false;\r\n            }\r\n\r\n            if (ALWAYS) {\r\n                return isCloserException(tokenBeforeClosingParen);\r\n            }\r\n            return !isCloserException(tokenBeforeClosingParen);\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: function checkParenSpaces(node) {\r\n                exceptions = getExceptions();\r\n                const tokens = sourceCode.tokensAndComments;\r\n\r\n                tokens.forEach((token, i) => {\r\n                    const prevToken = tokens[i - 1];\r\n                    const nextToken = tokens[i + 1];\r\n\r\n                    // if token is not an opening or closing paren token, do nothing\r\n                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {\r\n                        return;\r\n                    }\r\n\r\n                    // if token is an opening paren and is not followed by a required space\r\n                    if (token.value === \"(\" && openerMissingSpace(token, nextToken)) {\r\n                        context.report({\r\n                            node,\r\n                            loc: token.loc,\r\n                            messageId: \"missingOpeningSpace\",\r\n                            fix(fixer) {\r\n                                return fixer.insertTextAfter(token, \" \");\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // if token is an opening paren and is followed by a disallowed space\r\n                    if (token.value === \"(\" && openerRejectsSpace(token, nextToken)) {\r\n                        context.report({\r\n                            node,\r\n                            loc: { start: token.loc.end, end: nextToken.loc.start },\r\n                            messageId: \"rejectedOpeningSpace\",\r\n                            fix(fixer) {\r\n                                return fixer.removeRange([token.range[1], nextToken.range[0]]);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // if token is a closing paren and is not preceded by a required space\r\n                    if (token.value === \")\" && closerMissingSpace(prevToken, token)) {\r\n                        context.report({\r\n                            node,\r\n                            loc: token.loc,\r\n                            messageId: \"missingClosingSpace\",\r\n                            fix(fixer) {\r\n                                return fixer.insertTextBefore(token, \" \");\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // if token is a closing paren and is preceded by a disallowed space\r\n                    if (token.value === \")\" && closerRejectsSpace(prevToken, token)) {\r\n                        context.report({\r\n                            node,\r\n                            loc: { start: prevToken.loc.end, end: token.loc.start },\r\n                            messageId: \"rejectedClosingSpace\",\r\n                            fix(fixer) {\r\n                                return fixer.removeRange([prevToken.range[1], token.range[0]]);\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}