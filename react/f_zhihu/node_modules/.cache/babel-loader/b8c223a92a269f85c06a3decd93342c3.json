{"ast":null,"code":"/**\r\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require variables within the same declaration block to be sorted\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-vars\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\n    }\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          sourceCode = context.getSourceCode();\n    return {\n      VariableDeclaration(node) {\n        const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\n        const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\n        const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\n        let fixed = false;\n        idDeclarations.slice(1).reduce((memo, decl) => {\n          const lastVariableName = getSortableName(memo),\n                currentVariableName = getSortableName(decl);\n\n          if (currentVariableName < lastVariableName) {\n            context.report({\n              node: decl,\n              messageId: \"sortVars\",\n\n              fix(fixer) {\n                if (unfixable || fixed) {\n                  return null;\n                }\n\n                return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations // Clone the idDeclarations array to avoid mutating it\n                .slice() // Sort the array into the desired order\n                .sort((declA, declB) => {\n                  const aName = getSortableName(declA);\n                  const bName = getSortableName(declB);\n                  return aName > bName ? 1 : -1;\n                }) // Build a string out of the sorted list of identifier declarations and the text between the originals\n                .reduce((sourceText, identifier, index) => {\n                  const textAfterIdentifier = index === idDeclarations.length - 1 ? \"\" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\n                }, \"\"));\n              }\n\n            });\n            fixed = true;\n            return memo;\n          }\n\n          return decl;\n        }, idDeclarations[0]);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/sort-vars.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","ignoreCase","default","additionalProperties","fixable","messages","sortVars","create","context","configuration","options","sourceCode","getSourceCode","VariableDeclaration","node","idDeclarations","declarations","filter","decl","id","getSortableName","name","toLowerCase","unfixable","some","init","fixed","slice","reduce","memo","lastVariableName","currentVariableName","report","messageId","fix","fixer","replaceTextRange","range","length","sort","declA","declB","aName","bName","sourceText","identifier","index","textAfterIdentifier","getText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require sorting of variables within a single Variable Declaration block\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require variables within the same declaration block to be sorted\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/sort-vars\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignoreCase: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            sortVars: \"Variables within the same declaration block should be sorted alphabetically.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const configuration = context.options[0] || {},\r\n            ignoreCase = configuration.ignoreCase || false,\r\n            sourceCode = context.getSourceCode();\r\n\r\n        return {\r\n            VariableDeclaration(node) {\r\n                const idDeclarations = node.declarations.filter(decl => decl.id.type === \"Identifier\");\r\n                const getSortableName = ignoreCase ? decl => decl.id.name.toLowerCase() : decl => decl.id.name;\r\n                const unfixable = idDeclarations.some(decl => decl.init !== null && decl.init.type !== \"Literal\");\r\n                let fixed = false;\r\n\r\n                idDeclarations.slice(1).reduce((memo, decl) => {\r\n                    const lastVariableName = getSortableName(memo),\r\n                        currentVariableName = getSortableName(decl);\r\n\r\n                    if (currentVariableName < lastVariableName) {\r\n                        context.report({\r\n                            node: decl,\r\n                            messageId: \"sortVars\",\r\n                            fix(fixer) {\r\n                                if (unfixable || fixed) {\r\n                                    return null;\r\n                                }\r\n                                return fixer.replaceTextRange(\r\n                                    [idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]],\r\n                                    idDeclarations\r\n\r\n                                        // Clone the idDeclarations array to avoid mutating it\r\n                                        .slice()\r\n\r\n                                        // Sort the array into the desired order\r\n                                        .sort((declA, declB) => {\r\n                                            const aName = getSortableName(declA);\r\n                                            const bName = getSortableName(declB);\r\n\r\n                                            return aName > bName ? 1 : -1;\r\n                                        })\r\n\r\n                                        // Build a string out of the sorted list of identifier declarations and the text between the originals\r\n                                        .reduce((sourceText, identifier, index) => {\r\n                                            const textAfterIdentifier = index === idDeclarations.length - 1\r\n                                                ? \"\"\r\n                                                : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);\r\n\r\n                                            return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;\r\n                                        }, \"\")\r\n\r\n                                );\r\n                            }\r\n                        });\r\n                        fixed = true;\r\n                        return memo;\r\n                    }\r\n                    return decl;\r\n\r\n                }, idDeclarations[0]);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}