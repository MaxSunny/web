{"ast":null,"code":"/**\r\n * @fileoverview Require or disallow newline at the end of files\r\n * @author Nodeca Team <https://github.com/nodeca>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow newline at the end of files\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eol-last\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"unix\", \"windows\"]\n    }],\n    messages: {\n      missing: \"Newline required at end of file but not found.\",\n      unexpected: \"Newline not allowed at end of file.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n    return {\n      Program: function checkBadEOF(node) {\n        const sourceCode = context.getSourceCode(),\n              src = sourceCode.getText(),\n              lastLine = sourceCode.lines[sourceCode.lines.length - 1],\n              location = {\n          column: lastLine.length,\n          line: sourceCode.lines.length\n        },\n              LF = \"\\n\",\n              CRLF = `\\r${LF}`,\n              endsWithNewline = src.endsWith(LF);\n        /*\r\n         * Empty source is always valid: No content in file so we don't\r\n         * need to lint for a newline on the last line of content.\r\n         */\n\n        if (!src.length) {\n          return;\n        }\n\n        let mode = context.options[0] || \"always\",\n            appendCRLF = false;\n\n        if (mode === \"unix\") {\n          // `\"unix\"` should behave exactly as `\"always\"`\n          mode = \"always\";\n        }\n\n        if (mode === \"windows\") {\n          // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\n          mode = \"always\";\n          appendCRLF = true;\n        }\n\n        if (mode === \"always\" && !endsWithNewline) {\n          // File is not newline-terminated, but should be\n          context.report({\n            node,\n            loc: location,\n            messageId: \"missing\",\n\n            fix(fixer) {\n              return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\n            }\n\n          });\n        } else if (mode === \"never\" && endsWithNewline) {\n          const secondLastLine = sourceCode.lines[sourceCode.lines.length - 2]; // File is newline-terminated, but shouldn't be\n\n          context.report({\n            node,\n            loc: {\n              start: {\n                line: sourceCode.lines.length - 1,\n                column: secondLastLine.length\n              },\n              end: {\n                line: sourceCode.lines.length,\n                column: 0\n              }\n            },\n            messageId: \"unexpected\",\n\n            fix(fixer) {\n              const finalEOLs = /(?:\\r?\\n)+$/u,\n                    match = finalEOLs.exec(sourceCode.text),\n                    start = match.index,\n                    end = sourceCode.text.length;\n              return fixer.replaceTextRange([start, end], \"\");\n            }\n\n          });\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/eol-last.js"],"names":["module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","messages","missing","unexpected","create","context","Program","checkBadEOF","node","sourceCode","getSourceCode","src","getText","lastLine","lines","length","location","column","line","LF","CRLF","endsWithNewline","endsWith","mode","options","appendCRLF","report","loc","messageId","fix","fixer","insertTextAfterRange","secondLastLine","start","end","finalEOLs","match","exec","text","index","replaceTextRange"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Require or disallow newline at the end of files\r\n * @author Nodeca Team <https://github.com/nodeca>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow newline at the end of files\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/eol-last\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\", \"unix\", \"windows\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            missing: \"Newline required at end of file but not found.\",\r\n            unexpected: \"Newline not allowed at end of file.\"\r\n        }\r\n    },\r\n    create(context) {\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: function checkBadEOF(node) {\r\n                const sourceCode = context.getSourceCode(),\r\n                    src = sourceCode.getText(),\r\n                    lastLine = sourceCode.lines[sourceCode.lines.length - 1],\r\n                    location = {\r\n                        column: lastLine.length,\r\n                        line: sourceCode.lines.length\r\n                    },\r\n                    LF = \"\\n\",\r\n                    CRLF = `\\r${LF}`,\r\n                    endsWithNewline = src.endsWith(LF);\r\n\r\n                /*\r\n                 * Empty source is always valid: No content in file so we don't\r\n                 * need to lint for a newline on the last line of content.\r\n                 */\r\n                if (!src.length) {\r\n                    return;\r\n                }\r\n\r\n                let mode = context.options[0] || \"always\",\r\n                    appendCRLF = false;\r\n\r\n                if (mode === \"unix\") {\r\n\r\n                    // `\"unix\"` should behave exactly as `\"always\"`\r\n                    mode = \"always\";\r\n                }\r\n                if (mode === \"windows\") {\r\n\r\n                    // `\"windows\"` should behave exactly as `\"always\"`, but append CRLF in the fixer for backwards compatibility\r\n                    mode = \"always\";\r\n                    appendCRLF = true;\r\n                }\r\n                if (mode === \"always\" && !endsWithNewline) {\r\n\r\n                    // File is not newline-terminated, but should be\r\n                    context.report({\r\n                        node,\r\n                        loc: location,\r\n                        messageId: \"missing\",\r\n                        fix(fixer) {\r\n                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);\r\n                        }\r\n                    });\r\n                } else if (mode === \"never\" && endsWithNewline) {\r\n\r\n                    const secondLastLine = sourceCode.lines[sourceCode.lines.length - 2];\r\n\r\n                    // File is newline-terminated, but shouldn't be\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            start: { line: sourceCode.lines.length - 1, column: secondLastLine.length },\r\n                            end: { line: sourceCode.lines.length, column: 0 }\r\n                        },\r\n                        messageId: \"unexpected\",\r\n                        fix(fixer) {\r\n                            const finalEOLs = /(?:\\r?\\n)+$/u,\r\n                                match = finalEOLs.exec(sourceCode.text),\r\n                                start = match.index,\r\n                                end = sourceCode.text.length;\r\n\r\n                            return fixer.replaceTextRange([start, end], \"\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}