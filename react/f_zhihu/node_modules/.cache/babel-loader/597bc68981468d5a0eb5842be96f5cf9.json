{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow unsafe optional chaining\r\n * @author Yeon JuAn\r\n */\n\"use strict\";\n\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\n/**\r\n * Checks whether a node is a destructuring pattern or not\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\r\n */\n\nfunction isDestructuringPattern(node) {\n  return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowArithmeticOperators: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\n      unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const disallowArithmeticOperators = options.disallowArithmeticOperators || false;\n    /**\r\n     * Reports unsafe usage of optional chaining\r\n     * @param {ASTNode} node node to report\r\n     * @returns {void}\r\n     */\n\n    function reportUnsafeUsage(node) {\n      context.report({\n        messageId: \"unsafeOptionalChain\",\n        node\n      });\n    }\n    /**\r\n     * Reports unsafe arithmetic operation on optional chaining\r\n     * @param {ASTNode} node node to report\r\n     * @returns {void}\r\n     */\n\n\n    function reportUnsafeArithmetic(node) {\n      context.report({\n        messageId: \"unsafeArithmetic\",\n        node\n      });\n    }\n    /**\r\n     * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\r\n     * @param {ASTNode} [node] node to check\r\n     * @param {Function} reportFunc report function\r\n     * @returns {void}\r\n     */\n\n\n    function checkUndefinedShortCircuit(node, reportFunc) {\n      if (!node) {\n        return;\n      }\n\n      switch (node.type) {\n        case \"LogicalExpression\":\n          if (node.operator === \"||\" || node.operator === \"??\") {\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          } else if (node.operator === \"&&\") {\n            checkUndefinedShortCircuit(node.left, reportFunc);\n            checkUndefinedShortCircuit(node.right, reportFunc);\n          }\n\n          break;\n\n        case \"SequenceExpression\":\n          checkUndefinedShortCircuit(node.expressions[node.expressions.length - 1], reportFunc);\n          break;\n\n        case \"ConditionalExpression\":\n          checkUndefinedShortCircuit(node.consequent, reportFunc);\n          checkUndefinedShortCircuit(node.alternate, reportFunc);\n          break;\n\n        case \"AwaitExpression\":\n          checkUndefinedShortCircuit(node.argument, reportFunc);\n          break;\n\n        case \"ChainExpression\":\n          reportFunc(node);\n          break;\n\n        default:\n          break;\n      }\n    }\n    /**\r\n     * Checks unsafe usage of optional chaining\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkUnsafeUsage(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeUsage);\n    }\n    /**\r\n     * Checks unsafe arithmetic operations on optional chaining\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkUnsafeArithmetic(node) {\n      checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\n    }\n\n    return {\n      \"AssignmentExpression, AssignmentPattern\"(node) {\n        if (isDestructuringPattern(node.left)) {\n          checkUnsafeUsage(node.right);\n        }\n      },\n\n      \"ClassDeclaration, ClassExpression\"(node) {\n        checkUnsafeUsage(node.superClass);\n      },\n\n      CallExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.callee);\n        }\n      },\n\n      NewExpression(node) {\n        checkUnsafeUsage(node.callee);\n      },\n\n      VariableDeclarator(node) {\n        if (isDestructuringPattern(node.id)) {\n          checkUnsafeUsage(node.init);\n        }\n      },\n\n      MemberExpression(node) {\n        if (!node.optional) {\n          checkUnsafeUsage(node.object);\n        }\n      },\n\n      TaggedTemplateExpression(node) {\n        checkUnsafeUsage(node.tag);\n      },\n\n      ForOfStatement(node) {\n        checkUnsafeUsage(node.right);\n      },\n\n      SpreadElement(node) {\n        if (node.parent && node.parent.type !== \"ObjectExpression\") {\n          checkUnsafeUsage(node.argument);\n        }\n      },\n\n      BinaryExpression(node) {\n        if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\n          checkUnsafeUsage(node.right);\n        }\n\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n          checkUnsafeArithmetic(node.left);\n        }\n      },\n\n      WithStatement(node) {\n        checkUnsafeUsage(node.object);\n      },\n\n      UnaryExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.argument);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {\n          checkUnsafeArithmetic(node.right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js"],"names":["UNSAFE_ARITHMETIC_OPERATORS","Set","UNSAFE_ASSIGNMENT_OPERATORS","UNSAFE_RELATIONAL_OPERATORS","isDestructuringPattern","node","type","module","exports","meta","docs","description","recommended","url","schema","properties","disallowArithmeticOperators","default","additionalProperties","fixable","messages","unsafeOptionalChain","unsafeArithmetic","create","context","options","reportUnsafeUsage","report","messageId","reportUnsafeArithmetic","checkUndefinedShortCircuit","reportFunc","operator","right","left","expressions","length","consequent","alternate","argument","checkUnsafeUsage","checkUnsafeArithmetic","superClass","CallExpression","optional","callee","NewExpression","VariableDeclarator","id","init","MemberExpression","object","TaggedTemplateExpression","tag","ForOfStatement","SpreadElement","parent","BinaryExpression","has","WithStatement","UnaryExpression","AssignmentExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow unsafe optional chaining\r\n * @author Yeon JuAn\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst UNSAFE_ARITHMETIC_OPERATORS = new Set([\"+\", \"-\", \"/\", \"*\", \"%\", \"**\"]);\r\nconst UNSAFE_ASSIGNMENT_OPERATORS = new Set([\"+=\", \"-=\", \"/=\", \"*=\", \"%=\", \"**=\"]);\r\nconst UNSAFE_RELATIONAL_OPERATORS = new Set([\"in\", \"instanceof\"]);\r\n\r\n/**\r\n * Checks whether a node is a destructuring pattern or not\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} `true` if a node is a destructuring pattern, otherwise `false`\r\n */\r\nfunction isDestructuringPattern(node) {\r\n    return node.type === \"ObjectPattern\" || node.type === \"ArrayPattern\";\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow use of optional chaining in contexts where the `undefined` value is not allowed\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-unsafe-optional-chaining\"\r\n        },\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                disallowArithmeticOperators: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n        fixable: null,\r\n        messages: {\r\n            unsafeOptionalChain: \"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.\",\r\n            unsafeArithmetic: \"Unsafe arithmetic operation on optional chaining. It can result in NaN.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const disallowArithmeticOperators = (options.disallowArithmeticOperators) || false;\r\n\r\n        /**\r\n         * Reports unsafe usage of optional chaining\r\n         * @param {ASTNode} node node to report\r\n         * @returns {void}\r\n         */\r\n        function reportUnsafeUsage(node) {\r\n            context.report({\r\n                messageId: \"unsafeOptionalChain\",\r\n                node\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports unsafe arithmetic operation on optional chaining\r\n         * @param {ASTNode} node node to report\r\n         * @returns {void}\r\n         */\r\n        function reportUnsafeArithmetic(node) {\r\n            context.report({\r\n                messageId: \"unsafeArithmetic\",\r\n                node\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks and reports if a node can short-circuit with `undefined` by optional chaining.\r\n         * @param {ASTNode} [node] node to check\r\n         * @param {Function} reportFunc report function\r\n         * @returns {void}\r\n         */\r\n        function checkUndefinedShortCircuit(node, reportFunc) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            switch (node.type) {\r\n                case \"LogicalExpression\":\r\n                    if (node.operator === \"||\" || node.operator === \"??\") {\r\n                        checkUndefinedShortCircuit(node.right, reportFunc);\r\n                    } else if (node.operator === \"&&\") {\r\n                        checkUndefinedShortCircuit(node.left, reportFunc);\r\n                        checkUndefinedShortCircuit(node.right, reportFunc);\r\n                    }\r\n                    break;\r\n                case \"SequenceExpression\":\r\n                    checkUndefinedShortCircuit(\r\n                        node.expressions[node.expressions.length - 1],\r\n                        reportFunc\r\n                    );\r\n                    break;\r\n                case \"ConditionalExpression\":\r\n                    checkUndefinedShortCircuit(node.consequent, reportFunc);\r\n                    checkUndefinedShortCircuit(node.alternate, reportFunc);\r\n                    break;\r\n                case \"AwaitExpression\":\r\n                    checkUndefinedShortCircuit(node.argument, reportFunc);\r\n                    break;\r\n                case \"ChainExpression\":\r\n                    reportFunc(node);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks unsafe usage of optional chaining\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkUnsafeUsage(node) {\r\n            checkUndefinedShortCircuit(node, reportUnsafeUsage);\r\n        }\r\n\r\n        /**\r\n         * Checks unsafe arithmetic operations on optional chaining\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkUnsafeArithmetic(node) {\r\n            checkUndefinedShortCircuit(node, reportUnsafeArithmetic);\r\n        }\r\n\r\n        return {\r\n            \"AssignmentExpression, AssignmentPattern\"(node) {\r\n                if (isDestructuringPattern(node.left)) {\r\n                    checkUnsafeUsage(node.right);\r\n                }\r\n            },\r\n            \"ClassDeclaration, ClassExpression\"(node) {\r\n                checkUnsafeUsage(node.superClass);\r\n            },\r\n            CallExpression(node) {\r\n                if (!node.optional) {\r\n                    checkUnsafeUsage(node.callee);\r\n                }\r\n            },\r\n            NewExpression(node) {\r\n                checkUnsafeUsage(node.callee);\r\n            },\r\n            VariableDeclarator(node) {\r\n                if (isDestructuringPattern(node.id)) {\r\n                    checkUnsafeUsage(node.init);\r\n                }\r\n            },\r\n            MemberExpression(node) {\r\n                if (!node.optional) {\r\n                    checkUnsafeUsage(node.object);\r\n                }\r\n            },\r\n            TaggedTemplateExpression(node) {\r\n                checkUnsafeUsage(node.tag);\r\n            },\r\n            ForOfStatement(node) {\r\n                checkUnsafeUsage(node.right);\r\n            },\r\n            SpreadElement(node) {\r\n                if (node.parent && node.parent.type !== \"ObjectExpression\") {\r\n                    checkUnsafeUsage(node.argument);\r\n                }\r\n            },\r\n            BinaryExpression(node) {\r\n                if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {\r\n                    checkUnsafeUsage(node.right);\r\n                }\r\n                if (\r\n                    disallowArithmeticOperators &&\r\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\r\n                ) {\r\n                    checkUnsafeArithmetic(node.right);\r\n                    checkUnsafeArithmetic(node.left);\r\n                }\r\n            },\r\n            WithStatement(node) {\r\n                checkUnsafeUsage(node.object);\r\n            },\r\n            UnaryExpression(node) {\r\n                if (\r\n                    disallowArithmeticOperators &&\r\n                    UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)\r\n                ) {\r\n                    checkUnsafeArithmetic(node.argument);\r\n                }\r\n            },\r\n            AssignmentExpression(node) {\r\n                if (\r\n                    disallowArithmeticOperators &&\r\n                    UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)\r\n                ) {\r\n                    checkUnsafeArithmetic(node.right);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}