{"ast":null,"code":"/**\r\n * @fileoverview Utility for caching lint results.\r\n * @author Kevin Partington\r\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst fs = require(\"fs\");\n\nconst fileEntryCache = require(\"file-entry-cache\");\n\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\n\nconst pkg = require(\"../../package.json\");\n\nconst hash = require(\"./hash\");\n\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\"); //-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n\nconst configHashCache = new WeakMap();\nconst nodeVersion = process && process.version;\nconst validCacheStrategies = [\"metadata\", \"content\"];\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies.map(strategy => `\"${strategy}\"`).join(\", \")}`;\n/**\r\n * Tests whether a provided cacheStrategy is valid\r\n * @param {string} cacheStrategy The cache strategy to use\r\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\r\n */\n\nfunction isValidCacheStrategy(cacheStrategy) {\n  return validCacheStrategies.indexOf(cacheStrategy) !== -1;\n}\n/**\r\n * Calculates the hash of the config\r\n * @param {ConfigArray} config The config.\r\n * @returns {string} The hash of the config\r\n */\n\n\nfunction hashOfConfigFor(config) {\n  if (!configHashCache.has(config)) {\n    configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\n  }\n\n  return configHashCache.get(config);\n} //-----------------------------------------------------------------------------\n// Public Interface\n//-----------------------------------------------------------------------------\n\n/**\r\n * Lint result cache. This wraps around the file-entry-cache module,\r\n * transparently removing properties that are difficult or expensive to\r\n * serialize and adding them back in on retrieval.\r\n */\n\n\nclass LintResultCache {\n  /**\r\n   * Creates a new LintResultCache instance.\r\n   * @param {string} cacheFileLocation The cache file location.\r\n   * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\r\n   */\n  constructor(cacheFileLocation, cacheStrategy) {\n    assert(cacheFileLocation, \"Cache file location is required\");\n    assert(cacheStrategy, \"Cache strategy is required\");\n    assert(isValidCacheStrategy(cacheStrategy), invalidCacheStrategyErrorMessage);\n    debug(`Caching results to ${cacheFileLocation}`);\n    const useChecksum = cacheStrategy === \"content\";\n    debug(`Using \"${cacheStrategy}\" strategy to detect changes`);\n    this.fileEntryCache = fileEntryCache.create(cacheFileLocation, void 0, useChecksum);\n    this.cacheFileLocation = cacheFileLocation;\n  }\n  /**\r\n   * Retrieve cached lint results for a given file path, if present in the\r\n   * cache. If the file is present and has not been changed, rebuild any\r\n   * missing result information.\r\n   * @param {string} filePath The file for which to retrieve lint results.\r\n   * @param {ConfigArray} config The config of the file.\r\n   * @returns {Object|null} The rebuilt lint results, or null if the file is\r\n   *   changed or not in the filesystem.\r\n   */\n\n\n  getCachedLintResults(filePath, config) {\n    /*\r\n     * Cached lint results are valid if and only if:\r\n     * 1. The file is present in the filesystem\r\n     * 2. The file has not changed since the time it was previously linted\r\n     * 3. The ESLint configuration has not changed since the time the file\r\n     *    was previously linted\r\n     * If any of these are not true, we will not reuse the lint results.\r\n     */\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n    const hashOfConfig = hashOfConfigFor(config);\n    const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;\n\n    if (fileDescriptor.notFound) {\n      debug(`File not found on the file system: ${filePath}`);\n      return null;\n    }\n\n    if (changed) {\n      debug(`Cache entry not found or no longer valid: ${filePath}`);\n      return null;\n    } // If source is present but null, need to reread the file from the filesystem.\n\n\n    if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {\n      debug(`Rereading cached result source from filesystem: ${filePath}`);\n      fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\n    }\n\n    return fileDescriptor.meta.results;\n  }\n  /**\r\n   * Set the cached lint results for a given file path, after removing any\r\n   * information that will be both unnecessary and difficult to serialize.\r\n   * Avoids caching results with an \"output\" property (meaning fixes were\r\n   * applied), to prevent potentially incorrect results if fixes are not\r\n   * written to disk.\r\n   * @param {string} filePath The file for which to set lint results.\r\n   * @param {ConfigArray} config The config of the file.\r\n   * @param {Object} result The lint result to be set for the file.\r\n   * @returns {void}\r\n   */\n\n\n  setCachedLintResults(filePath, config, result) {\n    if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\n      return;\n    }\n\n    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\n\n    if (fileDescriptor && !fileDescriptor.notFound) {\n      debug(`Updating cached result: ${filePath}`); // Serialize the result, except that we want to remove the file source if present.\n\n      const resultToSerialize = Object.assign({}, result);\n      /*\r\n       * Set result.source to null.\r\n       * In `getCachedLintResults`, if source is explicitly null, we will\r\n       * read the file from the filesystem to set the value again.\r\n       */\n\n      if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\n        resultToSerialize.source = null;\n      }\n\n      fileDescriptor.meta.results = resultToSerialize;\n      fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\n    }\n  }\n  /**\r\n   * Persists the in-memory cache to disk.\r\n   * @returns {void}\r\n   */\n\n\n  reconcile() {\n    debug(`Persisting cached results: ${this.cacheFileLocation}`);\n    this.fileEntryCache.reconcile();\n  }\n\n}\n\nmodule.exports = LintResultCache;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/cli-engine/lint-result-cache.js"],"names":["assert","require","fs","fileEntryCache","stringify","pkg","hash","debug","configHashCache","WeakMap","nodeVersion","process","version","validCacheStrategies","invalidCacheStrategyErrorMessage","map","strategy","join","isValidCacheStrategy","cacheStrategy","indexOf","hashOfConfigFor","config","has","set","get","LintResultCache","constructor","cacheFileLocation","useChecksum","create","getCachedLintResults","filePath","fileDescriptor","getFileDescriptor","hashOfConfig","changed","meta","notFound","results","source","readFileSync","setCachedLintResults","result","Object","prototype","hasOwnProperty","call","resultToSerialize","assign","reconcile","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Utility for caching lint results.\r\n * @author Kevin Partington\r\n */\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Requirements\r\n//-----------------------------------------------------------------------------\r\n\r\nconst assert = require(\"assert\");\r\nconst fs = require(\"fs\");\r\nconst fileEntryCache = require(\"file-entry-cache\");\r\nconst stringify = require(\"json-stable-stringify-without-jsonify\");\r\nconst pkg = require(\"../../package.json\");\r\nconst hash = require(\"./hash\");\r\n\r\nconst debug = require(\"debug\")(\"eslint:lint-result-cache\");\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nconst configHashCache = new WeakMap();\r\nconst nodeVersion = process && process.version;\r\n\r\nconst validCacheStrategies = [\"metadata\", \"content\"];\r\nconst invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies\r\n    .map(strategy => `\"${strategy}\"`)\r\n    .join(\", \")}`;\r\n\r\n/**\r\n * Tests whether a provided cacheStrategy is valid\r\n * @param {string} cacheStrategy The cache strategy to use\r\n * @returns {boolean} true if `cacheStrategy` is one of `validCacheStrategies`; false otherwise\r\n */\r\nfunction isValidCacheStrategy(cacheStrategy) {\r\n    return (\r\n        validCacheStrategies.indexOf(cacheStrategy) !== -1\r\n    );\r\n}\r\n\r\n/**\r\n * Calculates the hash of the config\r\n * @param {ConfigArray} config The config.\r\n * @returns {string} The hash of the config\r\n */\r\nfunction hashOfConfigFor(config) {\r\n    if (!configHashCache.has(config)) {\r\n        configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));\r\n    }\r\n\r\n    return configHashCache.get(config);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Public Interface\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Lint result cache. This wraps around the file-entry-cache module,\r\n * transparently removing properties that are difficult or expensive to\r\n * serialize and adding them back in on retrieval.\r\n */\r\nclass LintResultCache {\r\n\r\n    /**\r\n     * Creates a new LintResultCache instance.\r\n     * @param {string} cacheFileLocation The cache file location.\r\n     * @param {\"metadata\" | \"content\"} cacheStrategy The cache strategy to use.\r\n     */\r\n    constructor(cacheFileLocation, cacheStrategy) {\r\n        assert(cacheFileLocation, \"Cache file location is required\");\r\n        assert(cacheStrategy, \"Cache strategy is required\");\r\n        assert(\r\n            isValidCacheStrategy(cacheStrategy),\r\n            invalidCacheStrategyErrorMessage\r\n        );\r\n\r\n        debug(`Caching results to ${cacheFileLocation}`);\r\n\r\n        const useChecksum = cacheStrategy === \"content\";\r\n\r\n        debug(\r\n            `Using \"${cacheStrategy}\" strategy to detect changes`\r\n        );\r\n\r\n        this.fileEntryCache = fileEntryCache.create(\r\n            cacheFileLocation,\r\n            void 0,\r\n            useChecksum\r\n        );\r\n        this.cacheFileLocation = cacheFileLocation;\r\n    }\r\n\r\n    /**\r\n     * Retrieve cached lint results for a given file path, if present in the\r\n     * cache. If the file is present and has not been changed, rebuild any\r\n     * missing result information.\r\n     * @param {string} filePath The file for which to retrieve lint results.\r\n     * @param {ConfigArray} config The config of the file.\r\n     * @returns {Object|null} The rebuilt lint results, or null if the file is\r\n     *   changed or not in the filesystem.\r\n     */\r\n    getCachedLintResults(filePath, config) {\r\n\r\n        /*\r\n         * Cached lint results are valid if and only if:\r\n         * 1. The file is present in the filesystem\r\n         * 2. The file has not changed since the time it was previously linted\r\n         * 3. The ESLint configuration has not changed since the time the file\r\n         *    was previously linted\r\n         * If any of these are not true, we will not reuse the lint results.\r\n         */\r\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\r\n        const hashOfConfig = hashOfConfigFor(config);\r\n        const changed =\r\n            fileDescriptor.changed ||\r\n            fileDescriptor.meta.hashOfConfig !== hashOfConfig;\r\n\r\n        if (fileDescriptor.notFound) {\r\n            debug(`File not found on the file system: ${filePath}`);\r\n            return null;\r\n        }\r\n\r\n        if (changed) {\r\n            debug(`Cache entry not found or no longer valid: ${filePath}`);\r\n            return null;\r\n        }\r\n\r\n        // If source is present but null, need to reread the file from the filesystem.\r\n        if (\r\n            fileDescriptor.meta.results &&\r\n            fileDescriptor.meta.results.source === null\r\n        ) {\r\n            debug(`Rereading cached result source from filesystem: ${filePath}`);\r\n            fileDescriptor.meta.results.source = fs.readFileSync(filePath, \"utf-8\");\r\n        }\r\n\r\n        return fileDescriptor.meta.results;\r\n    }\r\n\r\n    /**\r\n     * Set the cached lint results for a given file path, after removing any\r\n     * information that will be both unnecessary and difficult to serialize.\r\n     * Avoids caching results with an \"output\" property (meaning fixes were\r\n     * applied), to prevent potentially incorrect results if fixes are not\r\n     * written to disk.\r\n     * @param {string} filePath The file for which to set lint results.\r\n     * @param {ConfigArray} config The config of the file.\r\n     * @param {Object} result The lint result to be set for the file.\r\n     * @returns {void}\r\n     */\r\n    setCachedLintResults(filePath, config, result) {\r\n        if (result && Object.prototype.hasOwnProperty.call(result, \"output\")) {\r\n            return;\r\n        }\r\n\r\n        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);\r\n\r\n        if (fileDescriptor && !fileDescriptor.notFound) {\r\n            debug(`Updating cached result: ${filePath}`);\r\n\r\n            // Serialize the result, except that we want to remove the file source if present.\r\n            const resultToSerialize = Object.assign({}, result);\r\n\r\n            /*\r\n             * Set result.source to null.\r\n             * In `getCachedLintResults`, if source is explicitly null, we will\r\n             * read the file from the filesystem to set the value again.\r\n             */\r\n            if (Object.prototype.hasOwnProperty.call(resultToSerialize, \"source\")) {\r\n                resultToSerialize.source = null;\r\n            }\r\n\r\n            fileDescriptor.meta.results = resultToSerialize;\r\n            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Persists the in-memory cache to disk.\r\n     * @returns {void}\r\n     */\r\n    reconcile() {\r\n        debug(`Persisting cached results: ${this.cacheFileLocation}`);\r\n        this.fileEntryCache.reconcile();\r\n    }\r\n}\r\n\r\nmodule.exports = LintResultCache;\r\n"]},"metadata":{},"sourceType":"script"}