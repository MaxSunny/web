{"ast":null,"code":"/**\r\n * @fileoverview This option sets a specific tab width for your code\r\n *\r\n * This rule has been ported and modified from nodeca.\r\n * @author Vitaly Puzrin\r\n * @author Gyandeep Singh\r\n * @deprecated in ESLint v4.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent-legacy\"\n    },\n    deprecated: true,\n    replacedBy: [\"indent\"],\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0\n        },\n        VariableDeclarator: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            type: \"object\",\n            properties: {\n              var: {\n                type: \"integer\",\n                minimum: 0\n              },\n              let: {\n                type: \"integer\",\n                minimum: 0\n              },\n              const: {\n                type: \"integer\",\n                minimum: 0\n              }\n            }\n          }]\n        },\n        outerIIFEBody: {\n          type: \"integer\",\n          minimum: 0\n        },\n        MemberExpression: {\n          type: \"integer\",\n          minimum: 0\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            },\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          }\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            parameters: {\n              oneOf: [{\n                type: \"integer\",\n                minimum: 0\n              }, {\n                enum: [\"first\"]\n              }]\n            }\n          }\n        },\n        ArrayExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        },\n        ObjectExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"first\"]\n          }]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\n\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: null,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      ArrayExpression: 1,\n      ObjectExpression: 1\n    };\n    const sourceCode = context.getSourceCode();\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else\n        /* istanbul ignore else : this will be caught by options validation */\n        if (typeof context.options[0] === \"number\") {\n          indentSize = context.options[0];\n          indentType = \"space\";\n        }\n\n      if (context.options[1]) {\n        const opts = context.options[1];\n        options.SwitchCase = opts.SwitchCase || 0;\n        const variableDeclaratorRules = opts.VariableDeclarator;\n\n        if (typeof variableDeclaratorRules === \"number\") {\n          options.VariableDeclarator = {\n            var: variableDeclaratorRules,\n            let: variableDeclaratorRules,\n            const: variableDeclaratorRules\n          };\n        } else if (typeof variableDeclaratorRules === \"object\") {\n          Object.assign(options.VariableDeclarator, variableDeclaratorRules);\n        }\n\n        if (typeof opts.outerIIFEBody === \"number\") {\n          options.outerIIFEBody = opts.outerIIFEBody;\n        }\n\n        if (typeof opts.MemberExpression === \"number\") {\n          options.MemberExpression = opts.MemberExpression;\n        }\n\n        if (typeof opts.FunctionDeclaration === \"object\") {\n          Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\n        }\n\n        if (typeof opts.FunctionExpression === \"object\") {\n          Object.assign(options.FunctionExpression, opts.FunctionExpression);\n        }\n\n        if (typeof opts.CallExpression === \"object\") {\n          Object.assign(options.CallExpression, opts.CallExpression);\n        }\n\n        if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\n          options.ArrayExpression = opts.ArrayExpression;\n        }\n\n        if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\n          options.ObjectExpression = opts.ObjectExpression;\n        }\n      }\n    }\n\n    const caseIndentStore = {};\n    /**\r\n     * Creates an error message for a line, given the expected/actual indentation.\r\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\r\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\r\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\r\n     * @returns {string} An error message for this line\r\n     */\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n\n      let foundStatement;\n\n      if (actualSpaces > 0 && actualTabs > 0) {\n        foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\n      } else if (actualSpaces > 0) {\n        /*\r\n         * Abbreviate the message if the expected indentation is also spaces.\r\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\r\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n    /**\r\n     * Reports a given indent violation\r\n     * @param {ASTNode} node Node violating the indent rule\r\n     * @param {int} needed Expected indentation character count\r\n     * @param {int} gottenSpaces Indentation space count in the actual node/code\r\n     * @param {int} gottenTabs Indentation tab count in the actual node/code\r\n     * @param {Object} [loc] Error line and column location\r\n     * @param {boolean} isLastNodeCheck Is the error for last node check\r\n     * @returns {void}\r\n     */\n\n\n    function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\n      if (gottenSpaces && gottenTabs) {\n        // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\n        return;\n      }\n\n      const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\n      const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\n      context.report({\n        node,\n        loc,\n        messageId: \"expected\",\n        data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\n        fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\n      });\n    }\n    /**\r\n     * Get the actual indent of node\r\n     * @param {ASTNode|Token} node Node to examine\r\n     * @param {boolean} [byLastLine=false] get indent of node's last line\r\n     * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\r\n     * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\r\n     * `badChar` is the amount of the other indentation character.\r\n     */\n\n\n    function getNodeIndent(node, byLastLine) {\n      const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n      const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\n      const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\n      const spaces = indentChars.filter(char => char === \" \").length;\n      const tabs = indentChars.filter(char => char === \"\\t\").length;\n      return {\n        space: spaces,\n        tab: tabs,\n        goodChar: indentType === \"space\" ? spaces : tabs,\n        badChar: indentType === \"space\" ? tabs : spaces\n      };\n    }\n    /**\r\n     * Checks node is the first in its own start line. By default it looks by start line.\r\n     * @param {ASTNode} node The node to check\r\n     * @param {boolean} [byEndLocation=false] Lookup based on start position or end\r\n     * @returns {boolean} true if its the first in the its start line\r\n     */\n\n\n    function isNodeFirstInLine(node, byEndLocation) {\n      const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n            startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n            endLine = firstToken ? firstToken.loc.end.line : -1;\n      return startLine !== endLine;\n    }\n    /**\r\n     * Check indent for node\r\n     * @param {ASTNode} node Node to check\r\n     * @param {int} neededIndent needed indent\r\n     * @returns {void}\r\n     */\n\n\n    function checkNodeIndent(node, neededIndent) {\n      const actualIndent = getNodeIndent(node, false);\n\n      if (node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, neededIndent, actualIndent.space, actualIndent.tab);\n      }\n\n      if (node.type === \"IfStatement\" && node.alternate) {\n        const elseToken = sourceCode.getTokenBefore(node.alternate);\n        checkNodeIndent(elseToken, neededIndent);\n\n        if (!isNodeFirstInLine(node.alternate)) {\n          checkNodeIndent(node.alternate, neededIndent);\n        }\n      }\n\n      if (node.type === \"TryStatement\" && node.handler) {\n        const catchToken = sourceCode.getFirstToken(node.handler);\n        checkNodeIndent(catchToken, neededIndent);\n      }\n\n      if (node.type === \"TryStatement\" && node.finalizer) {\n        const finallyToken = sourceCode.getTokenBefore(node.finalizer);\n        checkNodeIndent(finallyToken, neededIndent);\n      }\n\n      if (node.type === \"DoWhileStatement\") {\n        const whileToken = sourceCode.getTokenAfter(node.body);\n        checkNodeIndent(whileToken, neededIndent);\n      }\n    }\n    /**\r\n     * Check indent for nodes list\r\n     * @param {ASTNode[]} nodes list of node objects\r\n     * @param {int} indent needed indent\r\n     * @returns {void}\r\n     */\n\n\n    function checkNodesIndent(nodes, indent) {\n      nodes.forEach(node => checkNodeIndent(node, indent));\n    }\n    /**\r\n     * Check last node line indent this detects, that block closed correctly\r\n     * @param {ASTNode} node Node to examine\r\n     * @param {int} lastLineIndent needed indent\r\n     * @returns {void}\r\n     */\n\n\n    function checkLastNodeLineIndent(node, lastLineIndent) {\n      const lastToken = sourceCode.getLastToken(node);\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\n        report(node, lastLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\r\n     * Check last node line indent this detects, that block closed correctly\r\n     * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\r\n     * @param {ASTNode} node Node to examine\r\n     * @param {int} firstLineIndent first line needed indent\r\n     * @returns {void}\r\n     */\n\n\n    function checkLastReturnStatementLineIndent(node, firstLineIndent) {\n      /*\r\n       * in case if return statement ends with ');' we have traverse back to ')'\r\n       * otherwise we'll measure indent for ';' and replace ')'\r\n       */\n      const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\n      const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\n\n      if (textBeforeClosingParenthesis.trim()) {\n        // There are tokens before the closing paren, don't report this case\n        return;\n      }\n\n      const endIndent = getNodeIndent(lastToken, true);\n\n      if (endIndent.goodChar !== firstLineIndent) {\n        report(node, firstLineIndent, endIndent.space, endIndent.tab, {\n          line: lastToken.loc.start.line,\n          column: lastToken.loc.start.column\n        }, true);\n      }\n    }\n    /**\r\n     * Check first node line indent is correct\r\n     * @param {ASTNode} node Node to examine\r\n     * @param {int} firstLineIndent needed indent\r\n     * @returns {void}\r\n     */\n\n\n    function checkFirstNodeLineIndent(node, firstLineIndent) {\n      const startIndent = getNodeIndent(node, false);\n\n      if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\n        report(node, firstLineIndent, startIndent.space, startIndent.tab, {\n          line: node.loc.start.line,\n          column: node.loc.start.column\n        });\n      }\n    }\n    /**\r\n     * Returns a parent node of given node based on a specified type\r\n     * if not present then return null\r\n     * @param {ASTNode} node node to examine\r\n     * @param {string} type type that is being looked for\r\n     * @param {string} stopAtList end points for the evaluating code\r\n     * @returns {ASTNode|void} if found then node otherwise null\r\n     */\n\n\n    function getParentNodeByType(node, type, stopAtList) {\n      let parent = node.parent;\n      const stopAtSet = new Set(stopAtList || [\"Program\"]);\n\n      while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\n        parent = parent.parent;\n      }\n\n      return parent.type === type ? parent : null;\n    }\n    /**\r\n     * Returns the VariableDeclarator based on the current node\r\n     * if not present then return null\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {ASTNode|void} if found then node otherwise null\r\n     */\n\n\n    function getVariableDeclaratorNode(node) {\n      return getParentNodeByType(node, \"VariableDeclarator\");\n    }\n    /**\r\n     * Check to see if the node is part of the multi-line variable declaration.\r\n     * Also if its on the same line as the varNode\r\n     * @param {ASTNode} node node to check\r\n     * @param {ASTNode} varNode variable declaration node to check against\r\n     * @returns {boolean} True if all the above condition satisfy\r\n     */\n\n\n    function isNodeInVarOnTop(node, varNode) {\n      return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;\n    }\n    /**\r\n     * Check to see if the argument before the callee node is multi-line and\r\n     * there should only be 1 argument before the callee node\r\n     * @param {ASTNode} node node to check\r\n     * @returns {boolean} True if arguments are multi-line\r\n     */\n\n\n    function isArgBeforeCalleeNodeMultiline(node) {\n      const parent = node.parent;\n\n      if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n        return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n      }\n\n      return false;\n    }\n    /**\r\n     * Check to see if the node is a file level IIFE\r\n     * @param {ASTNode} node The function node to check.\r\n     * @returns {boolean} True if the node is the outer IIFE\r\n     */\n\n\n    function isOuterIIFE(node) {\n      const parent = node.parent;\n      let stmt = parent.parent;\n      /*\r\n       * Verify that the node is an IIEF\r\n       */\n\n      if (parent.type !== \"CallExpression\" || parent.callee !== node) {\n        return false;\n      }\n      /*\r\n       * Navigate legal ancestors to determine whether this IIEF is outer\r\n       */\n\n\n      while (stmt.type === \"UnaryExpression\" && (stmt.operator === \"!\" || stmt.operator === \"~\" || stmt.operator === \"+\" || stmt.operator === \"-\") || stmt.type === \"AssignmentExpression\" || stmt.type === \"LogicalExpression\" || stmt.type === \"SequenceExpression\" || stmt.type === \"VariableDeclarator\") {\n        stmt = stmt.parent;\n      }\n\n      return (stmt.type === \"ExpressionStatement\" || stmt.type === \"VariableDeclaration\") && stmt.parent && stmt.parent.type === \"Program\";\n    }\n    /**\r\n     * Check indent for function block content\r\n     * @param {ASTNode} node A BlockStatement node that is inside of a function.\r\n     * @returns {void}\r\n     */\n\n\n    function checkIndentInFunctionBlock(node) {\n      /*\r\n       * Search first caller in chain.\r\n       * Ex.:\r\n       *\r\n       * Models <- Identifier\r\n       *   .User\r\n       *   .find()\r\n       *   .exec(function() {\r\n       *   // function body\r\n       * });\r\n       *\r\n       * Looks for 'Models'\r\n       */\n      const calleeNode = node.parent; // FunctionExpression\n\n      let indent;\n\n      if (calleeNode.parent && (calleeNode.parent.type === \"Property\" || calleeNode.parent.type === \"ArrayExpression\")) {\n        // If function is part of array or object, comma can be put at left\n        indent = getNodeIndent(calleeNode, false).goodChar;\n      } else {\n        // If function is standalone, simple calculate indent\n        indent = getNodeIndent(calleeNode).goodChar;\n      }\n\n      if (calleeNode.parent.type === \"CallExpression\") {\n        const calleeParent = calleeNode.parent;\n\n        if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n          if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        } else {\n          if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {\n            indent = getNodeIndent(calleeParent).goodChar;\n          }\n        }\n      }\n      /*\r\n       * function body indent should be indent + indent size, unless this\r\n       * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\r\n       */\n\n\n      let functionOffset = indentSize;\n\n      if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\n        functionOffset = options.outerIIFEBody * indentSize;\n      } else if (calleeNode.type === \"FunctionExpression\") {\n        functionOffset = options.FunctionExpression.body * indentSize;\n      } else if (calleeNode.type === \"FunctionDeclaration\") {\n        functionOffset = options.FunctionDeclaration.body * indentSize;\n      }\n\n      indent += functionOffset; // check if the node is inside a variable\n\n      const parentVarNode = getVariableDeclaratorNode(node);\n\n      if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n        indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      if (node.body.length > 0) {\n        checkNodesIndent(node.body, indent);\n      }\n\n      checkLastNodeLineIndent(node, indent - functionOffset);\n    }\n    /**\r\n     * Checks if the given node starts and ends on the same line\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} Whether or not the block starts and ends on the same line.\r\n     */\n\n\n    function isSingleLineNode(node) {\n      const lastToken = sourceCode.getLastToken(node),\n            startLine = node.loc.start.line,\n            endLine = lastToken.loc.end.line;\n      return startLine === endLine;\n    }\n    /**\r\n     * Check indent for array block content or object block content\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {void}\r\n     */\n\n\n    function checkIndentInArrayOrObjectBlock(node) {\n      // Skip inline\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      let elements = node.type === \"ArrayExpression\" ? node.elements : node.properties; // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n\n      elements = elements.filter(elem => elem !== null);\n      let nodeIndent;\n      let elementsIndent;\n      const parentVarNode = getVariableDeclaratorNode(node); // TODO - come up with a better strategy in future\n\n      if (isNodeFirstInLine(node)) {\n        const parent = node.parent;\n        nodeIndent = getNodeIndent(parent).goodChar;\n\n        if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\n          if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n            if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\n              nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\n              const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\n\n              if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {\n                /*\r\n                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\r\n                 * e.g. [{\r\n                 *        foo: 1\r\n                 *      },\r\n                 *      {\r\n                 *        bar: 1\r\n                 *      }]\r\n                 * the second object is not indented.\r\n                 */\n              } else if (typeof options[parent.type] === \"number\") {\n                nodeIndent += options[parent.type] * indentSize;\n              } else {\n                nodeIndent = parentElements[0].loc.start.column;\n              }\n            } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\n              if (typeof options.CallExpression.arguments === \"number\") {\n                nodeIndent += options.CallExpression.arguments * indentSize;\n              } else if (options.CallExpression.arguments === \"first\") {\n                if (parent.arguments.indexOf(node) !== -1) {\n                  nodeIndent = parent.arguments[0].loc.start.column;\n                }\n              } else {\n                nodeIndent += indentSize;\n              }\n            } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\n              nodeIndent += indentSize;\n            }\n          }\n        }\n\n        checkFirstNodeLineIndent(node, nodeIndent);\n      } else {\n        nodeIndent = getNodeIndent(node).goodChar;\n      }\n\n      if (options[node.type] === \"first\") {\n        elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\n      } else {\n        elementsIndent = nodeIndent + indentSize * options[node.type];\n      }\n      /*\r\n       * Check if the node is a multiple variable declaration; if so, then\r\n       * make sure indentation takes that into account.\r\n       */\n\n\n      if (isNodeInVarOnTop(node, parentVarNode)) {\n        elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n      }\n\n      checkNodesIndent(elements, elementsIndent);\n\n      if (elements.length > 0) {\n        // Skip last block line check if last item in same line\n        if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n          return;\n        }\n      }\n\n      checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\n    }\n    /**\r\n     * Check if the node or node body is a BlockStatement or not\r\n     * @param {ASTNode} node node to test\r\n     * @returns {boolean} True if it or its body is a block statement\r\n     */\n\n\n    function isNodeBodyBlock(node) {\n      return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || node.body && node.body.type === \"BlockStatement\" || node.consequent && node.consequent.type === \"BlockStatement\";\n    }\n    /**\r\n     * Check indentation for blocks\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function blockIndentationCheck(node) {\n      // Skip inline blocks\n      if (isSingleLineNode(node)) {\n        return;\n      }\n\n      if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"FunctionDeclaration\" || node.parent.type === \"ArrowFunctionExpression\")) {\n        checkIndentInFunctionBlock(node);\n        return;\n      }\n\n      let indent;\n      let nodesToCheck = [];\n      /*\r\n       * For this statements we should check indent from statement beginning,\r\n       * not from the beginning of the block.\r\n       */\n\n      const statementsWithProperties = [\"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"];\n\n      if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n        indent = getNodeIndent(node.parent).goodChar;\n      } else if (node.parent && node.parent.type === \"CatchClause\") {\n        indent = getNodeIndent(node.parent.parent).goodChar;\n      } else {\n        indent = getNodeIndent(node).goodChar;\n      }\n\n      if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n        nodesToCheck = [node.consequent];\n      } else if (Array.isArray(node.body)) {\n        nodesToCheck = node.body;\n      } else {\n        nodesToCheck = [node.body];\n      }\n\n      if (nodesToCheck.length > 0) {\n        checkNodesIndent(nodesToCheck, indent + indentSize);\n      }\n\n      if (node.type === \"BlockStatement\") {\n        checkLastNodeLineIndent(node, indent);\n      }\n    }\n    /**\r\n     * Filter out the elements which are on the same line of each other or the node.\r\n     * basically have only 1 elements from each line except the variable declaration line.\r\n     * @param {ASTNode} node Variable declaration node\r\n     * @returns {ASTNode[]} Filtered elements\r\n     */\n\n\n    function filterOutSameLineVars(node) {\n      return node.declarations.reduce((finalCollection, elem) => {\n        const lastElem = finalCollection[finalCollection.length - 1];\n\n        if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {\n          finalCollection.push(elem);\n        }\n\n        return finalCollection;\n      }, []);\n    }\n    /**\r\n     * Check indentation for variable declarations\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {void}\r\n     */\n\n\n    function checkIndentInVariableDeclarations(node) {\n      const elements = filterOutSameLineVars(node);\n      const nodeIndent = getNodeIndent(node).goodChar;\n      const lastElement = elements[elements.length - 1];\n      const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n      checkNodesIndent(elements, elementsIndent); // Only check the last line if there is any token after the last item\n\n      if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n        return;\n      }\n\n      const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n      if (tokenBeforeLastElement.value === \",\") {\n        // Special case for comma-first syntax where the semicolon is indented\n        checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\n      } else {\n        checkLastNodeLineIndent(node, elementsIndent - indentSize);\n      }\n    }\n    /**\r\n     * Check and decide whether to check for indentation for blockless nodes\r\n     * Scenarios are for or while statements without braces around them\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {void}\r\n     */\n\n\n    function blockLessNodes(node) {\n      if (node.body.type !== \"BlockStatement\") {\n        blockIndentationCheck(node);\n      }\n    }\n    /**\r\n     * Returns the expected indentation for the case statement\r\n     * @param {ASTNode} node node to examine\r\n     * @param {int} [providedSwitchIndent] indent for switch statement\r\n     * @returns {int} indent size\r\n     */\n\n\n    function expectedCaseIndent(node, providedSwitchIndent) {\n      const switchNode = node.type === \"SwitchStatement\" ? node : node.parent;\n      const switchIndent = typeof providedSwitchIndent === \"undefined\" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;\n      let caseIndent;\n\n      if (caseIndentStore[switchNode.loc.start.line]) {\n        return caseIndentStore[switchNode.loc.start.line];\n      }\n\n      if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n        caseIndent = switchIndent;\n      } else {\n        caseIndent = switchIndent + indentSize * options.SwitchCase;\n      }\n\n      caseIndentStore[switchNode.loc.start.line] = caseIndent;\n      return caseIndent;\n    }\n    /**\r\n     * Checks whether a return statement is wrapped in ()\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {boolean} the result\r\n     */\n\n\n    function isWrappedInParenthesis(node) {\n      const regex = /^return\\s*?\\(\\s*?\\);*?/u;\n      const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), \"\");\n      return regex.test(statementWithoutArgument);\n    }\n\n    return {\n      Program(node) {\n        if (node.body.length > 0) {\n          // Root nodes should have no indent\n          checkNodesIndent(node.body, getNodeIndent(node).goodChar);\n        }\n      },\n\n      ClassBody: blockIndentationCheck,\n      BlockStatement: blockIndentationCheck,\n      WhileStatement: blockLessNodes,\n      ForStatement: blockLessNodes,\n      ForInStatement: blockLessNodes,\n      ForOfStatement: blockLessNodes,\n      DoWhileStatement: blockLessNodes,\n\n      IfStatement(node) {\n        if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n          blockIndentationCheck(node);\n        }\n      },\n\n      VariableDeclaration(node) {\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n          checkIndentInVariableDeclarations(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      ArrayExpression(node) {\n        checkIndentInArrayOrObjectBlock(node);\n      },\n\n      MemberExpression(node) {\n        if (typeof options.MemberExpression === \"undefined\") {\n          return;\n        }\n\n        if (isSingleLineNode(node)) {\n          return;\n        }\n        /*\r\n         * The typical layout of variable declarations and assignments\r\n         * alter the expectation of correct indentation. Skip them.\r\n         * TODO: Add appropriate configuration options for variable\r\n         * declarations and assignments.\r\n         */\n\n\n        if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          return;\n        }\n\n        if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\n          return;\n        }\n\n        const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\n        const checkNodes = [node.property];\n        const dot = sourceCode.getTokenBefore(node.property);\n\n        if (dot.type === \"Punctuator\" && dot.value === \".\") {\n          checkNodes.push(dot);\n        }\n\n        checkNodesIndent(checkNodes, propertyIndent);\n      },\n\n      SwitchStatement(node) {\n        // Switch is not a 'BlockStatement'\n        const switchIndent = getNodeIndent(node).goodChar;\n        const caseIndent = expectedCaseIndent(node, switchIndent);\n        checkNodesIndent(node.cases, caseIndent);\n        checkLastNodeLineIndent(node, switchIndent);\n      },\n\n      SwitchCase(node) {\n        // Skip inline cases\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const caseIndent = expectedCaseIndent(node);\n        checkNodesIndent(node.consequent, caseIndent + indentSize);\n      },\n\n      FunctionDeclaration(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionDeclaration.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\n        }\n      },\n\n      FunctionExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\n          checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\n        } else if (options.FunctionExpression.parameters !== null) {\n          checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\n        }\n      },\n\n      ReturnStatement(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        const firstLineIndent = getNodeIndent(node).goodChar; // in case if return statement is wrapped in parenthesis\n\n        if (isWrappedInParenthesis(node)) {\n          checkLastReturnStatementLineIndent(node, firstLineIndent);\n        } else {\n          checkNodeIndent(node, firstLineIndent);\n        }\n      },\n\n      CallExpression(node) {\n        if (isSingleLineNode(node)) {\n          return;\n        }\n\n        if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\n          checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\n        } else if (options.CallExpression.arguments !== null) {\n          checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/indent-legacy.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","deprecated","replacedBy","fixable","schema","oneOf","enum","minimum","properties","SwitchCase","VariableDeclarator","var","let","const","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","CallExpression","ArrayExpression","ObjectExpression","additionalProperties","messages","expected","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","indentType","indentSize","options","arguments","sourceCode","getSourceCode","length","opts","variableDeclaratorRules","Object","assign","caseIndentStore","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","actual","report","node","needed","gottenSpaces","gottenTabs","loc","isLastNodeCheck","desiredIndent","repeat","textRange","range","end","column","start","messageId","data","fix","fixer","replaceTextRange","getNodeIndent","byLastLine","token","getLastToken","getFirstToken","srcCharsBeforeNode","getText","split","indentChars","slice","findIndex","char","spaces","filter","tabs","space","tab","goodChar","badChar","isNodeFirstInLine","byEndLocation","firstToken","getTokenBefore","startLine","line","endLine","checkNodeIndent","neededIndent","actualIndent","alternate","elseToken","handler","catchToken","finalizer","finallyToken","whileToken","getTokenAfter","checkNodesIndent","nodes","indent","forEach","checkLastNodeLineIndent","lastLineIndent","lastToken","endIndent","checkLastReturnStatementLineIndent","firstLineIndent","isClosingParenToken","textBeforeClosingParenthesis","trim","checkFirstNodeLineIndent","startIndent","getParentNodeByType","stopAtList","parent","stopAtSet","Set","has","getVariableDeclaratorNode","isNodeInVarOnTop","varNode","declarations","isArgBeforeCalleeNodeMultiline","isOuterIIFE","stmt","callee","operator","checkIndentInFunctionBlock","calleeNode","calleeParent","functionOffset","parentVarNode","kind","isSingleLineNode","checkIndentInArrayOrObjectBlock","elements","elem","nodeIndent","elementsIndent","parentElements","indexOf","isNodeBodyBlock","consequent","blockIndentationCheck","nodesToCheck","statementsWithProperties","Array","isArray","filterOutSameLineVars","reduce","finalCollection","lastElem","push","checkIndentInVariableDeclarations","lastElement","tokenBeforeLastElement","value","blockLessNodes","expectedCaseIndent","providedSwitchIndent","switchNode","switchIndent","caseIndent","cases","isWrappedInParenthesis","regex","statementWithoutArgument","replace","argument","test","Program","ClassBody","BlockStatement","WhileStatement","ForStatement","ForInStatement","ForOfStatement","DoWhileStatement","IfStatement","VariableDeclaration","propertyIndent","checkNodes","property","dot","SwitchStatement","params","ReturnStatement"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview This option sets a specific tab width for your code\r\n *\r\n * This rule has been ported and modified from nodeca.\r\n * @author Vitaly Puzrin\r\n * @author Gyandeep Singh\r\n * @deprecated in ESLint v4.0.0\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/* istanbul ignore next: this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway. */\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent indentation\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/indent-legacy\"\r\n        },\r\n\r\n        deprecated: true,\r\n\r\n        replacedBy: [\"indent\"],\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"tab\"]\r\n                    },\r\n                    {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    SwitchCase: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    VariableDeclarator: {\r\n                        oneOf: [\r\n                            {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            {\r\n                                type: \"object\",\r\n                                properties: {\r\n                                    var: {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    },\r\n                                    let: {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    },\r\n                                    const: {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    }\r\n                                }\r\n                            }\r\n                        ]\r\n                    },\r\n                    outerIIFEBody: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    MemberExpression: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    FunctionDeclaration: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            parameters: {\r\n                                oneOf: [\r\n                                    {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    },\r\n                                    {\r\n                                        enum: [\"first\"]\r\n                                    }\r\n                                ]\r\n                            },\r\n                            body: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        }\r\n                    },\r\n                    FunctionExpression: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            parameters: {\r\n                                oneOf: [\r\n                                    {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    },\r\n                                    {\r\n                                        enum: [\"first\"]\r\n                                    }\r\n                                ]\r\n                            },\r\n                            body: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        }\r\n                    },\r\n                    CallExpression: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            parameters: {\r\n                                oneOf: [\r\n                                    {\r\n                                        type: \"integer\",\r\n                                        minimum: 0\r\n                                    },\r\n                                    {\r\n                                        enum: [\"first\"]\r\n                                    }\r\n                                ]\r\n                            }\r\n                        }\r\n                    },\r\n                    ArrayExpression: {\r\n                        oneOf: [\r\n                            {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            {\r\n                                enum: [\"first\"]\r\n                            }\r\n                        ]\r\n                    },\r\n                    ObjectExpression: {\r\n                        oneOf: [\r\n                            {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            {\r\n                                enum: [\"first\"]\r\n                            }\r\n                        ]\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            expected: \"Expected indentation of {{expected}} but found {{actual}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const DEFAULT_VARIABLE_INDENT = 1;\r\n        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config\r\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\r\n\r\n        let indentType = \"space\";\r\n        let indentSize = 4;\r\n        const options = {\r\n            SwitchCase: 0,\r\n            VariableDeclarator: {\r\n                var: DEFAULT_VARIABLE_INDENT,\r\n                let: DEFAULT_VARIABLE_INDENT,\r\n                const: DEFAULT_VARIABLE_INDENT\r\n            },\r\n            outerIIFEBody: null,\r\n            FunctionDeclaration: {\r\n                parameters: DEFAULT_PARAMETER_INDENT,\r\n                body: DEFAULT_FUNCTION_BODY_INDENT\r\n            },\r\n            FunctionExpression: {\r\n                parameters: DEFAULT_PARAMETER_INDENT,\r\n                body: DEFAULT_FUNCTION_BODY_INDENT\r\n            },\r\n            CallExpression: {\r\n                arguments: DEFAULT_PARAMETER_INDENT\r\n            },\r\n            ArrayExpression: 1,\r\n            ObjectExpression: 1\r\n        };\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        if (context.options.length) {\r\n            if (context.options[0] === \"tab\") {\r\n                indentSize = 1;\r\n                indentType = \"tab\";\r\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\r\n                indentSize = context.options[0];\r\n                indentType = \"space\";\r\n            }\r\n\r\n            if (context.options[1]) {\r\n                const opts = context.options[1];\r\n\r\n                options.SwitchCase = opts.SwitchCase || 0;\r\n                const variableDeclaratorRules = opts.VariableDeclarator;\r\n\r\n                if (typeof variableDeclaratorRules === \"number\") {\r\n                    options.VariableDeclarator = {\r\n                        var: variableDeclaratorRules,\r\n                        let: variableDeclaratorRules,\r\n                        const: variableDeclaratorRules\r\n                    };\r\n                } else if (typeof variableDeclaratorRules === \"object\") {\r\n                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);\r\n                }\r\n\r\n                if (typeof opts.outerIIFEBody === \"number\") {\r\n                    options.outerIIFEBody = opts.outerIIFEBody;\r\n                }\r\n\r\n                if (typeof opts.MemberExpression === \"number\") {\r\n                    options.MemberExpression = opts.MemberExpression;\r\n                }\r\n\r\n                if (typeof opts.FunctionDeclaration === \"object\") {\r\n                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);\r\n                }\r\n\r\n                if (typeof opts.FunctionExpression === \"object\") {\r\n                    Object.assign(options.FunctionExpression, opts.FunctionExpression);\r\n                }\r\n\r\n                if (typeof opts.CallExpression === \"object\") {\r\n                    Object.assign(options.CallExpression, opts.CallExpression);\r\n                }\r\n\r\n                if (typeof opts.ArrayExpression === \"number\" || typeof opts.ArrayExpression === \"string\") {\r\n                    options.ArrayExpression = opts.ArrayExpression;\r\n                }\r\n\r\n                if (typeof opts.ObjectExpression === \"number\" || typeof opts.ObjectExpression === \"string\") {\r\n                    options.ObjectExpression = opts.ObjectExpression;\r\n                }\r\n            }\r\n        }\r\n\r\n        const caseIndentStore = {};\r\n\r\n        /**\r\n         * Creates an error message for a line, given the expected/actual indentation.\r\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\r\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\r\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\r\n         * @returns {string} An error message for this line\r\n         */\r\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\r\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\r\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\r\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\r\n            let foundStatement;\r\n\r\n            if (actualSpaces > 0 && actualTabs > 0) {\r\n                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. \"1 space and 2 tabs\"\r\n            } else if (actualSpaces > 0) {\r\n\r\n                /*\r\n                 * Abbreviate the message if the expected indentation is also spaces.\r\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\r\n                 */\r\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\r\n            } else if (actualTabs > 0) {\r\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\r\n            } else {\r\n                foundStatement = \"0\";\r\n            }\r\n            return {\r\n                expected: expectedStatement,\r\n                actual: foundStatement\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Reports a given indent violation\r\n         * @param {ASTNode} node Node violating the indent rule\r\n         * @param {int} needed Expected indentation character count\r\n         * @param {int} gottenSpaces Indentation space count in the actual node/code\r\n         * @param {int} gottenTabs Indentation tab count in the actual node/code\r\n         * @param {Object} [loc] Error line and column location\r\n         * @param {boolean} isLastNodeCheck Is the error for last node check\r\n         * @returns {void}\r\n         */\r\n        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {\r\n            if (gottenSpaces && gottenTabs) {\r\n\r\n                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.\r\n                return;\r\n            }\r\n\r\n            const desiredIndent = (indentType === \"space\" ? \" \" : \"\\t\").repeat(needed);\r\n\r\n            const textRange = isLastNodeCheck\r\n                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]\r\n                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];\r\n\r\n            context.report({\r\n                node,\r\n                loc,\r\n                messageId: \"expected\",\r\n                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),\r\n                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Get the actual indent of node\r\n         * @param {ASTNode|Token} node Node to examine\r\n         * @param {boolean} [byLastLine=false] get indent of node's last line\r\n         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also\r\n         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and\r\n         * `badChar` is the amount of the other indentation character.\r\n         */\r\n        function getNodeIndent(node, byLastLine) {\r\n            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\r\n            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split(\"\");\r\n            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== \" \" && char !== \"\\t\"));\r\n            const spaces = indentChars.filter(char => char === \" \").length;\r\n            const tabs = indentChars.filter(char => char === \"\\t\").length;\r\n\r\n            return {\r\n                space: spaces,\r\n                tab: tabs,\r\n                goodChar: indentType === \"space\" ? spaces : tabs,\r\n                badChar: indentType === \"space\" ? tabs : spaces\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Checks node is the first in its own start line. By default it looks by start line.\r\n         * @param {ASTNode} node The node to check\r\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\r\n         * @returns {boolean} true if its the first in the its start line\r\n         */\r\n        function isNodeFirstInLine(node, byEndLocation) {\r\n            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\r\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\r\n                endLine = firstToken ? firstToken.loc.end.line : -1;\r\n\r\n            return startLine !== endLine;\r\n        }\r\n\r\n        /**\r\n         * Check indent for node\r\n         * @param {ASTNode} node Node to check\r\n         * @param {int} neededIndent needed indent\r\n         * @returns {void}\r\n         */\r\n        function checkNodeIndent(node, neededIndent) {\r\n            const actualIndent = getNodeIndent(node, false);\r\n\r\n            if (\r\n                node.type !== \"ArrayExpression\" &&\r\n                node.type !== \"ObjectExpression\" &&\r\n                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&\r\n                isNodeFirstInLine(node)\r\n            ) {\r\n                report(node, neededIndent, actualIndent.space, actualIndent.tab);\r\n            }\r\n\r\n            if (node.type === \"IfStatement\" && node.alternate) {\r\n                const elseToken = sourceCode.getTokenBefore(node.alternate);\r\n\r\n                checkNodeIndent(elseToken, neededIndent);\r\n\r\n                if (!isNodeFirstInLine(node.alternate)) {\r\n                    checkNodeIndent(node.alternate, neededIndent);\r\n                }\r\n            }\r\n\r\n            if (node.type === \"TryStatement\" && node.handler) {\r\n                const catchToken = sourceCode.getFirstToken(node.handler);\r\n\r\n                checkNodeIndent(catchToken, neededIndent);\r\n            }\r\n\r\n            if (node.type === \"TryStatement\" && node.finalizer) {\r\n                const finallyToken = sourceCode.getTokenBefore(node.finalizer);\r\n\r\n                checkNodeIndent(finallyToken, neededIndent);\r\n            }\r\n\r\n            if (node.type === \"DoWhileStatement\") {\r\n                const whileToken = sourceCode.getTokenAfter(node.body);\r\n\r\n                checkNodeIndent(whileToken, neededIndent);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check indent for nodes list\r\n         * @param {ASTNode[]} nodes list of node objects\r\n         * @param {int} indent needed indent\r\n         * @returns {void}\r\n         */\r\n        function checkNodesIndent(nodes, indent) {\r\n            nodes.forEach(node => checkNodeIndent(node, indent));\r\n        }\r\n\r\n        /**\r\n         * Check last node line indent this detects, that block closed correctly\r\n         * @param {ASTNode} node Node to examine\r\n         * @param {int} lastLineIndent needed indent\r\n         * @returns {void}\r\n         */\r\n        function checkLastNodeLineIndent(node, lastLineIndent) {\r\n            const lastToken = sourceCode.getLastToken(node);\r\n            const endIndent = getNodeIndent(lastToken, true);\r\n\r\n            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {\r\n                report(\r\n                    node,\r\n                    lastLineIndent,\r\n                    endIndent.space,\r\n                    endIndent.tab,\r\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\r\n                    true\r\n                );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check last node line indent this detects, that block closed correctly\r\n         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'\r\n         * @param {ASTNode} node Node to examine\r\n         * @param {int} firstLineIndent first line needed indent\r\n         * @returns {void}\r\n         */\r\n        function checkLastReturnStatementLineIndent(node, firstLineIndent) {\r\n\r\n            /*\r\n             * in case if return statement ends with ');' we have traverse back to ')'\r\n             * otherwise we'll measure indent for ';' and replace ')'\r\n             */\r\n            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);\r\n            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);\r\n\r\n            if (textBeforeClosingParenthesis.trim()) {\r\n\r\n                // There are tokens before the closing paren, don't report this case\r\n                return;\r\n            }\r\n\r\n            const endIndent = getNodeIndent(lastToken, true);\r\n\r\n            if (endIndent.goodChar !== firstLineIndent) {\r\n                report(\r\n                    node,\r\n                    firstLineIndent,\r\n                    endIndent.space,\r\n                    endIndent.tab,\r\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\r\n                    true\r\n                );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check first node line indent is correct\r\n         * @param {ASTNode} node Node to examine\r\n         * @param {int} firstLineIndent needed indent\r\n         * @returns {void}\r\n         */\r\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\r\n            const startIndent = getNodeIndent(node, false);\r\n\r\n            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {\r\n                report(\r\n                    node,\r\n                    firstLineIndent,\r\n                    startIndent.space,\r\n                    startIndent.tab,\r\n                    { line: node.loc.start.line, column: node.loc.start.column }\r\n                );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a parent node of given node based on a specified type\r\n         * if not present then return null\r\n         * @param {ASTNode} node node to examine\r\n         * @param {string} type type that is being looked for\r\n         * @param {string} stopAtList end points for the evaluating code\r\n         * @returns {ASTNode|void} if found then node otherwise null\r\n         */\r\n        function getParentNodeByType(node, type, stopAtList) {\r\n            let parent = node.parent;\r\n            const stopAtSet = new Set(stopAtList || [\"Program\"]);\r\n\r\n            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== \"Program\") {\r\n                parent = parent.parent;\r\n            }\r\n\r\n            return parent.type === type ? parent : null;\r\n        }\r\n\r\n        /**\r\n         * Returns the VariableDeclarator based on the current node\r\n         * if not present then return null\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {ASTNode|void} if found then node otherwise null\r\n         */\r\n        function getVariableDeclaratorNode(node) {\r\n            return getParentNodeByType(node, \"VariableDeclarator\");\r\n        }\r\n\r\n        /**\r\n         * Check to see if the node is part of the multi-line variable declaration.\r\n         * Also if its on the same line as the varNode\r\n         * @param {ASTNode} node node to check\r\n         * @param {ASTNode} varNode variable declaration node to check against\r\n         * @returns {boolean} True if all the above condition satisfy\r\n         */\r\n        function isNodeInVarOnTop(node, varNode) {\r\n            return varNode &&\r\n                varNode.parent.loc.start.line === node.loc.start.line &&\r\n                varNode.parent.declarations.length > 1;\r\n        }\r\n\r\n        /**\r\n         * Check to see if the argument before the callee node is multi-line and\r\n         * there should only be 1 argument before the callee node\r\n         * @param {ASTNode} node node to check\r\n         * @returns {boolean} True if arguments are multi-line\r\n         */\r\n        function isArgBeforeCalleeNodeMultiline(node) {\r\n            const parent = node.parent;\r\n\r\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\r\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check to see if the node is a file level IIFE\r\n         * @param {ASTNode} node The function node to check.\r\n         * @returns {boolean} True if the node is the outer IIFE\r\n         */\r\n        function isOuterIIFE(node) {\r\n            const parent = node.parent;\r\n            let stmt = parent.parent;\r\n\r\n            /*\r\n             * Verify that the node is an IIEF\r\n             */\r\n            if (\r\n                parent.type !== \"CallExpression\" ||\r\n                parent.callee !== node) {\r\n\r\n                return false;\r\n            }\r\n\r\n            /*\r\n             * Navigate legal ancestors to determine whether this IIEF is outer\r\n             */\r\n            while (\r\n                stmt.type === \"UnaryExpression\" && (\r\n                    stmt.operator === \"!\" ||\r\n                    stmt.operator === \"~\" ||\r\n                    stmt.operator === \"+\" ||\r\n                    stmt.operator === \"-\") ||\r\n                stmt.type === \"AssignmentExpression\" ||\r\n                stmt.type === \"LogicalExpression\" ||\r\n                stmt.type === \"SequenceExpression\" ||\r\n                stmt.type === \"VariableDeclarator\") {\r\n\r\n                stmt = stmt.parent;\r\n            }\r\n\r\n            return ((\r\n                stmt.type === \"ExpressionStatement\" ||\r\n                stmt.type === \"VariableDeclaration\") &&\r\n                stmt.parent && stmt.parent.type === \"Program\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check indent for function block content\r\n         * @param {ASTNode} node A BlockStatement node that is inside of a function.\r\n         * @returns {void}\r\n         */\r\n        function checkIndentInFunctionBlock(node) {\r\n\r\n            /*\r\n             * Search first caller in chain.\r\n             * Ex.:\r\n             *\r\n             * Models <- Identifier\r\n             *   .User\r\n             *   .find()\r\n             *   .exec(function() {\r\n             *   // function body\r\n             * });\r\n             *\r\n             * Looks for 'Models'\r\n             */\r\n            const calleeNode = node.parent; // FunctionExpression\r\n            let indent;\r\n\r\n            if (calleeNode.parent &&\r\n                (calleeNode.parent.type === \"Property\" ||\r\n                calleeNode.parent.type === \"ArrayExpression\")) {\r\n\r\n                // If function is part of array or object, comma can be put at left\r\n                indent = getNodeIndent(calleeNode, false).goodChar;\r\n            } else {\r\n\r\n                // If function is standalone, simple calculate indent\r\n                indent = getNodeIndent(calleeNode).goodChar;\r\n            }\r\n\r\n            if (calleeNode.parent.type === \"CallExpression\") {\r\n                const calleeParent = calleeNode.parent;\r\n\r\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\r\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\r\n                        indent = getNodeIndent(calleeParent).goodChar;\r\n                    }\r\n                } else {\r\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\r\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\r\n                        !isNodeFirstInLine(calleeNode)) {\r\n                        indent = getNodeIndent(calleeParent).goodChar;\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * function body indent should be indent + indent size, unless this\r\n             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.\r\n             */\r\n            let functionOffset = indentSize;\r\n\r\n            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {\r\n                functionOffset = options.outerIIFEBody * indentSize;\r\n            } else if (calleeNode.type === \"FunctionExpression\") {\r\n                functionOffset = options.FunctionExpression.body * indentSize;\r\n            } else if (calleeNode.type === \"FunctionDeclaration\") {\r\n                functionOffset = options.FunctionDeclaration.body * indentSize;\r\n            }\r\n            indent += functionOffset;\r\n\r\n            // check if the node is inside a variable\r\n            const parentVarNode = getVariableDeclaratorNode(node);\r\n\r\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\r\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\r\n            }\r\n\r\n            if (node.body.length > 0) {\r\n                checkNodesIndent(node.body, indent);\r\n            }\r\n\r\n            checkLastNodeLineIndent(node, indent - functionOffset);\r\n        }\r\n\r\n\r\n        /**\r\n         * Checks if the given node starts and ends on the same line\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\r\n         */\r\n        function isSingleLineNode(node) {\r\n            const lastToken = sourceCode.getLastToken(node),\r\n                startLine = node.loc.start.line,\r\n                endLine = lastToken.loc.end.line;\r\n\r\n            return startLine === endLine;\r\n        }\r\n\r\n        /**\r\n         * Check indent for array block content or object block content\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {void}\r\n         */\r\n        function checkIndentInArrayOrObjectBlock(node) {\r\n\r\n            // Skip inline\r\n            if (isSingleLineNode(node)) {\r\n                return;\r\n            }\r\n\r\n            let elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\r\n\r\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\r\n            elements = elements.filter(elem => elem !== null);\r\n\r\n            let nodeIndent;\r\n            let elementsIndent;\r\n            const parentVarNode = getVariableDeclaratorNode(node);\r\n\r\n            // TODO - come up with a better strategy in future\r\n            if (isNodeFirstInLine(node)) {\r\n                const parent = node.parent;\r\n\r\n                nodeIndent = getNodeIndent(parent).goodChar;\r\n                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {\r\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\r\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === parent.loc.start.line) {\r\n                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\r\n                        } else if (parent.type === \"ObjectExpression\" || parent.type === \"ArrayExpression\") {\r\n                            const parentElements = node.parent.type === \"ObjectExpression\" ? node.parent.properties : node.parent.elements;\r\n\r\n                            if (parentElements[0] &&\r\n                                    parentElements[0].loc.start.line === parent.loc.start.line &&\r\n                                    parentElements[0].loc.end.line !== parent.loc.start.line) {\r\n\r\n                                /*\r\n                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.\r\n                                 * e.g. [{\r\n                                 *        foo: 1\r\n                                 *      },\r\n                                 *      {\r\n                                 *        bar: 1\r\n                                 *      }]\r\n                                 * the second object is not indented.\r\n                                 */\r\n                            } else if (typeof options[parent.type] === \"number\") {\r\n                                nodeIndent += options[parent.type] * indentSize;\r\n                            } else {\r\n                                nodeIndent = parentElements[0].loc.start.column;\r\n                            }\r\n                        } else if (parent.type === \"CallExpression\" || parent.type === \"NewExpression\") {\r\n                            if (typeof options.CallExpression.arguments === \"number\") {\r\n                                nodeIndent += options.CallExpression.arguments * indentSize;\r\n                            } else if (options.CallExpression.arguments === \"first\") {\r\n                                if (parent.arguments.indexOf(node) !== -1) {\r\n                                    nodeIndent = parent.arguments[0].loc.start.column;\r\n                                }\r\n                            } else {\r\n                                nodeIndent += indentSize;\r\n                            }\r\n                        } else if (parent.type === \"LogicalExpression\" || parent.type === \"ArrowFunctionExpression\") {\r\n                            nodeIndent += indentSize;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                checkFirstNodeLineIndent(node, nodeIndent);\r\n            } else {\r\n                nodeIndent = getNodeIndent(node).goodChar;\r\n            }\r\n\r\n            if (options[node.type] === \"first\") {\r\n                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.\r\n            } else {\r\n                elementsIndent = nodeIndent + indentSize * options[node.type];\r\n            }\r\n\r\n            /*\r\n             * Check if the node is a multiple variable declaration; if so, then\r\n             * make sure indentation takes that into account.\r\n             */\r\n            if (isNodeInVarOnTop(node, parentVarNode)) {\r\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\r\n            }\r\n\r\n            checkNodesIndent(elements, elementsIndent);\r\n\r\n            if (elements.length > 0) {\r\n\r\n                // Skip last block line check if last item in same line\r\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            checkLastNodeLineIndent(node, nodeIndent +\r\n                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));\r\n        }\r\n\r\n        /**\r\n         * Check if the node or node body is a BlockStatement or not\r\n         * @param {ASTNode} node node to test\r\n         * @returns {boolean} True if it or its body is a block statement\r\n         */\r\n        function isNodeBodyBlock(node) {\r\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\r\n                (node.consequent && node.consequent.type === \"BlockStatement\");\r\n        }\r\n\r\n        /**\r\n         * Check indentation for blocks\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function blockIndentationCheck(node) {\r\n\r\n            // Skip inline blocks\r\n            if (isSingleLineNode(node)) {\r\n                return;\r\n            }\r\n\r\n            if (node.parent && (\r\n                node.parent.type === \"FunctionExpression\" ||\r\n                node.parent.type === \"FunctionDeclaration\" ||\r\n                node.parent.type === \"ArrowFunctionExpression\")\r\n            ) {\r\n                checkIndentInFunctionBlock(node);\r\n                return;\r\n            }\r\n\r\n            let indent;\r\n            let nodesToCheck = [];\r\n\r\n            /*\r\n             * For this statements we should check indent from statement beginning,\r\n             * not from the beginning of the block.\r\n             */\r\n            const statementsWithProperties = [\r\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\", \"TryStatement\"\r\n            ];\r\n\r\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\r\n                indent = getNodeIndent(node.parent).goodChar;\r\n            } else if (node.parent && node.parent.type === \"CatchClause\") {\r\n                indent = getNodeIndent(node.parent.parent).goodChar;\r\n            } else {\r\n                indent = getNodeIndent(node).goodChar;\r\n            }\r\n\r\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\r\n                nodesToCheck = [node.consequent];\r\n            } else if (Array.isArray(node.body)) {\r\n                nodesToCheck = node.body;\r\n            } else {\r\n                nodesToCheck = [node.body];\r\n            }\r\n\r\n            if (nodesToCheck.length > 0) {\r\n                checkNodesIndent(nodesToCheck, indent + indentSize);\r\n            }\r\n\r\n            if (node.type === \"BlockStatement\") {\r\n                checkLastNodeLineIndent(node, indent);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Filter out the elements which are on the same line of each other or the node.\r\n         * basically have only 1 elements from each line except the variable declaration line.\r\n         * @param {ASTNode} node Variable declaration node\r\n         * @returns {ASTNode[]} Filtered elements\r\n         */\r\n        function filterOutSameLineVars(node) {\r\n            return node.declarations.reduce((finalCollection, elem) => {\r\n                const lastElem = finalCollection[finalCollection.length - 1];\r\n\r\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\r\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\r\n                    finalCollection.push(elem);\r\n                }\r\n\r\n                return finalCollection;\r\n            }, []);\r\n        }\r\n\r\n        /**\r\n         * Check indentation for variable declarations\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {void}\r\n         */\r\n        function checkIndentInVariableDeclarations(node) {\r\n            const elements = filterOutSameLineVars(node);\r\n            const nodeIndent = getNodeIndent(node).goodChar;\r\n            const lastElement = elements[elements.length - 1];\r\n\r\n            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\r\n\r\n            checkNodesIndent(elements, elementsIndent);\r\n\r\n            // Only check the last line if there is any token after the last item\r\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\r\n                return;\r\n            }\r\n\r\n            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\r\n\r\n            if (tokenBeforeLastElement.value === \",\") {\r\n\r\n                // Special case for comma-first syntax where the semicolon is indented\r\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);\r\n            } else {\r\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check and decide whether to check for indentation for blockless nodes\r\n         * Scenarios are for or while statements without braces around them\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {void}\r\n         */\r\n        function blockLessNodes(node) {\r\n            if (node.body.type !== \"BlockStatement\") {\r\n                blockIndentationCheck(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the expected indentation for the case statement\r\n         * @param {ASTNode} node node to examine\r\n         * @param {int} [providedSwitchIndent] indent for switch statement\r\n         * @returns {int} indent size\r\n         */\r\n        function expectedCaseIndent(node, providedSwitchIndent) {\r\n            const switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\r\n            const switchIndent = typeof providedSwitchIndent === \"undefined\"\r\n                ? getNodeIndent(switchNode).goodChar\r\n                : providedSwitchIndent;\r\n            let caseIndent;\r\n\r\n            if (caseIndentStore[switchNode.loc.start.line]) {\r\n                return caseIndentStore[switchNode.loc.start.line];\r\n            }\r\n\r\n            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\r\n                caseIndent = switchIndent;\r\n            } else {\r\n                caseIndent = switchIndent + (indentSize * options.SwitchCase);\r\n            }\r\n\r\n            caseIndentStore[switchNode.loc.start.line] = caseIndent;\r\n            return caseIndent;\r\n\r\n        }\r\n\r\n        /**\r\n         * Checks whether a return statement is wrapped in ()\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {boolean} the result\r\n         */\r\n        function isWrappedInParenthesis(node) {\r\n            const regex = /^return\\s*?\\(\\s*?\\);*?/u;\r\n\r\n            const statementWithoutArgument = sourceCode.getText(node).replace(\r\n                sourceCode.getText(node.argument), \"\"\r\n            );\r\n\r\n            return regex.test(statementWithoutArgument);\r\n        }\r\n\r\n        return {\r\n            Program(node) {\r\n                if (node.body.length > 0) {\r\n\r\n                    // Root nodes should have no indent\r\n                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);\r\n                }\r\n            },\r\n\r\n            ClassBody: blockIndentationCheck,\r\n\r\n            BlockStatement: blockIndentationCheck,\r\n\r\n            WhileStatement: blockLessNodes,\r\n\r\n            ForStatement: blockLessNodes,\r\n\r\n            ForInStatement: blockLessNodes,\r\n\r\n            ForOfStatement: blockLessNodes,\r\n\r\n            DoWhileStatement: blockLessNodes,\r\n\r\n            IfStatement(node) {\r\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\r\n                    blockIndentationCheck(node);\r\n                }\r\n            },\r\n\r\n            VariableDeclaration(node) {\r\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\r\n                    checkIndentInVariableDeclarations(node);\r\n                }\r\n            },\r\n\r\n            ObjectExpression(node) {\r\n                checkIndentInArrayOrObjectBlock(node);\r\n            },\r\n\r\n            ArrayExpression(node) {\r\n                checkIndentInArrayOrObjectBlock(node);\r\n            },\r\n\r\n            MemberExpression(node) {\r\n\r\n                if (typeof options.MemberExpression === \"undefined\") {\r\n                    return;\r\n                }\r\n\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * The typical layout of variable declarations and assignments\r\n                 * alter the expectation of correct indentation. Skip them.\r\n                 * TODO: Add appropriate configuration options for variable\r\n                 * declarations and assignments.\r\n                 */\r\n                if (getParentNodeByType(node, \"VariableDeclarator\", [\"FunctionExpression\", \"ArrowFunctionExpression\"])) {\r\n                    return;\r\n                }\r\n\r\n                if (getParentNodeByType(node, \"AssignmentExpression\", [\"FunctionExpression\"])) {\r\n                    return;\r\n                }\r\n\r\n                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;\r\n\r\n                const checkNodes = [node.property];\r\n\r\n                const dot = sourceCode.getTokenBefore(node.property);\r\n\r\n                if (dot.type === \"Punctuator\" && dot.value === \".\") {\r\n                    checkNodes.push(dot);\r\n                }\r\n\r\n                checkNodesIndent(checkNodes, propertyIndent);\r\n            },\r\n\r\n            SwitchStatement(node) {\r\n\r\n                // Switch is not a 'BlockStatement'\r\n                const switchIndent = getNodeIndent(node).goodChar;\r\n                const caseIndent = expectedCaseIndent(node, switchIndent);\r\n\r\n                checkNodesIndent(node.cases, caseIndent);\r\n\r\n\r\n                checkLastNodeLineIndent(node, switchIndent);\r\n            },\r\n\r\n            SwitchCase(node) {\r\n\r\n                // Skip inline cases\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n                const caseIndent = expectedCaseIndent(node);\r\n\r\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\r\n            },\r\n\r\n            FunctionDeclaration(node) {\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n                if (options.FunctionDeclaration.parameters === \"first\" && node.params.length) {\r\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\r\n                } else if (options.FunctionDeclaration.parameters !== null) {\r\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);\r\n                }\r\n            },\r\n\r\n            FunctionExpression(node) {\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n                if (options.FunctionExpression.parameters === \"first\" && node.params.length) {\r\n                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);\r\n                } else if (options.FunctionExpression.parameters !== null) {\r\n                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);\r\n                }\r\n            },\r\n\r\n            ReturnStatement(node) {\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n\r\n                const firstLineIndent = getNodeIndent(node).goodChar;\r\n\r\n                // in case if return statement is wrapped in parenthesis\r\n                if (isWrappedInParenthesis(node)) {\r\n                    checkLastReturnStatementLineIndent(node, firstLineIndent);\r\n                } else {\r\n                    checkNodeIndent(node, firstLineIndent);\r\n                }\r\n            },\r\n\r\n            CallExpression(node) {\r\n                if (isSingleLineNode(node)) {\r\n                    return;\r\n                }\r\n                if (options.CallExpression.arguments === \"first\" && node.arguments.length) {\r\n                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);\r\n                } else if (options.CallExpression.arguments !== null) {\r\n                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);\r\n                }\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}