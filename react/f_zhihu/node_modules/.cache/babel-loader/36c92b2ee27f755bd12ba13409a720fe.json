{"ast":null,"code":"/**\r\n * @fileoverview This rule sets a specific indentation style and width for your code\r\n *\r\n * @author Teddy Katz\r\n * @author Vitaly Puzrin\r\n * @author Gyandeep Singh\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst createTree = require(\"functional-red-black-tree\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst KNOWN_NODES = new Set([\"AssignmentExpression\", \"AssignmentPattern\", \"ArrayExpression\", \"ArrayPattern\", \"ArrowFunctionExpression\", \"AwaitExpression\", \"BlockStatement\", \"BinaryExpression\", \"BreakStatement\", \"CallExpression\", \"CatchClause\", \"ChainExpression\", \"ClassBody\", \"ClassDeclaration\", \"ClassExpression\", \"ConditionalExpression\", \"ContinueStatement\", \"DoWhileStatement\", \"DebuggerStatement\", \"EmptyStatement\", \"ExperimentalRestProperty\", \"ExperimentalSpreadProperty\", \"ExpressionStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"FunctionDeclaration\", \"FunctionExpression\", \"Identifier\", \"IfStatement\", \"Literal\", \"LabeledStatement\", \"LogicalExpression\", \"MemberExpression\", \"MetaProperty\", \"MethodDefinition\", \"NewExpression\", \"ObjectExpression\", \"ObjectPattern\", \"PrivateIdentifier\", \"Program\", \"Property\", \"PropertyDefinition\", \"RestElement\", \"ReturnStatement\", \"SequenceExpression\", \"SpreadElement\", \"StaticBlock\", \"Super\", \"SwitchCase\", \"SwitchStatement\", \"TaggedTemplateExpression\", \"TemplateElement\", \"TemplateLiteral\", \"ThisExpression\", \"ThrowStatement\", \"TryStatement\", \"UnaryExpression\", \"UpdateExpression\", \"VariableDeclaration\", \"VariableDeclarator\", \"WhileStatement\", \"WithStatement\", \"YieldExpression\", \"JSXFragment\", \"JSXOpeningFragment\", \"JSXClosingFragment\", \"JSXIdentifier\", \"JSXNamespacedName\", \"JSXMemberExpression\", \"JSXEmptyExpression\", \"JSXExpressionContainer\", \"JSXElement\", \"JSXClosingElement\", \"JSXOpeningElement\", \"JSXAttribute\", \"JSXSpreadAttribute\", \"JSXText\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExportAllDeclaration\", \"ExportSpecifier\", \"ImportDeclaration\", \"ImportSpecifier\", \"ImportDefaultSpecifier\", \"ImportNamespaceSpecifier\", \"ImportExpression\"]);\n/*\r\n * General rule strategy:\r\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\r\n *    specified token or to the first column.\r\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\r\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\r\n *    brace of the BlockStatement.\r\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\r\n *    OffsetStorage container.\r\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\r\n *    and report the token if the two values are not equal.\r\n */\n\n/**\r\n * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.\r\n * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation\r\n * can easily be swapped out.\r\n */\n\nclass BinarySearchTree {\n  /**\r\n   * Creates an empty tree\r\n   */\n  constructor() {\n    this._rbTree = createTree();\n  }\n  /**\r\n   * Inserts an entry into the tree.\r\n   * @param {number} key The entry's key\r\n   * @param {any} value The entry's value\r\n   * @returns {void}\r\n   */\n\n\n  insert(key, value) {\n    const iterator = this._rbTree.find(key);\n\n    if (iterator.valid) {\n      this._rbTree = iterator.update(value);\n    } else {\n      this._rbTree = this._rbTree.insert(key, value);\n    }\n  }\n  /**\r\n   * Finds the entry with the largest key less than or equal to the provided key\r\n   * @param {number} key The provided key\r\n   * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.\r\n   */\n\n\n  findLe(key) {\n    const iterator = this._rbTree.le(key);\n\n    return iterator && {\n      key: iterator.key,\n      value: iterator.value\n    };\n  }\n  /**\r\n   * Deletes all of the keys in the interval [start, end)\r\n   * @param {number} start The start of the range\r\n   * @param {number} end The end of the range\r\n   * @returns {void}\r\n   */\n\n\n  deleteRange(start, end) {\n    // Exit without traversing the tree if the range has zero size.\n    if (start === end) {\n      return;\n    }\n\n    const iterator = this._rbTree.ge(start);\n\n    while (iterator.valid && iterator.key < end) {\n      this._rbTree = this._rbTree.remove(iterator.key);\n      iterator.next();\n    }\n  }\n\n}\n/**\r\n * A helper class to get token-based info related to indentation\r\n */\n\n\nclass TokenInfo {\n  /**\r\n   * @param {SourceCode} sourceCode A SourceCode object\r\n   */\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\n      if (!map.has(token.loc.start.line)) {\n        map.set(token.loc.start.line, token);\n      }\n\n      if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\n        map.set(token.loc.end.line, token);\n      }\n\n      return map;\n    }, new Map());\n  }\n  /**\r\n   * Gets the first token on a given token's line\r\n   * @param {Token|ASTNode} token a node or token\r\n   * @returns {Token} The first token on the given line\r\n   */\n\n\n  getFirstTokenOfLine(token) {\n    return this.firstTokensByLineNumber.get(token.loc.start.line);\n  }\n  /**\r\n   * Determines whether a token is the first token in its line\r\n   * @param {Token} token The token\r\n   * @returns {boolean} `true` if the token is the first on its line\r\n   */\n\n\n  isFirstTokenOfLine(token) {\n    return this.getFirstTokenOfLine(token) === token;\n  }\n  /**\r\n   * Get the actual indent of a token\r\n   * @param {Token} token Token to examine. This should be the first token on its line.\r\n   * @returns {string} The indentation characters that precede the token\r\n   */\n\n\n  getTokenIndent(token) {\n    return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\n  }\n\n}\n/**\r\n * A class to store information on desired offsets of tokens from each other\r\n */\n\n\nclass OffsetStorage {\n  /**\r\n   * @param {TokenInfo} tokenInfo a TokenInfo instance\r\n   * @param {number} indentSize The desired size of each indentation level\r\n   * @param {string} indentType The indentation character\r\n   */\n  constructor(tokenInfo, indentSize, indentType) {\n    this._tokenInfo = tokenInfo;\n    this._indentSize = indentSize;\n    this._indentType = indentType;\n    this._tree = new BinarySearchTree();\n\n    this._tree.insert(0, {\n      offset: 0,\n      from: null,\n      force: false\n    });\n\n    this._lockedFirstTokens = new WeakMap();\n    this._desiredIndentCache = new WeakMap();\n    this._ignoredTokens = new WeakSet();\n  }\n\n  _getOffsetDescriptor(token) {\n    return this._tree.findLe(token.range[0]).value;\n  }\n  /**\r\n   * Sets the offset column of token B to match the offset column of token A.\r\n   * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\r\n   * most cases, `setDesiredOffset` should be used instead.\r\n   * @param {Token} baseToken The first token\r\n   * @param {Token} offsetToken The second token, whose offset should be matched to the first token\r\n   * @returns {void}\r\n   */\n\n\n  matchOffsetOf(baseToken, offsetToken) {\n    /*\r\n     * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\r\n     * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\r\n     * token of each element in the array after the first will be mapped to the first token of the first\r\n     * element. The desired indentation of each of these tokens is computed based on the desired indentation\r\n     * of the \"first\" element, rather than through the normal offset mechanism.\r\n     */\n    this._lockedFirstTokens.set(offsetToken, baseToken);\n  }\n  /**\r\n   * Sets the desired offset of a token.\r\n   *\r\n   * This uses a line-based offset collapsing behavior to handle tokens on the same line.\r\n   * For example, consider the following two cases:\r\n   *\r\n   * (\r\n   *     [\r\n   *         bar\r\n   *     ]\r\n   * )\r\n   *\r\n   * ([\r\n   *     bar\r\n   * ])\r\n   *\r\n   * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\r\n   * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\r\n   * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\r\n   * from the start of its line.\r\n   *\r\n   * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\r\n   * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\r\n   * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\r\n   * by 1 indent level from the start of the line.\r\n   *\r\n   * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\r\n   * without needing to check which lines those tokens are on.\r\n   *\r\n   * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\r\n   * behavior can occur. For example, consider the following cases:\r\n   *\r\n   * foo(\r\n   * ).\r\n   *     bar(\r\n   *         baz\r\n   *     )\r\n   *\r\n   * foo(\r\n   * ).bar(\r\n   *     baz\r\n   * )\r\n   *\r\n   * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\r\n   * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\r\n   * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\r\n   * collapsing would occur).\r\n   *\r\n   * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\r\n   * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\r\n   * in the second case.\r\n   * @param {Token} token The token\r\n   * @param {Token} fromToken The token that `token` should be offset from\r\n   * @param {number} offset The desired indent level\r\n   * @returns {void}\r\n   */\n\n\n  setDesiredOffset(token, fromToken, offset) {\n    return this.setDesiredOffsets(token.range, fromToken, offset);\n  }\n  /**\r\n   * Sets the desired offset of all tokens in a range\r\n   * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\r\n   * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\r\n   * it). This means that the offset of each token is updated O(AST depth) times.\r\n   * It would not be performant to store and update the offsets for each token independently, because the rule would end\r\n   * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\r\n   *\r\n   * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\r\n   * list could represent the state of the offset tree at a given point:\r\n   *\r\n   * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file\r\n   * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\r\n   * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\r\n   * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\r\n   * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token\r\n   *\r\n   * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\r\n   * `setDesiredOffsets([30, 43], fooToken, 1);`\r\n   * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\r\n   * @param {Token} fromToken The token that this is offset from\r\n   * @param {number} offset The desired indent level\r\n   * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\r\n   * @returns {void}\r\n   */\n\n\n  setDesiredOffsets(range, fromToken, offset, force) {\n    /*\r\n     * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\r\n     * descriptor. The tree for the example above would have the following nodes:\r\n     *\r\n     * * key: 0, value: { offset: 0, from: null }\r\n     * * key: 15, value: { offset: 1, from: barToken }\r\n     * * key: 30, value: { offset: 1, from: fooToken }\r\n     * * key: 43, value: { offset: 2, from: barToken }\r\n     * * key: 820, value: { offset: 1, from: bazToken }\r\n     *\r\n     * To find the offset descriptor for any given token, one needs to find the node with the largest key\r\n     * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary\r\n     * search tree indexed by key.\r\n     */\n    const descriptorToInsert = {\n      offset,\n      from: fromToken,\n      force\n    };\n\n    const descriptorAfterRange = this._tree.findLe(range[1]).value;\n\n    const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\n\n    const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken); // First, remove any existing nodes in the range from the tree.\n\n\n    this._tree.deleteRange(range[0] + 1, range[1]); // Insert a new node into the tree for this range\n\n\n    this._tree.insert(range[0], descriptorToInsert);\n    /*\r\n     * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\r\n     * even if it's in the current range.\r\n     */\n\n\n    if (fromTokenIsInRange) {\n      this._tree.insert(fromToken.range[0], fromTokenDescriptor);\n\n      this._tree.insert(fromToken.range[1], descriptorToInsert);\n    }\n    /*\r\n     * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\r\n     * tokens the same as it was before.\r\n     */\n\n\n    this._tree.insert(range[1], descriptorAfterRange);\n  }\n  /**\r\n   * Gets the desired indent of a token\r\n   * @param {Token} token The token\r\n   * @returns {string} The desired indent of the token\r\n   */\n\n\n  getDesiredIndent(token) {\n    if (!this._desiredIndentCache.has(token)) {\n      if (this._ignoredTokens.has(token)) {\n        /*\r\n         * If the token is ignored, use the actual indent of the token as the desired indent.\r\n         * This ensures that no errors are reported for this token.\r\n         */\n        this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));\n      } else if (this._lockedFirstTokens.has(token)) {\n        const firstToken = this._lockedFirstTokens.get(token);\n\n        this._desiredIndentCache.set(token, // (indentation for the first element's line)\n        this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) + // (space between the start of the first element's line and the first element)\n        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));\n      } else {\n        const offsetInfo = this._getOffsetDescriptor(token);\n\n        const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\\s*?\\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;\n\n        this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset));\n      }\n    }\n\n    return this._desiredIndentCache.get(token);\n  }\n  /**\r\n   * Ignores a token, preventing it from being reported.\r\n   * @param {Token} token The token\r\n   * @returns {void}\r\n   */\n\n\n  ignoreToken(token) {\n    if (this._tokenInfo.isFirstTokenOfLine(token)) {\n      this._ignoredTokens.add(token);\n    }\n  }\n  /**\r\n   * Gets the first token that the given token's indentation is dependent on\r\n   * @param {Token} token The token\r\n   * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\r\n   */\n\n\n  getFirstDependency(token) {\n    return this._getOffsetDescriptor(token).from;\n  }\n\n}\n\nconst ELEMENT_LIST_SCHEMA = {\n  oneOf: [{\n    type: \"integer\",\n    minimum: 0\n  }, {\n    enum: [\"first\", \"off\"]\n  }]\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent indentation\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/indent\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"tab\"]\n      }, {\n        type: \"integer\",\n        minimum: 0\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        SwitchCase: {\n          type: \"integer\",\n          minimum: 0,\n          default: 0\n        },\n        VariableDeclarator: {\n          oneOf: [ELEMENT_LIST_SCHEMA, {\n            type: \"object\",\n            properties: {\n              var: ELEMENT_LIST_SCHEMA,\n              let: ELEMENT_LIST_SCHEMA,\n              const: ELEMENT_LIST_SCHEMA\n            },\n            additionalProperties: false\n          }]\n        },\n        outerIIFEBody: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        MemberExpression: {\n          oneOf: [{\n            type: \"integer\",\n            minimum: 0\n          }, {\n            enum: [\"off\"]\n          }]\n        },\n        FunctionDeclaration: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        FunctionExpression: {\n          type: \"object\",\n          properties: {\n            parameters: ELEMENT_LIST_SCHEMA,\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        StaticBlock: {\n          type: \"object\",\n          properties: {\n            body: {\n              type: \"integer\",\n              minimum: 0\n            }\n          },\n          additionalProperties: false\n        },\n        CallExpression: {\n          type: \"object\",\n          properties: {\n            arguments: ELEMENT_LIST_SCHEMA\n          },\n          additionalProperties: false\n        },\n        ArrayExpression: ELEMENT_LIST_SCHEMA,\n        ObjectExpression: ELEMENT_LIST_SCHEMA,\n        ImportDeclaration: ELEMENT_LIST_SCHEMA,\n        flatTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        offsetTernaryExpressions: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoredNodes: {\n          type: \"array\",\n          items: {\n            type: \"string\",\n            not: {\n              pattern: \":exit$\"\n            }\n          }\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\n    }\n  },\n\n  create(context) {\n    const DEFAULT_VARIABLE_INDENT = 1;\n    const DEFAULT_PARAMETER_INDENT = 1;\n    const DEFAULT_FUNCTION_BODY_INDENT = 1;\n    let indentType = \"space\";\n    let indentSize = 4;\n    const options = {\n      SwitchCase: 0,\n      VariableDeclarator: {\n        var: DEFAULT_VARIABLE_INDENT,\n        let: DEFAULT_VARIABLE_INDENT,\n        const: DEFAULT_VARIABLE_INDENT\n      },\n      outerIIFEBody: 1,\n      FunctionDeclaration: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      FunctionExpression: {\n        parameters: DEFAULT_PARAMETER_INDENT,\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      StaticBlock: {\n        body: DEFAULT_FUNCTION_BODY_INDENT\n      },\n      CallExpression: {\n        arguments: DEFAULT_PARAMETER_INDENT\n      },\n      MemberExpression: 1,\n      ArrayExpression: 1,\n      ObjectExpression: 1,\n      ImportDeclaration: 1,\n      flatTernaryExpressions: false,\n      ignoredNodes: [],\n      ignoreComments: false\n    };\n\n    if (context.options.length) {\n      if (context.options[0] === \"tab\") {\n        indentSize = 1;\n        indentType = \"tab\";\n      } else {\n        indentSize = context.options[0];\n        indentType = \"space\";\n      }\n\n      if (context.options[1]) {\n        Object.assign(options, context.options[1]);\n\n        if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\n          options.VariableDeclarator = {\n            var: options.VariableDeclarator,\n            let: options.VariableDeclarator,\n            const: options.VariableDeclarator\n          };\n        }\n      }\n    }\n\n    const sourceCode = context.getSourceCode();\n    const tokenInfo = new TokenInfo(sourceCode);\n    const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\");\n    const parameterParens = new WeakSet();\n    /**\r\n     * Creates an error message for a line, given the expected/actual indentation.\r\n     * @param {int} expectedAmount The expected amount of indentation characters for this line\r\n     * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\r\n     * @param {int} actualTabs The actual number of indentation tabs that were found on this line\r\n     * @returns {string} An error message for this line\r\n     */\n\n    function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\n      const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\n\n      const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\n\n      const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\n\n      let foundStatement;\n\n      if (actualSpaces > 0) {\n        /*\r\n         * Abbreviate the message if the expected indentation is also spaces.\r\n         * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\r\n         */\n        foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\n      } else if (actualTabs > 0) {\n        foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\n      } else {\n        foundStatement = \"0\";\n      }\n\n      return {\n        expected: expectedStatement,\n        actual: foundStatement\n      };\n    }\n    /**\r\n     * Reports a given indent violation\r\n     * @param {Token} token Token violating the indent rule\r\n     * @param {string} neededIndent Expected indentation string\r\n     * @returns {void}\r\n     */\n\n\n    function report(token, neededIndent) {\n      const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\n      const numSpaces = actualIndent.filter(char => char === \" \").length;\n      const numTabs = actualIndent.filter(char => char === \"\\t\").length;\n      context.report({\n        node: token,\n        messageId: \"wrongIndentation\",\n        data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\n        loc: {\n          start: {\n            line: token.loc.start.line,\n            column: 0\n          },\n          end: {\n            line: token.loc.start.line,\n            column: token.loc.start.column\n          }\n        },\n\n        fix(fixer) {\n          const range = [token.range[0] - token.loc.start.column, token.range[0]];\n          const newText = neededIndent;\n          return fixer.replaceTextRange(range, newText);\n        }\n\n      });\n    }\n    /**\r\n     * Checks if a token's indentation is correct\r\n     * @param {Token} token Token to examine\r\n     * @param {string} desiredIndent Desired indentation of the string\r\n     * @returns {boolean} `true` if the token's indentation is correct\r\n     */\n\n\n    function validateTokenIndent(token, desiredIndent) {\n      const indentation = tokenInfo.getTokenIndent(token);\n      return indentation === desiredIndent || // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\n      indentation.includes(\" \") && indentation.includes(\"\\t\");\n    }\n    /**\r\n     * Check to see if the node is a file level IIFE\r\n     * @param {ASTNode} node The function node to check.\r\n     * @returns {boolean} True if the node is the outer IIFE\r\n     */\n\n\n    function isOuterIIFE(node) {\n      /*\r\n       * Verify that the node is an IIFE\r\n       */\n      if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\n        return false;\n      }\n      /*\r\n       * Navigate legal ancestors to determine whether this IIFE is outer.\r\n       * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\r\n       * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\r\n       */\n\n\n      let statement = node.parent && node.parent.parent;\n\n      while (statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 || statement.type === \"AssignmentExpression\" || statement.type === \"LogicalExpression\" || statement.type === \"SequenceExpression\" || statement.type === \"VariableDeclarator\") {\n        statement = statement.parent;\n      }\n\n      return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\n    }\n    /**\r\n     * Counts the number of linebreaks that follow the last non-whitespace character in a string\r\n     * @param {string} string The string to check\r\n     * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\r\n     * or the total number of linebreaks if the string is all whitespace.\r\n     */\n\n\n    function countTrailingLinebreaks(string) {\n      const trailingWhitespace = string.match(/\\s*$/u)[0];\n      const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\n      return linebreakMatches === null ? 0 : linebreakMatches.length;\n    }\n    /**\r\n     * Check indentation for lists of elements (arrays, objects, function params)\r\n     * @param {ASTNode[]} elements List of elements that should be offset\r\n     * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\r\n     * @param {Token} endToken The end token of the list, e.g. ']'\r\n     * @param {number|string} offset The amount that the elements should be offset\r\n     * @returns {void}\r\n     */\n\n\n    function addElementListIndent(elements, startToken, endToken, offset) {\n      /**\r\n       * Gets the first token of a given element, including surrounding parentheses.\r\n       * @param {ASTNode} element A node in the `elements` list\r\n       * @returns {Token} The first token of this element\r\n       */\n      function getFirstToken(element) {\n        let token = sourceCode.getTokenBefore(element);\n\n        while (astUtils.isOpeningParenToken(token) && token !== startToken) {\n          token = sourceCode.getTokenBefore(token);\n        }\n\n        return sourceCode.getTokenAfter(token);\n      } // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\n\n\n      offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === \"number\" ? offset : 1);\n      offsets.setDesiredOffset(endToken, startToken, 0); // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\n\n      if (offset === \"first\" && elements.length && !elements[0]) {\n        return;\n      }\n\n      elements.forEach((element, index) => {\n        if (!element) {\n          // Skip holes in arrays\n          return;\n        }\n\n        if (offset === \"off\") {\n          // Ignore the first token of every element if the \"off\" option is used\n          offsets.ignoreToken(getFirstToken(element));\n        } // Offset the following elements correctly relative to the first element\n\n\n        if (index === 0) {\n          return;\n        }\n\n        if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\n          offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\n        } else {\n          const previousElement = elements[index - 1];\n          const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\n          const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\n\n          if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {\n            offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);\n          }\n        }\n      });\n    }\n    /**\r\n     * Check and decide whether to check for indentation for blockless nodes\r\n     * Scenarios are for or while statements without braces around them\r\n     * @param {ASTNode} node node to examine\r\n     * @returns {void}\r\n     */\n\n\n    function addBlocklessNodeIndent(node) {\n      if (node.type !== \"BlockStatement\") {\n        const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\n        let firstBodyToken = sourceCode.getFirstToken(node);\n        let lastBodyToken = sourceCode.getLastToken(node);\n\n        while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {\n          firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\n          lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\n        }\n\n        offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\n        /*\r\n         * For blockless nodes with semicolon-first style, don't indent the semicolon.\r\n         * e.g.\r\n         * if (foo) bar()\r\n         * ; [1, 2, 3].map(foo)\r\n         */\n\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\n          offsets.setDesiredOffset(lastToken, lastParentToken, 0);\n        }\n      }\n    }\n    /**\r\n     * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\r\n     * @param {ASTNode} node A CallExpression or NewExpression node\r\n     * @returns {void}\r\n     */\n\n\n    function addFunctionCallIndent(node) {\n      let openingParen;\n\n      if (node.arguments.length) {\n        openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\n      } else {\n        openingParen = sourceCode.getLastToken(node, 1);\n      }\n\n      const closingParen = sourceCode.getLastToken(node);\n      parameterParens.add(openingParen);\n      parameterParens.add(closingParen);\n      /*\r\n       * If `?.` token exists, set desired offset for that.\r\n       * This logic is copied from `MemberExpression`'s.\r\n       */\n\n      if (node.optional) {\n        const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\n        const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, {\n          skip: calleeParenCount - 1\n        }) : sourceCode.getFirstToken(node.callee);\n        const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\n        const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;\n        offsets.setDesiredOffset(dotToken, offsetBase, 1);\n      }\n\n      const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\n      const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\n      offsets.setDesiredOffset(openingParen, offsetToken, 0);\n      addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\n    }\n    /**\r\n     * Checks the indentation of parenthesized values, given a list of tokens in a program\r\n     * @param {Token[]} tokens A list of tokens\r\n     * @returns {void}\r\n     */\n\n\n    function addParensIndent(tokens) {\n      const parenStack = [];\n      const parenPairs = [];\n      tokens.forEach(nextToken => {\n        // Accumulate a list of parenthesis pairs\n        if (astUtils.isOpeningParenToken(nextToken)) {\n          parenStack.push(nextToken);\n        } else if (astUtils.isClosingParenToken(nextToken)) {\n          parenPairs.unshift({\n            left: parenStack.pop(),\n            right: nextToken\n          });\n        }\n      });\n      parenPairs.forEach(pair => {\n        const leftParen = pair.left;\n        const rightParen = pair.right; // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\n\n        if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\n          const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\n          parenthesizedTokens.forEach(token => {\n            if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\n              offsets.setDesiredOffset(token, leftParen, 1);\n            }\n          });\n        }\n\n        offsets.setDesiredOffset(rightParen, leftParen, 0);\n      });\n    }\n    /**\r\n     * Ignore all tokens within an unknown node whose offset do not depend\r\n     * on another token's offset within the unknown node\r\n     * @param {ASTNode} node Unknown Node\r\n     * @returns {void}\r\n     */\n\n\n    function ignoreNode(node) {\n      const unknownNodeTokens = new Set(sourceCode.getTokens(node, {\n        includeComments: true\n      }));\n      unknownNodeTokens.forEach(token => {\n        if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\n          const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\n\n          if (token === firstTokenOfLine) {\n            offsets.ignoreToken(token);\n          } else {\n            offsets.setDesiredOffset(token, firstTokenOfLine, 0);\n          }\n        }\n      });\n    }\n    /**\r\n     * Check whether the given token is on the first line of a statement.\r\n     * @param {Token} token The token to check.\r\n     * @param {ASTNode} leafNode The expression node that the token belongs directly.\r\n     * @returns {boolean} `true` if the token is on the first line of a statement.\r\n     */\n\n\n    function isOnFirstLineOfStatement(token, leafNode) {\n      let node = leafNode;\n\n      while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\n        node = node.parent;\n      }\n\n      node = node.parent;\n      return !node || node.loc.start.line === token.loc.start.line;\n    }\n    /**\r\n     * Check whether there are any blank (whitespace-only) lines between\r\n     * two tokens on separate lines.\r\n     * @param {Token} firstToken The first token.\r\n     * @param {Token} secondToken The second token.\r\n     * @returns {boolean} `true` if the tokens are on separate lines and\r\n     *   there exists a blank line between them, `false` otherwise.\r\n     */\n\n\n    function hasBlankLinesBetween(firstToken, secondToken) {\n      const firstTokenLine = firstToken.loc.end.line;\n      const secondTokenLine = secondToken.loc.start.line;\n\n      if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\n        return false;\n      }\n\n      for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\n        if (!tokenInfo.firstTokensByLineNumber.has(line)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    const ignoredNodeFirstTokens = new Set();\n    const baseOffsetListeners = {\n      \"ArrayExpression, ArrayPattern\"(node) {\n        const openingBracket = sourceCode.getFirstToken(node);\n        const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\n        addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\n      },\n\n      \"ObjectExpression, ObjectPattern\"(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);\n        addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\n      },\n\n      ArrowFunctionExpression(node) {\n        const maybeOpeningParen = sourceCode.getFirstToken(node, {\n          skip: node.async ? 1 : 0\n        });\n\n        if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\n          const openingParen = maybeOpeningParen;\n          const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\n          parameterParens.add(openingParen);\n          parameterParens.add(closingParen);\n          addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\n        }\n\n        addBlocklessNodeIndent(node.body);\n      },\n\n      AssignmentExpression(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(sourceCode.getTokenAfter(operator));\n      },\n\n      \"BinaryExpression, LogicalExpression\"(node) {\n        const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        /*\r\n         * For backwards compatibility, don't check BinaryExpression indents, e.g.\r\n         * var foo = bar &&\r\n         *                   baz;\r\n         */\n\n        const tokenAfterOperator = sourceCode.getTokenAfter(operator);\n        offsets.ignoreToken(operator);\n        offsets.ignoreToken(tokenAfterOperator);\n        offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\n      },\n\n      \"BlockStatement, ClassBody\"(node) {\n        let blockIndentLevel;\n\n        if (node.parent && isOuterIIFE(node.parent)) {\n          blockIndentLevel = options.outerIIFEBody;\n        } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\n          blockIndentLevel = options.FunctionExpression.body;\n        } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\n          blockIndentLevel = options.FunctionDeclaration.body;\n        } else {\n          blockIndentLevel = 1;\n        }\n        /*\r\n         * For blocks that aren't lone statements, ensure that the opening curly brace\r\n         * is aligned with the parent.\r\n         */\n\n\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\n        }\n\n        addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\n      },\n\n      CallExpression: addFunctionCallIndent,\n\n      \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\n        const classToken = sourceCode.getFirstToken(node);\n        const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\n        offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\n      },\n\n      ConditionalExpression(node) {\n        const firstToken = sourceCode.getFirstToken(node); // `flatTernaryExpressions` option is for the following style:\n        // var a =\n        //     foo > 0 ? bar :\n        //     foo < 0 ? baz :\n        //     /*else*/ qiz ;\n\n        if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {\n          const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\n          const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\n          const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\n          const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\n          const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\n          offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\n          offsets.setDesiredOffset(colonToken, firstToken, 1);\n          offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n          /*\r\n           * The alternate and the consequent should usually have the same indentation.\r\n           * If they share part of a line, align the alternate against the first token of the consequent.\r\n           * This allows the alternate to be indented correctly in cases like this:\r\n           * foo ? (\r\n           *   bar\r\n           * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\r\n           *   baz // as a result, `baz` is offset by 1 rather than 2\r\n           * )\r\n           */\n\n          if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\n            offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\n          } else {\n            /**\r\n             * If the alternate and consequent do not share part of a line, offset the alternate from the first\r\n             * token of the conditional expression. For example:\r\n             * foo ? bar\r\n             *   : baz\r\n             *\r\n             * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\r\n             * having no expected indentation.\r\n             */\n            offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" && options.offsetTernaryExpressions ? 2 : 1);\n          }\n        }\n      },\n\n      \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\n\n      ExportNamedDeclaration(node) {\n        if (node.declaration === null) {\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken); // Indent the specifiers in `export {foo, bar, baz}`\n\n          addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {\n            skip: 1\n          }), closingCurly, 1);\n\n          if (node.source) {\n            // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\n            offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\n          }\n        }\n      },\n\n      ForStatement(node) {\n        const forOpeningParen = sourceCode.getFirstToken(node, 1);\n\n        if (node.init) {\n          offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\n        }\n\n        if (node.test) {\n          offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\n        }\n\n        if (node.update) {\n          offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\n        }\n\n        addBlocklessNodeIndent(node.body);\n      },\n\n      \"FunctionDeclaration, FunctionExpression\"(node) {\n        const closingParen = sourceCode.getTokenBefore(node.body);\n        const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\n      },\n\n      IfStatement(node) {\n        addBlocklessNodeIndent(node.consequent);\n\n        if (node.alternate && node.alternate.type !== \"IfStatement\") {\n          addBlocklessNodeIndent(node.alternate);\n        }\n      },\n\n      ImportDeclaration(node) {\n        if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\n          const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\n          const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\n          addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\n        }\n\n        const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\n        const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\n        const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\n\n        if (fromToken) {\n          const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\n          offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\n        }\n      },\n\n      ImportExpression(node) {\n        const openingParen = sourceCode.getFirstToken(node, 1);\n        const closingParen = sourceCode.getLastToken(node);\n        parameterParens.add(openingParen);\n        parameterParens.add(closingParen);\n        offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\n        addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\n      },\n\n      \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\n        const object = node.type === \"MetaProperty\" ? node.meta : node.object;\n        const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\n        const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\n        const objectParenCount = sourceCode.getTokensBetween(object, node.property, {\n          filter: astUtils.isClosingParenToken\n        }).length;\n        const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {\n          skip: objectParenCount - 1\n        }) : sourceCode.getFirstToken(object);\n        const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\n        const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\n\n        if (node.computed) {\n          // For computed MemberExpressions, match the closing bracket with the opening bracket.\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\n          offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\n        }\n        /*\r\n         * If the object ends on the same line that the property starts, match against the last token\r\n         * of the object, to ensure that the MemberExpression is not indented.\r\n         *\r\n         * Otherwise, match against the first token of the object, e.g.\r\n         * foo\r\n         *   .bar\r\n         *   .baz // <-- offset by 1 from `foo`\r\n         */\n\n\n        const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;\n\n        if (typeof options.MemberExpression === \"number\") {\n          // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\n          /*\r\n           * For computed MemberExpressions, match the first token of the property against the opening bracket.\r\n           * Otherwise, match the first token of the property against the object.\r\n           */\n\n          offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\n        } else {\n          // If the MemberExpression option is off, ignore the dot and the first token of the property.\n          offsets.ignoreToken(firstNonObjectToken);\n          offsets.ignoreToken(secondNonObjectToken); // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\n\n          offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\n          offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\n        }\n      },\n\n      NewExpression(node) {\n        // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\n        if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\n          addFunctionCallIndent(node);\n        }\n      },\n\n      Property(node) {\n        if (!node.shorthand && !node.method && node.kind === \"init\") {\n          const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\n          offsets.ignoreToken(sourceCode.getTokenAfter(colon));\n        }\n      },\n\n      PropertyDefinition(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const maybeSemicolonToken = sourceCode.getLastToken(node);\n        let keyLastToken = null; // Indent key.\n\n        if (node.computed) {\n          const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);\n          const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);\n          const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];\n\n          if (bracketTokenL !== firstToken) {\n            offsets.setDesiredOffset(bracketTokenL, firstToken, 0);\n          }\n\n          offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);\n          offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);\n        } else {\n          const idToken = keyLastToken = sourceCode.getFirstToken(node.key);\n\n          if (idToken !== firstToken) {\n            offsets.setDesiredOffset(idToken, firstToken, 1);\n          }\n        } // Indent initializer.\n\n\n        if (node.value) {\n          const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);\n          const valueToken = sourceCode.getTokenAfter(eqToken);\n          offsets.setDesiredOffset(eqToken, keyLastToken, 1);\n          offsets.setDesiredOffset(valueToken, eqToken, 1);\n\n          if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n            offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);\n          }\n        } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\n          offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);\n        }\n      },\n\n      StaticBlock(node) {\n        const openingCurly = sourceCode.getFirstToken(node, {\n          skip: 1\n        }); // skip the `static` token\n\n        const closingCurly = sourceCode.getLastToken(node);\n        addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);\n      },\n\n      SwitchStatement(node) {\n        const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\n\n        if (node.cases.length) {\n          sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {\n            includeComments: true,\n            filter: astUtils.isCommentToken\n          }).forEach(token => offsets.ignoreToken(token));\n        }\n      },\n\n      SwitchCase(node) {\n        if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\n          const caseKeyword = sourceCode.getFirstToken(node);\n          const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\n          offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\n        }\n      },\n\n      TemplateLiteral(node) {\n        node.expressions.forEach((expression, index) => {\n          const previousQuasi = node.quasis[index];\n          const nextQuasi = node.quasis[index + 1];\n          const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;\n          offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\n          offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\n        });\n      },\n\n      VariableDeclaration(node) {\n        let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;\n        const firstToken = sourceCode.getFirstToken(node),\n              lastToken = sourceCode.getLastToken(node);\n\n        if (options.VariableDeclarator[node.kind] === \"first\") {\n          if (node.declarations.length > 1) {\n            addElementListIndent(node.declarations, firstToken, lastToken, \"first\");\n            return;\n          }\n\n          variableIndent = DEFAULT_VARIABLE_INDENT;\n        }\n\n        if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\n          /*\r\n           * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\r\n           * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\r\n           * the following indentations are correct:\r\n           *\r\n           * var foo = {\r\n           *   ok: true\r\n           * };\r\n           *\r\n           * var foo = {\r\n           *     ok: true,\r\n           *   },\r\n           *   bar = 1;\r\n           *\r\n           * Account for when exiting the AST (after indentations have already been set for the nodes in\r\n           * the declaration) by manually increasing the indentation level of the tokens in this declarator\r\n           * on the same line as the start of the declaration, provided that there are declarators that\r\n           * follow this one.\r\n           */\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\n        } else {\n          offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\n        }\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          offsets.ignoreToken(lastToken);\n        }\n      },\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\n          const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\n          offsets.ignoreToken(equalOperator);\n          offsets.ignoreToken(tokenAfterOperator);\n          offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\n          offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\n        }\n      },\n\n      \"JSXAttribute[value]\"(node) {\n        const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\n        offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\n      },\n\n      JSXElement(node) {\n        if (node.closingElement) {\n          addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\n        }\n      },\n\n      JSXOpeningElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        let closingToken;\n\n        if (node.selfClosing) {\n          closingToken = sourceCode.getLastToken(node, {\n            skip: 1\n          });\n          offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\n        } else {\n          closingToken = sourceCode.getLastToken(node);\n        }\n\n        offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\n        addElementListIndent(node.attributes, firstToken, closingToken, 1);\n      },\n\n      JSXClosingElement(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        offsets.setDesiredOffsets(node.name.range, firstToken, 1);\n      },\n\n      JSXFragment(node) {\n        const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\n        const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\n        addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\n      },\n\n      JSXOpeningFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const closingToken = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, closingToken);\n      },\n\n      JSXClosingFragment(node) {\n        const firstToken = sourceCode.getFirstToken(node);\n        const slashToken = sourceCode.getLastToken(node, {\n          skip: 1\n        });\n        const closingToken = sourceCode.getLastToken(node);\n        const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\n        offsets.setDesiredOffsets(node.range, firstToken, 1);\n        offsets.matchOffsetOf(firstToken, tokenToMatch);\n      },\n\n      JSXExpressionContainer(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n\n      JSXSpreadAttribute(node) {\n        const openingCurly = sourceCode.getFirstToken(node);\n        const closingCurly = sourceCode.getLastToken(node);\n        offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);\n      },\n\n      \"*\"(node) {\n        const firstToken = sourceCode.getFirstToken(node); // Ensure that the children of every node are indented at least as much as the first token.\n\n        if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\n          offsets.setDesiredOffsets(node.range, firstToken, 0);\n        }\n      }\n\n    };\n    const listenerCallQueue = [];\n    /*\r\n     * To ignore the indentation of a node:\r\n     * 1. Don't call the node's listener when entering it (if it has a listener)\r\n     * 2. Don't set any offsets against the first token of the node.\r\n     * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\r\n     */\n\n    const offsetListeners = {};\n\n    for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\n      /*\r\n       * Offset listener calls are deferred until traversal is finished, and are called as\r\n       * part of the final `Program:exit` listener. This is necessary because a node might\r\n       * be matched by multiple selectors.\r\n       *\r\n       * Example: Suppose there is an offset listener for `Identifier`, and the user has\r\n       * specified in configuration that `MemberExpression > Identifier` should be ignored.\r\n       * Due to selector specificity rules, the `Identifier` listener will get called first. However,\r\n       * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\r\n       * should not have been called at all. Without doing extra selector matching, we don't know\r\n       * whether the Identifier matches the `MemberExpression > Identifier` selector until the\r\n       * `MemberExpression > Identifier` listener is called.\r\n       *\r\n       * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\r\n       * ignored nodes are known.\r\n       */\n      offsetListeners[selector] = node => listenerCallQueue.push({\n        listener,\n        node\n      });\n    } // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\n\n\n    const ignoredNodes = new Set();\n    /**\r\n     * Ignores a node\r\n     * @param {ASTNode} node The node to ignore\r\n     * @returns {void}\r\n     */\n\n    function addToIgnoredNodes(node) {\n      ignoredNodes.add(node);\n      ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\n    }\n\n    const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {\n      [ignoredSelector]: addToIgnoredNodes\n    }), {});\n    /*\r\n     * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\r\n     * at the end.\r\n     *\r\n     * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\r\n     * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\r\n     * so those listeners wouldn't be called anyway.\r\n     */\n\n    return Object.assign(offsetListeners, ignoredNodeListeners, {\n      \"*:exit\"(node) {\n        // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\n        if (!KNOWN_NODES.has(node.type)) {\n          addToIgnoredNodes(node);\n        }\n      },\n\n      \"Program:exit\"() {\n        // If ignoreComments option is enabled, ignore all comment tokens.\n        if (options.ignoreComments) {\n          sourceCode.getAllComments().forEach(comment => offsets.ignoreToken(comment));\n        } // Invoke the queued offset listeners for the nodes that aren't ignored.\n\n\n        listenerCallQueue.filter(nodeInfo => !ignoredNodes.has(nodeInfo.node)).forEach(nodeInfo => nodeInfo.listener(nodeInfo.node)); // Update the offsets for ignored nodes to prevent their child tokens from being reported.\n\n        ignoredNodes.forEach(ignoreNode);\n        addParensIndent(sourceCode.ast.tokens);\n        /*\r\n         * Create a Map from (tokenOrComment) => (precedingToken).\r\n         * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\r\n         */\n\n        const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\n          const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {\n            includeComments: true\n          });\n          return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\n        }, new WeakMap());\n        sourceCode.lines.forEach((line, lineIndex) => {\n          const lineNumber = lineIndex + 1;\n\n          if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\n            // Don't check indentation on blank lines\n            return;\n          }\n\n          const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\n\n          if (firstTokenOfLine.loc.start.line !== lineNumber) {\n            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\n            return;\n          }\n\n          if (astUtils.isCommentToken(firstTokenOfLine)) {\n            const tokenBefore = precedingTokens.get(firstTokenOfLine);\n            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\n            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\n            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\n            /*\r\n             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\r\n             *\r\n             * let foo\r\n             * // comment\r\n             * ;(async () => {})()\r\n             */\n\n            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\n              offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\n            } // If a comment matches the expected indentation of the token immediately before or after, don't report it.\n\n\n            if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {\n              return;\n            }\n          } // If the token matches the expected indentation, don't report it.\n\n\n          if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\n            return;\n          } // Otherwise, report the token/comment.\n\n\n          report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\n        });\n      }\n\n    });\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/indent.js"],"names":["createTree","require","astUtils","KNOWN_NODES","Set","BinarySearchTree","constructor","_rbTree","insert","key","value","iterator","find","valid","update","findLe","le","deleteRange","start","end","ge","remove","next","TokenInfo","sourceCode","firstTokensByLineNumber","tokensAndComments","reduce","map","token","has","loc","line","set","text","slice","range","column","trim","Map","getFirstTokenOfLine","get","isFirstTokenOfLine","getTokenIndent","OffsetStorage","tokenInfo","indentSize","indentType","_tokenInfo","_indentSize","_indentType","_tree","offset","from","force","_lockedFirstTokens","WeakMap","_desiredIndentCache","_ignoredTokens","WeakSet","_getOffsetDescriptor","matchOffsetOf","baseToken","offsetToken","setDesiredOffset","fromToken","setDesiredOffsets","descriptorToInsert","descriptorAfterRange","fromTokenIsInRange","fromTokenDescriptor","getDesiredIndent","firstToken","repeat","offsetInfo","test","ignoreToken","add","getFirstDependency","ELEMENT_LIST_SCHEMA","oneOf","type","minimum","enum","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","SwitchCase","default","VariableDeclarator","var","let","const","additionalProperties","outerIIFEBody","MemberExpression","FunctionDeclaration","parameters","body","FunctionExpression","StaticBlock","CallExpression","arguments","ArrayExpression","ObjectExpression","ImportDeclaration","flatTernaryExpressions","offsetTernaryExpressions","ignoredNodes","items","not","pattern","ignoreComments","messages","wrongIndentation","create","context","DEFAULT_VARIABLE_INDENT","DEFAULT_PARAMETER_INDENT","DEFAULT_FUNCTION_BODY_INDENT","options","length","Object","assign","getSourceCode","offsets","parameterParens","createErrorMessageData","expectedAmount","actualSpaces","actualTabs","expectedStatement","foundSpacesWord","foundTabsWord","foundStatement","expected","actual","report","neededIndent","actualIndent","Array","numSpaces","filter","char","numTabs","node","messageId","data","fix","fixer","newText","replaceTextRange","validateTokenIndent","desiredIndent","indentation","includes","isOuterIIFE","parent","callee","statement","indexOf","operator","countTrailingLinebreaks","string","trailingWhitespace","match","linebreakMatches","createGlobalLinebreakMatcher","addElementListIndent","elements","startToken","endToken","getFirstToken","element","getTokenBefore","isOpeningParenToken","getTokenAfter","forEach","index","previousElement","firstTokenOfPreviousElement","previousElementLastToken","getLastToken","addBlocklessNodeIndent","lastParentToken","isNotOpeningParenToken","firstBodyToken","lastBodyToken","isClosingParenToken","lastToken","isSemicolonToken","addFunctionCallIndent","openingParen","getFirstTokenBetween","closingParen","optional","dotToken","isQuestionDotToken","calleeParenCount","getTokensBetween","firstTokenOfCallee","skip","lastTokenOfCallee","offsetBase","offsetAfterToken","quasi","addParensIndent","tokens","parenStack","parenPairs","nextToken","push","unshift","left","pop","right","pair","leftParen","rightParen","parenthesizedTokens","ignoreNode","unknownNodeTokens","getTokens","includeComments","firstTokenOfLine","isOnFirstLineOfStatement","leafNode","endsWith","hasBlankLinesBetween","secondToken","firstTokenLine","secondTokenLine","ignoredNodeFirstTokens","baseOffsetListeners","openingBracket","closingBracket","reverse","_","isClosingBracketToken","openingCurly","closingCurly","isClosingBraceToken","ArrowFunctionExpression","maybeOpeningParen","async","params","AssignmentExpression","tokenAfterOperator","blockIndentLevel","STATEMENT_LIST_PARENTS","classToken","extendsToken","superClass","ConditionalExpression","isTokenOnSameLine","consequent","questionMarkToken","colonToken","alternate","firstConsequentToken","lastConsequentToken","firstAlternateToken","ExportNamedDeclaration","declaration","specifiers","source","ForStatement","forOpeningParen","init","IfStatement","some","specifier","isOpeningBraceToken","sourceToken","semiToken","ImportExpression","object","firstNonObjectToken","property","isNotClosingParenToken","secondNonObjectToken","objectParenCount","firstObjectToken","lastObjectToken","firstPropertyToken","computed","NewExpression","Property","shorthand","method","kind","colon","isColonToken","PropertyDefinition","maybeSemicolonToken","keyLastToken","bracketTokenL","isOpeningBracketToken","bracketTokenR","keyRange","idToken","eqToken","isEqToken","valueToken","SwitchStatement","discriminant","cases","isCommentToken","caseKeyword","tokenAfterCurrentCase","TemplateLiteral","expressions","expression","previousQuasi","quasis","nextQuasi","tokenToAlignFrom","VariableDeclaration","variableIndent","prototype","hasOwnProperty","call","declarations","equalOperator","id","equalsToken","name","JSXElement","closingElement","children","openingElement","JSXOpeningElement","closingToken","selfClosing","attributes","JSXClosingElement","JSXFragment","firstOpeningToken","openingFragment","firstClosingToken","closingFragment","JSXOpeningFragment","JSXClosingFragment","slashToken","tokenToMatch","JSXExpressionContainer","JSXSpreadAttribute","listenerCallQueue","offsetListeners","selector","listener","entries","addToIgnoredNodes","ignoredNodeListeners","listeners","ignoredSelector","getAllComments","comment","nodeInfo","ast","precedingTokens","comments","commentMap","tokenOrCommentBefore","lines","lineIndex","lineNumber","tokenBefore","tokenAfter","mayAlignWithBefore","mayAlignWithAfter"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview This rule sets a specific indentation style and width for your code\r\n *\r\n * @author Teddy Katz\r\n * @author Vitaly Puzrin\r\n * @author Gyandeep Singh\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst createTree = require(\"functional-red-black-tree\");\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst KNOWN_NODES = new Set([\r\n    \"AssignmentExpression\",\r\n    \"AssignmentPattern\",\r\n    \"ArrayExpression\",\r\n    \"ArrayPattern\",\r\n    \"ArrowFunctionExpression\",\r\n    \"AwaitExpression\",\r\n    \"BlockStatement\",\r\n    \"BinaryExpression\",\r\n    \"BreakStatement\",\r\n    \"CallExpression\",\r\n    \"CatchClause\",\r\n    \"ChainExpression\",\r\n    \"ClassBody\",\r\n    \"ClassDeclaration\",\r\n    \"ClassExpression\",\r\n    \"ConditionalExpression\",\r\n    \"ContinueStatement\",\r\n    \"DoWhileStatement\",\r\n    \"DebuggerStatement\",\r\n    \"EmptyStatement\",\r\n    \"ExperimentalRestProperty\",\r\n    \"ExperimentalSpreadProperty\",\r\n    \"ExpressionStatement\",\r\n    \"ForStatement\",\r\n    \"ForInStatement\",\r\n    \"ForOfStatement\",\r\n    \"FunctionDeclaration\",\r\n    \"FunctionExpression\",\r\n    \"Identifier\",\r\n    \"IfStatement\",\r\n    \"Literal\",\r\n    \"LabeledStatement\",\r\n    \"LogicalExpression\",\r\n    \"MemberExpression\",\r\n    \"MetaProperty\",\r\n    \"MethodDefinition\",\r\n    \"NewExpression\",\r\n    \"ObjectExpression\",\r\n    \"ObjectPattern\",\r\n    \"PrivateIdentifier\",\r\n    \"Program\",\r\n    \"Property\",\r\n    \"PropertyDefinition\",\r\n    \"RestElement\",\r\n    \"ReturnStatement\",\r\n    \"SequenceExpression\",\r\n    \"SpreadElement\",\r\n    \"StaticBlock\",\r\n    \"Super\",\r\n    \"SwitchCase\",\r\n    \"SwitchStatement\",\r\n    \"TaggedTemplateExpression\",\r\n    \"TemplateElement\",\r\n    \"TemplateLiteral\",\r\n    \"ThisExpression\",\r\n    \"ThrowStatement\",\r\n    \"TryStatement\",\r\n    \"UnaryExpression\",\r\n    \"UpdateExpression\",\r\n    \"VariableDeclaration\",\r\n    \"VariableDeclarator\",\r\n    \"WhileStatement\",\r\n    \"WithStatement\",\r\n    \"YieldExpression\",\r\n    \"JSXFragment\",\r\n    \"JSXOpeningFragment\",\r\n    \"JSXClosingFragment\",\r\n    \"JSXIdentifier\",\r\n    \"JSXNamespacedName\",\r\n    \"JSXMemberExpression\",\r\n    \"JSXEmptyExpression\",\r\n    \"JSXExpressionContainer\",\r\n    \"JSXElement\",\r\n    \"JSXClosingElement\",\r\n    \"JSXOpeningElement\",\r\n    \"JSXAttribute\",\r\n    \"JSXSpreadAttribute\",\r\n    \"JSXText\",\r\n    \"ExportDefaultDeclaration\",\r\n    \"ExportNamedDeclaration\",\r\n    \"ExportAllDeclaration\",\r\n    \"ExportSpecifier\",\r\n    \"ImportDeclaration\",\r\n    \"ImportSpecifier\",\r\n    \"ImportDefaultSpecifier\",\r\n    \"ImportNamespaceSpecifier\",\r\n    \"ImportExpression\"\r\n]);\r\n\r\n/*\r\n * General rule strategy:\r\n * 1. An OffsetStorage instance stores a map of desired offsets, where each token has a specified offset from another\r\n *    specified token or to the first column.\r\n * 2. As the AST is traversed, modify the desired offsets of tokens accordingly. For example, when entering a\r\n *    BlockStatement, offset all of the tokens in the BlockStatement by 1 indent level from the opening curly\r\n *    brace of the BlockStatement.\r\n * 3. After traversing the AST, calculate the expected indentation levels of every token according to the\r\n *    OffsetStorage container.\r\n * 4. For each line, compare the expected indentation of the first token to the actual indentation in the file,\r\n *    and report the token if the two values are not equal.\r\n */\r\n\r\n\r\n/**\r\n * A mutable balanced binary search tree that stores (key, value) pairs. The keys are numeric, and must be unique.\r\n * This is intended to be a generic wrapper around a balanced binary search tree library, so that the underlying implementation\r\n * can easily be swapped out.\r\n */\r\nclass BinarySearchTree {\r\n\r\n    /**\r\n     * Creates an empty tree\r\n     */\r\n    constructor() {\r\n        this._rbTree = createTree();\r\n    }\r\n\r\n    /**\r\n     * Inserts an entry into the tree.\r\n     * @param {number} key The entry's key\r\n     * @param {any} value The entry's value\r\n     * @returns {void}\r\n     */\r\n    insert(key, value) {\r\n        const iterator = this._rbTree.find(key);\r\n\r\n        if (iterator.valid) {\r\n            this._rbTree = iterator.update(value);\r\n        } else {\r\n            this._rbTree = this._rbTree.insert(key, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Finds the entry with the largest key less than or equal to the provided key\r\n     * @param {number} key The provided key\r\n     * @returns {{key: number, value: *}|null} The found entry, or null if no such entry exists.\r\n     */\r\n    findLe(key) {\r\n        const iterator = this._rbTree.le(key);\r\n\r\n        return iterator && { key: iterator.key, value: iterator.value };\r\n    }\r\n\r\n    /**\r\n     * Deletes all of the keys in the interval [start, end)\r\n     * @param {number} start The start of the range\r\n     * @param {number} end The end of the range\r\n     * @returns {void}\r\n     */\r\n    deleteRange(start, end) {\r\n\r\n        // Exit without traversing the tree if the range has zero size.\r\n        if (start === end) {\r\n            return;\r\n        }\r\n        const iterator = this._rbTree.ge(start);\r\n\r\n        while (iterator.valid && iterator.key < end) {\r\n            this._rbTree = this._rbTree.remove(iterator.key);\r\n            iterator.next();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A helper class to get token-based info related to indentation\r\n */\r\nclass TokenInfo {\r\n\r\n    /**\r\n     * @param {SourceCode} sourceCode A SourceCode object\r\n     */\r\n    constructor(sourceCode) {\r\n        this.sourceCode = sourceCode;\r\n        this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {\r\n            if (!map.has(token.loc.start.line)) {\r\n                map.set(token.loc.start.line, token);\r\n            }\r\n            if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {\r\n                map.set(token.loc.end.line, token);\r\n            }\r\n            return map;\r\n        }, new Map());\r\n    }\r\n\r\n    /**\r\n     * Gets the first token on a given token's line\r\n     * @param {Token|ASTNode} token a node or token\r\n     * @returns {Token} The first token on the given line\r\n     */\r\n    getFirstTokenOfLine(token) {\r\n        return this.firstTokensByLineNumber.get(token.loc.start.line);\r\n    }\r\n\r\n    /**\r\n     * Determines whether a token is the first token in its line\r\n     * @param {Token} token The token\r\n     * @returns {boolean} `true` if the token is the first on its line\r\n     */\r\n    isFirstTokenOfLine(token) {\r\n        return this.getFirstTokenOfLine(token) === token;\r\n    }\r\n\r\n    /**\r\n     * Get the actual indent of a token\r\n     * @param {Token} token Token to examine. This should be the first token on its line.\r\n     * @returns {string} The indentation characters that precede the token\r\n     */\r\n    getTokenIndent(token) {\r\n        return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);\r\n    }\r\n}\r\n\r\n/**\r\n * A class to store information on desired offsets of tokens from each other\r\n */\r\nclass OffsetStorage {\r\n\r\n    /**\r\n     * @param {TokenInfo} tokenInfo a TokenInfo instance\r\n     * @param {number} indentSize The desired size of each indentation level\r\n     * @param {string} indentType The indentation character\r\n     */\r\n    constructor(tokenInfo, indentSize, indentType) {\r\n        this._tokenInfo = tokenInfo;\r\n        this._indentSize = indentSize;\r\n        this._indentType = indentType;\r\n\r\n        this._tree = new BinarySearchTree();\r\n        this._tree.insert(0, { offset: 0, from: null, force: false });\r\n\r\n        this._lockedFirstTokens = new WeakMap();\r\n        this._desiredIndentCache = new WeakMap();\r\n        this._ignoredTokens = new WeakSet();\r\n    }\r\n\r\n    _getOffsetDescriptor(token) {\r\n        return this._tree.findLe(token.range[0]).value;\r\n    }\r\n\r\n    /**\r\n     * Sets the offset column of token B to match the offset column of token A.\r\n     * - **WARNING**: This matches a *column*, even if baseToken is not the first token on its line. In\r\n     * most cases, `setDesiredOffset` should be used instead.\r\n     * @param {Token} baseToken The first token\r\n     * @param {Token} offsetToken The second token, whose offset should be matched to the first token\r\n     * @returns {void}\r\n     */\r\n    matchOffsetOf(baseToken, offsetToken) {\r\n\r\n        /*\r\n         * lockedFirstTokens is a map from a token whose indentation is controlled by the \"first\" option to\r\n         * the token that it depends on. For example, with the `ArrayExpression: first` option, the first\r\n         * token of each element in the array after the first will be mapped to the first token of the first\r\n         * element. The desired indentation of each of these tokens is computed based on the desired indentation\r\n         * of the \"first\" element, rather than through the normal offset mechanism.\r\n         */\r\n        this._lockedFirstTokens.set(offsetToken, baseToken);\r\n    }\r\n\r\n    /**\r\n     * Sets the desired offset of a token.\r\n     *\r\n     * This uses a line-based offset collapsing behavior to handle tokens on the same line.\r\n     * For example, consider the following two cases:\r\n     *\r\n     * (\r\n     *     [\r\n     *         bar\r\n     *     ]\r\n     * )\r\n     *\r\n     * ([\r\n     *     bar\r\n     * ])\r\n     *\r\n     * Based on the first case, it's clear that the `bar` token needs to have an offset of 1 indent level (4 spaces) from\r\n     * the `[` token, and the `[` token has to have an offset of 1 indent level from the `(` token. Since the `(` token is\r\n     * the first on its line (with an indent of 0 spaces), the `bar` token needs to be offset by 2 indent levels (8 spaces)\r\n     * from the start of its line.\r\n     *\r\n     * However, in the second case `bar` should only be indented by 4 spaces. This is because the offset of 1 indent level\r\n     * between the `(` and the `[` tokens gets \"collapsed\" because the two tokens are on the same line. As a result, the\r\n     * `(` token is mapped to the `[` token with an offset of 0, and the rule correctly decides that `bar` should be indented\r\n     * by 1 indent level from the start of the line.\r\n     *\r\n     * This is useful because rule listeners can usually just call `setDesiredOffset` for all the tokens in the node,\r\n     * without needing to check which lines those tokens are on.\r\n     *\r\n     * Note that since collapsing only occurs when two tokens are on the same line, there are a few cases where non-intuitive\r\n     * behavior can occur. For example, consider the following cases:\r\n     *\r\n     * foo(\r\n     * ).\r\n     *     bar(\r\n     *         baz\r\n     *     )\r\n     *\r\n     * foo(\r\n     * ).bar(\r\n     *     baz\r\n     * )\r\n     *\r\n     * Based on the first example, it would seem that `bar` should be offset by 1 indent level from `foo`, and `baz`\r\n     * should be offset by 1 indent level from `bar`. However, this is not correct, because it would result in `baz`\r\n     * being indented by 2 indent levels in the second case (since `foo`, `bar`, and `baz` are all on separate lines, no\r\n     * collapsing would occur).\r\n     *\r\n     * Instead, the correct way would be to offset `baz` by 1 level from `bar`, offset `bar` by 1 level from the `)`, and\r\n     * offset the `)` by 0 levels from `foo`. This ensures that the offset between `bar` and the `)` are correctly collapsed\r\n     * in the second case.\r\n     * @param {Token} token The token\r\n     * @param {Token} fromToken The token that `token` should be offset from\r\n     * @param {number} offset The desired indent level\r\n     * @returns {void}\r\n     */\r\n    setDesiredOffset(token, fromToken, offset) {\r\n        return this.setDesiredOffsets(token.range, fromToken, offset);\r\n    }\r\n\r\n    /**\r\n     * Sets the desired offset of all tokens in a range\r\n     * It's common for node listeners in this file to need to apply the same offset to a large, contiguous range of tokens.\r\n     * Moreover, the offset of any given token is usually updated multiple times (roughly once for each node that contains\r\n     * it). This means that the offset of each token is updated O(AST depth) times.\r\n     * It would not be performant to store and update the offsets for each token independently, because the rule would end\r\n     * up having a time complexity of O(number of tokens * AST depth), which is quite slow for large files.\r\n     *\r\n     * Instead, the offset tree is represented as a collection of contiguous offset ranges in a file. For example, the following\r\n     * list could represent the state of the offset tree at a given point:\r\n     *\r\n     * - Tokens starting in the interval [0, 15) are aligned with the beginning of the file\r\n     * - Tokens starting in the interval [15, 30) are offset by 1 indent level from the `bar` token\r\n     * - Tokens starting in the interval [30, 43) are offset by 1 indent level from the `foo` token\r\n     * - Tokens starting in the interval [43, 820) are offset by 2 indent levels from the `bar` token\r\n     * - Tokens starting in the interval [820, âˆž) are offset by 1 indent level from the `baz` token\r\n     *\r\n     * The `setDesiredOffsets` methods inserts ranges like the ones above. The third line above would be inserted by using:\r\n     * `setDesiredOffsets([30, 43], fooToken, 1);`\r\n     * @param {[number, number]} range A [start, end] pair. All tokens with range[0] <= token.start < range[1] will have the offset applied.\r\n     * @param {Token} fromToken The token that this is offset from\r\n     * @param {number} offset The desired indent level\r\n     * @param {boolean} force `true` if this offset should not use the normal collapsing behavior. This should almost always be false.\r\n     * @returns {void}\r\n     */\r\n    setDesiredOffsets(range, fromToken, offset, force) {\r\n\r\n        /*\r\n         * Offset ranges are stored as a collection of nodes, where each node maps a numeric key to an offset\r\n         * descriptor. The tree for the example above would have the following nodes:\r\n         *\r\n         * * key: 0, value: { offset: 0, from: null }\r\n         * * key: 15, value: { offset: 1, from: barToken }\r\n         * * key: 30, value: { offset: 1, from: fooToken }\r\n         * * key: 43, value: { offset: 2, from: barToken }\r\n         * * key: 820, value: { offset: 1, from: bazToken }\r\n         *\r\n         * To find the offset descriptor for any given token, one needs to find the node with the largest key\r\n         * which is <= token.start. To make this operation fast, the nodes are stored in a balanced binary\r\n         * search tree indexed by key.\r\n         */\r\n\r\n        const descriptorToInsert = { offset, from: fromToken, force };\r\n\r\n        const descriptorAfterRange = this._tree.findLe(range[1]).value;\r\n\r\n        const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];\r\n        const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);\r\n\r\n        // First, remove any existing nodes in the range from the tree.\r\n        this._tree.deleteRange(range[0] + 1, range[1]);\r\n\r\n        // Insert a new node into the tree for this range\r\n        this._tree.insert(range[0], descriptorToInsert);\r\n\r\n        /*\r\n         * To avoid circular offset dependencies, keep the `fromToken` token mapped to whatever it was mapped to previously,\r\n         * even if it's in the current range.\r\n         */\r\n        if (fromTokenIsInRange) {\r\n            this._tree.insert(fromToken.range[0], fromTokenDescriptor);\r\n            this._tree.insert(fromToken.range[1], descriptorToInsert);\r\n        }\r\n\r\n        /*\r\n         * To avoid modifying the offset of tokens after the range, insert another node to keep the offset of the following\r\n         * tokens the same as it was before.\r\n         */\r\n        this._tree.insert(range[1], descriptorAfterRange);\r\n    }\r\n\r\n    /**\r\n     * Gets the desired indent of a token\r\n     * @param {Token} token The token\r\n     * @returns {string} The desired indent of the token\r\n     */\r\n    getDesiredIndent(token) {\r\n        if (!this._desiredIndentCache.has(token)) {\r\n\r\n            if (this._ignoredTokens.has(token)) {\r\n\r\n                /*\r\n                 * If the token is ignored, use the actual indent of the token as the desired indent.\r\n                 * This ensures that no errors are reported for this token.\r\n                 */\r\n                this._desiredIndentCache.set(\r\n                    token,\r\n                    this._tokenInfo.getTokenIndent(token)\r\n                );\r\n            } else if (this._lockedFirstTokens.has(token)) {\r\n                const firstToken = this._lockedFirstTokens.get(token);\r\n\r\n                this._desiredIndentCache.set(\r\n                    token,\r\n\r\n                    // (indentation for the first element's line)\r\n                    this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) +\r\n\r\n                        // (space between the start of the first element's line and the first element)\r\n                        this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column)\r\n                );\r\n            } else {\r\n                const offsetInfo = this._getOffsetDescriptor(token);\r\n                const offset = (\r\n                    offsetInfo.from &&\r\n                    offsetInfo.from.loc.start.line === token.loc.start.line &&\r\n                    !/^\\s*?\\n/u.test(token.value) &&\r\n                    !offsetInfo.force\r\n                ) ? 0 : offsetInfo.offset * this._indentSize;\r\n\r\n                this._desiredIndentCache.set(\r\n                    token,\r\n                    (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : \"\") + this._indentType.repeat(offset)\r\n                );\r\n            }\r\n        }\r\n        return this._desiredIndentCache.get(token);\r\n    }\r\n\r\n    /**\r\n     * Ignores a token, preventing it from being reported.\r\n     * @param {Token} token The token\r\n     * @returns {void}\r\n     */\r\n    ignoreToken(token) {\r\n        if (this._tokenInfo.isFirstTokenOfLine(token)) {\r\n            this._ignoredTokens.add(token);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the first token that the given token's indentation is dependent on\r\n     * @param {Token} token The token\r\n     * @returns {Token} The token that the given token depends on, or `null` if the given token is at the top level\r\n     */\r\n    getFirstDependency(token) {\r\n        return this._getOffsetDescriptor(token).from;\r\n    }\r\n}\r\n\r\nconst ELEMENT_LIST_SCHEMA = {\r\n    oneOf: [\r\n        {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        },\r\n        {\r\n            enum: [\"first\", \"off\"]\r\n        }\r\n    ]\r\n};\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent indentation\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/indent\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"tab\"]\r\n                    },\r\n                    {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    SwitchCase: {\r\n                        type: \"integer\",\r\n                        minimum: 0,\r\n                        default: 0\r\n                    },\r\n                    VariableDeclarator: {\r\n                        oneOf: [\r\n                            ELEMENT_LIST_SCHEMA,\r\n                            {\r\n                                type: \"object\",\r\n                                properties: {\r\n                                    var: ELEMENT_LIST_SCHEMA,\r\n                                    let: ELEMENT_LIST_SCHEMA,\r\n                                    const: ELEMENT_LIST_SCHEMA\r\n                                },\r\n                                additionalProperties: false\r\n                            }\r\n                        ]\r\n                    },\r\n                    outerIIFEBody: {\r\n                        oneOf: [\r\n                            {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            {\r\n                                enum: [\"off\"]\r\n                            }\r\n                        ]\r\n                    },\r\n                    MemberExpression: {\r\n                        oneOf: [\r\n                            {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            {\r\n                                enum: [\"off\"]\r\n                            }\r\n                        ]\r\n                    },\r\n                    FunctionDeclaration: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            parameters: ELEMENT_LIST_SCHEMA,\r\n                            body: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    FunctionExpression: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            parameters: ELEMENT_LIST_SCHEMA,\r\n                            body: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    StaticBlock: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            body: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    CallExpression: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            arguments: ELEMENT_LIST_SCHEMA\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    ArrayExpression: ELEMENT_LIST_SCHEMA,\r\n                    ObjectExpression: ELEMENT_LIST_SCHEMA,\r\n                    ImportDeclaration: ELEMENT_LIST_SCHEMA,\r\n                    flatTernaryExpressions: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    offsetTernaryExpressions: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoredNodes: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\",\r\n                            not: {\r\n                                pattern: \":exit$\"\r\n                            }\r\n                        }\r\n                    },\r\n                    ignoreComments: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            wrongIndentation: \"Expected indentation of {{expected}} but found {{actual}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const DEFAULT_VARIABLE_INDENT = 1;\r\n        const DEFAULT_PARAMETER_INDENT = 1;\r\n        const DEFAULT_FUNCTION_BODY_INDENT = 1;\r\n\r\n        let indentType = \"space\";\r\n        let indentSize = 4;\r\n        const options = {\r\n            SwitchCase: 0,\r\n            VariableDeclarator: {\r\n                var: DEFAULT_VARIABLE_INDENT,\r\n                let: DEFAULT_VARIABLE_INDENT,\r\n                const: DEFAULT_VARIABLE_INDENT\r\n            },\r\n            outerIIFEBody: 1,\r\n            FunctionDeclaration: {\r\n                parameters: DEFAULT_PARAMETER_INDENT,\r\n                body: DEFAULT_FUNCTION_BODY_INDENT\r\n            },\r\n            FunctionExpression: {\r\n                parameters: DEFAULT_PARAMETER_INDENT,\r\n                body: DEFAULT_FUNCTION_BODY_INDENT\r\n            },\r\n            StaticBlock: {\r\n                body: DEFAULT_FUNCTION_BODY_INDENT\r\n            },\r\n            CallExpression: {\r\n                arguments: DEFAULT_PARAMETER_INDENT\r\n            },\r\n            MemberExpression: 1,\r\n            ArrayExpression: 1,\r\n            ObjectExpression: 1,\r\n            ImportDeclaration: 1,\r\n            flatTernaryExpressions: false,\r\n            ignoredNodes: [],\r\n            ignoreComments: false\r\n        };\r\n\r\n        if (context.options.length) {\r\n            if (context.options[0] === \"tab\") {\r\n                indentSize = 1;\r\n                indentType = \"tab\";\r\n            } else {\r\n                indentSize = context.options[0];\r\n                indentType = \"space\";\r\n            }\r\n\r\n            if (context.options[1]) {\r\n                Object.assign(options, context.options[1]);\r\n\r\n                if (typeof options.VariableDeclarator === \"number\" || options.VariableDeclarator === \"first\") {\r\n                    options.VariableDeclarator = {\r\n                        var: options.VariableDeclarator,\r\n                        let: options.VariableDeclarator,\r\n                        const: options.VariableDeclarator\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        const sourceCode = context.getSourceCode();\r\n        const tokenInfo = new TokenInfo(sourceCode);\r\n        const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === \"space\" ? \" \" : \"\\t\");\r\n        const parameterParens = new WeakSet();\r\n\r\n        /**\r\n         * Creates an error message for a line, given the expected/actual indentation.\r\n         * @param {int} expectedAmount The expected amount of indentation characters for this line\r\n         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line\r\n         * @param {int} actualTabs The actual number of indentation tabs that were found on this line\r\n         * @returns {string} An error message for this line\r\n         */\r\n        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {\r\n            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? \"\" : \"s\"}`; // e.g. \"2 tabs\"\r\n            const foundSpacesWord = `space${actualSpaces === 1 ? \"\" : \"s\"}`; // e.g. \"space\"\r\n            const foundTabsWord = `tab${actualTabs === 1 ? \"\" : \"s\"}`; // e.g. \"tabs\"\r\n            let foundStatement;\r\n\r\n            if (actualSpaces > 0) {\r\n\r\n                /*\r\n                 * Abbreviate the message if the expected indentation is also spaces.\r\n                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'\r\n                 */\r\n                foundStatement = indentType === \"space\" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;\r\n            } else if (actualTabs > 0) {\r\n                foundStatement = indentType === \"tab\" ? actualTabs : `${actualTabs} ${foundTabsWord}`;\r\n            } else {\r\n                foundStatement = \"0\";\r\n            }\r\n            return {\r\n                expected: expectedStatement,\r\n                actual: foundStatement\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Reports a given indent violation\r\n         * @param {Token} token Token violating the indent rule\r\n         * @param {string} neededIndent Expected indentation string\r\n         * @returns {void}\r\n         */\r\n        function report(token, neededIndent) {\r\n            const actualIndent = Array.from(tokenInfo.getTokenIndent(token));\r\n            const numSpaces = actualIndent.filter(char => char === \" \").length;\r\n            const numTabs = actualIndent.filter(char => char === \"\\t\").length;\r\n\r\n            context.report({\r\n                node: token,\r\n                messageId: \"wrongIndentation\",\r\n                data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),\r\n                loc: {\r\n                    start: { line: token.loc.start.line, column: 0 },\r\n                    end: { line: token.loc.start.line, column: token.loc.start.column }\r\n                },\r\n                fix(fixer) {\r\n                    const range = [token.range[0] - token.loc.start.column, token.range[0]];\r\n                    const newText = neededIndent;\r\n\r\n                    return fixer.replaceTextRange(range, newText);\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks if a token's indentation is correct\r\n         * @param {Token} token Token to examine\r\n         * @param {string} desiredIndent Desired indentation of the string\r\n         * @returns {boolean} `true` if the token's indentation is correct\r\n         */\r\n        function validateTokenIndent(token, desiredIndent) {\r\n            const indentation = tokenInfo.getTokenIndent(token);\r\n\r\n            return indentation === desiredIndent ||\r\n\r\n                // To avoid conflicts with no-mixed-spaces-and-tabs, don't report mixed spaces and tabs.\r\n                indentation.includes(\" \") && indentation.includes(\"\\t\");\r\n        }\r\n\r\n        /**\r\n         * Check to see if the node is a file level IIFE\r\n         * @param {ASTNode} node The function node to check.\r\n         * @returns {boolean} True if the node is the outer IIFE\r\n         */\r\n        function isOuterIIFE(node) {\r\n\r\n            /*\r\n             * Verify that the node is an IIFE\r\n             */\r\n            if (!node.parent || node.parent.type !== \"CallExpression\" || node.parent.callee !== node) {\r\n                return false;\r\n            }\r\n\r\n            /*\r\n             * Navigate legal ancestors to determine whether this IIFE is outer.\r\n             * A \"legal ancestor\" is an expression or statement that causes the function to get executed immediately.\r\n             * For example, `!(function(){})()` is an outer IIFE even though it is preceded by a ! operator.\r\n             */\r\n            let statement = node.parent && node.parent.parent;\r\n\r\n            while (\r\n                statement.type === \"UnaryExpression\" && [\"!\", \"~\", \"+\", \"-\"].indexOf(statement.operator) > -1 ||\r\n                statement.type === \"AssignmentExpression\" ||\r\n                statement.type === \"LogicalExpression\" ||\r\n                statement.type === \"SequenceExpression\" ||\r\n                statement.type === \"VariableDeclarator\"\r\n            ) {\r\n                statement = statement.parent;\r\n            }\r\n\r\n            return (statement.type === \"ExpressionStatement\" || statement.type === \"VariableDeclaration\") && statement.parent.type === \"Program\";\r\n        }\r\n\r\n        /**\r\n         * Counts the number of linebreaks that follow the last non-whitespace character in a string\r\n         * @param {string} string The string to check\r\n         * @returns {number} The number of JavaScript linebreaks that follow the last non-whitespace character,\r\n         * or the total number of linebreaks if the string is all whitespace.\r\n         */\r\n        function countTrailingLinebreaks(string) {\r\n            const trailingWhitespace = string.match(/\\s*$/u)[0];\r\n            const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());\r\n\r\n            return linebreakMatches === null ? 0 : linebreakMatches.length;\r\n        }\r\n\r\n        /**\r\n         * Check indentation for lists of elements (arrays, objects, function params)\r\n         * @param {ASTNode[]} elements List of elements that should be offset\r\n         * @param {Token} startToken The start token of the list that element should be aligned against, e.g. '['\r\n         * @param {Token} endToken The end token of the list, e.g. ']'\r\n         * @param {number|string} offset The amount that the elements should be offset\r\n         * @returns {void}\r\n         */\r\n        function addElementListIndent(elements, startToken, endToken, offset) {\r\n\r\n            /**\r\n             * Gets the first token of a given element, including surrounding parentheses.\r\n             * @param {ASTNode} element A node in the `elements` list\r\n             * @returns {Token} The first token of this element\r\n             */\r\n            function getFirstToken(element) {\r\n                let token = sourceCode.getTokenBefore(element);\r\n\r\n                while (astUtils.isOpeningParenToken(token) && token !== startToken) {\r\n                    token = sourceCode.getTokenBefore(token);\r\n                }\r\n                return sourceCode.getTokenAfter(token);\r\n            }\r\n\r\n            // Run through all the tokens in the list, and offset them by one indent level (mainly for comments, other things will end up overridden)\r\n            offsets.setDesiredOffsets(\r\n                [startToken.range[1], endToken.range[0]],\r\n                startToken,\r\n                typeof offset === \"number\" ? offset : 1\r\n            );\r\n            offsets.setDesiredOffset(endToken, startToken, 0);\r\n\r\n            // If the preference is \"first\" but there is no first element (e.g. sparse arrays w/ empty first slot), fall back to 1 level.\r\n            if (offset === \"first\" && elements.length && !elements[0]) {\r\n                return;\r\n            }\r\n            elements.forEach((element, index) => {\r\n                if (!element) {\r\n\r\n                    // Skip holes in arrays\r\n                    return;\r\n                }\r\n                if (offset === \"off\") {\r\n\r\n                    // Ignore the first token of every element if the \"off\" option is used\r\n                    offsets.ignoreToken(getFirstToken(element));\r\n                }\r\n\r\n                // Offset the following elements correctly relative to the first element\r\n                if (index === 0) {\r\n                    return;\r\n                }\r\n                if (offset === \"first\" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {\r\n                    offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));\r\n                } else {\r\n                    const previousElement = elements[index - 1];\r\n                    const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);\r\n                    const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);\r\n\r\n                    if (\r\n                        previousElement &&\r\n                        previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line\r\n                    ) {\r\n                        offsets.setDesiredOffsets(\r\n                            [previousElement.range[1], element.range[1]],\r\n                            firstTokenOfPreviousElement,\r\n                            0\r\n                        );\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check and decide whether to check for indentation for blockless nodes\r\n         * Scenarios are for or while statements without braces around them\r\n         * @param {ASTNode} node node to examine\r\n         * @returns {void}\r\n         */\r\n        function addBlocklessNodeIndent(node) {\r\n            if (node.type !== \"BlockStatement\") {\r\n                const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);\r\n\r\n                let firstBodyToken = sourceCode.getFirstToken(node);\r\n                let lastBodyToken = sourceCode.getLastToken(node);\r\n\r\n                while (\r\n                    astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) &&\r\n                    astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))\r\n                ) {\r\n                    firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);\r\n                    lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);\r\n                }\r\n\r\n                offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);\r\n\r\n                /*\r\n                 * For blockless nodes with semicolon-first style, don't indent the semicolon.\r\n                 * e.g.\r\n                 * if (foo) bar()\r\n                 * ; [1, 2, 3].map(foo)\r\n                 */\r\n                const lastToken = sourceCode.getLastToken(node);\r\n\r\n                if (node.type !== \"EmptyStatement\" && astUtils.isSemicolonToken(lastToken)) {\r\n                    offsets.setDesiredOffset(lastToken, lastParentToken, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the indentation for nodes that are like function calls (`CallExpression` and `NewExpression`)\r\n         * @param {ASTNode} node A CallExpression or NewExpression node\r\n         * @returns {void}\r\n         */\r\n        function addFunctionCallIndent(node) {\r\n            let openingParen;\r\n\r\n            if (node.arguments.length) {\r\n                openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);\r\n            } else {\r\n                openingParen = sourceCode.getLastToken(node, 1);\r\n            }\r\n            const closingParen = sourceCode.getLastToken(node);\r\n\r\n            parameterParens.add(openingParen);\r\n            parameterParens.add(closingParen);\r\n\r\n            /*\r\n             * If `?.` token exists, set desired offset for that.\r\n             * This logic is copied from `MemberExpression`'s.\r\n             */\r\n            if (node.optional) {\r\n                const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);\r\n                const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, { filter: astUtils.isClosingParenToken }).length;\r\n                const firstTokenOfCallee = calleeParenCount\r\n                    ? sourceCode.getTokenBefore(node.callee, { skip: calleeParenCount - 1 })\r\n                    : sourceCode.getFirstToken(node.callee);\r\n                const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);\r\n                const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line\r\n                    ? lastTokenOfCallee\r\n                    : firstTokenOfCallee;\r\n\r\n                offsets.setDesiredOffset(dotToken, offsetBase, 1);\r\n            }\r\n\r\n            const offsetAfterToken = node.callee.type === \"TaggedTemplateExpression\" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;\r\n            const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);\r\n\r\n            offsets.setDesiredOffset(openingParen, offsetToken, 0);\r\n\r\n            addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);\r\n        }\r\n\r\n        /**\r\n         * Checks the indentation of parenthesized values, given a list of tokens in a program\r\n         * @param {Token[]} tokens A list of tokens\r\n         * @returns {void}\r\n         */\r\n        function addParensIndent(tokens) {\r\n            const parenStack = [];\r\n            const parenPairs = [];\r\n\r\n            tokens.forEach(nextToken => {\r\n\r\n                // Accumulate a list of parenthesis pairs\r\n                if (astUtils.isOpeningParenToken(nextToken)) {\r\n                    parenStack.push(nextToken);\r\n                } else if (astUtils.isClosingParenToken(nextToken)) {\r\n                    parenPairs.unshift({ left: parenStack.pop(), right: nextToken });\r\n                }\r\n            });\r\n\r\n            parenPairs.forEach(pair => {\r\n                const leftParen = pair.left;\r\n                const rightParen = pair.right;\r\n\r\n                // We only want to handle parens around expressions, so exclude parentheses that are in function parameters and function call arguments.\r\n                if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {\r\n                    const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));\r\n\r\n                    parenthesizedTokens.forEach(token => {\r\n                        if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {\r\n                            offsets.setDesiredOffset(token, leftParen, 1);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                offsets.setDesiredOffset(rightParen, leftParen, 0);\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Ignore all tokens within an unknown node whose offset do not depend\r\n         * on another token's offset within the unknown node\r\n         * @param {ASTNode} node Unknown Node\r\n         * @returns {void}\r\n         */\r\n        function ignoreNode(node) {\r\n            const unknownNodeTokens = new Set(sourceCode.getTokens(node, { includeComments: true }));\r\n\r\n            unknownNodeTokens.forEach(token => {\r\n                if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {\r\n                    const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);\r\n\r\n                    if (token === firstTokenOfLine) {\r\n                        offsets.ignoreToken(token);\r\n                    } else {\r\n                        offsets.setDesiredOffset(token, firstTokenOfLine, 0);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check whether the given token is on the first line of a statement.\r\n         * @param {Token} token The token to check.\r\n         * @param {ASTNode} leafNode The expression node that the token belongs directly.\r\n         * @returns {boolean} `true` if the token is on the first line of a statement.\r\n         */\r\n        function isOnFirstLineOfStatement(token, leafNode) {\r\n            let node = leafNode;\r\n\r\n            while (node.parent && !node.parent.type.endsWith(\"Statement\") && !node.parent.type.endsWith(\"Declaration\")) {\r\n                node = node.parent;\r\n            }\r\n            node = node.parent;\r\n\r\n            return !node || node.loc.start.line === token.loc.start.line;\r\n        }\r\n\r\n        /**\r\n         * Check whether there are any blank (whitespace-only) lines between\r\n         * two tokens on separate lines.\r\n         * @param {Token} firstToken The first token.\r\n         * @param {Token} secondToken The second token.\r\n         * @returns {boolean} `true` if the tokens are on separate lines and\r\n         *   there exists a blank line between them, `false` otherwise.\r\n         */\r\n        function hasBlankLinesBetween(firstToken, secondToken) {\r\n            const firstTokenLine = firstToken.loc.end.line;\r\n            const secondTokenLine = secondToken.loc.start.line;\r\n\r\n            if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {\r\n                return false;\r\n            }\r\n\r\n            for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {\r\n                if (!tokenInfo.firstTokensByLineNumber.has(line)) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        const ignoredNodeFirstTokens = new Set();\r\n\r\n        const baseOffsetListeners = {\r\n            \"ArrayExpression, ArrayPattern\"(node) {\r\n                const openingBracket = sourceCode.getFirstToken(node);\r\n                const closingBracket = sourceCode.getTokenAfter([...node.elements].reverse().find(_ => _) || openingBracket, astUtils.isClosingBracketToken);\r\n\r\n                addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);\r\n            },\r\n\r\n            \"ObjectExpression, ObjectPattern\"(node) {\r\n                const openingCurly = sourceCode.getFirstToken(node);\r\n                const closingCurly = sourceCode.getTokenAfter(\r\n                    node.properties.length ? node.properties[node.properties.length - 1] : openingCurly,\r\n                    astUtils.isClosingBraceToken\r\n                );\r\n\r\n                addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);\r\n            },\r\n\r\n            ArrowFunctionExpression(node) {\r\n                const maybeOpeningParen = sourceCode.getFirstToken(node, { skip: node.async ? 1 : 0 });\r\n\r\n                if (astUtils.isOpeningParenToken(maybeOpeningParen)) {\r\n                    const openingParen = maybeOpeningParen;\r\n                    const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);\r\n\r\n                    parameterParens.add(openingParen);\r\n                    parameterParens.add(closingParen);\r\n                    addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);\r\n                }\r\n\r\n                addBlocklessNodeIndent(node.body);\r\n            },\r\n\r\n            AssignmentExpression(node) {\r\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\r\n\r\n                offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);\r\n                offsets.ignoreToken(operator);\r\n                offsets.ignoreToken(sourceCode.getTokenAfter(operator));\r\n            },\r\n\r\n            \"BinaryExpression, LogicalExpression\"(node) {\r\n                const operator = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\r\n\r\n                /*\r\n                 * For backwards compatibility, don't check BinaryExpression indents, e.g.\r\n                 * var foo = bar &&\r\n                 *                   baz;\r\n                 */\r\n\r\n                const tokenAfterOperator = sourceCode.getTokenAfter(operator);\r\n\r\n                offsets.ignoreToken(operator);\r\n                offsets.ignoreToken(tokenAfterOperator);\r\n                offsets.setDesiredOffset(tokenAfterOperator, operator, 0);\r\n            },\r\n\r\n            \"BlockStatement, ClassBody\"(node) {\r\n                let blockIndentLevel;\r\n\r\n                if (node.parent && isOuterIIFE(node.parent)) {\r\n                    blockIndentLevel = options.outerIIFEBody;\r\n                } else if (node.parent && (node.parent.type === \"FunctionExpression\" || node.parent.type === \"ArrowFunctionExpression\")) {\r\n                    blockIndentLevel = options.FunctionExpression.body;\r\n                } else if (node.parent && node.parent.type === \"FunctionDeclaration\") {\r\n                    blockIndentLevel = options.FunctionDeclaration.body;\r\n                } else {\r\n                    blockIndentLevel = 1;\r\n                }\r\n\r\n                /*\r\n                 * For blocks that aren't lone statements, ensure that the opening curly brace\r\n                 * is aligned with the parent.\r\n                 */\r\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\r\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);\r\n                }\r\n\r\n                addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);\r\n            },\r\n\r\n            CallExpression: addFunctionCallIndent,\r\n\r\n            \"ClassDeclaration[superClass], ClassExpression[superClass]\"(node) {\r\n                const classToken = sourceCode.getFirstToken(node);\r\n                const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);\r\n\r\n                offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);\r\n            },\r\n\r\n            ConditionalExpression(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n\r\n                // `flatTernaryExpressions` option is for the following style:\r\n                // var a =\r\n                //     foo > 0 ? bar :\r\n                //     foo < 0 ? baz :\r\n                //     /*else*/ qiz ;\r\n                if (!options.flatTernaryExpressions ||\r\n                    !astUtils.isTokenOnSameLine(node.test, node.consequent) ||\r\n                    isOnFirstLineOfStatement(firstToken, node)\r\n                ) {\r\n                    const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, token => token.type === \"Punctuator\" && token.value === \"?\");\r\n                    const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, token => token.type === \"Punctuator\" && token.value === \":\");\r\n\r\n                    const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);\r\n                    const lastConsequentToken = sourceCode.getTokenBefore(colonToken);\r\n                    const firstAlternateToken = sourceCode.getTokenAfter(colonToken);\r\n\r\n                    offsets.setDesiredOffset(questionMarkToken, firstToken, 1);\r\n                    offsets.setDesiredOffset(colonToken, firstToken, 1);\r\n\r\n                    offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === \"Punctuator\" &&\r\n                        options.offsetTernaryExpressions ? 2 : 1);\r\n\r\n                    /*\r\n                     * The alternate and the consequent should usually have the same indentation.\r\n                     * If they share part of a line, align the alternate against the first token of the consequent.\r\n                     * This allows the alternate to be indented correctly in cases like this:\r\n                     * foo ? (\r\n                     *   bar\r\n                     * ) : ( // this '(' is aligned with the '(' above, so it's considered to be aligned with `foo`\r\n                     *   baz // as a result, `baz` is offset by 1 rather than 2\r\n                     * )\r\n                     */\r\n                    if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {\r\n                        offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);\r\n                    } else {\r\n\r\n                        /**\r\n                         * If the alternate and consequent do not share part of a line, offset the alternate from the first\r\n                         * token of the conditional expression. For example:\r\n                         * foo ? bar\r\n                         *   : baz\r\n                         *\r\n                         * If `baz` were aligned with `bar` rather than being offset by 1 from `foo`, `baz` would end up\r\n                         * having no expected indentation.\r\n                         */\r\n                        offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === \"Punctuator\" &&\r\n                            options.offsetTernaryExpressions ? 2 : 1);\r\n                    }\r\n                }\r\n            },\r\n\r\n            \"DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement\": node => addBlocklessNodeIndent(node.body),\r\n\r\n            ExportNamedDeclaration(node) {\r\n                if (node.declaration === null) {\r\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\r\n\r\n                    // Indent the specifiers in `export {foo, bar, baz}`\r\n                    addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, { skip: 1 }), closingCurly, 1);\r\n\r\n                    if (node.source) {\r\n\r\n                        // Indent everything after and including the `from` token in `export {foo, bar, baz} from 'qux'`\r\n                        offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);\r\n                    }\r\n                }\r\n            },\r\n\r\n            ForStatement(node) {\r\n                const forOpeningParen = sourceCode.getFirstToken(node, 1);\r\n\r\n                if (node.init) {\r\n                    offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);\r\n                }\r\n                if (node.test) {\r\n                    offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);\r\n                }\r\n                if (node.update) {\r\n                    offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);\r\n                }\r\n                addBlocklessNodeIndent(node.body);\r\n            },\r\n\r\n            \"FunctionDeclaration, FunctionExpression\"(node) {\r\n                const closingParen = sourceCode.getTokenBefore(node.body);\r\n                const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);\r\n\r\n                parameterParens.add(openingParen);\r\n                parameterParens.add(closingParen);\r\n                addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);\r\n            },\r\n\r\n            IfStatement(node) {\r\n                addBlocklessNodeIndent(node.consequent);\r\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\r\n                    addBlocklessNodeIndent(node.alternate);\r\n                }\r\n            },\r\n\r\n            ImportDeclaration(node) {\r\n                if (node.specifiers.some(specifier => specifier.type === \"ImportSpecifier\")) {\r\n                    const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);\r\n                    const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);\r\n\r\n                    addElementListIndent(node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\"), openingCurly, closingCurly, options.ImportDeclaration);\r\n                }\r\n\r\n                const fromToken = sourceCode.getLastToken(node, token => token.type === \"Identifier\" && token.value === \"from\");\r\n                const sourceToken = sourceCode.getLastToken(node, token => token.type === \"String\");\r\n                const semiToken = sourceCode.getLastToken(node, token => token.type === \"Punctuator\" && token.value === \";\");\r\n\r\n                if (fromToken) {\r\n                    const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];\r\n\r\n                    offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);\r\n                }\r\n            },\r\n\r\n            ImportExpression(node) {\r\n                const openingParen = sourceCode.getFirstToken(node, 1);\r\n                const closingParen = sourceCode.getLastToken(node);\r\n\r\n                parameterParens.add(openingParen);\r\n                parameterParens.add(closingParen);\r\n                offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);\r\n\r\n                addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);\r\n            },\r\n\r\n            \"MemberExpression, JSXMemberExpression, MetaProperty\"(node) {\r\n                const object = node.type === \"MetaProperty\" ? node.meta : node.object;\r\n                const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);\r\n                const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);\r\n\r\n                const objectParenCount = sourceCode.getTokensBetween(object, node.property, { filter: astUtils.isClosingParenToken }).length;\r\n                const firstObjectToken = objectParenCount\r\n                    ? sourceCode.getTokenBefore(object, { skip: objectParenCount - 1 })\r\n                    : sourceCode.getFirstToken(object);\r\n                const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);\r\n                const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;\r\n\r\n                if (node.computed) {\r\n\r\n                    // For computed MemberExpressions, match the closing bracket with the opening bracket.\r\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);\r\n                    offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);\r\n                }\r\n\r\n                /*\r\n                 * If the object ends on the same line that the property starts, match against the last token\r\n                 * of the object, to ensure that the MemberExpression is not indented.\r\n                 *\r\n                 * Otherwise, match against the first token of the object, e.g.\r\n                 * foo\r\n                 *   .bar\r\n                 *   .baz // <-- offset by 1 from `foo`\r\n                 */\r\n                const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line\r\n                    ? lastObjectToken\r\n                    : firstObjectToken;\r\n\r\n                if (typeof options.MemberExpression === \"number\") {\r\n\r\n                    // Match the dot (for non-computed properties) or the opening bracket (for computed properties) against the object.\r\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);\r\n\r\n                    /*\r\n                     * For computed MemberExpressions, match the first token of the property against the opening bracket.\r\n                     * Otherwise, match the first token of the property against the object.\r\n                     */\r\n                    offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);\r\n                } else {\r\n\r\n                    // If the MemberExpression option is off, ignore the dot and the first token of the property.\r\n                    offsets.ignoreToken(firstNonObjectToken);\r\n                    offsets.ignoreToken(secondNonObjectToken);\r\n\r\n                    // To ignore the property indentation, ensure that the property tokens depend on the ignored tokens.\r\n                    offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);\r\n                    offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);\r\n                }\r\n            },\r\n\r\n            NewExpression(node) {\r\n\r\n                // Only indent the arguments if the NewExpression has parens (e.g. `new Foo(bar)` or `new Foo()`, but not `new Foo`\r\n                if (node.arguments.length > 0 ||\r\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node)) &&\r\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {\r\n                    addFunctionCallIndent(node);\r\n                }\r\n            },\r\n\r\n            Property(node) {\r\n                if (!node.shorthand && !node.method && node.kind === \"init\") {\r\n                    const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);\r\n\r\n                    offsets.ignoreToken(sourceCode.getTokenAfter(colon));\r\n                }\r\n            },\r\n\r\n            PropertyDefinition(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n                const maybeSemicolonToken = sourceCode.getLastToken(node);\r\n                let keyLastToken = null;\r\n\r\n                // Indent key.\r\n                if (node.computed) {\r\n                    const bracketTokenL = sourceCode.getTokenBefore(node.key, astUtils.isOpeningBracketToken);\r\n                    const bracketTokenR = keyLastToken = sourceCode.getTokenAfter(node.key, astUtils.isClosingBracketToken);\r\n                    const keyRange = [bracketTokenL.range[1], bracketTokenR.range[0]];\r\n\r\n                    if (bracketTokenL !== firstToken) {\r\n                        offsets.setDesiredOffset(bracketTokenL, firstToken, 0);\r\n                    }\r\n                    offsets.setDesiredOffsets(keyRange, bracketTokenL, 1);\r\n                    offsets.setDesiredOffset(bracketTokenR, bracketTokenL, 0);\r\n                } else {\r\n                    const idToken = keyLastToken = sourceCode.getFirstToken(node.key);\r\n\r\n                    if (idToken !== firstToken) {\r\n                        offsets.setDesiredOffset(idToken, firstToken, 1);\r\n                    }\r\n                }\r\n\r\n                // Indent initializer.\r\n                if (node.value) {\r\n                    const eqToken = sourceCode.getTokenBefore(node.value, astUtils.isEqToken);\r\n                    const valueToken = sourceCode.getTokenAfter(eqToken);\r\n\r\n                    offsets.setDesiredOffset(eqToken, keyLastToken, 1);\r\n                    offsets.setDesiredOffset(valueToken, eqToken, 1);\r\n                    if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\r\n                        offsets.setDesiredOffset(maybeSemicolonToken, eqToken, 1);\r\n                    }\r\n                } else if (astUtils.isSemicolonToken(maybeSemicolonToken)) {\r\n                    offsets.setDesiredOffset(maybeSemicolonToken, keyLastToken, 1);\r\n                }\r\n            },\r\n\r\n            StaticBlock(node) {\r\n                const openingCurly = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\r\n                const closingCurly = sourceCode.getLastToken(node);\r\n\r\n                addElementListIndent(node.body, openingCurly, closingCurly, options.StaticBlock.body);\r\n            },\r\n\r\n            SwitchStatement(node) {\r\n                const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);\r\n                const closingCurly = sourceCode.getLastToken(node);\r\n\r\n                offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);\r\n\r\n                if (node.cases.length) {\r\n                    sourceCode.getTokensBetween(\r\n                        node.cases[node.cases.length - 1],\r\n                        closingCurly,\r\n                        { includeComments: true, filter: astUtils.isCommentToken }\r\n                    ).forEach(token => offsets.ignoreToken(token));\r\n                }\r\n            },\r\n\r\n            SwitchCase(node) {\r\n                if (!(node.consequent.length === 1 && node.consequent[0].type === \"BlockStatement\")) {\r\n                    const caseKeyword = sourceCode.getFirstToken(node);\r\n                    const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);\r\n\r\n                    offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);\r\n                }\r\n            },\r\n\r\n            TemplateLiteral(node) {\r\n                node.expressions.forEach((expression, index) => {\r\n                    const previousQuasi = node.quasis[index];\r\n                    const nextQuasi = node.quasis[index + 1];\r\n                    const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line\r\n                        ? sourceCode.getFirstToken(previousQuasi)\r\n                        : null;\r\n\r\n                    offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);\r\n                    offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);\r\n                });\r\n            },\r\n\r\n            VariableDeclaration(node) {\r\n                let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind)\r\n                    ? options.VariableDeclarator[node.kind]\r\n                    : DEFAULT_VARIABLE_INDENT;\r\n\r\n                const firstToken = sourceCode.getFirstToken(node),\r\n                    lastToken = sourceCode.getLastToken(node);\r\n\r\n                if (options.VariableDeclarator[node.kind] === \"first\") {\r\n                    if (node.declarations.length > 1) {\r\n                        addElementListIndent(\r\n                            node.declarations,\r\n                            firstToken,\r\n                            lastToken,\r\n                            \"first\"\r\n                        );\r\n                        return;\r\n                    }\r\n\r\n                    variableIndent = DEFAULT_VARIABLE_INDENT;\r\n                }\r\n\r\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {\r\n\r\n                    /*\r\n                     * VariableDeclarator indentation is a bit different from other forms of indentation, in that the\r\n                     * indentation of an opening bracket sometimes won't match that of a closing bracket. For example,\r\n                     * the following indentations are correct:\r\n                     *\r\n                     * var foo = {\r\n                     *   ok: true\r\n                     * };\r\n                     *\r\n                     * var foo = {\r\n                     *     ok: true,\r\n                     *   },\r\n                     *   bar = 1;\r\n                     *\r\n                     * Account for when exiting the AST (after indentations have already been set for the nodes in\r\n                     * the declaration) by manually increasing the indentation level of the tokens in this declarator\r\n                     * on the same line as the start of the declaration, provided that there are declarators that\r\n                     * follow this one.\r\n                     */\r\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);\r\n                } else {\r\n                    offsets.setDesiredOffsets(node.range, firstToken, variableIndent);\r\n                }\r\n\r\n                if (astUtils.isSemicolonToken(lastToken)) {\r\n                    offsets.ignoreToken(lastToken);\r\n                }\r\n            },\r\n\r\n            VariableDeclarator(node) {\r\n                if (node.init) {\r\n                    const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);\r\n                    const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);\r\n\r\n                    offsets.ignoreToken(equalOperator);\r\n                    offsets.ignoreToken(tokenAfterOperator);\r\n                    offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);\r\n                    offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);\r\n                }\r\n            },\r\n\r\n            \"JSXAttribute[value]\"(node) {\r\n                const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, token => token.type === \"Punctuator\" && token.value === \"=\");\r\n\r\n                offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);\r\n            },\r\n\r\n            JSXElement(node) {\r\n                if (node.closingElement) {\r\n                    addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);\r\n                }\r\n            },\r\n\r\n            JSXOpeningElement(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n                let closingToken;\r\n\r\n                if (node.selfClosing) {\r\n                    closingToken = sourceCode.getLastToken(node, { skip: 1 });\r\n                    offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);\r\n                } else {\r\n                    closingToken = sourceCode.getLastToken(node);\r\n                }\r\n                offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));\r\n                addElementListIndent(node.attributes, firstToken, closingToken, 1);\r\n            },\r\n\r\n            JSXClosingElement(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n\r\n                offsets.setDesiredOffsets(node.name.range, firstToken, 1);\r\n            },\r\n\r\n            JSXFragment(node) {\r\n                const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);\r\n                const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);\r\n\r\n                addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);\r\n            },\r\n\r\n            JSXOpeningFragment(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n                const closingToken = sourceCode.getLastToken(node);\r\n\r\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\r\n                offsets.matchOffsetOf(firstToken, closingToken);\r\n            },\r\n\r\n            JSXClosingFragment(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n                const slashToken = sourceCode.getLastToken(node, { skip: 1 });\r\n                const closingToken = sourceCode.getLastToken(node);\r\n                const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;\r\n\r\n                offsets.setDesiredOffsets(node.range, firstToken, 1);\r\n                offsets.matchOffsetOf(firstToken, tokenToMatch);\r\n            },\r\n\r\n            JSXExpressionContainer(node) {\r\n                const openingCurly = sourceCode.getFirstToken(node);\r\n                const closingCurly = sourceCode.getLastToken(node);\r\n\r\n                offsets.setDesiredOffsets(\r\n                    [openingCurly.range[1], closingCurly.range[0]],\r\n                    openingCurly,\r\n                    1\r\n                );\r\n            },\r\n\r\n            JSXSpreadAttribute(node) {\r\n                const openingCurly = sourceCode.getFirstToken(node);\r\n                const closingCurly = sourceCode.getLastToken(node);\r\n\r\n                offsets.setDesiredOffsets(\r\n                    [openingCurly.range[1], closingCurly.range[0]],\r\n                    openingCurly,\r\n                    1\r\n                );\r\n            },\r\n\r\n            \"*\"(node) {\r\n                const firstToken = sourceCode.getFirstToken(node);\r\n\r\n                // Ensure that the children of every node are indented at least as much as the first token.\r\n                if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {\r\n                    offsets.setDesiredOffsets(node.range, firstToken, 0);\r\n                }\r\n            }\r\n        };\r\n\r\n        const listenerCallQueue = [];\r\n\r\n        /*\r\n         * To ignore the indentation of a node:\r\n         * 1. Don't call the node's listener when entering it (if it has a listener)\r\n         * 2. Don't set any offsets against the first token of the node.\r\n         * 3. Call `ignoreNode` on the node sometime after exiting it and before validating offsets.\r\n         */\r\n        const offsetListeners = {};\r\n\r\n        for (const [selector, listener] of Object.entries(baseOffsetListeners)) {\r\n\r\n            /*\r\n             * Offset listener calls are deferred until traversal is finished, and are called as\r\n             * part of the final `Program:exit` listener. This is necessary because a node might\r\n             * be matched by multiple selectors.\r\n             *\r\n             * Example: Suppose there is an offset listener for `Identifier`, and the user has\r\n             * specified in configuration that `MemberExpression > Identifier` should be ignored.\r\n             * Due to selector specificity rules, the `Identifier` listener will get called first. However,\r\n             * if a given Identifier node is supposed to be ignored, then the `Identifier` offset listener\r\n             * should not have been called at all. Without doing extra selector matching, we don't know\r\n             * whether the Identifier matches the `MemberExpression > Identifier` selector until the\r\n             * `MemberExpression > Identifier` listener is called.\r\n             *\r\n             * To avoid this, the `Identifier` listener isn't called until traversal finishes and all\r\n             * ignored nodes are known.\r\n             */\r\n            offsetListeners[selector] = node => listenerCallQueue.push({ listener, node });\r\n        }\r\n\r\n        // For each ignored node selector, set up a listener to collect it into the `ignoredNodes` set.\r\n        const ignoredNodes = new Set();\r\n\r\n        /**\r\n         * Ignores a node\r\n         * @param {ASTNode} node The node to ignore\r\n         * @returns {void}\r\n         */\r\n        function addToIgnoredNodes(node) {\r\n            ignoredNodes.add(node);\r\n            ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));\r\n        }\r\n\r\n        const ignoredNodeListeners = options.ignoredNodes.reduce(\r\n            (listeners, ignoredSelector) => Object.assign(listeners, { [ignoredSelector]: addToIgnoredNodes }),\r\n            {}\r\n        );\r\n\r\n        /*\r\n         * Join the listeners, and add a listener to verify that all tokens actually have the correct indentation\r\n         * at the end.\r\n         *\r\n         * Using Object.assign will cause some offset listeners to be overwritten if the same selector also appears\r\n         * in `ignoredNodeListeners`. This isn't a problem because all of the matching nodes will be ignored,\r\n         * so those listeners wouldn't be called anyway.\r\n         */\r\n        return Object.assign(\r\n            offsetListeners,\r\n            ignoredNodeListeners,\r\n            {\r\n                \"*:exit\"(node) {\r\n\r\n                    // If a node's type is nonstandard, we can't tell how its children should be offset, so ignore it.\r\n                    if (!KNOWN_NODES.has(node.type)) {\r\n                        addToIgnoredNodes(node);\r\n                    }\r\n                },\r\n                \"Program:exit\"() {\r\n\r\n                    // If ignoreComments option is enabled, ignore all comment tokens.\r\n                    if (options.ignoreComments) {\r\n                        sourceCode.getAllComments()\r\n                            .forEach(comment => offsets.ignoreToken(comment));\r\n                    }\r\n\r\n                    // Invoke the queued offset listeners for the nodes that aren't ignored.\r\n                    listenerCallQueue\r\n                        .filter(nodeInfo => !ignoredNodes.has(nodeInfo.node))\r\n                        .forEach(nodeInfo => nodeInfo.listener(nodeInfo.node));\r\n\r\n                    // Update the offsets for ignored nodes to prevent their child tokens from being reported.\r\n                    ignoredNodes.forEach(ignoreNode);\r\n\r\n                    addParensIndent(sourceCode.ast.tokens);\r\n\r\n                    /*\r\n                     * Create a Map from (tokenOrComment) => (precedingToken).\r\n                     * This is necessary because sourceCode.getTokenBefore does not handle a comment as an argument correctly.\r\n                     */\r\n                    const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {\r\n                        const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, { includeComments: true });\r\n\r\n                        return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);\r\n                    }, new WeakMap());\r\n\r\n                    sourceCode.lines.forEach((line, lineIndex) => {\r\n                        const lineNumber = lineIndex + 1;\r\n\r\n                        if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {\r\n\r\n                            // Don't check indentation on blank lines\r\n                            return;\r\n                        }\r\n\r\n                        const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);\r\n\r\n                        if (firstTokenOfLine.loc.start.line !== lineNumber) {\r\n\r\n                            // Don't check the indentation of multi-line tokens (e.g. template literals or block comments) twice.\r\n                            return;\r\n                        }\r\n\r\n                        if (astUtils.isCommentToken(firstTokenOfLine)) {\r\n                            const tokenBefore = precedingTokens.get(firstTokenOfLine);\r\n                            const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];\r\n                            const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);\r\n                            const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);\r\n\r\n                            /*\r\n                             * If a comment precedes a line that begins with a semicolon token, align to that token, i.e.\r\n                             *\r\n                             * let foo\r\n                             * // comment\r\n                             * ;(async () => {})()\r\n                             */\r\n                            if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {\r\n                                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);\r\n                            }\r\n\r\n                            // If a comment matches the expected indentation of the token immediately before or after, don't report it.\r\n                            if (\r\n                                mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) ||\r\n                                mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))\r\n                            ) {\r\n                                return;\r\n                            }\r\n                        }\r\n\r\n                        // If the token matches the expected indentation, don't report it.\r\n                        if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {\r\n                            return;\r\n                        }\r\n\r\n                        // Otherwise, report the token/comment.\r\n                        report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}