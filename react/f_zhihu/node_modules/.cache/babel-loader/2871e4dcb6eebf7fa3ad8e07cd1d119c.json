{"ast":null,"code":"/**\r\n * @fileoverview Flat config schema\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Type Definitions\n//-----------------------------------------------------------------------------\n\n/**\r\n * @typedef ObjectPropertySchema\r\n * @property {Function|string} merge The function or name of the function to call\r\n *      to merge multiple objects with this property.\r\n * @property {Function|string} validate The function or name of the function to call\r\n *      to validate the value of this property.\r\n */\n//-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\nconst ruleSeverities = new Map([[0, 0], [\"off\", 0], [1, 1], [\"warn\", 1], [2, 2], [\"error\", 2]]);\nconst globalVariablesValues = new Set([true, \"true\", \"writable\", \"writeable\", false, \"false\", \"readonly\", \"readable\", null, \"off\"]);\n/**\r\n * Check if a value is a non-null object.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} `true` if the value is a non-null object.\r\n */\n\nfunction isNonNullObject(value) {\n  return typeof value === \"object\" && value !== null;\n}\n/**\r\n * Check if a value is undefined.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} `true` if the value is undefined.\r\n */\n\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\n/**\r\n * Deeply merges two objects.\r\n * @param {Object} first The base object.\r\n * @param {Object} second The overrides object.\r\n * @returns {Object} An object with properties from both first and second.\r\n */\n\n\nfunction deepMerge() {\n  let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /*\r\n   * If the second value is an array, just return it. We don't merge\r\n   * arrays because order matters and we can't know the correct order.\r\n   */\n  if (Array.isArray(second)) {\n    return second;\n  }\n  /*\r\n   * First create a result object where properties from the second object\r\n   * overwrite properties from the first. This sets up a baseline to use\r\n   * later rather than needing to inspect and change every property\r\n   * individually.\r\n   */\n\n\n  const result = { ...first,\n    ...second\n  };\n\n  for (const key of Object.keys(second)) {\n    // avoid hairy edge case\n    if (key === \"__proto__\") {\n      continue;\n    }\n\n    const firstValue = first[key];\n    const secondValue = second[key];\n\n    if (isNonNullObject(firstValue)) {\n      result[key] = deepMerge(firstValue, secondValue);\n    } else if (isUndefined(firstValue)) {\n      if (isNonNullObject(secondValue)) {\n        result[key] = deepMerge(Array.isArray(secondValue) ? [] : {}, secondValue);\n      } else if (!isUndefined(secondValue)) {\n        result[key] = secondValue;\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Normalizes the rule options config for a given rule by ensuring that\r\n * it is an array and that the first item is 0, 1, or 2.\r\n * @param {Array|string|number} ruleOptions The rule options config.\r\n * @returns {Array} An array of rule options.\r\n */\n\n\nfunction normalizeRuleOptions(ruleOptions) {\n  const finalOptions = Array.isArray(ruleOptions) ? ruleOptions.slice(0) : [ruleOptions];\n  finalOptions[0] = ruleSeverities.get(finalOptions[0]);\n  return finalOptions;\n} //-----------------------------------------------------------------------------\n// Assertions\n//-----------------------------------------------------------------------------\n\n/**\r\n * Validates that a value is a valid rule options entry.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't a valid rule options.\r\n */\n\n\nfunction assertIsRuleOptions(value) {\n  if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\n    throw new TypeError(\"Expected a string, number, or array.\");\n  }\n}\n/**\r\n * Validates that a value is valid rule severity.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't a valid rule severity.\r\n */\n\n\nfunction assertIsRuleSeverity(value) {\n  const severity = typeof value === \"string\" ? ruleSeverities.get(value.toLowerCase()) : ruleSeverities.get(value);\n\n  if (typeof severity === \"undefined\") {\n    throw new TypeError(\"Expected severity of \\\"off\\\", 0, \\\"warn\\\", 1, \\\"error\\\", or 2.\");\n  }\n}\n/**\r\n * Validates that a given string is the form pluginName/objectName.\r\n * @param {string} value The string to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the string isn't in the correct format.\r\n */\n\n\nfunction assertIsPluginMemberName(value) {\n  if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\n    throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\n  }\n}\n/**\r\n * Validates that a value is an object.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't an object.\r\n */\n\n\nfunction assertIsObject(value) {\n  if (!isNonNullObject(value)) {\n    throw new TypeError(\"Expected an object.\");\n  }\n}\n/**\r\n * Validates that a value is an object or a string.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't an object or a string.\r\n */\n\n\nfunction assertIsObjectOrString(value) {\n  if ((!value || typeof value !== \"object\") && typeof value !== \"string\") {\n    throw new TypeError(\"Expected an object or string.\");\n  }\n} //-----------------------------------------------------------------------------\n// Low-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\n\n\nconst booleanSchema = {\n  merge: \"replace\",\n  validate: \"boolean\"\n};\n/** @type {ObjectPropertySchema} */\n\nconst deepObjectAssignSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return deepMerge(first, second);\n  },\n\n  validate: \"object\"\n}; //-----------------------------------------------------------------------------\n// High-Level Schemas\n//-----------------------------------------------------------------------------\n\n/** @type {ObjectPropertySchema} */\n\nconst globalsSchema = {\n  merge: \"assign\",\n\n  validate(value) {\n    assertIsObject(value);\n\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (key !== key.trim()) {\n        throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\n      }\n\n      if (!globalVariablesValues.has(value[key])) {\n        throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\n      }\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst parserSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    assertIsObjectOrString(value);\n\n    if (typeof value === \"object\" && typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\") {\n      throw new TypeError(\"Expected object to have a parse() or parseForESLint() method.\");\n    }\n\n    if (typeof value === \"string\") {\n      assertIsPluginMemberName(value);\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst pluginsSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\n    const result = {}; // manually validate that plugins are not redefined\n\n    for (const key of keys) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (key in first && key in second && first[key] !== second[key]) {\n        throw new TypeError(`Cannot redefine plugin \"${key}\".`);\n      }\n\n      result[key] = second[key] || first[key];\n    }\n\n    return result;\n  },\n\n  validate(value) {\n    // first check the value to be sure it's an object\n    if (value === null || typeof value !== \"object\") {\n      throw new TypeError(\"Expected an object.\");\n    } // second check the keys to make sure they are objects\n\n\n    for (const key of Object.keys(value)) {\n      // avoid hairy edge case\n      if (key === \"__proto__\") {\n        continue;\n      }\n\n      if (value[key] === null || typeof value[key] !== \"object\") {\n        throw new TypeError(`Key \"${key}\": Expected an object.`);\n      }\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst processorSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value === \"string\") {\n      assertIsPluginMemberName(value);\n    } else if (value && typeof value === \"object\") {\n      if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\n        throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\n      }\n    } else {\n      throw new TypeError(\"Expected an object or a string.\");\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst rulesSchema = {\n  merge() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const result = { ...first,\n      ...second\n    };\n\n    for (const ruleId of Object.keys(result)) {\n      // avoid hairy edge case\n      if (ruleId === \"__proto__\") {\n        /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\n        delete result.__proto__;\n        continue;\n      }\n\n      result[ruleId] = normalizeRuleOptions(result[ruleId]);\n      /*\r\n       * If either rule config is missing, then the correct\r\n       * config is already present and we just need to normalize\r\n       * the severity.\r\n       */\n\n      if (!(ruleId in first) || !(ruleId in second)) {\n        continue;\n      }\n\n      const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\n      const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\n      /*\r\n       * If the second rule config only has a severity (length of 1),\r\n       * then use that severity and keep the rest of the options from\r\n       * the first rule config.\r\n       */\n\n      if (secondRuleOptions.length === 1) {\n        result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\n        continue;\n      }\n      /*\r\n       * In any other situation, then the second rule config takes\r\n       * precedence. That means the value at `result[ruleId]` is\r\n       * already correct and no further work is necessary.\r\n       */\n\n    }\n\n    return result;\n  },\n\n  validate(value) {\n    assertIsObject(value);\n    let lastRuleId; // Performance: One try-catch has less overhead than one per loop iteration\n\n    try {\n      /*\r\n       * We are not checking the rule schema here because there is no\r\n       * guarantee that the rule definition is present at this point. Instead\r\n       * we wait and check the rule schema during the finalization step\r\n       * of calculating a config.\r\n       */\n      for (const ruleId of Object.keys(value)) {\n        // avoid hairy edge case\n        if (ruleId === \"__proto__\") {\n          continue;\n        }\n\n        lastRuleId = ruleId;\n        const ruleOptions = value[ruleId];\n        assertIsRuleOptions(ruleOptions);\n\n        if (Array.isArray(ruleOptions)) {\n          assertIsRuleSeverity(ruleOptions[0]);\n        } else {\n          assertIsRuleSeverity(ruleOptions);\n        }\n      }\n    } catch (error) {\n      error.message = `Key \"${lastRuleId}\": ${error.message}`;\n      throw error;\n    }\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst ecmaVersionSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value === \"number\" || value === \"latest\") {\n      return;\n    }\n\n    throw new TypeError(\"Expected a number or \\\"latest\\\".\");\n  }\n\n};\n/** @type {ObjectPropertySchema} */\n\nconst sourceTypeSchema = {\n  merge: \"replace\",\n\n  validate(value) {\n    if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\n      throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\n    }\n  }\n\n}; //-----------------------------------------------------------------------------\n// Full schema\n//-----------------------------------------------------------------------------\n\nexports.flatConfigSchema = {\n  settings: deepObjectAssignSchema,\n  linterOptions: {\n    schema: {\n      noInlineConfig: booleanSchema,\n      reportUnusedDisableDirectives: booleanSchema\n    }\n  },\n  languageOptions: {\n    schema: {\n      ecmaVersion: ecmaVersionSchema,\n      sourceType: sourceTypeSchema,\n      globals: globalsSchema,\n      parser: parserSchema,\n      parserOptions: deepObjectAssignSchema\n    }\n  },\n  processor: processorSchema,\n  plugins: pluginsSchema,\n  rules: rulesSchema\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/config/flat-config-schema.js"],"names":["ruleSeverities","Map","globalVariablesValues","Set","isNonNullObject","value","isUndefined","deepMerge","first","second","Array","isArray","result","key","Object","keys","firstValue","secondValue","normalizeRuleOptions","ruleOptions","finalOptions","slice","get","assertIsRuleOptions","TypeError","assertIsRuleSeverity","severity","toLowerCase","assertIsPluginMemberName","test","assertIsObject","assertIsObjectOrString","booleanSchema","merge","validate","deepObjectAssignSchema","globalsSchema","trim","has","parserSchema","parse","parseForESLint","pluginsSchema","processorSchema","preprocess","postprocess","rulesSchema","ruleId","__proto__","firstRuleOptions","secondRuleOptions","length","lastRuleId","error","message","ecmaVersionSchema","sourceTypeSchema","exports","flatConfigSchema","settings","linterOptions","schema","noInlineConfig","reportUnusedDisableDirectives","languageOptions","ecmaVersion","sourceType","globals","parser","parserOptions","processor","plugins","rules"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Flat config schema\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Type Definitions\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * @typedef ObjectPropertySchema\r\n * @property {Function|string} merge The function or name of the function to call\r\n *      to merge multiple objects with this property.\r\n * @property {Function|string} validate The function or name of the function to call\r\n *      to validate the value of this property.\r\n */\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\nconst ruleSeverities = new Map([\r\n    [0, 0], [\"off\", 0],\r\n    [1, 1], [\"warn\", 1],\r\n    [2, 2], [\"error\", 2]\r\n]);\r\n\r\nconst globalVariablesValues = new Set([\r\n    true, \"true\", \"writable\", \"writeable\",\r\n    false, \"false\", \"readonly\", \"readable\", null,\r\n    \"off\"\r\n]);\r\n\r\n/**\r\n * Check if a value is a non-null object.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} `true` if the value is a non-null object.\r\n */\r\nfunction isNonNullObject(value) {\r\n    return typeof value === \"object\" && value !== null;\r\n}\r\n\r\n/**\r\n * Check if a value is undefined.\r\n * @param {any} value The value to check.\r\n * @returns {boolean} `true` if the value is undefined.\r\n */\r\nfunction isUndefined(value) {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\n/**\r\n * Deeply merges two objects.\r\n * @param {Object} first The base object.\r\n * @param {Object} second The overrides object.\r\n * @returns {Object} An object with properties from both first and second.\r\n */\r\nfunction deepMerge(first = {}, second = {}) {\r\n\r\n    /*\r\n     * If the second value is an array, just return it. We don't merge\r\n     * arrays because order matters and we can't know the correct order.\r\n     */\r\n    if (Array.isArray(second)) {\r\n        return second;\r\n    }\r\n\r\n    /*\r\n     * First create a result object where properties from the second object\r\n     * overwrite properties from the first. This sets up a baseline to use\r\n     * later rather than needing to inspect and change every property\r\n     * individually.\r\n     */\r\n    const result = {\r\n        ...first,\r\n        ...second\r\n    };\r\n\r\n    for (const key of Object.keys(second)) {\r\n\r\n        // avoid hairy edge case\r\n        if (key === \"__proto__\") {\r\n            continue;\r\n        }\r\n\r\n        const firstValue = first[key];\r\n        const secondValue = second[key];\r\n\r\n        if (isNonNullObject(firstValue)) {\r\n            result[key] = deepMerge(firstValue, secondValue);\r\n        } else if (isUndefined(firstValue)) {\r\n            if (isNonNullObject(secondValue)) {\r\n                result[key] = deepMerge(\r\n                    Array.isArray(secondValue) ? [] : {},\r\n                    secondValue\r\n                );\r\n            } else if (!isUndefined(secondValue)) {\r\n                result[key] = secondValue;\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n\r\n}\r\n\r\n/**\r\n * Normalizes the rule options config for a given rule by ensuring that\r\n * it is an array and that the first item is 0, 1, or 2.\r\n * @param {Array|string|number} ruleOptions The rule options config.\r\n * @returns {Array} An array of rule options.\r\n */\r\nfunction normalizeRuleOptions(ruleOptions) {\r\n\r\n    const finalOptions = Array.isArray(ruleOptions)\r\n        ? ruleOptions.slice(0)\r\n        : [ruleOptions];\r\n\r\n    finalOptions[0] = ruleSeverities.get(finalOptions[0]);\r\n    return finalOptions;\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Assertions\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Validates that a value is a valid rule options entry.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't a valid rule options.\r\n */\r\nfunction assertIsRuleOptions(value) {\r\n\r\n    if (typeof value !== \"string\" && typeof value !== \"number\" && !Array.isArray(value)) {\r\n        throw new TypeError(\"Expected a string, number, or array.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Validates that a value is valid rule severity.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't a valid rule severity.\r\n */\r\nfunction assertIsRuleSeverity(value) {\r\n    const severity = typeof value === \"string\"\r\n        ? ruleSeverities.get(value.toLowerCase())\r\n        : ruleSeverities.get(value);\r\n\r\n    if (typeof severity === \"undefined\") {\r\n        throw new TypeError(\"Expected severity of \\\"off\\\", 0, \\\"warn\\\", 1, \\\"error\\\", or 2.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Validates that a given string is the form pluginName/objectName.\r\n * @param {string} value The string to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the string isn't in the correct format.\r\n */\r\nfunction assertIsPluginMemberName(value) {\r\n    if (!/[@a-z0-9-_$]+(?:\\/(?:[a-z0-9-_$]+))+$/iu.test(value)) {\r\n        throw new TypeError(`Expected string in the form \"pluginName/objectName\" but found \"${value}\".`);\r\n    }\r\n}\r\n\r\n/**\r\n * Validates that a value is an object.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't an object.\r\n */\r\nfunction assertIsObject(value) {\r\n    if (!isNonNullObject(value)) {\r\n        throw new TypeError(\"Expected an object.\");\r\n    }\r\n}\r\n\r\n/**\r\n * Validates that a value is an object or a string.\r\n * @param {any} value The value to check.\r\n * @returns {void}\r\n * @throws {TypeError} If the value isn't an object or a string.\r\n */\r\nfunction assertIsObjectOrString(value) {\r\n    if ((!value || typeof value !== \"object\") && typeof value !== \"string\") {\r\n        throw new TypeError(\"Expected an object or string.\");\r\n    }\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Low-Level Schemas\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst booleanSchema = {\r\n    merge: \"replace\",\r\n    validate: \"boolean\"\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst deepObjectAssignSchema = {\r\n    merge(first = {}, second = {}) {\r\n        return deepMerge(first, second);\r\n    },\r\n    validate: \"object\"\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// High-Level Schemas\r\n//-----------------------------------------------------------------------------\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst globalsSchema = {\r\n    merge: \"assign\",\r\n    validate(value) {\r\n\r\n        assertIsObject(value);\r\n\r\n        for (const key of Object.keys(value)) {\r\n\r\n            // avoid hairy edge case\r\n            if (key === \"__proto__\") {\r\n                continue;\r\n            }\r\n\r\n            if (key !== key.trim()) {\r\n                throw new TypeError(`Global \"${key}\" has leading or trailing whitespace.`);\r\n            }\r\n\r\n            if (!globalVariablesValues.has(value[key])) {\r\n                throw new TypeError(`Key \"${key}\": Expected \"readonly\", \"writable\", or \"off\".`);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst parserSchema = {\r\n    merge: \"replace\",\r\n    validate(value) {\r\n        assertIsObjectOrString(value);\r\n\r\n        if (typeof value === \"object\" && typeof value.parse !== \"function\" && typeof value.parseForESLint !== \"function\") {\r\n            throw new TypeError(\"Expected object to have a parse() or parseForESLint() method.\");\r\n        }\r\n\r\n        if (typeof value === \"string\") {\r\n            assertIsPluginMemberName(value);\r\n        }\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst pluginsSchema = {\r\n    merge(first = {}, second = {}) {\r\n        const keys = new Set([...Object.keys(first), ...Object.keys(second)]);\r\n        const result = {};\r\n\r\n        // manually validate that plugins are not redefined\r\n        for (const key of keys) {\r\n\r\n            // avoid hairy edge case\r\n            if (key === \"__proto__\") {\r\n                continue;\r\n            }\r\n\r\n            if (key in first && key in second && first[key] !== second[key]) {\r\n                throw new TypeError(`Cannot redefine plugin \"${key}\".`);\r\n            }\r\n\r\n            result[key] = second[key] || first[key];\r\n        }\r\n\r\n        return result;\r\n    },\r\n    validate(value) {\r\n\r\n        // first check the value to be sure it's an object\r\n        if (value === null || typeof value !== \"object\") {\r\n            throw new TypeError(\"Expected an object.\");\r\n        }\r\n\r\n        // second check the keys to make sure they are objects\r\n        for (const key of Object.keys(value)) {\r\n\r\n            // avoid hairy edge case\r\n            if (key === \"__proto__\") {\r\n                continue;\r\n            }\r\n\r\n            if (value[key] === null || typeof value[key] !== \"object\") {\r\n                throw new TypeError(`Key \"${key}\": Expected an object.`);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst processorSchema = {\r\n    merge: \"replace\",\r\n    validate(value) {\r\n        if (typeof value === \"string\") {\r\n            assertIsPluginMemberName(value);\r\n        } else if (value && typeof value === \"object\") {\r\n            if (typeof value.preprocess !== \"function\" || typeof value.postprocess !== \"function\") {\r\n                throw new TypeError(\"Object must have a preprocess() and a postprocess() method.\");\r\n            }\r\n        } else {\r\n            throw new TypeError(\"Expected an object or a string.\");\r\n        }\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst rulesSchema = {\r\n    merge(first = {}, second = {}) {\r\n\r\n        const result = {\r\n            ...first,\r\n            ...second\r\n        };\r\n\r\n        for (const ruleId of Object.keys(result)) {\r\n\r\n            // avoid hairy edge case\r\n            if (ruleId === \"__proto__\") {\r\n\r\n                /* eslint-disable-next-line no-proto -- Though deprecated, may still be present */\r\n                delete result.__proto__;\r\n                continue;\r\n            }\r\n\r\n            result[ruleId] = normalizeRuleOptions(result[ruleId]);\r\n\r\n            /*\r\n             * If either rule config is missing, then the correct\r\n             * config is already present and we just need to normalize\r\n             * the severity.\r\n             */\r\n            if (!(ruleId in first) || !(ruleId in second)) {\r\n                continue;\r\n            }\r\n\r\n            const firstRuleOptions = normalizeRuleOptions(first[ruleId]);\r\n            const secondRuleOptions = normalizeRuleOptions(second[ruleId]);\r\n\r\n            /*\r\n             * If the second rule config only has a severity (length of 1),\r\n             * then use that severity and keep the rest of the options from\r\n             * the first rule config.\r\n             */\r\n            if (secondRuleOptions.length === 1) {\r\n                result[ruleId] = [secondRuleOptions[0], ...firstRuleOptions.slice(1)];\r\n                continue;\r\n            }\r\n\r\n            /*\r\n             * In any other situation, then the second rule config takes\r\n             * precedence. That means the value at `result[ruleId]` is\r\n             * already correct and no further work is necessary.\r\n             */\r\n        }\r\n\r\n        return result;\r\n    },\r\n\r\n    validate(value) {\r\n        assertIsObject(value);\r\n\r\n        let lastRuleId;\r\n\r\n        // Performance: One try-catch has less overhead than one per loop iteration\r\n        try {\r\n\r\n            /*\r\n             * We are not checking the rule schema here because there is no\r\n             * guarantee that the rule definition is present at this point. Instead\r\n             * we wait and check the rule schema during the finalization step\r\n             * of calculating a config.\r\n             */\r\n            for (const ruleId of Object.keys(value)) {\r\n\r\n                // avoid hairy edge case\r\n                if (ruleId === \"__proto__\") {\r\n                    continue;\r\n                }\r\n\r\n                lastRuleId = ruleId;\r\n\r\n                const ruleOptions = value[ruleId];\r\n\r\n                assertIsRuleOptions(ruleOptions);\r\n\r\n                if (Array.isArray(ruleOptions)) {\r\n                    assertIsRuleSeverity(ruleOptions[0]);\r\n                } else {\r\n                    assertIsRuleSeverity(ruleOptions);\r\n                }\r\n            }\r\n        } catch (error) {\r\n            error.message = `Key \"${lastRuleId}\": ${error.message}`;\r\n            throw error;\r\n        }\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst ecmaVersionSchema = {\r\n    merge: \"replace\",\r\n    validate(value) {\r\n        if (typeof value === \"number\" || value === \"latest\") {\r\n            return;\r\n        }\r\n\r\n        throw new TypeError(\"Expected a number or \\\"latest\\\".\");\r\n    }\r\n};\r\n\r\n/** @type {ObjectPropertySchema} */\r\nconst sourceTypeSchema = {\r\n    merge: \"replace\",\r\n    validate(value) {\r\n        if (typeof value !== \"string\" || !/^(?:script|module|commonjs)$/u.test(value)) {\r\n            throw new TypeError(\"Expected \\\"script\\\", \\\"module\\\", or \\\"commonjs\\\".\");\r\n        }\r\n    }\r\n};\r\n\r\n//-----------------------------------------------------------------------------\r\n// Full schema\r\n//-----------------------------------------------------------------------------\r\n\r\nexports.flatConfigSchema = {\r\n    settings: deepObjectAssignSchema,\r\n    linterOptions: {\r\n        schema: {\r\n            noInlineConfig: booleanSchema,\r\n            reportUnusedDisableDirectives: booleanSchema\r\n        }\r\n    },\r\n    languageOptions: {\r\n        schema: {\r\n            ecmaVersion: ecmaVersionSchema,\r\n            sourceType: sourceTypeSchema,\r\n            globals: globalsSchema,\r\n            parser: parserSchema,\r\n            parserOptions: deepObjectAssignSchema\r\n        }\r\n    },\r\n    processor: processorSchema,\r\n    plugins: pluginsSchema,\r\n    rules: rulesSchema\r\n};\r\n"]},"metadata":{},"sourceType":"script"}