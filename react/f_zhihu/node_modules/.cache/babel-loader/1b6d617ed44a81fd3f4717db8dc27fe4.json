{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  findVariable\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpValidator,\n  visitRegExpAST,\n  RegExpParser\n} = require(\"regexpp\");\n\nconst {\n  canTokensBeAdjacent\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\n/**\r\n * Determines whether the given node is a string literal.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a string literal.\r\n */\n\nfunction isStringLiteral(node) {\n  return node.type === \"Literal\" && typeof node.value === \"string\";\n}\n/**\r\n * Determines whether the given node is a regex literal.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a regex literal.\r\n */\n\n\nfunction isRegexLiteral(node) {\n  return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\n}\n/**\r\n * Determines whether the given node is a template literal without expressions.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a template literal without expressions.\r\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n\nconst validPrecedingTokens = [\"(\", \";\", \"[\", \",\", \"=\", \"+\", \"*\", \"-\", \"?\", \"~\", \"%\", \"**\", \"!\", \"typeof\", \"instanceof\", \"&&\", \"||\", \"??\", \"return\", \"...\", \"delete\", \"void\", \"in\", \"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\", \"<<\", \">>\", \">>>\", \"&\", \"|\", \"^\", \":\", \"{\", \"=>\", \"*=\", \"<<=\", \">>=\", \">>>=\", \"^=\", \"|=\", \"&=\", \"??=\", \"||=\", \"&&=\", \"**=\", \"+=\", \"-=\", \"/=\", \"%=\", \"/\", \"do\", \"break\", \"continue\", \"debugger\", \"case\", \"throw\"]; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        disallowRedundantWrapping: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\n      replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\n      unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\n      unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\n    }\n  },\n\n  create(context) {\n    const [{\n      disallowRedundantWrapping = false\n    } = {}] = context.options;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Determines whether the given identifier node is a reference to a global variable.\r\n     * @param {ASTNode} node `Identifier` node to check.\r\n     * @returns {boolean} True if the identifier is a reference to a global variable.\r\n     */\n\n    function isGlobalReference(node) {\n      const scope = context.getScope();\n      const variable = findVariable(scope, node);\n      return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\n    }\n    /**\r\n     * Determines whether the given node is a String.raw`` tagged template expression\r\n     * with a static template literal.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} True if the node is String.raw`` with a static template.\r\n     */\n\n\n    function isStringRawTaggedStaticTemplateLiteral(node) {\n      return node.type === \"TaggedTemplateExpression\" && astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral(node.quasi);\n    }\n    /**\r\n     * Gets the value of a string\r\n     * @param {ASTNode} node The node to get the string of.\r\n     * @returns {string|null} The value of the node.\r\n     */\n\n\n    function getStringValue(node) {\n      if (isStringLiteral(node)) {\n        return node.value;\n      }\n\n      if (isStaticTemplateLiteral(node)) {\n        return node.quasis[0].value.cooked;\n      }\n\n      if (isStringRawTaggedStaticTemplateLiteral(node)) {\n        return node.quasi.quasis[0].value.raw;\n      }\n\n      return null;\n    }\n    /**\r\n     * Determines whether the given node is considered to be a static string by the logic of this rule.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} True if the node is a static string.\r\n     */\n\n\n    function isStaticString(node) {\n      return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);\n    }\n    /**\r\n     * Determines whether the relevant arguments of the given are all static string literals.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} True if all arguments are static strings.\r\n     */\n\n\n    function hasOnlyStaticStringArguments(node) {\n      const args = node.arguments;\n\n      if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} True if the node already contains a regex literal argument.\r\n     */\n\n\n    function isUnnecessarilyWrappedRegexLiteral(node) {\n      const args = node.arguments;\n\n      if (args.length === 1 && isRegexLiteral(args[0])) {\n        return true;\n      }\n\n      if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Returns a ecmaVersion compatible for regexpp.\r\n     * @param {any} ecmaVersion The ecmaVersion to convert.\r\n     * @returns {import(\"regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\r\n     */\n\n\n    function getRegexppEcmaVersion(ecmaVersion) {\n      if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\n        return 5;\n      }\n\n      return Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION);\n    }\n    /**\r\n     * Makes a character escaped or else returns null.\r\n     * @param {string} character The character to escape.\r\n     * @returns {string} The resulting escaped character.\r\n     */\n\n\n    function resolveEscapes(character) {\n      switch (character) {\n        case \"\\n\":\n        case \"\\\\\\n\":\n          return \"\\\\n\";\n\n        case \"\\r\":\n        case \"\\\\\\r\":\n          return \"\\\\r\";\n\n        case \"\\t\":\n        case \"\\\\\\t\":\n          return \"\\\\t\";\n\n        case \"\\v\":\n        case \"\\\\\\v\":\n          return \"\\\\v\";\n\n        case \"\\f\":\n        case \"\\\\\\f\":\n          return \"\\\\f\";\n\n        case \"/\":\n          return \"\\\\/\";\n\n        default:\n          return null;\n      }\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const traceMap = {\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(traceMap)) {\n          if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\n            if (node.arguments.length === 2) {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExpWithFlags\"\n              });\n            } else {\n              context.report({\n                node,\n                messageId: \"unexpectedRedundantRegExp\"\n              });\n            }\n          } else if (hasOnlyStaticStringArguments(node)) {\n            let regexContent = getStringValue(node.arguments[0]);\n            let noFix = false;\n            let flags;\n\n            if (node.arguments[1]) {\n              flags = getStringValue(node.arguments[1]);\n            }\n\n            const regexppEcmaVersion = getRegexppEcmaVersion(context.parserOptions.ecmaVersion);\n            const RegExpValidatorInstance = new RegExpValidator({\n              ecmaVersion: regexppEcmaVersion\n            });\n\n            try {\n              RegExpValidatorInstance.validatePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n\n              if (flags) {\n                RegExpValidatorInstance.validateFlags(flags);\n              }\n            } catch {\n              noFix = true;\n            }\n\n            const tokenBefore = sourceCode.getTokenBefore(node);\n\n            if (tokenBefore && !validPrecedingTokens.includes(tokenBefore.value)) {\n              noFix = true;\n            }\n\n            if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\n              noFix = true;\n            }\n\n            if (sourceCode.getCommentsInside(node).length > 0) {\n              noFix = true;\n            }\n\n            if (regexContent && !noFix) {\n              let charIncrease = 0;\n              const ast = new RegExpParser({\n                ecmaVersion: regexppEcmaVersion\n              }).parsePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\n              visitRegExpAST(ast, {\n                onCharacterEnter(characterNode) {\n                  const escaped = resolveEscapes(characterNode.raw);\n\n                  if (escaped) {\n                    regexContent = regexContent.slice(0, characterNode.start + charIncrease) + escaped + regexContent.slice(characterNode.end + charIncrease);\n\n                    if (characterNode.raw.length === 1) {\n                      charIncrease += 1;\n                    }\n                  }\n                }\n\n              });\n            }\n\n            const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\n            context.report({\n              node,\n              messageId: \"unexpectedRegExp\",\n              suggest: noFix ? [] : [{\n                messageId: \"replaceWithLiteral\",\n\n                fix(fixer) {\n                  const tokenAfter = sourceCode.getTokenAfter(node);\n                  return fixer.replaceText(node, (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") + newRegExpValue + (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\"));\n                }\n\n              }]\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-regex-literals.js"],"names":["astUtils","require","CALL","CONSTRUCT","ReferenceTracker","findVariable","RegExpValidator","visitRegExpAST","RegExpParser","canTokensBeAdjacent","REGEXPP_LATEST_ECMA_VERSION","isStringLiteral","node","type","value","isRegexLiteral","Object","prototype","hasOwnProperty","call","isStaticTemplateLiteral","expressions","length","validPrecedingTokens","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","disallowRedundantWrapping","default","additionalProperties","messages","unexpectedRegExp","replaceWithLiteral","unexpectedRedundantRegExp","unexpectedRedundantRegExpWithFlags","create","context","options","sourceCode","getSourceCode","isGlobalReference","scope","getScope","variable","defs","isStringRawTaggedStaticTemplateLiteral","isSpecificMemberAccess","tag","skipChainExpression","object","quasi","getStringValue","quasis","cooked","raw","isStaticString","hasOnlyStaticStringArguments","args","arguments","every","isUnnecessarilyWrappedRegexLiteral","getRegexppEcmaVersion","ecmaVersion","Math","min","resolveEscapes","character","Program","tracker","traceMap","RegExp","iterateGlobalReferences","report","messageId","regexContent","noFix","flags","regexppEcmaVersion","parserOptions","RegExpValidatorInstance","validatePattern","includes","validateFlags","tokenBefore","getTokenBefore","test","getCommentsInside","charIncrease","ast","parsePattern","onCharacterEnter","characterNode","escaped","slice","start","end","newRegExpValue","suggest","fix","fixer","tokenAfter","getTokenAfter","replaceText","range"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { CALL, CONSTRUCT, ReferenceTracker, findVariable } = require(\"eslint-utils\");\r\nconst { RegExpValidator, visitRegExpAST, RegExpParser } = require(\"regexpp\");\r\nconst { canTokensBeAdjacent } = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst REGEXPP_LATEST_ECMA_VERSION = 2022;\r\n\r\n/**\r\n * Determines whether the given node is a string literal.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a string literal.\r\n */\r\nfunction isStringLiteral(node) {\r\n    return node.type === \"Literal\" && typeof node.value === \"string\";\r\n}\r\n\r\n/**\r\n * Determines whether the given node is a regex literal.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a regex literal.\r\n */\r\nfunction isRegexLiteral(node) {\r\n    return node.type === \"Literal\" && Object.prototype.hasOwnProperty.call(node, \"regex\");\r\n}\r\n\r\n/**\r\n * Determines whether the given node is a template literal without expressions.\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} True if the node is a template literal without expressions.\r\n */\r\nfunction isStaticTemplateLiteral(node) {\r\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\r\n}\r\n\r\nconst validPrecedingTokens = [\r\n    \"(\",\r\n    \";\",\r\n    \"[\",\r\n    \",\",\r\n    \"=\",\r\n    \"+\",\r\n    \"*\",\r\n    \"-\",\r\n    \"?\",\r\n    \"~\",\r\n    \"%\",\r\n    \"**\",\r\n    \"!\",\r\n    \"typeof\",\r\n    \"instanceof\",\r\n    \"&&\",\r\n    \"||\",\r\n    \"??\",\r\n    \"return\",\r\n    \"...\",\r\n    \"delete\",\r\n    \"void\",\r\n    \"in\",\r\n    \"<\",\r\n    \">\",\r\n    \"<=\",\r\n    \">=\",\r\n    \"==\",\r\n    \"===\",\r\n    \"!=\",\r\n    \"!==\",\r\n    \"<<\",\r\n    \">>\",\r\n    \">>>\",\r\n    \"&\",\r\n    \"|\",\r\n    \"^\",\r\n    \":\",\r\n    \"{\",\r\n    \"=>\",\r\n    \"*=\",\r\n    \"<<=\",\r\n    \">>=\",\r\n    \">>>=\",\r\n    \"^=\",\r\n    \"|=\",\r\n    \"&=\",\r\n    \"??=\",\r\n    \"||=\",\r\n    \"&&=\",\r\n    \"**=\",\r\n    \"+=\",\r\n    \"-=\",\r\n    \"/=\",\r\n    \"%=\",\r\n    \"/\",\r\n    \"do\",\r\n    \"break\",\r\n    \"continue\",\r\n    \"debugger\",\r\n    \"case\",\r\n    \"throw\"\r\n];\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow use of the `RegExp` constructor in favor of regular expression literals\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-regex-literals\"\r\n        },\r\n\r\n        hasSuggestions: true,\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    disallowRedundantWrapping: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedRegExp: \"Use a regular expression literal instead of the 'RegExp' constructor.\",\r\n            replaceWithLiteral: \"Replace with an equivalent regular expression literal.\",\r\n            unexpectedRedundantRegExp: \"Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.\",\r\n            unexpectedRedundantRegExpWithFlags: \"Use regular expression literal with flags instead of the 'RegExp' constructor.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const [{ disallowRedundantWrapping = false } = {}] = context.options;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Determines whether the given identifier node is a reference to a global variable.\r\n         * @param {ASTNode} node `Identifier` node to check.\r\n         * @returns {boolean} True if the identifier is a reference to a global variable.\r\n         */\r\n        function isGlobalReference(node) {\r\n            const scope = context.getScope();\r\n            const variable = findVariable(scope, node);\r\n\r\n            return variable !== null && variable.scope.type === \"global\" && variable.defs.length === 0;\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given node is a String.raw`` tagged template expression\r\n         * with a static template literal.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} True if the node is String.raw`` with a static template.\r\n         */\r\n        function isStringRawTaggedStaticTemplateLiteral(node) {\r\n            return node.type === \"TaggedTemplateExpression\" &&\r\n                astUtils.isSpecificMemberAccess(node.tag, \"String\", \"raw\") &&\r\n                isGlobalReference(astUtils.skipChainExpression(node.tag).object) &&\r\n                isStaticTemplateLiteral(node.quasi);\r\n        }\r\n\r\n        /**\r\n         * Gets the value of a string\r\n         * @param {ASTNode} node The node to get the string of.\r\n         * @returns {string|null} The value of the node.\r\n         */\r\n        function getStringValue(node) {\r\n            if (isStringLiteral(node)) {\r\n                return node.value;\r\n            }\r\n\r\n            if (isStaticTemplateLiteral(node)) {\r\n                return node.quasis[0].value.cooked;\r\n            }\r\n\r\n            if (isStringRawTaggedStaticTemplateLiteral(node)) {\r\n                return node.quasi.quasis[0].value.raw;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given node is considered to be a static string by the logic of this rule.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} True if the node is a static string.\r\n         */\r\n        function isStaticString(node) {\r\n            return isStringLiteral(node) ||\r\n                isStaticTemplateLiteral(node) ||\r\n                isStringRawTaggedStaticTemplateLiteral(node);\r\n        }\r\n\r\n        /**\r\n         * Determines whether the relevant arguments of the given are all static string literals.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} True if all arguments are static strings.\r\n         */\r\n        function hasOnlyStaticStringArguments(node) {\r\n            const args = node.arguments;\r\n\r\n            if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines whether the arguments of the given node indicate that a regex literal is unnecessarily wrapped.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} True if the node already contains a regex literal argument.\r\n         */\r\n        function isUnnecessarilyWrappedRegexLiteral(node) {\r\n            const args = node.arguments;\r\n\r\n            if (args.length === 1 && isRegexLiteral(args[0])) {\r\n                return true;\r\n            }\r\n\r\n            if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns a ecmaVersion compatible for regexpp.\r\n         * @param {any} ecmaVersion The ecmaVersion to convert.\r\n         * @returns {import(\"regexpp/ecma-versions\").EcmaVersion} The resulting ecmaVersion compatible for regexpp.\r\n         */\r\n        function getRegexppEcmaVersion(ecmaVersion) {\r\n            if (typeof ecmaVersion !== \"number\" || ecmaVersion <= 5) {\r\n                return 5;\r\n            }\r\n            return Math.min(ecmaVersion + 2009, REGEXPP_LATEST_ECMA_VERSION);\r\n        }\r\n\r\n        /**\r\n         * Makes a character escaped or else returns null.\r\n         * @param {string} character The character to escape.\r\n         * @returns {string} The resulting escaped character.\r\n         */\r\n        function resolveEscapes(character) {\r\n            switch (character) {\r\n                case \"\\n\":\r\n                case \"\\\\\\n\":\r\n                    return \"\\\\n\";\r\n\r\n                case \"\\r\":\r\n                case \"\\\\\\r\":\r\n                    return \"\\\\r\";\r\n\r\n                case \"\\t\":\r\n                case \"\\\\\\t\":\r\n                    return \"\\\\t\";\r\n\r\n                case \"\\v\":\r\n                case \"\\\\\\v\":\r\n                    return \"\\\\v\";\r\n\r\n                case \"\\f\":\r\n                case \"\\\\\\f\":\r\n                    return \"\\\\f\";\r\n\r\n                case \"/\":\r\n                    return \"\\\\/\";\r\n\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                const scope = context.getScope();\r\n                const tracker = new ReferenceTracker(scope);\r\n                const traceMap = {\r\n                    RegExp: {\r\n                        [CALL]: true,\r\n                        [CONSTRUCT]: true\r\n                    }\r\n                };\r\n\r\n                for (const { node } of tracker.iterateGlobalReferences(traceMap)) {\r\n                    if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {\r\n                        if (node.arguments.length === 2) {\r\n                            context.report({ node, messageId: \"unexpectedRedundantRegExpWithFlags\" });\r\n                        } else {\r\n                            context.report({ node, messageId: \"unexpectedRedundantRegExp\" });\r\n                        }\r\n                    } else if (hasOnlyStaticStringArguments(node)) {\r\n                        let regexContent = getStringValue(node.arguments[0]);\r\n                        let noFix = false;\r\n                        let flags;\r\n\r\n                        if (node.arguments[1]) {\r\n                            flags = getStringValue(node.arguments[1]);\r\n                        }\r\n\r\n                        const regexppEcmaVersion = getRegexppEcmaVersion(context.parserOptions.ecmaVersion);\r\n                        const RegExpValidatorInstance = new RegExpValidator({ ecmaVersion: regexppEcmaVersion });\r\n\r\n                        try {\r\n                            RegExpValidatorInstance.validatePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\r\n                            if (flags) {\r\n                                RegExpValidatorInstance.validateFlags(flags);\r\n                            }\r\n                        } catch {\r\n                            noFix = true;\r\n                        }\r\n\r\n                        const tokenBefore = sourceCode.getTokenBefore(node);\r\n\r\n                        if (tokenBefore && !validPrecedingTokens.includes(tokenBefore.value)) {\r\n                            noFix = true;\r\n                        }\r\n\r\n                        if (!/^[-a-zA-Z0-9\\\\[\\](){} \\t\\r\\n\\v\\f!@#$%^&*+^_=/~`.><?,'\"|:;]*$/u.test(regexContent)) {\r\n                            noFix = true;\r\n                        }\r\n\r\n                        if (sourceCode.getCommentsInside(node).length > 0) {\r\n                            noFix = true;\r\n                        }\r\n\r\n                        if (regexContent && !noFix) {\r\n                            let charIncrease = 0;\r\n\r\n                            const ast = new RegExpParser({ ecmaVersion: regexppEcmaVersion }).parsePattern(regexContent, 0, regexContent.length, flags ? flags.includes(\"u\") : false);\r\n\r\n                            visitRegExpAST(ast, {\r\n                                onCharacterEnter(characterNode) {\r\n                                    const escaped = resolveEscapes(characterNode.raw);\r\n\r\n                                    if (escaped) {\r\n                                        regexContent =\r\n                                            regexContent.slice(0, characterNode.start + charIncrease) +\r\n                                            escaped +\r\n                                            regexContent.slice(characterNode.end + charIncrease);\r\n\r\n                                        if (characterNode.raw.length === 1) {\r\n                                            charIncrease += 1;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        const newRegExpValue = `/${regexContent || \"(?:)\"}/${flags || \"\"}`;\r\n\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"unexpectedRegExp\",\r\n                            suggest: noFix ? [] : [{\r\n                                messageId: \"replaceWithLiteral\",\r\n                                fix(fixer) {\r\n                                    const tokenAfter = sourceCode.getTokenAfter(node);\r\n\r\n                                    return fixer.replaceText(\r\n                                        node,\r\n                                        (tokenBefore && !canTokensBeAdjacent(tokenBefore, newRegExpValue) && tokenBefore.range[1] === node.range[0] ? \" \" : \"\") +\r\n                                            newRegExpValue +\r\n                                            (tokenAfter && !canTokensBeAdjacent(newRegExpValue, tokenAfter) && node.range[1] === tokenAfter.range[0] ? \" \" : \"\")\r\n                                    );\r\n                                }\r\n                            }]\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}