{"ast":null,"code":"/**\r\n * @fileoverview Rule to validate spacing before function paren.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before `function` definition opening parenthesis\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-function-paren\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          anonymous: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          named: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          },\n          asyncArrow: {\n            enum: [\"always\", \"never\", \"ignore\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before function parentheses.\",\n      missingSpace: \"Missing space before function parentheses.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\n    /**\r\n     * Determines whether a function has a name.\r\n     * @param {ASTNode} node The function node.\r\n     * @returns {boolean} Whether the function has a name.\r\n     */\n\n    function isNamedFunction(node) {\n      if (node.id) {\n        return true;\n      }\n\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.kind === \"get\" || parent.kind === \"set\" || parent.method);\n    }\n    /**\r\n     * Gets the config for a given function\r\n     * @param {ASTNode} node The function node\r\n     * @returns {string} \"always\", \"never\", or \"ignore\"\r\n     */\n\n\n    function getConfigForFunction(node) {\n      if (node.type === \"ArrowFunctionExpression\") {\n        // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\n        if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {\n          skip: 1\n        }))) {\n          return overrideConfig.asyncArrow || baseConfig;\n        }\n      } else if (isNamedFunction(node)) {\n        return overrideConfig.named || baseConfig; // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\n      } else if (!node.generator) {\n        return overrideConfig.anonymous || baseConfig;\n      }\n\n      return \"ignore\";\n    }\n    /**\r\n     * Checks the parens of a function node\r\n     * @param {ASTNode} node A function node\r\n     * @returns {void}\r\n     */\n\n\n    function checkFunction(node) {\n      const functionConfig = getConfigForFunction(node);\n\n      if (functionConfig === \"ignore\") {\n        return;\n      }\n\n      const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n      const leftToken = sourceCode.getTokenBefore(rightToken);\n      const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\n\n      if (hasSpacing && functionConfig === \"never\") {\n        context.report({\n          node,\n          loc: {\n            start: leftToken.loc.end,\n            end: rightToken.loc.start\n          },\n          messageId: \"unexpectedSpace\",\n\n          fix(fixer) {\n            const comments = sourceCode.getCommentsBefore(rightToken); // Don't fix anything if there's a single line comment between the left and the right token\n\n            if (comments.some(comment => comment.type === \"Line\")) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\"));\n          }\n\n        });\n      } else if (!hasSpacing && functionConfig === \"always\") {\n        context.report({\n          node,\n          loc: rightToken.loc,\n          messageId: \"missingSpace\",\n          fix: fixer => fixer.insertTextAfter(leftToken, \" \")\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkFunction,\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/space-before-function-paren.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","anonymous","named","asyncArrow","additionalProperties","messages","unexpectedSpace","missingSpace","create","context","sourceCode","getSourceCode","baseConfig","options","overrideConfig","isNamedFunction","node","id","parent","kind","method","getConfigForFunction","async","isOpeningParenToken","getFirstToken","skip","generator","checkFunction","functionConfig","rightToken","leftToken","getTokenBefore","hasSpacing","isSpaceBetweenTokens","report","loc","start","end","messageId","fix","fixer","comments","getCommentsBefore","some","comment","replaceTextRange","range","reduce","text","getText","insertTextAfter","ArrowFunctionExpression","FunctionDeclaration","FunctionExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to validate spacing before function paren.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing before `function` definition opening parenthesis\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/space-before-function-paren\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"always\", \"never\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            anonymous: {\r\n                                enum: [\"always\", \"never\", \"ignore\"]\r\n                            },\r\n                            named: {\r\n                                enum: [\"always\", \"never\", \"ignore\"]\r\n                            },\r\n                            asyncArrow: {\r\n                                enum: [\"always\", \"never\", \"ignore\"]\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedSpace: \"Unexpected space before function parentheses.\",\r\n            missingSpace: \"Missing space before function parentheses.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const baseConfig = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\r\n        const overrideConfig = typeof context.options[0] === \"object\" ? context.options[0] : {};\r\n\r\n        /**\r\n         * Determines whether a function has a name.\r\n         * @param {ASTNode} node The function node.\r\n         * @returns {boolean} Whether the function has a name.\r\n         */\r\n        function isNamedFunction(node) {\r\n            if (node.id) {\r\n                return true;\r\n            }\r\n\r\n            const parent = node.parent;\r\n\r\n            return parent.type === \"MethodDefinition\" ||\r\n                (parent.type === \"Property\" &&\r\n                    (\r\n                        parent.kind === \"get\" ||\r\n                        parent.kind === \"set\" ||\r\n                        parent.method\r\n                    )\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Gets the config for a given function\r\n         * @param {ASTNode} node The function node\r\n         * @returns {string} \"always\", \"never\", or \"ignore\"\r\n         */\r\n        function getConfigForFunction(node) {\r\n            if (node.type === \"ArrowFunctionExpression\") {\r\n\r\n                // Always ignore non-async functions and arrow functions without parens, e.g. async foo => bar\r\n                if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, { skip: 1 }))) {\r\n                    return overrideConfig.asyncArrow || baseConfig;\r\n                }\r\n            } else if (isNamedFunction(node)) {\r\n                return overrideConfig.named || baseConfig;\r\n\r\n            // `generator-star-spacing` should warn anonymous generators. E.g. `function* () {}`\r\n            } else if (!node.generator) {\r\n                return overrideConfig.anonymous || baseConfig;\r\n            }\r\n\r\n            return \"ignore\";\r\n        }\r\n\r\n        /**\r\n         * Checks the parens of a function node\r\n         * @param {ASTNode} node A function node\r\n         * @returns {void}\r\n         */\r\n        function checkFunction(node) {\r\n            const functionConfig = getConfigForFunction(node);\r\n\r\n            if (functionConfig === \"ignore\") {\r\n                return;\r\n            }\r\n\r\n            const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\r\n            const leftToken = sourceCode.getTokenBefore(rightToken);\r\n            const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);\r\n\r\n            if (hasSpacing && functionConfig === \"never\") {\r\n                context.report({\r\n                    node,\r\n                    loc: {\r\n                        start: leftToken.loc.end,\r\n                        end: rightToken.loc.start\r\n                    },\r\n                    messageId: \"unexpectedSpace\",\r\n                    fix(fixer) {\r\n                        const comments = sourceCode.getCommentsBefore(rightToken);\r\n\r\n                        // Don't fix anything if there's a single line comment between the left and the right token\r\n                        if (comments.some(comment => comment.type === \"Line\")) {\r\n                            return null;\r\n                        }\r\n                        return fixer.replaceTextRange(\r\n                            [leftToken.range[1], rightToken.range[0]],\r\n                            comments.reduce((text, comment) => text + sourceCode.getText(comment), \"\")\r\n                        );\r\n                    }\r\n                });\r\n            } else if (!hasSpacing && functionConfig === \"always\") {\r\n                context.report({\r\n                    node,\r\n                    loc: rightToken.loc,\r\n                    messageId: \"missingSpace\",\r\n                    fix: fixer => fixer.insertTextAfter(leftToken, \" \")\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            ArrowFunctionExpression: checkFunction,\r\n            FunctionDeclaration: checkFunction,\r\n            FunctionExpression: checkFunction\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}