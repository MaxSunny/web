{"ast":null,"code":"/**\r\n * @fileoverview Rule to check for max length on a line.\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    code: {\n      type: \"integer\",\n      minimum: 0\n    },\n    comments: {\n      type: \"integer\",\n      minimum: 0\n    },\n    tabWidth: {\n      type: \"integer\",\n      minimum: 0\n    },\n    ignorePattern: {\n      type: \"string\"\n    },\n    ignoreComments: {\n      type: \"boolean\"\n    },\n    ignoreStrings: {\n      type: \"boolean\"\n    },\n    ignoreUrls: {\n      type: \"boolean\"\n    },\n    ignoreTemplateLiterals: {\n      type: \"boolean\"\n    },\n    ignoreRegExpLiterals: {\n      type: \"boolean\"\n    },\n    ignoreTrailingComments: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  anyOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 0\n  }]\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce a maximum line length\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-len\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_OR_INTEGER_SCHEMA, OPTIONS_SCHEMA],\n    messages: {\n      max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\n      maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\n    }\n  },\n\n  create(context) {\n    /*\r\n     * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\r\n     * - They're matching an entire string that we know is a URI\r\n     * - We're matching part of a string where we think there *might* be a URL\r\n     * - We're only concerned about URLs, as picking out any URI would cause\r\n     *   too many false positives\r\n     * - We don't care about matching the entire URL, any small segment is fine\r\n     */\n    const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Computes the length of a line that may contain tabs. The width of each\r\n     * tab will be the number of spaces to the next tab stop.\r\n     * @param {string} line The line.\r\n     * @param {int} tabWidth The width of each tab stop in spaces.\r\n     * @returns {int} The computed line length.\r\n     * @private\r\n     */\n\n    function computeLineLength(line, tabWidth) {\n      let extraCharacterCount = 0;\n      line.replace(/\\t/gu, (match, offset) => {\n        const totalOffset = offset + extraCharacterCount,\n              previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n              spaceCount = tabWidth - previousTabStopOffset;\n        extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\n      });\n      return Array.from(line).length + extraCharacterCount;\n    } // The options object must be the last option specified…\n\n\n    const options = Object.assign({}, context.options[context.options.length - 1]); // …but max code length…\n\n    if (typeof context.options[0] === \"number\") {\n      options.code = context.options[0];\n    } // …and tabWidth can be optionally specified directly as integers.\n\n\n    if (typeof context.options[1] === \"number\") {\n      options.tabWidth = context.options[1];\n    }\n\n    const maxLength = typeof options.code === \"number\" ? options.code : 80,\n          tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\n          ignoreComments = !!options.ignoreComments,\n          ignoreStrings = !!options.ignoreStrings,\n          ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\n          ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\n          ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\n          ignoreUrls = !!options.ignoreUrls,\n          maxCommentLength = options.comments;\n    let ignorePattern = options.ignorePattern || null;\n\n    if (ignorePattern) {\n      ignorePattern = new RegExp(ignorePattern, \"u\");\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Tells if a given comment is trailing: it starts on the current line and\r\n     * extends to or past the end of the current line.\r\n     * @param {string} line The source line we want to check for a trailing comment on\r\n     * @param {number} lineNumber The one-indexed line number for line\r\n     * @param {ASTNode} comment The comment to inspect\r\n     * @returns {boolean} If the comment is trailing on the given line\r\n     */\n\n\n    function isTrailingComment(line, lineNumber, comment) {\n      return comment && comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n    }\n    /**\r\n     * Tells if a comment encompasses the entire line.\r\n     * @param {string} line The source line with a trailing comment\r\n     * @param {number} lineNumber The one-indexed line number this is on\r\n     * @param {ASTNode} comment The comment to remove\r\n     * @returns {boolean} If the comment covers the entire line\r\n     */\n\n\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n            end = comment.loc.end,\n            isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\n      return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);\n    }\n    /**\r\n     * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\r\n     */\n\n\n    function isJSXEmptyExpressionInSingleLineContainer(node) {\n      if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\n        return false;\n      }\n\n      const parent = node.parent;\n      return parent.loc.start.line === parent.loc.end.line;\n    }\n    /**\r\n     * Gets the line after the comment and any remaining trailing whitespace is\r\n     * stripped.\r\n     * @param {string} line The source line with a trailing comment\r\n     * @param {ASTNode} comment The comment to remove\r\n     * @returns {string} Line without comment and trailing whitespace\r\n     */\n\n\n    function stripTrailingComment(line, comment) {\n      // loc.column is zero-indexed\n      return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\n    }\n    /**\r\n     * Ensure that an array exists at [key] on `object`, and add `value` to it.\r\n     * @param {Object} object the object to mutate\r\n     * @param {string} key the object's key\r\n     * @param {any} value the value to add\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function ensureArrayAndPush(object, key, value) {\n      if (!Array.isArray(object[key])) {\n        object[key] = [];\n      }\n\n      object[key].push(value);\n    }\n    /**\r\n     * Retrieves an array containing all strings (\" or ') in the source code.\r\n     * @returns {ASTNode[]} An array of string nodes.\r\n     */\n\n\n    function getAllStrings() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"String\" || token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\");\n    }\n    /**\r\n     * Retrieves an array containing all template literals in the source code.\r\n     * @returns {ASTNode[]} An array of template literal nodes.\r\n     */\n\n\n    function getAllTemplateLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\n    }\n    /**\r\n     * Retrieves an array containing all RegExp literals in the source code.\r\n     * @returns {ASTNode[]} An array of RegExp literal nodes.\r\n     */\n\n\n    function getAllRegExpLiterals() {\n      return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\n    }\n    /**\r\n     * A reducer to group an AST node by line number, both start and end.\r\n     * @param {Object} acc the accumulator\r\n     * @param {ASTNode} node the AST node in question\r\n     * @returns {Object} the modified accumulator\r\n     * @private\r\n     */\n\n\n    function groupByLineNumber(acc, node) {\n      for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\n        ensureArrayAndPush(acc, i, node);\n      }\n\n      return acc;\n    }\n    /**\r\n     * Returns an array of all comments in the source code.\r\n     * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\r\n     * the element is changed with JSXExpressionContainer node.\r\n     * @returns {ASTNode[]} An array of comment nodes\r\n     */\n\n\n    function getAllComments() {\n      const comments = [];\n      sourceCode.getAllComments().forEach(commentNode => {\n        const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\n\n        if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\n          // push a unique node only\n          if (comments[comments.length - 1] !== containingNode.parent) {\n            comments.push(containingNode.parent);\n          }\n        } else {\n          comments.push(commentNode);\n        }\n      });\n      return comments;\n    }\n    /**\r\n     * Check the program for max length\r\n     * @param {ASTNode} node Node to examine\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkProgramForMaxLength(node) {\n      // split (honors line-ending)\n      const lines = sourceCode.lines,\n            // list of comments to ignore\n      comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : []; // we iterate over comments in parallel with the lines\n\n      let commentsIndex = 0;\n      const strings = getAllStrings();\n      const stringsByLine = strings.reduce(groupByLineNumber, {});\n      const templateLiterals = getAllTemplateLiterals();\n      const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\n      const regExpLiterals = getAllRegExpLiterals();\n      const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\n      lines.forEach((line, i) => {\n        // i is zero-indexed, line numbers are one-indexed\n        const lineNumber = i + 1;\n        /*\r\n         * if we're checking comment length; we need to know whether this\r\n         * line is a comment\r\n         */\n\n        let lineIsComment = false;\n        let textToMeasure;\n        /*\r\n         * We can short-circuit the comment checks if we're already out of\r\n         * comments to check.\r\n         */\n\n        if (commentsIndex < comments.length) {\n          let comment = null; // iterate over comments until we find one past the current line\n\n          do {\n            comment = comments[++commentsIndex];\n          } while (comment && comment.loc.start.line <= lineNumber); // and step back by one\n\n\n          comment = comments[--commentsIndex];\n\n          if (isFullLineComment(line, lineNumber, comment)) {\n            lineIsComment = true;\n            textToMeasure = line;\n          } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n            textToMeasure = stripTrailingComment(line, comment); // ignore multiple trailing comments in the same line\n\n            let lastIndex = commentsIndex;\n\n            while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\n              textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\n            }\n          } else {\n            textToMeasure = line;\n          }\n        } else {\n          textToMeasure = line;\n        }\n\n        if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {\n          // ignore this line\n          return;\n        }\n\n        const lineLength = computeLineLength(textToMeasure, tabWidth);\n        const commentLengthApplies = lineIsComment && maxCommentLength;\n\n        if (lineIsComment && ignoreComments) {\n          return;\n        }\n\n        const loc = {\n          start: {\n            line: lineNumber,\n            column: 0\n          },\n          end: {\n            line: lineNumber,\n            column: textToMeasure.length\n          }\n        };\n\n        if (commentLengthApplies) {\n          if (lineLength > maxCommentLength) {\n            context.report({\n              node,\n              loc,\n              messageId: \"maxComment\",\n              data: {\n                lineLength,\n                maxCommentLength\n              }\n            });\n          }\n        } else if (lineLength > maxLength) {\n          context.report({\n            node,\n            loc,\n            messageId: \"max\",\n            data: {\n              lineLength,\n              maxLength\n            }\n          });\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: checkProgramForMaxLength\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/max-len.js"],"names":["OPTIONS_SCHEMA","type","properties","code","minimum","comments","tabWidth","ignorePattern","ignoreComments","ignoreStrings","ignoreUrls","ignoreTemplateLiterals","ignoreRegExpLiterals","ignoreTrailingComments","additionalProperties","OPTIONS_OR_INTEGER_SCHEMA","anyOf","module","exports","meta","docs","description","recommended","url","schema","messages","max","maxComment","create","context","URL_REGEXP","sourceCode","getSourceCode","computeLineLength","line","extraCharacterCount","replace","match","offset","totalOffset","previousTabStopOffset","spaceCount","Array","from","length","options","Object","assign","maxLength","maxCommentLength","RegExp","isTrailingComment","lineNumber","comment","loc","start","end","column","isFullLineComment","isFirstTokenOnLine","slice","trim","isJSXEmptyExpressionInSingleLineContainer","node","parent","stripTrailingComment","ensureArrayAndPush","object","key","value","isArray","push","getAllStrings","ast","tokens","filter","token","getNodeByRangeIndex","range","getAllTemplateLiterals","getAllRegExpLiterals","groupByLineNumber","acc","i","getAllComments","forEach","commentNode","containingNode","checkProgramForMaxLength","lines","commentsIndex","strings","stringsByLine","reduce","templateLiterals","templateLiteralsByLine","regExpLiterals","regExpLiteralsByLine","lineIsComment","textToMeasure","lastIndex","test","lineLength","commentLengthApplies","report","messageId","data","Program"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check for max length on a line.\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst OPTIONS_SCHEMA = {\r\n    type: \"object\",\r\n    properties: {\r\n        code: {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        },\r\n        comments: {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        },\r\n        tabWidth: {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        },\r\n        ignorePattern: {\r\n            type: \"string\"\r\n        },\r\n        ignoreComments: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreStrings: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreUrls: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreTemplateLiterals: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreRegExpLiterals: {\r\n            type: \"boolean\"\r\n        },\r\n        ignoreTrailingComments: {\r\n            type: \"boolean\"\r\n        }\r\n    },\r\n    additionalProperties: false\r\n};\r\n\r\nconst OPTIONS_OR_INTEGER_SCHEMA = {\r\n    anyOf: [\r\n        OPTIONS_SCHEMA,\r\n        {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        }\r\n    ]\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce a maximum line length\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/max-len\"\r\n        },\r\n\r\n        schema: [\r\n            OPTIONS_OR_INTEGER_SCHEMA,\r\n            OPTIONS_OR_INTEGER_SCHEMA,\r\n            OPTIONS_SCHEMA\r\n        ],\r\n        messages: {\r\n            max: \"This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.\",\r\n            maxComment: \"This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /*\r\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\r\n         * - They're matching an entire string that we know is a URI\r\n         * - We're matching part of a string where we think there *might* be a URL\r\n         * - We're only concerned about URLs, as picking out any URI would cause\r\n         *   too many false positives\r\n         * - We don't care about matching the entire URL, any small segment is fine\r\n         */\r\n        const URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/u;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Computes the length of a line that may contain tabs. The width of each\r\n         * tab will be the number of spaces to the next tab stop.\r\n         * @param {string} line The line.\r\n         * @param {int} tabWidth The width of each tab stop in spaces.\r\n         * @returns {int} The computed line length.\r\n         * @private\r\n         */\r\n        function computeLineLength(line, tabWidth) {\r\n            let extraCharacterCount = 0;\r\n\r\n            line.replace(/\\t/gu, (match, offset) => {\r\n                const totalOffset = offset + extraCharacterCount,\r\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\r\n                    spaceCount = tabWidth - previousTabStopOffset;\r\n\r\n                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab\r\n            });\r\n            return Array.from(line).length + extraCharacterCount;\r\n        }\r\n\r\n        // The options object must be the last option specified…\r\n        const options = Object.assign({}, context.options[context.options.length - 1]);\r\n\r\n        // …but max code length…\r\n        if (typeof context.options[0] === \"number\") {\r\n            options.code = context.options[0];\r\n        }\r\n\r\n        // …and tabWidth can be optionally specified directly as integers.\r\n        if (typeof context.options[1] === \"number\") {\r\n            options.tabWidth = context.options[1];\r\n        }\r\n\r\n        const maxLength = typeof options.code === \"number\" ? options.code : 80,\r\n            tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 4,\r\n            ignoreComments = !!options.ignoreComments,\r\n            ignoreStrings = !!options.ignoreStrings,\r\n            ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,\r\n            ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,\r\n            ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,\r\n            ignoreUrls = !!options.ignoreUrls,\r\n            maxCommentLength = options.comments;\r\n        let ignorePattern = options.ignorePattern || null;\r\n\r\n        if (ignorePattern) {\r\n            ignorePattern = new RegExp(ignorePattern, \"u\");\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Tells if a given comment is trailing: it starts on the current line and\r\n         * extends to or past the end of the current line.\r\n         * @param {string} line The source line we want to check for a trailing comment on\r\n         * @param {number} lineNumber The one-indexed line number for line\r\n         * @param {ASTNode} comment The comment to inspect\r\n         * @returns {boolean} If the comment is trailing on the given line\r\n         */\r\n        function isTrailingComment(line, lineNumber, comment) {\r\n            return comment &&\r\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\r\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\r\n        }\r\n\r\n        /**\r\n         * Tells if a comment encompasses the entire line.\r\n         * @param {string} line The source line with a trailing comment\r\n         * @param {number} lineNumber The one-indexed line number this is on\r\n         * @param {ASTNode} comment The comment to remove\r\n         * @returns {boolean} If the comment covers the entire line\r\n         */\r\n        function isFullLineComment(line, lineNumber, comment) {\r\n            const start = comment.loc.start,\r\n                end = comment.loc.end,\r\n                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();\r\n\r\n            return comment &&\r\n                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&\r\n                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));\r\n        }\r\n\r\n        /**\r\n         * Check if a node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} True if the node is a JSXEmptyExpression contained in a single line JSXExpressionContainer.\r\n         */\r\n        function isJSXEmptyExpressionInSingleLineContainer(node) {\r\n            if (!node || !node.parent || node.type !== \"JSXEmptyExpression\" || node.parent.type !== \"JSXExpressionContainer\") {\r\n                return false;\r\n            }\r\n\r\n            const parent = node.parent;\r\n\r\n            return parent.loc.start.line === parent.loc.end.line;\r\n        }\r\n\r\n        /**\r\n         * Gets the line after the comment and any remaining trailing whitespace is\r\n         * stripped.\r\n         * @param {string} line The source line with a trailing comment\r\n         * @param {ASTNode} comment The comment to remove\r\n         * @returns {string} Line without comment and trailing whitespace\r\n         */\r\n        function stripTrailingComment(line, comment) {\r\n\r\n            // loc.column is zero-indexed\r\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/u, \"\");\r\n        }\r\n\r\n        /**\r\n         * Ensure that an array exists at [key] on `object`, and add `value` to it.\r\n         * @param {Object} object the object to mutate\r\n         * @param {string} key the object's key\r\n         * @param {any} value the value to add\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function ensureArrayAndPush(object, key, value) {\r\n            if (!Array.isArray(object[key])) {\r\n                object[key] = [];\r\n            }\r\n            object[key].push(value);\r\n        }\r\n\r\n        /**\r\n         * Retrieves an array containing all strings (\" or ') in the source code.\r\n         * @returns {ASTNode[]} An array of string nodes.\r\n         */\r\n        function getAllStrings() {\r\n            return sourceCode.ast.tokens.filter(token => (token.type === \"String\" ||\r\n                (token.type === \"JSXText\" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === \"JSXAttribute\")));\r\n        }\r\n\r\n        /**\r\n         * Retrieves an array containing all template literals in the source code.\r\n         * @returns {ASTNode[]} An array of template literal nodes.\r\n         */\r\n        function getAllTemplateLiterals() {\r\n            return sourceCode.ast.tokens.filter(token => token.type === \"Template\");\r\n        }\r\n\r\n\r\n        /**\r\n         * Retrieves an array containing all RegExp literals in the source code.\r\n         * @returns {ASTNode[]} An array of RegExp literal nodes.\r\n         */\r\n        function getAllRegExpLiterals() {\r\n            return sourceCode.ast.tokens.filter(token => token.type === \"RegularExpression\");\r\n        }\r\n\r\n\r\n        /**\r\n         * A reducer to group an AST node by line number, both start and end.\r\n         * @param {Object} acc the accumulator\r\n         * @param {ASTNode} node the AST node in question\r\n         * @returns {Object} the modified accumulator\r\n         * @private\r\n         */\r\n        function groupByLineNumber(acc, node) {\r\n            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {\r\n                ensureArrayAndPush(acc, i, node);\r\n            }\r\n            return acc;\r\n        }\r\n\r\n        /**\r\n         * Returns an array of all comments in the source code.\r\n         * If the element in the array is a JSXEmptyExpression contained with a single line JSXExpressionContainer,\r\n         * the element is changed with JSXExpressionContainer node.\r\n         * @returns {ASTNode[]} An array of comment nodes\r\n         */\r\n        function getAllComments() {\r\n            const comments = [];\r\n\r\n            sourceCode.getAllComments()\r\n                .forEach(commentNode => {\r\n                    const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);\r\n\r\n                    if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {\r\n\r\n                        // push a unique node only\r\n                        if (comments[comments.length - 1] !== containingNode.parent) {\r\n                            comments.push(containingNode.parent);\r\n                        }\r\n                    } else {\r\n                        comments.push(commentNode);\r\n                    }\r\n                });\r\n\r\n            return comments;\r\n        }\r\n\r\n        /**\r\n         * Check the program for max length\r\n         * @param {ASTNode} node Node to examine\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkProgramForMaxLength(node) {\r\n\r\n            // split (honors line-ending)\r\n            const lines = sourceCode.lines,\r\n\r\n                // list of comments to ignore\r\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];\r\n\r\n            // we iterate over comments in parallel with the lines\r\n            let commentsIndex = 0;\r\n\r\n            const strings = getAllStrings();\r\n            const stringsByLine = strings.reduce(groupByLineNumber, {});\r\n\r\n            const templateLiterals = getAllTemplateLiterals();\r\n            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});\r\n\r\n            const regExpLiterals = getAllRegExpLiterals();\r\n            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});\r\n\r\n            lines.forEach((line, i) => {\r\n\r\n                // i is zero-indexed, line numbers are one-indexed\r\n                const lineNumber = i + 1;\r\n\r\n                /*\r\n                 * if we're checking comment length; we need to know whether this\r\n                 * line is a comment\r\n                 */\r\n                let lineIsComment = false;\r\n                let textToMeasure;\r\n\r\n                /*\r\n                 * We can short-circuit the comment checks if we're already out of\r\n                 * comments to check.\r\n                 */\r\n                if (commentsIndex < comments.length) {\r\n                    let comment = null;\r\n\r\n                    // iterate over comments until we find one past the current line\r\n                    do {\r\n                        comment = comments[++commentsIndex];\r\n                    } while (comment && comment.loc.start.line <= lineNumber);\r\n\r\n                    // and step back by one\r\n                    comment = comments[--commentsIndex];\r\n\r\n                    if (isFullLineComment(line, lineNumber, comment)) {\r\n                        lineIsComment = true;\r\n                        textToMeasure = line;\r\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\r\n                        textToMeasure = stripTrailingComment(line, comment);\r\n\r\n                        // ignore multiple trailing comments in the same line\r\n                        let lastIndex = commentsIndex;\r\n\r\n                        while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {\r\n                            textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);\r\n                        }\r\n                    } else {\r\n                        textToMeasure = line;\r\n                    }\r\n                } else {\r\n                    textToMeasure = line;\r\n                }\r\n                if (ignorePattern && ignorePattern.test(textToMeasure) ||\r\n                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||\r\n                    ignoreStrings && stringsByLine[lineNumber] ||\r\n                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||\r\n                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]\r\n                ) {\r\n\r\n                    // ignore this line\r\n                    return;\r\n                }\r\n\r\n                const lineLength = computeLineLength(textToMeasure, tabWidth);\r\n                const commentLengthApplies = lineIsComment && maxCommentLength;\r\n\r\n                if (lineIsComment && ignoreComments) {\r\n                    return;\r\n                }\r\n\r\n                const loc = {\r\n                    start: {\r\n                        line: lineNumber,\r\n                        column: 0\r\n                    },\r\n                    end: {\r\n                        line: lineNumber,\r\n                        column: textToMeasure.length\r\n                    }\r\n                };\r\n\r\n                if (commentLengthApplies) {\r\n                    if (lineLength > maxCommentLength) {\r\n                        context.report({\r\n                            node,\r\n                            loc,\r\n                            messageId: \"maxComment\",\r\n                            data: {\r\n                                lineLength,\r\n                                maxCommentLength\r\n                            }\r\n                        });\r\n                    }\r\n                } else if (lineLength > maxLength) {\r\n                    context.report({\r\n                        node,\r\n                        loc,\r\n                        messageId: \"max\",\r\n                        data: {\r\n                            lineLength,\r\n                            maxLength\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: checkProgramForMaxLength\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}