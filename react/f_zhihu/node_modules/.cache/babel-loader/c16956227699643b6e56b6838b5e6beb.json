{"ast":null,"code":"/**\r\n * @fileoverview Look for useless escapes in strings and regexes\r\n * @author Onur Temizkan\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\r\n * Returns the union of two sets.\r\n * @param {Set} setA The first set\r\n * @param {Set} setB The second set\r\n * @returns {Set} The union of the two sets\r\n */\n\n\nfunction union(setA, setB) {\n  return new Set(function* () {\n    yield* setA;\n    yield* setB;\n  }());\n}\n\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\n/**\r\n * Parses a regular expression into a list of characters with character class info.\r\n * @param {string} regExpText The raw text used to create the regular expression\r\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\r\n * @example\r\n *\r\n * parseRegExp(\"a\\\\b[cd-]\");\r\n *\r\n * // returns:\r\n * [\r\n *     { text: \"a\", index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"b\", index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"c\", index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false },\r\n *     { text: \"d\", index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"-\", index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false }\r\n * ];\r\n *\r\n */\n\nfunction parseRegExp(regExpText) {\n  const charList = [];\n  regExpText.split(\"\").reduce((state, char, index) => {\n    if (!state.escapeNextChar) {\n      if (char === \"\\\\\") {\n        return Object.assign(state, {\n          escapeNextChar: true\n        });\n      }\n\n      if (char === \"[\" && !state.inCharClass) {\n        return Object.assign(state, {\n          inCharClass: true,\n          startingCharClass: true\n        });\n      }\n\n      if (char === \"]\" && state.inCharClass) {\n        if (charList.length && charList[charList.length - 1].inCharClass) {\n          charList[charList.length - 1].endsCharClass = true;\n        }\n\n        return Object.assign(state, {\n          inCharClass: false,\n          startingCharClass: false\n        });\n      }\n    }\n\n    charList.push({\n      text: char,\n      index,\n      escaped: state.escapeNextChar,\n      inCharClass: state.inCharClass,\n      startsCharClass: state.startingCharClass,\n      endsCharClass: false\n    });\n    return Object.assign(state, {\n      escapeNextChar: false,\n      startingCharClass: false\n    });\n  }, {\n    escapeNextChar: false,\n    inCharClass: false,\n    startingCharClass: false\n  });\n  return charList;\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary escape characters\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-useless-escape\"\n    },\n    hasSuggestions: true,\n    messages: {\n      unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\n      removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\n      escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\n    },\n    schema: []\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports a node\r\n     * @param {ASTNode} node The node to report\r\n     * @param {number} startOffset The backslash's offset from the start of the node\r\n     * @param {string} character The uselessly escaped character (not including the backslash)\r\n     * @returns {void}\r\n     */\n\n    function report(node, startOffset, character) {\n      const rangeStart = node.range[0] + startOffset;\n      const range = [rangeStart, rangeStart + 1];\n      const start = sourceCode.getLocFromIndex(rangeStart);\n      context.report({\n        node,\n        loc: {\n          start,\n          end: {\n            line: start.line,\n            column: start.column + 1\n          }\n        },\n        messageId: \"unnecessaryEscape\",\n        data: {\n          character\n        },\n        suggest: [{\n          messageId: \"removeEscape\",\n\n          fix(fixer) {\n            return fixer.removeRange(range);\n          }\n\n        }, {\n          messageId: \"escapeBackslash\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\\\\");\n          }\n\n        }]\n      });\n    }\n    /**\r\n     * Checks if the escape character in given string slice is unnecessary.\r\n     * @private\r\n     * @param {ASTNode} node node to validate.\r\n     * @param {string} match string slice to validate.\r\n     * @returns {void}\r\n     */\n\n\n    function validateString(node, match) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n      const escapedChar = match[0][1];\n      let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\n      let isQuoteEscape;\n\n      if (isTemplateElement) {\n        isQuoteEscape = escapedChar === \"`\";\n\n        if (escapedChar === \"$\") {\n          // Warn if `\\$` is not followed by `{`\n          isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\n        } else if (escapedChar === \"{\") {\n          /*\r\n           * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\r\n           * is necessary and the rule should not warn. If preceded by `/$`, the rule\r\n           * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\r\n           */\n          isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\n        }\n      } else {\n        isQuoteEscape = escapedChar === node.raw[0];\n      }\n\n      if (isUnnecessaryEscape && !isQuoteEscape) {\n        report(node, match.index, match[0].slice(1));\n      }\n    }\n    /**\r\n     * Checks if a node has an escape.\r\n     * @param {ASTNode} node node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function check(node) {\n      const isTemplateElement = node.type === \"TemplateElement\";\n\n      if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === \"TaggedTemplateExpression\" && node.parent === node.parent.parent.quasi) {\n        // Don't report tagged template literals, because the backslash character is accessible to the tag function.\n        return;\n      }\n\n      if (typeof node.value === \"string\" || isTemplateElement) {\n        /*\r\n         * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\r\n         * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\r\n         */\n        if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\n          return;\n        }\n\n        const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\n        const pattern = /\\\\[^\\d]/gu;\n        let match;\n\n        while (match = pattern.exec(value)) {\n          validateString(node, match);\n        }\n      } else if (node.regex) {\n        parseRegExp(node.regex.pattern)\n        /*\r\n         * The '-' character is a special case, because it's only valid to escape it if it's in a character\r\n         * class, and is not at either edge of the character class. To account for this, don't consider '-'\r\n         * characters to be valid in general, and filter out '-' characters that appear in the middle of a\r\n         * character class.\r\n         */\n        .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\n        /*\r\n         * The '^' character is also a special case; it must always be escaped outside of character classes, but\r\n         * it only needs to be escaped in character classes if it's at the beginning of the character class. To\r\n         * account for this, consider it to be a valid escape character outside of character classes, and filter\r\n         * out '^' characters that appear at the start of a character class.\r\n         */\n        .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass)) // Filter out characters that aren't escaped.\n        .filter(charInfo => charInfo.escaped) // Filter out characters that are valid to escape, based on their position in the regular expression.\n        .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)) // Report all the remaining characters.\n        .forEach(charInfo => report(node, charInfo.index, charInfo.text));\n      }\n    }\n\n    return {\n      Literal: check,\n      TemplateElement: check\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-escape.js"],"names":["astUtils","require","union","setA","setB","Set","VALID_STRING_ESCAPES","LINEBREAKS","REGEX_GENERAL_ESCAPES","REGEX_NON_CHARCLASS_ESCAPES","parseRegExp","regExpText","charList","split","reduce","state","char","index","escapeNextChar","Object","assign","inCharClass","startingCharClass","length","endsCharClass","push","text","escaped","startsCharClass","module","exports","meta","type","docs","description","recommended","url","hasSuggestions","messages","unnecessaryEscape","removeEscape","escapeBackslash","schema","create","context","sourceCode","getSourceCode","report","node","startOffset","character","rangeStart","range","start","getLocFromIndex","loc","end","line","column","messageId","data","suggest","fix","fixer","removeRange","insertTextBeforeRange","validateString","match","isTemplateElement","escapedChar","isUnnecessaryEscape","has","isQuoteEscape","input","raw","slice","check","parent","quasi","value","getText","pattern","exec","regex","filter","charInfo","forEach","Literal","TemplateElement"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Look for useless escapes in strings and regexes\r\n * @author Onur Temizkan\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Returns the union of two sets.\r\n * @param {Set} setA The first set\r\n * @param {Set} setB The second set\r\n * @returns {Set} The union of the two sets\r\n */\r\nfunction union(setA, setB) {\r\n    return new Set(function *() {\r\n        yield* setA;\r\n        yield* setB;\r\n    }());\r\n}\r\n\r\nconst VALID_STRING_ESCAPES = union(new Set(\"\\\\nrvtbfux\"), astUtils.LINEBREAKS);\r\nconst REGEX_GENERAL_ESCAPES = new Set(\"\\\\bcdDfnpPrsStvwWxu0123456789]\");\r\nconst REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set(\"^/.$*+?[{}|()Bk\"));\r\n\r\n/**\r\n * Parses a regular expression into a list of characters with character class info.\r\n * @param {string} regExpText The raw text used to create the regular expression\r\n * @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.\r\n * @example\r\n *\r\n * parseRegExp(\"a\\\\b[cd-]\");\r\n *\r\n * // returns:\r\n * [\r\n *     { text: \"a\", index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"b\", index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"c\", index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false },\r\n *     { text: \"d\", index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false },\r\n *     { text: \"-\", index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false }\r\n * ];\r\n *\r\n */\r\nfunction parseRegExp(regExpText) {\r\n    const charList = [];\r\n\r\n    regExpText.split(\"\").reduce((state, char, index) => {\r\n        if (!state.escapeNextChar) {\r\n            if (char === \"\\\\\") {\r\n                return Object.assign(state, { escapeNextChar: true });\r\n            }\r\n            if (char === \"[\" && !state.inCharClass) {\r\n                return Object.assign(state, { inCharClass: true, startingCharClass: true });\r\n            }\r\n            if (char === \"]\" && state.inCharClass) {\r\n                if (charList.length && charList[charList.length - 1].inCharClass) {\r\n                    charList[charList.length - 1].endsCharClass = true;\r\n                }\r\n                return Object.assign(state, { inCharClass: false, startingCharClass: false });\r\n            }\r\n        }\r\n        charList.push({\r\n            text: char,\r\n            index,\r\n            escaped: state.escapeNextChar,\r\n            inCharClass: state.inCharClass,\r\n            startsCharClass: state.startingCharClass,\r\n            endsCharClass: false\r\n        });\r\n        return Object.assign(state, { escapeNextChar: false, startingCharClass: false });\r\n    }, { escapeNextChar: false, inCharClass: false, startingCharClass: false });\r\n\r\n    return charList;\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary escape characters\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-useless-escape\"\r\n        },\r\n\r\n        hasSuggestions: true,\r\n\r\n        messages: {\r\n            unnecessaryEscape: \"Unnecessary escape character: \\\\{{character}}.\",\r\n            removeEscape: \"Remove the `\\\\`. This maintains the current functionality.\",\r\n            escapeBackslash: \"Replace the `\\\\` with `\\\\\\\\` to include the actual backslash character.\"\r\n        },\r\n\r\n        schema: []\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports a node\r\n         * @param {ASTNode} node The node to report\r\n         * @param {number} startOffset The backslash's offset from the start of the node\r\n         * @param {string} character The uselessly escaped character (not including the backslash)\r\n         * @returns {void}\r\n         */\r\n        function report(node, startOffset, character) {\r\n            const rangeStart = node.range[0] + startOffset;\r\n            const range = [rangeStart, rangeStart + 1];\r\n            const start = sourceCode.getLocFromIndex(rangeStart);\r\n\r\n            context.report({\r\n                node,\r\n                loc: {\r\n                    start,\r\n                    end: { line: start.line, column: start.column + 1 }\r\n                },\r\n                messageId: \"unnecessaryEscape\",\r\n                data: { character },\r\n                suggest: [\r\n                    {\r\n                        messageId: \"removeEscape\",\r\n                        fix(fixer) {\r\n                            return fixer.removeRange(range);\r\n                        }\r\n                    },\r\n                    {\r\n                        messageId: \"escapeBackslash\",\r\n                        fix(fixer) {\r\n                            return fixer.insertTextBeforeRange(range, \"\\\\\");\r\n                        }\r\n                    }\r\n                ]\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks if the escape character in given string slice is unnecessary.\r\n         * @private\r\n         * @param {ASTNode} node node to validate.\r\n         * @param {string} match string slice to validate.\r\n         * @returns {void}\r\n         */\r\n        function validateString(node, match) {\r\n            const isTemplateElement = node.type === \"TemplateElement\";\r\n            const escapedChar = match[0][1];\r\n            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);\r\n            let isQuoteEscape;\r\n\r\n            if (isTemplateElement) {\r\n                isQuoteEscape = escapedChar === \"`\";\r\n\r\n                if (escapedChar === \"$\") {\r\n\r\n                    // Warn if `\\$` is not followed by `{`\r\n                    isUnnecessaryEscape = match.input[match.index + 2] !== \"{\";\r\n                } else if (escapedChar === \"{\") {\r\n\r\n                    /*\r\n                     * Warn if `\\{` is not preceded by `$`. If preceded by `$`, escaping\r\n                     * is necessary and the rule should not warn. If preceded by `/$`, the rule\r\n                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.\r\n                     */\r\n                    isUnnecessaryEscape = match.input[match.index - 1] !== \"$\";\r\n                }\r\n            } else {\r\n                isQuoteEscape = escapedChar === node.raw[0];\r\n            }\r\n\r\n            if (isUnnecessaryEscape && !isQuoteEscape) {\r\n                report(node, match.index, match[0].slice(1));\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks if a node has an escape.\r\n         * @param {ASTNode} node node to check.\r\n         * @returns {void}\r\n         */\r\n        function check(node) {\r\n            const isTemplateElement = node.type === \"TemplateElement\";\r\n\r\n            if (\r\n                isTemplateElement &&\r\n                node.parent &&\r\n                node.parent.parent &&\r\n                node.parent.parent.type === \"TaggedTemplateExpression\" &&\r\n                node.parent === node.parent.parent.quasi\r\n            ) {\r\n\r\n                // Don't report tagged template literals, because the backslash character is accessible to the tag function.\r\n                return;\r\n            }\r\n\r\n            if (typeof node.value === \"string\" || isTemplateElement) {\r\n\r\n                /*\r\n                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.\r\n                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.\r\n                 */\r\n                if (node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\") {\r\n                    return;\r\n                }\r\n\r\n                const value = isTemplateElement ? sourceCode.getText(node) : node.raw;\r\n                const pattern = /\\\\[^\\d]/gu;\r\n                let match;\r\n\r\n                while ((match = pattern.exec(value))) {\r\n                    validateString(node, match);\r\n                }\r\n            } else if (node.regex) {\r\n                parseRegExp(node.regex.pattern)\r\n\r\n                    /*\r\n                     * The '-' character is a special case, because it's only valid to escape it if it's in a character\r\n                     * class, and is not at either edge of the character class. To account for this, don't consider '-'\r\n                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a\r\n                     * character class.\r\n                     */\r\n                    .filter(charInfo => !(charInfo.text === \"-\" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))\r\n\r\n                    /*\r\n                     * The '^' character is also a special case; it must always be escaped outside of character classes, but\r\n                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To\r\n                     * account for this, consider it to be a valid escape character outside of character classes, and filter\r\n                     * out '^' characters that appear at the start of a character class.\r\n                     */\r\n                    .filter(charInfo => !(charInfo.text === \"^\" && charInfo.startsCharClass))\r\n\r\n                    // Filter out characters that aren't escaped.\r\n                    .filter(charInfo => charInfo.escaped)\r\n\r\n                    // Filter out characters that are valid to escape, based on their position in the regular expression.\r\n                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))\r\n\r\n                    // Report all the remaining characters.\r\n                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));\r\n            }\r\n\r\n        }\r\n\r\n        return {\r\n            Literal: check,\r\n            TemplateElement: check\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}