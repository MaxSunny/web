{"ast":null,"code":"/**\r\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\r\n * @author Teddy Katz\r\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n/**\r\n * Compares the locations of two objects in a source file\r\n * @param {{line: number, column: number}} itemA The first object\r\n * @param {{line: number, column: number}} itemB The second object\r\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\r\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\r\n */\n\n\nfunction compareLocations(itemA, itemB) {\n  return itemA.line - itemB.line || itemA.column - itemB.column;\n}\n/**\r\n * Groups a set of directives into sub-arrays by their parent comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @returns {Directive[][]} Directives grouped by their parent comment.\r\n */\n\n\nfunction groupByParentComment(directives) {\n  const groups = new Map();\n\n  for (const directive of directives) {\n    const {\n      unprocessedDirective: {\n        parentComment\n      }\n    } = directive;\n\n    if (groups.has(parentComment)) {\n      groups.get(parentComment).push(directive);\n    } else {\n      groups.set(parentComment, [directive]);\n    }\n  }\n\n  return [...groups.values()];\n}\n/**\r\n * Creates removal details for a set of directives within the same comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @param {Token} commentToken The backing Comment token.\r\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\r\n */\n\n\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\n  /*\r\n   * `commentToken.value` starts right after `//` or `/*`.\r\n   * All calculated offsets will be relative to this index.\r\n   */\n  const commentValueStart = commentToken.range[0] + \"//\".length; // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\n\n  const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\n  /*\r\n   * Get the list text without any surrounding whitespace. In order to preserve the original\r\n   * formatting, we don't want to change that whitespace.\r\n   *\r\n   *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n   *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   */\n\n  const listText = commentToken.value.slice(listStartOffset) // remove directive name and all whitespace before the list\n  .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\n  .trimRight(); // remove all whitespace after the list\n\n  /*\r\n   * We can assume that `listText` contains multiple elements.\r\n   * Otherwise, this function wouldn't be called - if there is\r\n   * only one rule in the list, then the whole comment must be removed.\r\n   */\n\n  return directives.map(directive => {\n    const {\n      ruleId\n    } = directive;\n    const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)${escapeRegExp(ruleId)}(?:\\s*,\\s*|$)`, \"u\");\n    const match = regex.exec(listText);\n    const matchedText = match[0];\n    const matchStartOffset = listStartOffset + match.index;\n    const matchEndOffset = matchStartOffset + matchedText.length;\n    const firstIndexOfComma = matchedText.indexOf(\",\");\n    const lastIndexOfComma = matchedText.lastIndexOf(\",\");\n    let removalStartOffset, removalEndOffset;\n\n    if (firstIndexOfComma !== lastIndexOfComma) {\n      /*\r\n       * Since there are two commas, this must one of the elements in the middle of the list.\r\n       * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\r\n       *\r\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n       *                                    ^^^^^^^^^^^^^^\r\n       *\r\n       * We want to remove only the content between the two commas, and also one of the commas.\r\n       *\r\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n       *                                     ^^^^^^^^^^^\r\n       */\n      removalStartOffset = matchStartOffset + firstIndexOfComma;\n      removalEndOffset = matchStartOffset + lastIndexOfComma;\n    } else {\n      /*\r\n       * This is either the first element or the last element.\r\n       *\r\n       * If this is the first element, matched range starts where the first rule name starts\r\n       * and ends where the second rule name starts. This is exactly the range we want\r\n       * to remove so that the second rule name will start where the first one was starting\r\n       * and thus preserve the original formatting.\r\n       *\r\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n       *                            ^^^^^^^^^^^\r\n       *\r\n       * Similarly, if this is the last element, we've already matched the range we want to\r\n       * remove. The previous rule name will end where the last one was ending, relative\r\n       * to the content on the right side.\r\n       *\r\n       *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n       *                                               ^^^^^^^^^^^^^\r\n       */\n      removalStartOffset = matchStartOffset;\n      removalEndOffset = matchEndOffset;\n    }\n\n    return {\n      description: `'${ruleId}'`,\n      fix: {\n        range: [commentValueStart + removalStartOffset, commentValueStart + removalEndOffset],\n        text: \"\"\n      },\n      unprocessedDirective: directive.unprocessedDirective\n    };\n  });\n}\n/**\r\n * Creates a description of deleting an entire unused disable comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @param {Token} commentToken The backing Comment token.\r\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\r\n */\n\n\nfunction createCommentRemoval(directives, commentToken) {\n  const {\n    range\n  } = commentToken;\n  const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\n  return {\n    description: ruleIds.length <= 2 ? ruleIds.join(\" or \") : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\n    fix: {\n      range,\n      text: \" \"\n    },\n    unprocessedDirective: directives[0].unprocessedDirective\n  };\n}\n/**\r\n * Parses details from directives to create output Problems.\r\n * @param {Directive[]} allDirectives Unused directives to be removed.\r\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\r\n */\n\n\nfunction processUnusedDisableDirectives(allDirectives) {\n  const directiveGroups = groupByParentComment(allDirectives);\n  return directiveGroups.flatMap(directives => {\n    const {\n      parentComment\n    } = directives[0].unprocessedDirective;\n    const remainingRuleIds = new Set(parentComment.ruleIds);\n\n    for (const directive of directives) {\n      remainingRuleIds.delete(directive.ruleId);\n    }\n\n    return remainingRuleIds.size ? createIndividualDirectivesRemoval(directives, parentComment.commentToken) : [createCommentRemoval(directives, parentComment.commentToken)];\n  });\n}\n/**\r\n * This is the same as the exported function, except that it\r\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\r\n * disable directives.\r\n * @param {Object} options options for applying directives. This is the same as the options\r\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\r\n * (this function always reports unused disable directives).\r\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\r\n * of problems (including suppressed ones) and unused eslint-disable directives\r\n */\n\n\nfunction applyDirectives(options) {\n  const problems = [];\n  const usedDisableDirectives = new Set();\n\n  for (const problem of options.problems) {\n    let disableDirectivesForProblem = [];\n    let nextDirectiveIndex = 0;\n\n    while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {\n      const directive = options.directives[nextDirectiveIndex++];\n\n      if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\n        switch (directive.type) {\n          case \"disable\":\n            disableDirectivesForProblem.push(directive);\n            break;\n\n          case \"enable\":\n            disableDirectivesForProblem = [];\n            break;\n          // no default\n        }\n      }\n    }\n\n    if (disableDirectivesForProblem.length > 0) {\n      const suppressions = disableDirectivesForProblem.map(directive => ({\n        kind: \"directive\",\n        justification: directive.unprocessedDirective.justification\n      }));\n\n      if (problem.suppressions) {\n        problem.suppressions = problem.suppressions.concat(suppressions);\n      } else {\n        problem.suppressions = suppressions;\n        usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\n      }\n    }\n\n    problems.push(problem);\n  }\n\n  const unusedDisableDirectivesToReport = options.directives.filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\n  const processed = processUnusedDisableDirectives(unusedDisableDirectivesToReport);\n  const unusedDisableDirectives = processed.map(_ref => {\n    let {\n      description,\n      fix,\n      unprocessedDirective\n    } = _ref;\n    const {\n      parentComment,\n      type,\n      line,\n      column\n    } = unprocessedDirective;\n    return {\n      ruleId: null,\n      message: description ? `Unused eslint-disable directive (no problems were reported from ${description}).` : \"Unused eslint-disable directive (no problems were reported).\",\n      line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\n      column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\n      severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\n      nodeType: null,\n      ...(options.disableFixes ? {} : {\n        fix\n      })\n    };\n  });\n  return {\n    problems,\n    unusedDisableDirectives\n  };\n}\n/**\r\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\r\n * of reported problems, adds the suppression information to the problems.\r\n * @param {Object} options Information about directives and problems\r\n * @param {{\r\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\r\n *      ruleId: (string|null),\r\n *      line: number,\r\n *      column: number,\r\n *      justification: string\r\n * }} options.directives Directive comments found in the file, with one-based columns.\r\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\r\n * comment for two different rules is represented as two directives).\r\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\r\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\r\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\r\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\r\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\r\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\r\n */\n\n\nmodule.exports = _ref2 => {\n  let {\n    directives,\n    disableFixes,\n    problems,\n    reportUnusedDisableDirectives = \"off\"\n  } = _ref2;\n  const blockDirectives = directives.filter(directive => directive.type === \"disable\" || directive.type === \"enable\").map(directive => Object.assign({}, directive, {\n    unprocessedDirective: directive\n  })).sort(compareLocations);\n  const lineDirectives = directives.flatMap(directive => {\n    switch (directive.type) {\n      case \"disable\":\n      case \"enable\":\n        return [];\n\n      case \"disable-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 1,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      case \"disable-next-line\":\n        return [{\n          type: \"disable\",\n          line: directive.line + 1,\n          column: 1,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }, {\n          type: \"enable\",\n          line: directive.line + 2,\n          column: 0,\n          ruleId: directive.ruleId,\n          unprocessedDirective: directive\n        }];\n\n      default:\n        throw new TypeError(`Unrecognized directive type '${directive.type}'`);\n    }\n  }).sort(compareLocations);\n  const blockDirectivesResult = applyDirectives({\n    problems,\n    directives: blockDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  const lineDirectivesResult = applyDirectives({\n    problems: blockDirectivesResult.problems,\n    directives: lineDirectives,\n    disableFixes,\n    reportUnusedDisableDirectives\n  });\n  return reportUnusedDisableDirectives !== \"off\" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/apply-disable-directives.js"],"names":["escapeRegExp","require","compareLocations","itemA","itemB","line","column","groupByParentComment","directives","groups","Map","directive","unprocessedDirective","parentComment","has","get","push","set","values","createIndividualDirectivesRemoval","commentToken","commentValueStart","range","length","listStartOffset","exec","value","listText","slice","split","trimRight","map","ruleId","regex","RegExp","String","raw","match","matchedText","matchStartOffset","index","matchEndOffset","firstIndexOfComma","indexOf","lastIndexOfComma","lastIndexOf","removalStartOffset","removalEndOffset","description","fix","text","createCommentRemoval","ruleIds","filter","join","processUnusedDisableDirectives","allDirectives","directiveGroups","flatMap","remainingRuleIds","Set","delete","size","applyDirectives","options","problems","usedDisableDirectives","problem","disableDirectivesForProblem","nextDirectiveIndex","type","suppressions","kind","justification","concat","add","unusedDisableDirectivesToReport","processed","unusedDisableDirectives","message","loc","start","severity","reportUnusedDisableDirectives","nodeType","disableFixes","module","exports","blockDirectives","Object","assign","sort","lineDirectives","TypeError","blockDirectivesResult","lineDirectivesResult"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments\r\n * @author Teddy Katz\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst escapeRegExp = require(\"escape-string-regexp\");\r\n\r\n/**\r\n * Compares the locations of two objects in a source file\r\n * @param {{line: number, column: number}} itemA The first object\r\n * @param {{line: number, column: number}} itemB The second object\r\n * @returns {number} A value less than 1 if itemA appears before itemB in the source file, greater than 1 if\r\n * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.\r\n */\r\nfunction compareLocations(itemA, itemB) {\r\n    return itemA.line - itemB.line || itemA.column - itemB.column;\r\n}\r\n\r\n/**\r\n * Groups a set of directives into sub-arrays by their parent comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @returns {Directive[][]} Directives grouped by their parent comment.\r\n */\r\nfunction groupByParentComment(directives) {\r\n    const groups = new Map();\r\n\r\n    for (const directive of directives) {\r\n        const { unprocessedDirective: { parentComment } } = directive;\r\n\r\n        if (groups.has(parentComment)) {\r\n            groups.get(parentComment).push(directive);\r\n        } else {\r\n            groups.set(parentComment, [directive]);\r\n        }\r\n    }\r\n\r\n    return [...groups.values()];\r\n}\r\n\r\n/**\r\n * Creates removal details for a set of directives within the same comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @param {Token} commentToken The backing Comment token.\r\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\r\n */\r\nfunction createIndividualDirectivesRemoval(directives, commentToken) {\r\n\r\n    /*\r\n     * `commentToken.value` starts right after `//` or `/*`.\r\n     * All calculated offsets will be relative to this index.\r\n     */\r\n    const commentValueStart = commentToken.range[0] + \"//\".length;\r\n\r\n    // Find where the list of rules starts. `\\S+` matches with the directive name (e.g. `eslint-disable-line`)\r\n    const listStartOffset = /^\\s*\\S+\\s+/u.exec(commentToken.value)[0].length;\r\n\r\n    /*\r\n     * Get the list text without any surrounding whitespace. In order to preserve the original\r\n     * formatting, we don't want to change that whitespace.\r\n     *\r\n     *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n     *                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n     */\r\n    const listText = commentToken.value\r\n        .slice(listStartOffset) // remove directive name and all whitespace before the list\r\n        .split(/\\s-{2,}\\s/u)[0] // remove `-- comment`, if it exists\r\n        .trimRight(); // remove all whitespace after the list\r\n\r\n    /*\r\n     * We can assume that `listText` contains multiple elements.\r\n     * Otherwise, this function wouldn't be called - if there is\r\n     * only one rule in the list, then the whole comment must be removed.\r\n     */\r\n\r\n    return directives.map(directive => {\r\n        const { ruleId } = directive;\r\n\r\n        const regex = new RegExp(String.raw`(?:^|\\s*,\\s*)${escapeRegExp(ruleId)}(?:\\s*,\\s*|$)`, \"u\");\r\n        const match = regex.exec(listText);\r\n        const matchedText = match[0];\r\n        const matchStartOffset = listStartOffset + match.index;\r\n        const matchEndOffset = matchStartOffset + matchedText.length;\r\n\r\n        const firstIndexOfComma = matchedText.indexOf(\",\");\r\n        const lastIndexOfComma = matchedText.lastIndexOf(\",\");\r\n\r\n        let removalStartOffset, removalEndOffset;\r\n\r\n        if (firstIndexOfComma !== lastIndexOfComma) {\r\n\r\n            /*\r\n             * Since there are two commas, this must one of the elements in the middle of the list.\r\n             * Matched range starts where the previous rule name ends, and ends where the next rule name starts.\r\n             *\r\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n             *                                    ^^^^^^^^^^^^^^\r\n             *\r\n             * We want to remove only the content between the two commas, and also one of the commas.\r\n             *\r\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n             *                                     ^^^^^^^^^^^\r\n             */\r\n            removalStartOffset = matchStartOffset + firstIndexOfComma;\r\n            removalEndOffset = matchStartOffset + lastIndexOfComma;\r\n\r\n        } else {\r\n\r\n            /*\r\n             * This is either the first element or the last element.\r\n             *\r\n             * If this is the first element, matched range starts where the first rule name starts\r\n             * and ends where the second rule name starts. This is exactly the range we want\r\n             * to remove so that the second rule name will start where the first one was starting\r\n             * and thus preserve the original formatting.\r\n             *\r\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n             *                            ^^^^^^^^^^^\r\n             *\r\n             * Similarly, if this is the last element, we've already matched the range we want to\r\n             * remove. The previous rule name will end where the last one was ending, relative\r\n             * to the content on the right side.\r\n             *\r\n             *     // eslint-disable-line rule-one , rule-two , rule-three -- comment\r\n             *                                               ^^^^^^^^^^^^^\r\n             */\r\n            removalStartOffset = matchStartOffset;\r\n            removalEndOffset = matchEndOffset;\r\n        }\r\n\r\n        return {\r\n            description: `'${ruleId}'`,\r\n            fix: {\r\n                range: [\r\n                    commentValueStart + removalStartOffset,\r\n                    commentValueStart + removalEndOffset\r\n                ],\r\n                text: \"\"\r\n            },\r\n            unprocessedDirective: directive.unprocessedDirective\r\n        };\r\n    });\r\n}\r\n\r\n/**\r\n * Creates a description of deleting an entire unused disable comment.\r\n * @param {Directive[]} directives Unused directives to be removed.\r\n * @param {Token} commentToken The backing Comment token.\r\n * @returns {{ description, fix, unprocessedDirective }} Details for later creation of an output Problem.\r\n */\r\nfunction createCommentRemoval(directives, commentToken) {\r\n    const { range } = commentToken;\r\n    const ruleIds = directives.filter(directive => directive.ruleId).map(directive => `'${directive.ruleId}'`);\r\n\r\n    return {\r\n        description: ruleIds.length <= 2\r\n            ? ruleIds.join(\" or \")\r\n            : `${ruleIds.slice(0, ruleIds.length - 1).join(\", \")}, or ${ruleIds[ruleIds.length - 1]}`,\r\n        fix: {\r\n            range,\r\n            text: \" \"\r\n        },\r\n        unprocessedDirective: directives[0].unprocessedDirective\r\n    };\r\n}\r\n\r\n/**\r\n * Parses details from directives to create output Problems.\r\n * @param {Directive[]} allDirectives Unused directives to be removed.\r\n * @returns {{ description, fix, unprocessedDirective }[]} Details for later creation of output Problems.\r\n */\r\nfunction processUnusedDisableDirectives(allDirectives) {\r\n    const directiveGroups = groupByParentComment(allDirectives);\r\n\r\n    return directiveGroups.flatMap(\r\n        directives => {\r\n            const { parentComment } = directives[0].unprocessedDirective;\r\n            const remainingRuleIds = new Set(parentComment.ruleIds);\r\n\r\n            for (const directive of directives) {\r\n                remainingRuleIds.delete(directive.ruleId);\r\n            }\r\n\r\n            return remainingRuleIds.size\r\n                ? createIndividualDirectivesRemoval(directives, parentComment.commentToken)\r\n                : [createCommentRemoval(directives, parentComment.commentToken)];\r\n        }\r\n    );\r\n}\r\n\r\n/**\r\n * This is the same as the exported function, except that it\r\n * doesn't handle disable-line and disable-next-line directives, and it always reports unused\r\n * disable directives.\r\n * @param {Object} options options for applying directives. This is the same as the options\r\n * for the exported function, except that `reportUnusedDisableDirectives` is not supported\r\n * (this function always reports unused disable directives).\r\n * @returns {{problems: Problem[], unusedDisableDirectives: Problem[]}} An object with a list\r\n * of problems (including suppressed ones) and unused eslint-disable directives\r\n */\r\nfunction applyDirectives(options) {\r\n    const problems = [];\r\n    const usedDisableDirectives = new Set();\r\n\r\n    for (const problem of options.problems) {\r\n        let disableDirectivesForProblem = [];\r\n        let nextDirectiveIndex = 0;\r\n\r\n        while (\r\n            nextDirectiveIndex < options.directives.length &&\r\n            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0\r\n        ) {\r\n            const directive = options.directives[nextDirectiveIndex++];\r\n\r\n            if (directive.ruleId === null || directive.ruleId === problem.ruleId) {\r\n                switch (directive.type) {\r\n                    case \"disable\":\r\n                        disableDirectivesForProblem.push(directive);\r\n                        break;\r\n\r\n                    case \"enable\":\r\n                        disableDirectivesForProblem = [];\r\n                        break;\r\n\r\n                    // no default\r\n                }\r\n            }\r\n        }\r\n\r\n        if (disableDirectivesForProblem.length > 0) {\r\n            const suppressions = disableDirectivesForProblem.map(directive => ({\r\n                kind: \"directive\",\r\n                justification: directive.unprocessedDirective.justification\r\n            }));\r\n\r\n            if (problem.suppressions) {\r\n                problem.suppressions = problem.suppressions.concat(suppressions);\r\n            } else {\r\n                problem.suppressions = suppressions;\r\n                usedDisableDirectives.add(disableDirectivesForProblem[disableDirectivesForProblem.length - 1]);\r\n            }\r\n        }\r\n\r\n        problems.push(problem);\r\n    }\r\n\r\n    const unusedDisableDirectivesToReport = options.directives\r\n        .filter(directive => directive.type === \"disable\" && !usedDisableDirectives.has(directive));\r\n\r\n    const processed = processUnusedDisableDirectives(unusedDisableDirectivesToReport);\r\n\r\n    const unusedDisableDirectives = processed\r\n        .map(({ description, fix, unprocessedDirective }) => {\r\n            const { parentComment, type, line, column } = unprocessedDirective;\r\n\r\n            return {\r\n                ruleId: null,\r\n                message: description\r\n                    ? `Unused eslint-disable directive (no problems were reported from ${description}).`\r\n                    : \"Unused eslint-disable directive (no problems were reported).\",\r\n                line: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.line : line,\r\n                column: type === \"disable-next-line\" ? parentComment.commentToken.loc.start.column + 1 : column,\r\n                severity: options.reportUnusedDisableDirectives === \"warn\" ? 1 : 2,\r\n                nodeType: null,\r\n                ...options.disableFixes ? {} : { fix }\r\n            };\r\n        });\r\n\r\n    return { problems, unusedDisableDirectives };\r\n}\r\n\r\n/**\r\n * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list\r\n * of reported problems, adds the suppression information to the problems.\r\n * @param {Object} options Information about directives and problems\r\n * @param {{\r\n *      type: (\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\"),\r\n *      ruleId: (string|null),\r\n *      line: number,\r\n *      column: number,\r\n *      justification: string\r\n * }} options.directives Directive comments found in the file, with one-based columns.\r\n * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable\r\n * comment for two different rules is represented as two directives).\r\n * @param {{ruleId: (string|null), line: number, column: number}[]} options.problems\r\n * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.\r\n * @param {\"off\" | \"warn\" | \"error\"} options.reportUnusedDisableDirectives If `\"warn\"` or `\"error\"`, adds additional problems for unused directives\r\n * @param {boolean} options.disableFixes If true, it doesn't make `fix` properties.\r\n * @returns {{ruleId: (string|null), line: number, column: number, suppressions?: {kind: string, justification: string}}[]}\r\n * An object with a list of reported problems, the suppressed of which contain the suppression information.\r\n */\r\nmodule.exports = ({ directives, disableFixes, problems, reportUnusedDisableDirectives = \"off\" }) => {\r\n    const blockDirectives = directives\r\n        .filter(directive => directive.type === \"disable\" || directive.type === \"enable\")\r\n        .map(directive => Object.assign({}, directive, { unprocessedDirective: directive }))\r\n        .sort(compareLocations);\r\n\r\n    const lineDirectives = directives.flatMap(directive => {\r\n        switch (directive.type) {\r\n            case \"disable\":\r\n            case \"enable\":\r\n                return [];\r\n\r\n            case \"disable-line\":\r\n                return [\r\n                    { type: \"disable\", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\r\n                    { type: \"enable\", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\r\n                ];\r\n\r\n            case \"disable-next-line\":\r\n                return [\r\n                    { type: \"disable\", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive },\r\n                    { type: \"enable\", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive }\r\n                ];\r\n\r\n            default:\r\n                throw new TypeError(`Unrecognized directive type '${directive.type}'`);\r\n        }\r\n    }).sort(compareLocations);\r\n\r\n    const blockDirectivesResult = applyDirectives({\r\n        problems,\r\n        directives: blockDirectives,\r\n        disableFixes,\r\n        reportUnusedDisableDirectives\r\n    });\r\n    const lineDirectivesResult = applyDirectives({\r\n        problems: blockDirectivesResult.problems,\r\n        directives: lineDirectives,\r\n        disableFixes,\r\n        reportUnusedDisableDirectives\r\n    });\r\n\r\n    return reportUnusedDisableDirectives !== \"off\"\r\n        ? lineDirectivesResult.problems\r\n            .concat(blockDirectivesResult.unusedDisableDirectives)\r\n            .concat(lineDirectivesResult.unusedDisableDirectives)\r\n            .sort(compareLocations)\r\n        : lineDirectivesResult.problems;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}