{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of variables before they are defined\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\n/**\r\n * Parses a given value as options.\r\n * @param {any} options A value to parse.\r\n * @returns {Object} The parsed options.\r\n */\n\nfunction parseOptions(options) {\n  let functions = true;\n  let classes = true;\n  let variables = true;\n\n  if (typeof options === \"string\") {\n    functions = options !== \"nofunc\";\n  } else if (typeof options === \"object\" && options !== null) {\n    functions = options.functions !== false;\n    classes = options.classes !== false;\n    variables = options.variables !== false;\n  }\n\n  return {\n    functions,\n    classes,\n    variables\n  };\n}\n/**\r\n * Checks whether or not a given location is inside of the range of a given node.\r\n * @param {ASTNode} node An node to check.\r\n * @param {number} location A location to check.\r\n * @returns {boolean} `true` if the location is inside of the range of the node.\r\n */\n\n\nfunction isInRange(node, location) {\n  return node && node.range[0] <= location && location <= node.range[1];\n}\n/**\r\n * Checks whether or not a given location is inside of the range of a class static initializer.\r\n * Static initializers are static blocks and initializers of static fields.\r\n * @param {ASTNode} node `ClassBody` node to check static initializers.\r\n * @param {number} location A location to check.\r\n * @returns {boolean} `true` if the location is inside of a class static initializer.\r\n */\n\n\nfunction isInClassStaticInitializerRange(node, location) {\n  return node.body.some(classMember => classMember.type === \"StaticBlock\" && isInRange(classMember, location) || classMember.type === \"PropertyDefinition\" && classMember.static && classMember.value && isInRange(classMember.value, location));\n}\n/**\r\n * Checks whether a given scope is the scope of a a class static initializer.\r\n * Static initializers are static blocks and initializers of static fields.\r\n * @param {eslint-scope.Scope} scope A scope to check.\r\n * @returns {boolean} `true` if the scope is a class static initializer scope.\r\n */\n\n\nfunction isClassStaticInitializerScope(scope) {\n  if (scope.type === \"class-static-block\") {\n    return true;\n  }\n\n  if (scope.type === \"class-field-initializer\") {\n    // `scope.block` is PropertyDefinition#value node\n    const propertyDefinition = scope.block.parent;\n    return propertyDefinition.static;\n  }\n\n  return false;\n}\n/**\r\n * Checks whether a given reference is evaluated in an execution context\r\n * that isn't the one where the variable it refers to is defined.\r\n * Execution contexts are:\r\n * - top-level\r\n * - functions\r\n * - class field initializers (implicit functions)\r\n * - class static blocks (implicit functions)\r\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\r\n * and therefore we'll consider them as a part of the parent execution context.\r\n * Example:\r\n *\r\n *   const x = 1;\r\n *\r\n *   x; // returns `false`\r\n *   () => x; // returns `true`\r\n *\r\n *   class C {\r\n *       field = x; // returns `true`\r\n *       static field = x; // returns `false`\r\n *\r\n *       method() {\r\n *           x; // returns `true`\r\n *       }\r\n *\r\n *       static method() {\r\n *           x; // returns `true`\r\n *       }\r\n *\r\n *       static {\r\n *           x; // returns `false`\r\n *       }\r\n *   }\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is from a separate execution context.\r\n */\n\n\nfunction isFromSeparateExecutionContext(reference) {\n  const variable = reference.resolved;\n  let scope = reference.from; // Scope#variableScope represents execution context\n\n  while (variable.scope.variableScope !== scope.variableScope) {\n    if (isClassStaticInitializerScope(scope.variableScope)) {\n      scope = scope.variableScope.upper;\n    } else {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\r\n *\r\n * This returns `true` in the following cases:\r\n *\r\n *     var a = a\r\n *     var [a = a] = list\r\n *     var {a = a} = obj\r\n *     for (var a in a) {}\r\n *     for (var a of a) {}\r\n *     var C = class { [C]; };\r\n *     var C = class { static foo = C; };\r\n *     var C = class { static { foo = C; } };\r\n *     class C extends C {}\r\n *     class C extends (class { static foo = C; }) {}\r\n *     class C { [C]; }\r\n * @param {Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\r\n */\n\n\nfunction isEvaluatedDuringInitialization(reference) {\n  if (isFromSeparateExecutionContext(reference)) {\n    /*\r\n     * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\r\n     * For example, `const x = () => x;` is valid.\r\n     */\n    return false;\n  }\n\n  const location = reference.identifier.range[1];\n  const definition = reference.resolved.defs[0];\n\n  if (definition.type === \"ClassName\") {\n    // `ClassDeclaration` or `ClassExpression`\n    const classDefinition = definition.node;\n    return isInRange(classDefinition, location) &&\n    /*\r\n     * Class binding is initialized before running static initializers.\r\n     * For example, `class C { static foo = C; static { bar = C; } }` is valid.\r\n     */\n    !isInClassStaticInitializerRange(classDefinition.body, location);\n  }\n\n  let node = definition.name.parent;\n\n  while (node) {\n    if (node.type === \"VariableDeclarator\") {\n      if (isInRange(node.init, location)) {\n        return true;\n      }\n\n      if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n        return true;\n      }\n\n      break;\n    } else if (node.type === \"AssignmentPattern\") {\n      if (isInRange(node.right, location)) {\n        return true;\n      }\n    } else if (SENTINEL_TYPE.test(node.type)) {\n      break;\n    }\n\n    node = node.parent;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow the use of variables before they are defined\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-use-before-define\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"nofunc\"]\n      }, {\n        type: \"object\",\n        properties: {\n          functions: {\n            type: \"boolean\"\n          },\n          classes: {\n            type: \"boolean\"\n          },\n          variables: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\n    }\n  },\n\n  create(context) {\n    const options = parseOptions(context.options[0]);\n    /**\r\n     * Determines whether a given reference should be checked.\r\n     *\r\n     * Returns `false` if the reference is:\r\n     * - initialization's (e.g., `let a = 1`).\r\n     * - referring to an undefined variable (i.e., if it's an unresolved reference).\r\n     * - referring to a variable that is defined, but not in the given source code\r\n     *   (e.g., global environment variable or `arguments` in functions).\r\n     * - allowed by options.\r\n     * @param {eslint-scope.Reference} reference The reference\r\n     * @returns {boolean} `true` if the reference should be checked\r\n     */\n\n    function shouldCheck(reference) {\n      if (reference.init) {\n        return false;\n      }\n\n      const variable = reference.resolved;\n\n      if (!variable || variable.defs.length === 0) {\n        return false;\n      }\n\n      const definitionType = variable.defs[0].type;\n\n      if (!options.functions && definitionType === \"FunctionName\") {\n        return false;\n      }\n\n      if ((!options.variables && definitionType === \"Variable\" || !options.classes && definitionType === \"ClassName\") && // don't skip checking the reference if it's in the same execution context, because of TDZ\n      isFromSeparateExecutionContext(reference)) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Finds and validates all references in a given scope and its child scopes.\r\n     * @param {eslint-scope.Scope} scope The scope object.\r\n     * @returns {void}\r\n     */\n\n\n    function checkReferencesInScope(scope) {\n      scope.references.filter(shouldCheck).forEach(reference => {\n        const variable = reference.resolved;\n        const definitionIdentifier = variable.defs[0].name;\n\n        if (reference.identifier.range[1] < definitionIdentifier.range[1] || isEvaluatedDuringInitialization(reference)) {\n          context.report({\n            node: reference.identifier,\n            messageId: \"usedBeforeDefined\",\n            data: reference.identifier\n          });\n        }\n      });\n      scope.childScopes.forEach(checkReferencesInScope);\n    }\n\n    return {\n      Program() {\n        checkReferencesInScope(context.getScope());\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-use-before-define.js"],"names":["SENTINEL_TYPE","FOR_IN_OF_TYPE","parseOptions","options","functions","classes","variables","isInRange","node","location","range","isInClassStaticInitializerRange","body","some","classMember","type","static","value","isClassStaticInitializerScope","scope","propertyDefinition","block","parent","isFromSeparateExecutionContext","reference","variable","resolved","from","variableScope","upper","isEvaluatedDuringInitialization","identifier","definition","defs","classDefinition","name","init","test","right","module","exports","meta","docs","description","recommended","url","schema","oneOf","enum","properties","additionalProperties","messages","usedBeforeDefined","create","context","shouldCheck","length","definitionType","checkReferencesInScope","references","filter","forEach","definitionIdentifier","report","messageId","data","childScopes","Program","getScope"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of variables before they are defined\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\r\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\r\n\r\n/**\r\n * Parses a given value as options.\r\n * @param {any} options A value to parse.\r\n * @returns {Object} The parsed options.\r\n */\r\nfunction parseOptions(options) {\r\n    let functions = true;\r\n    let classes = true;\r\n    let variables = true;\r\n\r\n    if (typeof options === \"string\") {\r\n        functions = (options !== \"nofunc\");\r\n    } else if (typeof options === \"object\" && options !== null) {\r\n        functions = options.functions !== false;\r\n        classes = options.classes !== false;\r\n        variables = options.variables !== false;\r\n    }\r\n\r\n    return { functions, classes, variables };\r\n}\r\n\r\n/**\r\n * Checks whether or not a given location is inside of the range of a given node.\r\n * @param {ASTNode} node An node to check.\r\n * @param {number} location A location to check.\r\n * @returns {boolean} `true` if the location is inside of the range of the node.\r\n */\r\nfunction isInRange(node, location) {\r\n    return node && node.range[0] <= location && location <= node.range[1];\r\n}\r\n\r\n/**\r\n * Checks whether or not a given location is inside of the range of a class static initializer.\r\n * Static initializers are static blocks and initializers of static fields.\r\n * @param {ASTNode} node `ClassBody` node to check static initializers.\r\n * @param {number} location A location to check.\r\n * @returns {boolean} `true` if the location is inside of a class static initializer.\r\n */\r\nfunction isInClassStaticInitializerRange(node, location) {\r\n    return node.body.some(classMember => (\r\n        (\r\n            classMember.type === \"StaticBlock\" &&\r\n            isInRange(classMember, location)\r\n        ) ||\r\n        (\r\n            classMember.type === \"PropertyDefinition\" &&\r\n            classMember.static &&\r\n            classMember.value &&\r\n            isInRange(classMember.value, location)\r\n        )\r\n    ));\r\n}\r\n\r\n/**\r\n * Checks whether a given scope is the scope of a a class static initializer.\r\n * Static initializers are static blocks and initializers of static fields.\r\n * @param {eslint-scope.Scope} scope A scope to check.\r\n * @returns {boolean} `true` if the scope is a class static initializer scope.\r\n */\r\nfunction isClassStaticInitializerScope(scope) {\r\n    if (scope.type === \"class-static-block\") {\r\n        return true;\r\n    }\r\n\r\n    if (scope.type === \"class-field-initializer\") {\r\n\r\n        // `scope.block` is PropertyDefinition#value node\r\n        const propertyDefinition = scope.block.parent;\r\n\r\n        return propertyDefinition.static;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether a given reference is evaluated in an execution context\r\n * that isn't the one where the variable it refers to is defined.\r\n * Execution contexts are:\r\n * - top-level\r\n * - functions\r\n * - class field initializers (implicit functions)\r\n * - class static blocks (implicit functions)\r\n * Static class field initializers and class static blocks are automatically run during the class definition evaluation,\r\n * and therefore we'll consider them as a part of the parent execution context.\r\n * Example:\r\n *\r\n *   const x = 1;\r\n *\r\n *   x; // returns `false`\r\n *   () => x; // returns `true`\r\n *\r\n *   class C {\r\n *       field = x; // returns `true`\r\n *       static field = x; // returns `false`\r\n *\r\n *       method() {\r\n *           x; // returns `true`\r\n *       }\r\n *\r\n *       static method() {\r\n *           x; // returns `true`\r\n *       }\r\n *\r\n *       static {\r\n *           x; // returns `false`\r\n *       }\r\n *   }\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is from a separate execution context.\r\n */\r\nfunction isFromSeparateExecutionContext(reference) {\r\n    const variable = reference.resolved;\r\n    let scope = reference.from;\r\n\r\n    // Scope#variableScope represents execution context\r\n    while (variable.scope.variableScope !== scope.variableScope) {\r\n        if (isClassStaticInitializerScope(scope.variableScope)) {\r\n            scope = scope.variableScope.upper;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given reference is evaluated during the initialization of its variable.\r\n *\r\n * This returns `true` in the following cases:\r\n *\r\n *     var a = a\r\n *     var [a = a] = list\r\n *     var {a = a} = obj\r\n *     for (var a in a) {}\r\n *     for (var a of a) {}\r\n *     var C = class { [C]; };\r\n *     var C = class { static foo = C; };\r\n *     var C = class { static { foo = C; } };\r\n *     class C extends C {}\r\n *     class C extends (class { static foo = C; }) {}\r\n *     class C { [C]; }\r\n * @param {Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is evaluated during the initialization.\r\n */\r\nfunction isEvaluatedDuringInitialization(reference) {\r\n    if (isFromSeparateExecutionContext(reference)) {\r\n\r\n        /*\r\n         * Even if the reference appears in the initializer, it isn't evaluated during the initialization.\r\n         * For example, `const x = () => x;` is valid.\r\n         */\r\n        return false;\r\n    }\r\n\r\n    const location = reference.identifier.range[1];\r\n    const definition = reference.resolved.defs[0];\r\n\r\n    if (definition.type === \"ClassName\") {\r\n\r\n        // `ClassDeclaration` or `ClassExpression`\r\n        const classDefinition = definition.node;\r\n\r\n        return (\r\n            isInRange(classDefinition, location) &&\r\n\r\n            /*\r\n             * Class binding is initialized before running static initializers.\r\n             * For example, `class C { static foo = C; static { bar = C; } }` is valid.\r\n             */\r\n            !isInClassStaticInitializerRange(classDefinition.body, location)\r\n        );\r\n    }\r\n\r\n    let node = definition.name.parent;\r\n\r\n    while (node) {\r\n        if (node.type === \"VariableDeclarator\") {\r\n            if (isInRange(node.init, location)) {\r\n                return true;\r\n            }\r\n            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\r\n                isInRange(node.parent.parent.right, location)\r\n            ) {\r\n                return true;\r\n            }\r\n            break;\r\n        } else if (node.type === \"AssignmentPattern\") {\r\n            if (isInRange(node.right, location)) {\r\n                return true;\r\n            }\r\n        } else if (SENTINEL_TYPE.test(node.type)) {\r\n            break;\r\n        }\r\n\r\n        node = node.parent;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow the use of variables before they are defined\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-use-before-define\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"nofunc\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            functions: { type: \"boolean\" },\r\n                            classes: { type: \"boolean\" },\r\n                            variables: { type: \"boolean\" }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            usedBeforeDefined: \"'{{name}}' was used before it was defined.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = parseOptions(context.options[0]);\r\n\r\n        /**\r\n         * Determines whether a given reference should be checked.\r\n         *\r\n         * Returns `false` if the reference is:\r\n         * - initialization's (e.g., `let a = 1`).\r\n         * - referring to an undefined variable (i.e., if it's an unresolved reference).\r\n         * - referring to a variable that is defined, but not in the given source code\r\n         *   (e.g., global environment variable or `arguments` in functions).\r\n         * - allowed by options.\r\n         * @param {eslint-scope.Reference} reference The reference\r\n         * @returns {boolean} `true` if the reference should be checked\r\n         */\r\n        function shouldCheck(reference) {\r\n            if (reference.init) {\r\n                return false;\r\n            }\r\n\r\n            const variable = reference.resolved;\r\n\r\n            if (!variable || variable.defs.length === 0) {\r\n                return false;\r\n            }\r\n\r\n            const definitionType = variable.defs[0].type;\r\n\r\n            if (!options.functions && definitionType === \"FunctionName\") {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                (\r\n                    !options.variables && definitionType === \"Variable\" ||\r\n                    !options.classes && definitionType === \"ClassName\"\r\n                ) &&\r\n\r\n                // don't skip checking the reference if it's in the same execution context, because of TDZ\r\n                isFromSeparateExecutionContext(reference)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Finds and validates all references in a given scope and its child scopes.\r\n         * @param {eslint-scope.Scope} scope The scope object.\r\n         * @returns {void}\r\n         */\r\n        function checkReferencesInScope(scope) {\r\n            scope.references.filter(shouldCheck).forEach(reference => {\r\n                const variable = reference.resolved;\r\n                const definitionIdentifier = variable.defs[0].name;\r\n\r\n                if (\r\n                    reference.identifier.range[1] < definitionIdentifier.range[1] ||\r\n                    isEvaluatedDuringInitialization(reference)\r\n                ) {\r\n                    context.report({\r\n                        node: reference.identifier,\r\n                        messageId: \"usedBeforeDefined\",\r\n                        data: reference.identifier\r\n                    });\r\n                }\r\n            });\r\n\r\n            scope.childScopes.forEach(checkReferencesInScope);\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                checkReferencesInScope(context.getScope());\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}