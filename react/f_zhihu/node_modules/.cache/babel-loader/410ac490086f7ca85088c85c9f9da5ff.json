{"ast":null,"code":"/**\r\n * @fileoverview Main Linter Class\r\n * @author Gyandeep Singh\r\n * @author aladdin-add\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\"),\n      eslintScope = require(\"eslint-scope\"),\n      evk = require(\"eslint-visitor-keys\"),\n      espree = require(\"espree\"),\n      merge = require(\"lodash.merge\"),\n      pkg = require(\"../../package.json\"),\n      astUtils = require(\"../shared/ast-utils\"),\n      {\n  Legacy: {\n    ConfigOps,\n    ConfigValidator,\n    environments: BuiltInEnvironments\n  }\n} = require(\"@eslint/eslintrc/universal\"),\n      Traverser = require(\"../shared/traverser\"),\n      {\n  SourceCode\n} = require(\"../source-code\"),\n      CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n      applyDisableDirectives = require(\"./apply-disable-directives\"),\n      ConfigCommentParser = require(\"./config-comment-parser\"),\n      NodeEventGenerator = require(\"./node-event-generator\"),\n      createReportTranslator = require(\"./report-translator\"),\n      Rules = require(\"./rules\"),\n      createEmitter = require(\"./safe-emitter\"),\n      SourceCodeFixer = require(\"./source-code-fixer\"),\n      timing = require(\"./timing\"),\n      ruleReplacements = require(\"../../conf/replacements.json\");\n\nconst {\n  getRuleFromConfig\n} = require(\"../config/flat-config-helpers\");\n\nconst {\n  FlatConfigArray\n} = require(\"../config/flat-config-array\");\n\nconst debug = require(\"debug\")(\"eslint:linter\");\n\nconst MAX_AUTOFIX_PASSES = 10;\nconst DEFAULT_PARSER_NAME = \"espree\";\nconst DEFAULT_ECMA_VERSION = 5;\nconst commentParser = new ConfigCommentParser();\nconst DEFAULT_ERROR_LOC = {\n  start: {\n    line: 1,\n    column: 0\n  },\n  end: {\n    line: 1,\n    column: 1\n  }\n};\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\nconst globals = require(\"../../conf/globals\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ConfigArray>} ConfigArray */\n\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ExtractedConfig>} ExtractedConfig */\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").Environment} Environment */\n\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\n\n/** @typedef {import(\"../shared/types\").Processor} Processor */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\r\n * @template T\r\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\r\n */\n\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\r\n * @typedef {Object} DisableDirective\r\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\r\n * @property {number} line The line number\r\n * @property {number} column The column number\r\n * @property {(string|null)} ruleId The rule ID\r\n * @property {string} justification The justification of directive\r\n */\n\n/**\r\n * The private data for `Linter` instance.\r\n * @typedef {Object} LinterInternalSlots\r\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\r\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\r\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\r\n * @property {Map<string, Parser>} parserMap The loaded parsers.\r\n * @property {Rules} ruleMap The loaded rules.\r\n */\n\n/**\r\n * @typedef {Object} VerifyOptions\r\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\r\n *      to change config once it is set. Defaults to true if not supplied.\r\n *      Useful if you want to validate JS without comments overriding rules.\r\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\r\n *      properties into the lint result.\r\n * @property {string} [filename] the filename of the source code.\r\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\r\n *      unused `eslint-disable` directives.\r\n */\n\n/**\r\n * @typedef {Object} ProcessorOptions\r\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\r\n *      predicate function that selects adopt code blocks.\r\n * @property {Processor.postprocess} [postprocess] postprocessor for report\r\n *      messages. If provided, this should accept an array of the message lists\r\n *      for each code block returned from the preprocessor, apply a mapping to\r\n *      the messages as appropriate, and return a one-dimensional array of\r\n *      messages.\r\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\r\n *      If provided, this should accept a string of source text, and return an\r\n *      array of code blocks to lint.\r\n */\n\n/**\r\n * @typedef {Object} FixOptions\r\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\r\n *      whether fixes should be applied.\r\n */\n\n/**\r\n * @typedef {Object} InternalOptions\r\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\r\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines if a given object is Espree.\r\n * @param {Object} parser The parser to check.\r\n * @returns {boolean} True if the parser is Espree or false if not.\r\n */\n\n\nfunction isEspree(parser) {\n  return !!(parser === espree || parser[parserSymbol] === espree);\n}\n/**\r\n * Retrieves globals for the given ecmaVersion.\r\n * @param {number} ecmaVersion The version to retrieve globals for.\r\n * @returns {Object} The globals for the given ecmaVersion.\r\n */\n\n\nfunction getGlobalsForEcmaVersion(ecmaVersion) {\n  switch (ecmaVersion) {\n    case 3:\n      return globals.es3;\n\n    case 5:\n      return globals.es5;\n\n    default:\n      if (ecmaVersion < 2015) {\n        return globals[`es${ecmaVersion + 2009}`];\n      }\n\n      return globals[`es${ecmaVersion}`];\n  }\n}\n/**\r\n * Ensures that variables representing built-in properties of the Global Object,\r\n * and any globals declared by special block comments, are present in the global\r\n * scope.\r\n * @param {Scope} globalScope The global scope.\r\n * @param {Object} configGlobals The globals declared in configuration\r\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\r\n * @returns {void}\r\n */\n\n\nfunction addDeclaredGlobals(globalScope, configGlobals, _ref) {\n  let {\n    exportedVariables,\n    enabledGlobals\n  } = _ref;\n\n  // Define configured global variables.\n  for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\n    /*\r\n     * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\r\n     * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\r\n     */\n    const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\n    const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\n    const value = commentValue || configValue;\n    const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\n\n    if (value === \"off\") {\n      continue;\n    }\n\n    let variable = globalScope.set.get(id);\n\n    if (!variable) {\n      variable = new eslintScope.Variable(id, globalScope);\n      globalScope.variables.push(variable);\n      globalScope.set.set(id, variable);\n    }\n\n    variable.eslintImplicitGlobalSetting = configValue;\n    variable.eslintExplicitGlobal = sourceComments !== void 0;\n    variable.eslintExplicitGlobalComments = sourceComments;\n    variable.writeable = value === \"writable\";\n  } // mark all exported variables as such\n\n\n  Object.keys(exportedVariables).forEach(name => {\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n    }\n  });\n  /*\r\n   * \"through\" contains all references which definitions cannot be found.\r\n   * Since we augment the global scope using configuration, we need to update\r\n   * references and remove the ones that were added by configuration.\r\n   */\n\n  globalScope.through = globalScope.through.filter(reference => {\n    const name = reference.identifier.name;\n    const variable = globalScope.set.get(name);\n\n    if (variable) {\n      /*\r\n       * Links the variable and the reference.\r\n       * And this reference is removed from `Scope#through`.\r\n       */\n      reference.resolved = variable;\n      variable.references.push(reference);\n      return false;\n    }\n\n    return true;\n  });\n}\n/**\r\n * creates a missing-rule message.\r\n * @param {string} ruleId the ruleId to create\r\n * @returns {string} created error message\r\n * @private\r\n */\n\n\nfunction createMissingRuleMessage(ruleId) {\n  return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}` : `Definition for rule '${ruleId}' was not found.`;\n}\n/**\r\n * creates a linting problem\r\n * @param {Object} options to create linting error\r\n * @param {string} [options.ruleId] the ruleId to report\r\n * @param {Object} [options.loc] the loc to report\r\n * @param {string} [options.message] the error message to report\r\n * @param {string} [options.severity] the error message to report\r\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\r\n * @private\r\n */\n\n\nfunction createLintingProblem(options) {\n  const {\n    ruleId = null,\n    loc = DEFAULT_ERROR_LOC,\n    message = createMissingRuleMessage(options.ruleId),\n    severity = 2\n  } = options;\n  return {\n    ruleId,\n    message,\n    line: loc.start.line,\n    column: loc.start.column + 1,\n    endLine: loc.end.line,\n    endColumn: loc.end.column + 1,\n    severity,\n    nodeType: null\n  };\n}\n/**\r\n * Creates a collection of disable directives from a comment\r\n * @param {Object} options to create disable directives\r\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\r\n * @param {token} options.commentToken The Comment token\r\n * @param {string} options.value The value after the directive in the comment\r\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\r\n * @param {string} options.justification The justification of the directive\r\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\r\n * @returns {Object} Directives and problems from the comment\r\n */\n\n\nfunction createDisableDirectives(options) {\n  const {\n    commentToken,\n    type,\n    value,\n    justification,\n    ruleMapper\n  } = options;\n  const ruleIds = Object.keys(commentParser.parseListConfig(value));\n  const directiveRules = ruleIds.length ? ruleIds : [null];\n  const result = {\n    directives: [],\n    // valid disable directives\n    directiveProblems: [] // problems in directives\n\n  };\n  const parentComment = {\n    commentToken,\n    ruleIds\n  };\n\n  for (const ruleId of directiveRules) {\n    // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\n    if (ruleId === null || !!ruleMapper(ruleId)) {\n      if (type === \"disable-next-line\") {\n        result.directives.push({\n          parentComment,\n          type,\n          line: commentToken.loc.end.line,\n          column: commentToken.loc.end.column + 1,\n          ruleId,\n          justification\n        });\n      } else {\n        result.directives.push({\n          parentComment,\n          type,\n          line: commentToken.loc.start.line,\n          column: commentToken.loc.start.column + 1,\n          ruleId,\n          justification\n        });\n      }\n    } else {\n      result.directiveProblems.push(createLintingProblem({\n        ruleId,\n        loc: commentToken.loc\n      }));\n    }\n  }\n\n  return result;\n}\n/**\r\n * Extract the directive and the justification from a given directive comment and trim them.\r\n * @param {string} value The comment text to extract.\r\n * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\r\n */\n\n\nfunction extractDirectiveComment(value) {\n  const match = /\\s-{2,}\\s/u.exec(value);\n\n  if (!match) {\n    return {\n      directivePart: value.trim(),\n      justificationPart: \"\"\n    };\n  }\n\n  const directive = value.slice(0, match.index).trim();\n  const justification = value.slice(match.index + match[0].length).trim();\n  return {\n    directivePart: directive,\n    justificationPart: justification\n  };\n}\n/**\r\n * Parses comments in file to extract file-specific config of rules, globals\r\n * and environments and merges them with global config; also code blocks\r\n * where reporting is disabled or enabled and merges them with reporting config.\r\n * @param {ASTNode} ast The top node of the AST.\r\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\r\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\r\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\r\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\r\n */\n\n\nfunction getDirectiveComments(ast, ruleMapper, warnInlineConfig) {\n  const configuredRules = {};\n  const enabledGlobals = Object.create(null);\n  const exportedVariables = {};\n  const problems = [];\n  const disableDirectives = [];\n  const validator = new ConfigValidator({\n    builtInRules: Rules\n  });\n  ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\n    const {\n      directivePart,\n      justificationPart\n    } = extractDirectiveComment(comment.value);\n    const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(directivePart);\n\n    if (!match) {\n      return;\n    }\n\n    const directiveText = match[1];\n    const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\n\n    if (comment.type === \"Line\" && !lineCommentSupported) {\n      return;\n    }\n\n    if (warnInlineConfig) {\n      const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\n        loc: comment.loc,\n        severity: 1\n      }));\n      return;\n    }\n\n    if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\n      const message = `${directiveText} comment should not span multiple lines.`;\n      problems.push(createLintingProblem({\n        ruleId: null,\n        message,\n        loc: comment.loc\n      }));\n      return;\n    }\n\n    const directiveValue = directivePart.slice(match.index + directiveText.length);\n\n    switch (directiveText) {\n      case \"eslint-disable\":\n      case \"eslint-enable\":\n      case \"eslint-disable-next-line\":\n      case \"eslint-disable-line\":\n        {\n          const directiveType = directiveText.slice(\"eslint-\".length);\n          const options = {\n            commentToken: comment,\n            type: directiveType,\n            value: directiveValue,\n            justification: justificationPart,\n            ruleMapper\n          };\n          const {\n            directives,\n            directiveProblems\n          } = createDisableDirectives(options);\n          disableDirectives.push(...directives);\n          problems.push(...directiveProblems);\n          break;\n        }\n\n      case \"exported\":\n        Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\n        break;\n\n      case \"globals\":\n      case \"global\":\n        for (const [id, {\n          value\n        }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\n          let normalizedValue;\n\n          try {\n            normalizedValue = ConfigOps.normalizeConfigGlobal(value);\n          } catch (err) {\n            problems.push(createLintingProblem({\n              ruleId: null,\n              loc: comment.loc,\n              message: err.message\n            }));\n            continue;\n          }\n\n          if (enabledGlobals[id]) {\n            enabledGlobals[id].comments.push(comment);\n            enabledGlobals[id].value = normalizedValue;\n          } else {\n            enabledGlobals[id] = {\n              comments: [comment],\n              value: normalizedValue\n            };\n          }\n        }\n\n        break;\n\n      case \"eslint\":\n        {\n          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\n\n          if (parseResult.success) {\n            Object.keys(parseResult.config).forEach(name => {\n              const rule = ruleMapper(name);\n              const ruleValue = parseResult.config[name];\n\n              if (!rule) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  loc: comment.loc\n                }));\n                return;\n              }\n\n              try {\n                validator.validateRuleOptions(rule, name, ruleValue);\n              } catch (err) {\n                problems.push(createLintingProblem({\n                  ruleId: name,\n                  message: err.message,\n                  loc: comment.loc\n                })); // do not apply the config, if found invalid options.\n\n                return;\n              }\n\n              configuredRules[name] = ruleValue;\n            });\n          } else {\n            problems.push(parseResult.error);\n          }\n\n          break;\n        }\n      // no default\n    }\n  });\n  return {\n    configuredRules,\n    enabledGlobals,\n    exportedVariables,\n    problems,\n    disableDirectives\n  };\n}\n/**\r\n * Normalize ECMAScript version from the initial config\r\n * @param {Parser} parser The parser which uses this options.\r\n * @param {number} ecmaVersion ECMAScript version from the initial config\r\n * @returns {number} normalized ECMAScript version\r\n */\n\n\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\n  if (isEspree(parser)) {\n    if (ecmaVersion === \"latest\") {\n      return espree.latestEcmaVersion;\n    }\n  }\n  /*\r\n   * Calculate ECMAScript edition number from official year version starting with\r\n   * ES2015, which corresponds with ES6 (or a difference of 2009).\r\n   */\n\n\n  return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\n}\n/**\r\n * Normalize ECMAScript version from the initial config into languageOptions (year)\r\n * format.\r\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\r\n * @returns {number} normalized ECMAScript version\r\n */\n\n\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\n  switch (ecmaVersion) {\n    case 3:\n      return 3;\n    // void 0 = no ecmaVersion specified so use the default\n\n    case 5:\n    case void 0:\n      return 5;\n\n    default:\n      if (typeof ecmaVersion === \"number\") {\n        return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\n      }\n\n  }\n  /*\r\n   * We default to the latest supported ecmaVersion for everything else.\r\n   * Remember, this is for languageOptions.ecmaVersion, which sets the version\r\n   * that is used for a number of processes inside of ESLint. It's normally\r\n   * safe to assume people want the latest unless otherwise specified.\r\n   */\n\n\n  return espree.latestEcmaVersion + 2009;\n}\n\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)(?:\\*\\/|$)/gsu;\n/**\r\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\r\n * @param {string} text A source code text to check.\r\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\r\n */\n\nfunction findEslintEnv(text) {\n  let match, retv;\n  eslintEnvPattern.lastIndex = 0;\n\n  while ((match = eslintEnvPattern.exec(text)) !== null) {\n    if (match[0].endsWith(\"*/\")) {\n      retv = Object.assign(retv || {}, commentParser.parseListConfig(extractDirectiveComment(match[1]).directivePart));\n    }\n  }\n\n  return retv;\n}\n/**\r\n * Convert \"/path/to/<text>\" to \"<text>\".\r\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\r\n * was omitted because `configArray.extractConfig()` requires an absolute path.\r\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\r\n * case.\r\n * Also, code blocks can have their virtual filename. If the parent filename was\r\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\r\n * it's not an absolute path).\r\n * @param {string} filename The filename to normalize.\r\n * @returns {string} The normalized filename.\r\n */\n\n\nfunction normalizeFilename(filename) {\n  const parts = filename.split(path.sep);\n  const index = parts.lastIndexOf(\"<text>\");\n  return index === -1 ? filename : parts.slice(index).join(path.sep);\n}\n/**\r\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\r\n * consistent shape.\r\n * @param {VerifyOptions} providedOptions Options\r\n * @param {ConfigData} config Config.\r\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\r\n */\n\n\nfunction normalizeVerifyOptions(providedOptions, config) {\n  const linterOptions = config.linterOptions || config; // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\n\n  const disableInlineConfig = linterOptions.noInlineConfig === true;\n  const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\n  const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : \"\";\n  let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\n\n  if (typeof reportUnusedDisableDirectives === \"boolean\") {\n    reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\n  }\n\n  if (typeof reportUnusedDisableDirectives !== \"string\") {\n    reportUnusedDisableDirectives = linterOptions.reportUnusedDisableDirectives ? \"warn\" : \"off\";\n  }\n\n  return {\n    filename: normalizeFilename(providedOptions.filename || \"<input>\"),\n    allowInlineConfig: !ignoreInlineConfig,\n    warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,\n    reportUnusedDisableDirectives,\n    disableFixes: Boolean(providedOptions.disableFixes)\n  };\n}\n/**\r\n * Combines the provided parserOptions with the options from environments\r\n * @param {Parser} parser The parser which uses this options.\r\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\r\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\r\n * @returns {ParserOptions} Resulting parser options after merge\r\n */\n\n\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\n  const parserOptionsFromEnv = enabledEnvironments.filter(env => env.parserOptions).reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\n  const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\n  const isModule = mergedParserOptions.sourceType === \"module\";\n\n  if (isModule) {\n    /*\r\n     * can't have global return inside of modules\r\n     * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\r\n     */\n    mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {\n      globalReturn: false\n    });\n  }\n\n  mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\n  return mergedParserOptions;\n}\n/**\r\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\r\n * @param {ConfigData} config Config object.\r\n * @param {Object} config.globals Global variable definitions.\r\n * @param {Parser} config.parser The parser to use.\r\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\r\n * @returns {LanguageOptions} The languageOptions equivalent.\r\n */\n\n\nfunction createLanguageOptions(_ref2) {\n  let {\n    globals: configuredGlobals,\n    parser,\n    parserOptions\n  } = _ref2;\n  const {\n    ecmaVersion,\n    sourceType\n  } = parserOptions;\n  return {\n    globals: configuredGlobals,\n    ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),\n    sourceType,\n    parser,\n    parserOptions\n  };\n}\n/**\r\n * Combines the provided globals object with the globals from environments\r\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\r\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\r\n * @returns {Record<string, GlobalConf>} The resolved globals object\r\n */\n\n\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\n  return Object.assign({}, ...enabledEnvironments.filter(env => env.globals).map(env => env.globals), providedGlobals);\n}\n/**\r\n * Strips Unicode BOM from a given text.\r\n * @param {string} text A text to strip.\r\n * @returns {string} The stripped text.\r\n */\n\n\nfunction stripUnicodeBOM(text) {\n  /*\r\n   * Check Unicode BOM.\r\n   * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\r\n   * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\r\n   */\n  if (text.charCodeAt(0) === 0xFEFF) {\n    return text.slice(1);\n  }\n\n  return text;\n}\n/**\r\n * Get the options for a rule (not including severity), if any\r\n * @param {Array|number} ruleConfig rule configuration\r\n * @returns {Array} of rule options, empty Array if none\r\n */\n\n\nfunction getRuleOptions(ruleConfig) {\n  if (Array.isArray(ruleConfig)) {\n    return ruleConfig.slice(1);\n  }\n\n  return [];\n}\n/**\r\n * Analyze scope of the given AST.\r\n * @param {ASTNode} ast The `Program` node to analyze.\r\n * @param {LanguageOptions} languageOptions The parser options.\r\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\r\n * @returns {ScopeManager} The analysis result.\r\n */\n\n\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\n  const parserOptions = languageOptions.parserOptions;\n  const ecmaFeatures = parserOptions.ecmaFeatures || {};\n  const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\n  return eslintScope.analyze(ast, {\n    ignoreEval: true,\n    nodejsScope: ecmaFeatures.globalReturn,\n    impliedStrict: ecmaFeatures.impliedStrict,\n    ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\n    sourceType: languageOptions.sourceType || \"script\",\n    childVisitorKeys: visitorKeys || evk.KEYS,\n    fallback: Traverser.getKeys\n  });\n}\n/**\r\n * Parses text into an AST. Moved out here because the try-catch prevents\r\n * optimization of functions, so it's best to keep the try-catch as isolated\r\n * as possible\r\n * @param {string} text The text to parse.\r\n * @param {LanguageOptions} languageOptions Options to pass to the parser\r\n * @param {string} filePath The path to the file being parsed.\r\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\r\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\r\n * @private\r\n */\n\n\nfunction parse(text, languageOptions, filePath) {\n  const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\n  const {\n    ecmaVersion,\n    sourceType,\n    parser\n  } = languageOptions;\n  const parserOptions = Object.assign({\n    ecmaVersion,\n    sourceType\n  }, languageOptions.parserOptions, {\n    loc: true,\n    range: true,\n    raw: true,\n    tokens: true,\n    comment: true,\n    eslintVisitorKeys: true,\n    eslintScopeManager: true,\n    filePath\n  });\n  /*\r\n   * Check for parsing errors first. If there's a parsing error, nothing\r\n   * else can happen. However, a parsing error does not throw an error\r\n   * from this method - it's just considered a fatal error message, a\r\n   * problem that ESLint identified just like any other.\r\n   */\n\n  try {\n    debug(\"Parsing:\", filePath);\n    const parseResult = typeof parser.parseForESLint === \"function\" ? parser.parseForESLint(textToParse, parserOptions) : {\n      ast: parser.parse(textToParse, parserOptions)\n    };\n    debug(\"Parsing successful:\", filePath);\n    const ast = parseResult.ast;\n    const parserServices = parseResult.services || {};\n    const visitorKeys = parseResult.visitorKeys || evk.KEYS;\n    debug(\"Scope analysis:\", filePath);\n    const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);\n    debug(\"Scope analysis successful:\", filePath);\n    return {\n      success: true,\n\n      /*\r\n       * Save all values that `parseForESLint()` returned.\r\n       * If a `SourceCode` object is given as the first parameter instead of source code text,\r\n       * linter skips the parsing process and reuses the source code object.\r\n       * In that case, linter needs all the values that `parseForESLint()` returned.\r\n       */\n      sourceCode: new SourceCode({\n        text,\n        ast,\n        parserServices,\n        scopeManager,\n        visitorKeys\n      })\n    };\n  } catch (ex) {\n    // If the message includes a leading line number, strip it:\n    const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\n    debug(\"%s\\n%s\", message, ex.stack);\n    return {\n      success: false,\n      error: {\n        ruleId: null,\n        fatal: true,\n        severity: 2,\n        message,\n        line: ex.lineNumber,\n        column: ex.column\n      }\n    };\n  }\n}\n/**\r\n * Gets the scope for the current node\r\n * @param {ScopeManager} scopeManager The scope manager for this AST\r\n * @param {ASTNode} currentNode The node to get the scope of\r\n * @returns {eslint-scope.Scope} The scope information for this node\r\n */\n\n\nfunction getScope(scopeManager, currentNode) {\n  // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\n  const inner = currentNode.type !== \"Program\";\n\n  for (let node = currentNode; node; node = node.parent) {\n    const scope = scopeManager.acquire(node, inner);\n\n    if (scope) {\n      if (scope.type === \"function-expression-name\") {\n        return scope.childScopes[0];\n      }\n\n      return scope;\n    }\n  }\n\n  return scopeManager.scopes[0];\n}\n/**\r\n * Marks a variable as used in the current scope\r\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\r\n * @param {ASTNode} currentNode The node currently being traversed\r\n * @param {LanguageOptions} languageOptions The options used to parse this text\r\n * @param {string} name The name of the variable that should be marked as used.\r\n * @returns {boolean} True if the variable was found and marked as used, false if not.\r\n */\n\n\nfunction markVariableAsUsed(scopeManager, currentNode, languageOptions, name) {\n  const parserOptions = languageOptions.parserOptions;\n  const sourceType = languageOptions.sourceType;\n  const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn || sourceType === \"commonjs\";\n  const specialScope = hasGlobalReturn || sourceType === \"module\";\n  const currentScope = getScope(scopeManager, currentNode); // Special Node.js scope means we need to start one level deeper\n\n  const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\n\n  for (let scope = initialScope; scope; scope = scope.upper) {\n    const variable = scope.variables.find(scopeVar => scopeVar.name === name);\n\n    if (variable) {\n      variable.eslintUsed = true;\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * Runs a rule, and gets its listeners\r\n * @param {Rule} rule A normalized rule with a `create` method\r\n * @param {Context} ruleContext The context that should be passed to the rule\r\n * @throws {any} Any error during the rule's `create`\r\n * @returns {Object} A map of selector listeners provided by the rule\r\n */\n\n\nfunction createRuleListeners(rule, ruleContext) {\n  try {\n    return rule.create(ruleContext);\n  } catch (ex) {\n    ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\n    throw ex;\n  }\n}\n/**\r\n * Gets all the ancestors of a given node\r\n * @param {ASTNode} node The node\r\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\r\n * from the root node and going inwards to the parent node.\r\n */\n\n\nfunction getAncestors(node) {\n  const ancestorsStartingAtParent = [];\n\n  for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n    ancestorsStartingAtParent.push(ancestor);\n  }\n\n  return ancestorsStartingAtParent.reverse();\n} // methods that exist on SourceCode object\n\n\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\n  getSource: \"getText\",\n  getSourceLines: \"getLines\",\n  getAllComments: \"getAllComments\",\n  getNodeByRangeIndex: \"getNodeByRangeIndex\",\n  getComments: \"getComments\",\n  getCommentsBefore: \"getCommentsBefore\",\n  getCommentsAfter: \"getCommentsAfter\",\n  getCommentsInside: \"getCommentsInside\",\n  getJSDocComment: \"getJSDocComment\",\n  getFirstToken: \"getFirstToken\",\n  getFirstTokens: \"getFirstTokens\",\n  getLastToken: \"getLastToken\",\n  getLastTokens: \"getLastTokens\",\n  getTokenAfter: \"getTokenAfter\",\n  getTokenBefore: \"getTokenBefore\",\n  getTokenByRangeStart: \"getTokenByRangeStart\",\n  getTokens: \"getTokens\",\n  getTokensAfter: \"getTokensAfter\",\n  getTokensBefore: \"getTokensBefore\",\n  getTokensBetween: \"getTokensBetween\"\n};\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {\n  [methodName]() {\n    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...arguments);\n  }\n\n}), {}));\n/**\r\n * Runs the given rules on the given SourceCode object\r\n * @param {SourceCode} sourceCode A SourceCode object for the given text\r\n * @param {Object} configuredRules The rules configuration\r\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\r\n * @param {string | undefined} parserName The name of the parser in the config\r\n * @param {LanguageOptions} languageOptions The options for parsing the code.\r\n * @param {Object} settings The settings that were enabled in the config\r\n * @param {string} filename The reported filename of the code\r\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\r\n * @param {string | undefined} cwd cwd of the cli\r\n * @param {string} physicalFilename The full path of the file on disk without any code block information\r\n * @returns {Problem[]} An array of reported problems\r\n */\n\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserName, languageOptions, settings, filename, disableFixes, cwd, physicalFilename) {\n  const emitter = createEmitter();\n  const nodeQueue = [];\n  let currentNode = sourceCode.ast;\n  Traverser.traverse(sourceCode.ast, {\n    enter(node, parent) {\n      node.parent = parent;\n      nodeQueue.push({\n        isEntering: true,\n        node\n      });\n    },\n\n    leave(node) {\n      nodeQueue.push({\n        isEntering: false,\n        node\n      });\n    },\n\n    visitorKeys: sourceCode.visitorKeys\n  });\n  /*\r\n   * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\r\n   * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\r\n   * properties once for each rule.\r\n   */\n\n  const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {\n    getAncestors: () => getAncestors(currentNode),\n    getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\n    getCwd: () => cwd,\n    getFilename: () => filename,\n    getPhysicalFilename: () => physicalFilename || filename,\n    getScope: () => getScope(sourceCode.scopeManager, currentNode),\n    getSourceCode: () => sourceCode,\n    markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, languageOptions, name),\n    parserOptions: { ...languageOptions.parserOptions\n    },\n    parserPath: parserName,\n    languageOptions,\n    parserServices: sourceCode.parserServices,\n    settings\n  }));\n  const lintingProblems = [];\n  Object.keys(configuredRules).forEach(ruleId => {\n    const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]); // not load disabled rules\n\n    if (severity === 0) {\n      return;\n    }\n\n    const rule = ruleMapper(ruleId);\n\n    if (!rule) {\n      lintingProblems.push(createLintingProblem({\n        ruleId\n      }));\n      return;\n    }\n\n    const messageIds = rule.meta && rule.meta.messages;\n    let reportTranslator = null;\n    const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {\n      id: ruleId,\n      options: getRuleOptions(configuredRules[ruleId]),\n\n      report() {\n        /*\r\n         * Create a report translator lazily.\r\n         * In a vast majority of cases, any given rule reports zero errors on a given\r\n         * piece of code. Creating a translator lazily avoids the performance cost of\r\n         * creating a new translator function for each rule that usually doesn't get\r\n         * called.\r\n         *\r\n         * Using lazy report translators improves end-to-end performance by about 3%\r\n         * with Node 8.4.0.\r\n         */\n        if (reportTranslator === null) {\n          reportTranslator = createReportTranslator({\n            ruleId,\n            severity,\n            sourceCode,\n            messageIds,\n            disableFixes\n          });\n        }\n\n        const problem = reportTranslator(...arguments);\n\n        if (problem.fix && !(rule.meta && rule.meta.fixable)) {\n          throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\n        }\n\n        if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {\n          if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== \"undefined\") {\n            // Encourage migration from the former property name.\n            throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.\");\n          }\n\n          throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.\");\n        }\n\n        lintingProblems.push(problem);\n      }\n\n    }));\n    const ruleListeners = createRuleListeners(rule, ruleContext);\n    /**\r\n     * Include `ruleId` in error logs\r\n     * @param {Function} ruleListener A rule method that listens for a node.\r\n     * @returns {Function} ruleListener wrapped in error handler\r\n     */\n\n    function addRuleErrorHandler(ruleListener) {\n      return function ruleErrorHandler() {\n        try {\n          return ruleListener(...arguments);\n        } catch (e) {\n          e.ruleId = ruleId;\n          throw e;\n        }\n      };\n    } // add all the selectors from the rule as listeners\n\n\n    Object.keys(ruleListeners).forEach(selector => {\n      const ruleListener = timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector];\n      emitter.on(selector, addRuleErrorHandler(ruleListener));\n    });\n  }); // only run code path analyzer if the top level node is \"Program\", skip otherwise\n\n  const eventGenerator = nodeQueue[0].node.type === \"Program\" ? new CodePathAnalyzer(new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  })) : new NodeEventGenerator(emitter, {\n    visitorKeys: sourceCode.visitorKeys,\n    fallback: Traverser.getKeys\n  });\n  nodeQueue.forEach(traversalInfo => {\n    currentNode = traversalInfo.node;\n\n    try {\n      if (traversalInfo.isEntering) {\n        eventGenerator.enterNode(currentNode);\n      } else {\n        eventGenerator.leaveNode(currentNode);\n      }\n    } catch (err) {\n      err.currentNode = currentNode;\n      throw err;\n    }\n  });\n  return lintingProblems;\n}\n/**\r\n * Ensure the source code to be a string.\r\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\r\n * @returns {string} The source code text.\r\n */\n\n\nfunction ensureText(textOrSourceCode) {\n  if (typeof textOrSourceCode === \"object\") {\n    const {\n      hasBOM,\n      text\n    } = textOrSourceCode;\n    const bom = hasBOM ? \"\\uFEFF\" : \"\";\n    return bom + text;\n  }\n\n  return String(textOrSourceCode);\n}\n/**\r\n * Get an environment.\r\n * @param {LinterInternalSlots} slots The internal slots of Linter.\r\n * @param {string} envId The environment ID to get.\r\n * @returns {Environment|null} The environment.\r\n */\n\n\nfunction getEnv(slots, envId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;\n}\n/**\r\n * Get a rule.\r\n * @param {LinterInternalSlots} slots The internal slots of Linter.\r\n * @param {string} ruleId The rule ID to get.\r\n * @returns {Rule|null} The rule.\r\n */\n\n\nfunction getRule(slots, ruleId) {\n  return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);\n}\n/**\r\n * Normalize the value of the cwd\r\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\r\n * @returns {string | undefined} normalized cwd\r\n */\n\n\nfunction normalizeCwd(cwd) {\n  if (cwd) {\n    return cwd;\n  }\n\n  if (typeof process === \"object\") {\n    return process.cwd();\n  } // It's more explicit to assign the undefined\n  // eslint-disable-next-line no-undefined -- Consistently returning a value\n\n\n  return undefined;\n}\n/**\r\n * The map to store private data.\r\n * @type {WeakMap<Linter, LinterInternalSlots>}\r\n */\n\n\nconst internalSlotsMap = new WeakMap();\n/**\r\n * Throws an error when the given linter is in flat config mode.\r\n * @param {Linter} linter The linter to check.\r\n * @returns {void}\r\n * @throws {Error} If the linter is in flat config mode.\r\n */\n\nfunction assertEslintrcConfig(linter) {\n  const {\n    configType\n  } = internalSlotsMap.get(linter);\n\n  if (configType === \"flat\") {\n    throw new Error(\"This method cannot be used with flat config. Add your entries directly into the config array.\");\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * Object that is responsible for verifying JavaScript text\r\n * @name Linter\r\n */\n\n\nclass Linter {\n  /**\r\n   * Initialize the Linter.\r\n   * @param {Object} [config] the config object\r\n   * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\r\n   * @param {\"flat\"|\"eslintrc\"} [config.configType=\"eslintrc\"] the type of config used.\r\n   */\n  constructor() {\n    let {\n      cwd,\n      configType\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    internalSlotsMap.set(this, {\n      cwd: normalizeCwd(cwd),\n      lastConfigArray: null,\n      lastSourceCode: null,\n      lastSuppressedMessages: [],\n      configType,\n      // TODO: Remove after flat config conversion\n      parserMap: new Map([[\"espree\", espree]]),\n      ruleMap: new Rules()\n    });\n    this.version = pkg.version;\n  }\n  /**\r\n   * Getter for package version.\r\n   * @static\r\n   * @returns {string} The version from package.json.\r\n   */\n\n\n  static get version() {\n    return pkg.version;\n  }\n  /**\r\n   * Same as linter.verify, except without support for processors.\r\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n   * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\r\n   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\r\n   * @throws {Error} If during rule execution.\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\r\n   */\n\n\n  _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text; // evaluate arguments\n\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    } // Resolve parser.\n\n\n    let parserName = DEFAULT_PARSER_NAME;\n    let parser = espree;\n\n    if (typeof config.parser === \"object\" && config.parser !== null) {\n      parserName = config.parser.filePath;\n      parser = config.parser.definition;\n    } else if (typeof config.parser === \"string\") {\n      if (!slots.parserMap.has(config.parser)) {\n        return [{\n          ruleId: null,\n          fatal: true,\n          severity: 2,\n          message: `Configured parser '${config.parser}' was not found.`,\n          line: 0,\n          column: 0\n        }];\n      }\n\n      parserName = config.parser;\n      parser = slots.parserMap.get(config.parser);\n    } // search and apply \"eslint-env *\".\n\n\n    const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};\n    const resolvedEnvConfig = Object.assign({\n      builtin: true\n    }, config.env, envInFile);\n    const enabledEnvs = Object.keys(resolvedEnvConfig).filter(envName => resolvedEnvConfig[envName]).map(envName => getEnv(slots, envName)).filter(env => env);\n    const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\n    const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\n    const settings = config.settings || {};\n    const languageOptions = createLanguageOptions({\n      globals: config.globals,\n      parser,\n      parserOptions\n    });\n\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, languageOptions, options.filename);\n\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      /*\r\n       * If the given source code object as the first argument does not have scopeManager, analyze the scope.\r\n       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\r\n       */\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n        });\n      }\n    }\n\n    const sourceCode = slots.lastSourceCode;\n    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig) : {\n      configuredRules: {},\n      enabledGlobals: {},\n      exportedVariables: {},\n      problems: [],\n      disableDirectives: []\n    }; // augment global scope with declared global variables\n\n    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {\n      exportedVariables: commentDirectives.exportedVariables,\n      enabledGlobals: commentDirectives.enabledGlobals\n    });\n    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n    let lintingProblems;\n\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRule(slots, ruleId), parserName, languageOptions, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n\n      debug(\"Parser Options:\", parserOptions);\n      debug(\"Parser Path:\", parserName);\n      debug(\"Settings:\", settings);\n\n      if (err.ruleId) {\n        err.message += `\\nRule: \"${err.ruleId}\"`;\n      }\n\n      throw err;\n    }\n\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      disableFixes: options.disableFixes,\n      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n  /**\r\n   * Verifies the text against the rules specified by the second argument.\r\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n   * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\r\n   * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\r\n   *      If this is not set, the filename will default to '<input>' in the rule context. If\r\n   *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\r\n   * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\r\n   */\n\n\n  verify(textOrSourceCode, config, filenameOrOptions) {\n    debug(\"Verify\");\n    const {\n      configType\n    } = internalSlotsMap.get(this);\n    const options = typeof filenameOrOptions === \"string\" ? {\n      filename: filenameOrOptions\n    } : filenameOrOptions || {};\n\n    if (config) {\n      if (configType === \"flat\") {\n        /*\r\n         * Because of how Webpack packages up the files, we can't\r\n         * compare directly to `FlatConfigArray` using `instanceof`\r\n         * because it's not the same `FlatConfigArray` as in the tests.\r\n         * So, we work around it by assuming an array is, in fact, a\r\n         * `FlatConfigArray` if it has a `getConfig()` method.\r\n         */\n        let configArray = config;\n\n        if (!Array.isArray(config) || typeof config.getConfig !== \"function\") {\n          configArray = new FlatConfigArray(config);\n          configArray.normalizeSync();\n        }\n\n        return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));\n      }\n\n      if (typeof config.extractConfig === \"function\") {\n        return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, config, options));\n      }\n    }\n    /*\r\n     * If we get to here, it means `config` is just an object rather\r\n     * than a config array so we can go right into linting.\r\n     */\n\n    /*\r\n     * `Linter` doesn't support `overrides` property in configuration.\r\n     * So we cannot apply multiple processors.\r\n     */\n\n\n    if (options.preprocess || options.postprocess) {\n      return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, config, options));\n    }\n\n    return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, config, options));\n  }\n  /**\r\n   * Verify with a processor.\r\n   * @param {string|SourceCode} textOrSourceCode The source code.\r\n   * @param {FlatConfig} config The config array.\r\n   * @param {VerifyOptions&ProcessorOptions} options The options.\r\n   * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n   */\n\n\n  _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n\n    const preprocess = options.preprocess || (rawText => [rawText]);\n\n    const postprocess = options.postprocess || (messagesList => messagesList.flat());\n\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n\n    const originalExtname = path.extname(filename);\n    const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\"); // Keep the legacy behavior.\n\n      if (typeof block === \"string\") {\n        return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);\n      }\n\n      const blockText = block.text;\n      const blockName = path.join(filename, `${i}_${block.filename}`); // Skip this block if filtered.\n\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      } // Resolve configuration again if the file content or extension was changed.\n\n\n      if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithFlatConfigArray(blockText, configForRecursive, { ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      } // Does lint.\n\n\n      return this._verifyWithFlatConfigArrayAndWithoutProcessors(blockText, config, { ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n  /**\r\n   * Same as linter.verify, except without support for processors.\r\n   * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n   * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\r\n   * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\r\n   * @throws {Error} If during rule execution.\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\r\n   */\n\n\n  _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\n    const slots = internalSlotsMap.get(this);\n    const config = providedConfig || {};\n    const options = normalizeVerifyOptions(providedOptions, config);\n    let text; // evaluate arguments\n\n    if (typeof textOrSourceCode === \"string\") {\n      slots.lastSourceCode = null;\n      text = textOrSourceCode;\n    } else {\n      slots.lastSourceCode = textOrSourceCode;\n      text = textOrSourceCode.text;\n    }\n\n    const languageOptions = config.languageOptions;\n    languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(languageOptions.ecmaVersion); // add configured globals and language globals\n\n    const configuredGlobals = { ...getGlobalsForEcmaVersion(languageOptions.ecmaVersion),\n      ...(languageOptions.sourceType === \"commonjs\" ? globals.commonjs : void 0),\n      ...languageOptions.globals\n    }; // Espree expects this information to be passed in\n\n    if (isEspree(languageOptions.parser)) {\n      const parserOptions = languageOptions.parserOptions;\n\n      if (languageOptions.sourceType) {\n        parserOptions.sourceType = languageOptions.sourceType;\n\n        if (parserOptions.sourceType === \"module\" && parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) {\n          parserOptions.ecmaFeatures.globalReturn = false;\n        }\n      }\n    }\n\n    const settings = config.settings || {};\n\n    if (!slots.lastSourceCode) {\n      const parseResult = parse(text, languageOptions, options.filename);\n\n      if (!parseResult.success) {\n        return [parseResult.error];\n      }\n\n      slots.lastSourceCode = parseResult.sourceCode;\n    } else {\n      /*\r\n       * If the given source code object as the first argument does not have scopeManager, analyze the scope.\r\n       * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\r\n       */\n      if (!slots.lastSourceCode.scopeManager) {\n        slots.lastSourceCode = new SourceCode({\n          text: slots.lastSourceCode.text,\n          ast: slots.lastSourceCode.ast,\n          parserServices: slots.lastSourceCode.parserServices,\n          visitorKeys: slots.lastSourceCode.visitorKeys,\n          scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\n        });\n      }\n    }\n\n    const sourceCode = slots.lastSourceCode;\n    const commentDirectives = options.allowInlineConfig ? getDirectiveComments(sourceCode.ast, ruleId => getRuleFromConfig(ruleId, config), options.warnInlineConfig) : {\n      configuredRules: {},\n      enabledGlobals: {},\n      exportedVariables: {},\n      problems: [],\n      disableDirectives: []\n    }; // augment global scope with declared global variables\n\n    addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {\n      exportedVariables: commentDirectives.exportedVariables,\n      enabledGlobals: commentDirectives.enabledGlobals\n    });\n    const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\n    let lintingProblems;\n\n    try {\n      lintingProblems = runRules(sourceCode, configuredRules, ruleId => getRuleFromConfig(ruleId, config), void 0, languageOptions, settings, options.filename, options.disableFixes, slots.cwd, providedOptions.physicalFilename);\n    } catch (err) {\n      err.message += `\\nOccurred while linting ${options.filename}`;\n      debug(\"An error occurred while traversing\");\n      debug(\"Filename:\", options.filename);\n\n      if (err.currentNode) {\n        const {\n          line\n        } = err.currentNode.loc.start;\n        debug(\"Line:\", line);\n        err.message += `:${line}`;\n      }\n\n      debug(\"Parser Options:\", languageOptions.parserOptions); // debug(\"Parser Path:\", parserName);\n\n      debug(\"Settings:\", settings);\n\n      if (err.ruleId) {\n        err.message += `\\nRule: \"${err.ruleId}\"`;\n      }\n\n      throw err;\n    }\n\n    return applyDisableDirectives({\n      directives: commentDirectives.disableDirectives,\n      disableFixes: options.disableFixes,\n      problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\n      reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\n    });\n  }\n  /**\r\n   * Verify a given code with `ConfigArray`.\r\n   * @param {string|SourceCode} textOrSourceCode The source code.\r\n   * @param {ConfigArray} configArray The config array.\r\n   * @param {VerifyOptions&ProcessorOptions} options The options.\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n   */\n\n\n  _verifyWithConfigArray(textOrSourceCode, configArray, options) {\n    debug(\"With ConfigArray: %s\", options.filename); // Store the config array in order to get plugin envs and rules later.\n\n    internalSlotsMap.get(this).lastConfigArray = configArray; // Extract the final config for this file.\n\n    const config = configArray.extractConfig(options.filename);\n    const processor = config.processor && configArray.pluginProcessors.get(config.processor); // Verify.\n\n    if (processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithProcessor(textOrSourceCode, config, { ...options,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    }\n\n    return this._verifyWithoutProcessors(textOrSourceCode, config, options);\n  }\n  /**\r\n   * Verify a given code with a flat config.\r\n   * @param {string|SourceCode} textOrSourceCode The source code.\r\n   * @param {FlatConfigArray} configArray The config array.\r\n   * @param {VerifyOptions&ProcessorOptions} options The options.\r\n   * @param {boolean} [firstCall=false] Indicates if this is being called directly\r\n   *      from verify(). (TODO: Remove once eslintrc is removed.)\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n   */\n\n\n  _verifyWithFlatConfigArray(textOrSourceCode, configArray, options) {\n    let firstCall = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    debug(\"With flat config: %s\", options.filename); // we need a filename to match configs against\n\n    const filename = options.filename || \"<input>\"; // Store the config array in order to get plugin envs and rules later.\n\n    internalSlotsMap.get(this).lastConfigArray = configArray;\n    const config = configArray.getConfig(filename); // Verify.\n\n    if (config.processor) {\n      debug(\"Apply the processor: %o\", config.processor);\n      const {\n        preprocess,\n        postprocess,\n        supportsAutofix\n      } = config.processor;\n      const disableFixes = options.disableFixes || !supportsAutofix;\n      return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, { ...options,\n        filename,\n        disableFixes,\n        postprocess,\n        preprocess\n      }, configArray);\n    } // check for options-based processing\n\n\n    if (firstCall && (options.preprocess || options.postprocess)) {\n      return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);\n    }\n\n    return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);\n  }\n  /**\r\n   * Verify with a processor.\r\n   * @param {string|SourceCode} textOrSourceCode The source code.\r\n   * @param {ConfigData|ExtractedConfig} config The config array.\r\n   * @param {VerifyOptions&ProcessorOptions} options The options.\r\n   * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\r\n   * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n   */\n\n\n  _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\n    const filename = options.filename || \"<input>\";\n    const filenameToExpose = normalizeFilename(filename);\n    const physicalFilename = options.physicalFilename || filenameToExpose;\n    const text = ensureText(textOrSourceCode);\n\n    const preprocess = options.preprocess || (rawText => [rawText]);\n\n    const postprocess = options.postprocess || (messagesList => messagesList.flat());\n\n    const filterCodeBlock = options.filterCodeBlock || (blockFilename => blockFilename.endsWith(\".js\"));\n\n    const originalExtname = path.extname(filename);\n    const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\n      debug(\"A code block was found: %o\", block.filename || \"(unnamed)\"); // Keep the legacy behavior.\n\n      if (typeof block === \"string\") {\n        return this._verifyWithoutProcessors(block, config, options);\n      }\n\n      const blockText = block.text;\n      const blockName = path.join(filename, `${i}_${block.filename}`); // Skip this block if filtered.\n\n      if (!filterCodeBlock(blockName, blockText)) {\n        debug(\"This code block was skipped.\");\n        return [];\n      } // Resolve configuration again if the file content or extension was changed.\n\n\n      if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\n        debug(\"Resolving configuration again because the file content or extension was changed.\");\n        return this._verifyWithConfigArray(blockText, configForRecursive, { ...options,\n          filename: blockName,\n          physicalFilename\n        });\n      } // Does lint.\n\n\n      return this._verifyWithoutProcessors(blockText, config, { ...options,\n        filename: blockName,\n        physicalFilename\n      });\n    });\n    return postprocess(messageLists, filenameToExpose);\n  }\n  /**\r\n   * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\r\n   * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\r\n   * @param {Problem[]} problems A list of reported problems.\r\n   * @returns {LintMessage[]} A list of LintMessage.\r\n   */\n\n\n  _distinguishSuppressedMessages(problems) {\n    const messages = [];\n    const suppressedMessages = [];\n    const slots = internalSlotsMap.get(this);\n\n    for (const problem of problems) {\n      if (problem.suppressions) {\n        suppressedMessages.push(problem);\n      } else {\n        messages.push(problem);\n      }\n    }\n\n    slots.lastSuppressedMessages = suppressedMessages;\n    return messages;\n  }\n  /**\r\n   * Gets the SourceCode object representing the parsed source.\r\n   * @returns {SourceCode} The SourceCode object.\r\n   */\n\n\n  getSourceCode() {\n    return internalSlotsMap.get(this).lastSourceCode;\n  }\n  /**\r\n   * Gets the list of SuppressedLintMessage produced in the last running.\r\n   * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\r\n   */\n\n\n  getSuppressedMessages() {\n    return internalSlotsMap.get(this).lastSuppressedMessages;\n  }\n  /**\r\n   * Defines a new linting rule.\r\n   * @param {string} ruleId A unique rule identifier\r\n   * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\r\n   * @returns {void}\r\n   */\n\n\n  defineRule(ruleId, ruleModule) {\n    assertEslintrcConfig(this);\n    internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\n  }\n  /**\r\n   * Defines many new linting rules.\r\n   * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\r\n   * @returns {void}\r\n   */\n\n\n  defineRules(rulesToDefine) {\n    assertEslintrcConfig(this);\n    Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\n      this.defineRule(ruleId, rulesToDefine[ruleId]);\n    });\n  }\n  /**\r\n   * Gets an object with all loaded rules.\r\n   * @returns {Map<string, Rule>} All loaded rules\r\n   */\n\n\n  getRules() {\n    assertEslintrcConfig(this);\n    const {\n      lastConfigArray,\n      ruleMap\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* ruleMap;\n\n      if (lastConfigArray) {\n        yield* lastConfigArray.pluginRules;\n      }\n    }());\n  }\n  /**\r\n   * Define a new parser module\r\n   * @param {string} parserId Name of the parser\r\n   * @param {Parser} parserModule The parser object\r\n   * @returns {void}\r\n   */\n\n\n  defineParser(parserId, parserModule) {\n    assertEslintrcConfig(this);\n    internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\n  }\n  /**\r\n   * Performs multiple autofix passes over the text until as many fixes as possible\r\n   * have been applied.\r\n   * @param {string} text The source text to apply fixes to.\r\n   * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\r\n   * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\r\n   * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\r\n   *      SourceCodeFixer.\r\n   */\n\n\n  verifyAndFix(text, config, options) {\n    let messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0,\n        currentText = text;\n    const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\n    const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\n    /**\r\n     * This loop continues until one of the following is true:\r\n     *\r\n     * 1. No more fixes have been applied.\r\n     * 2. Ten passes have been made.\r\n     *\r\n     * That means anytime a fix is successfully applied, there will be another pass.\r\n     * Essentially, guaranteeing a minimum of two passes.\r\n     */\n\n    do {\n      passNumber++;\n      debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\n      messages = this.verify(currentText, config, options);\n      debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\n      fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\n      /*\r\n       * stop if there are any syntax errors.\r\n       * 'fixedResult.output' is a empty string.\r\n       */\n\n      if (messages.length === 1 && messages[0].fatal) {\n        break;\n      } // keep track if any fixes were ever applied - important for return value\n\n\n      fixed = fixed || fixedResult.fixed; // update to use the fixed output instead of the original text\n\n      currentText = fixedResult.output;\n    } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);\n    /*\r\n     * If the last result had fixes, we need to lint again to be sure we have\r\n     * the most up-to-date information.\r\n     */\n\n\n    if (fixedResult.fixed) {\n      fixedResult.messages = this.verify(currentText, config, options);\n    } // ensure the last result properly reflects if fixes were done\n\n\n    fixedResult.fixed = fixed;\n    fixedResult.output = currentText;\n    return fixedResult;\n  }\n\n}\n\nmodule.exports = {\n  Linter,\n\n  /**\r\n   * Get the internal slots of a given Linter instance for tests.\r\n   * @param {Linter} instance The Linter instance to get.\r\n   * @returns {LinterInternalSlots} The internal slots.\r\n   */\n  getLinterInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/linter.js"],"names":["path","require","eslintScope","evk","espree","merge","pkg","astUtils","Legacy","ConfigOps","ConfigValidator","environments","BuiltInEnvironments","Traverser","SourceCode","CodePathAnalyzer","applyDisableDirectives","ConfigCommentParser","NodeEventGenerator","createReportTranslator","Rules","createEmitter","SourceCodeFixer","timing","ruleReplacements","getRuleFromConfig","FlatConfigArray","debug","MAX_AUTOFIX_PASSES","DEFAULT_PARSER_NAME","DEFAULT_ECMA_VERSION","commentParser","DEFAULT_ERROR_LOC","start","line","column","end","parserSymbol","Symbol","for","globals","isEspree","parser","getGlobalsForEcmaVersion","ecmaVersion","es3","es5","addDeclaredGlobals","globalScope","configGlobals","exportedVariables","enabledGlobals","id","Set","Object","keys","configValue","normalizeConfigGlobal","commentValue","value","sourceComments","comments","variable","set","get","Variable","variables","push","eslintImplicitGlobalSetting","eslintExplicitGlobal","eslintExplicitGlobalComments","writeable","forEach","name","eslintUsed","through","filter","reference","identifier","resolved","references","createMissingRuleMessage","ruleId","prototype","hasOwnProperty","call","rules","join","createLintingProblem","options","loc","message","severity","endLine","endColumn","nodeType","createDisableDirectives","commentToken","type","justification","ruleMapper","ruleIds","parseListConfig","directiveRules","length","result","directives","directiveProblems","parentComment","extractDirectiveComment","match","exec","directivePart","trim","justificationPart","directive","slice","index","getDirectiveComments","ast","warnInlineConfig","configuredRules","create","problems","disableDirectives","validator","builtInRules","token","comment","directiveText","lineCommentSupported","test","kind","directiveValue","directiveType","assign","parseStringConfig","entries","normalizedValue","err","parseResult","parseJsonConfig","success","config","rule","ruleValue","validateRuleOptions","error","normalizeEcmaVersion","latestEcmaVersion","normalizeEcmaVersionForLanguageOptions","eslintEnvPattern","findEslintEnv","text","retv","lastIndex","endsWith","normalizeFilename","filename","parts","split","sep","lastIndexOf","normalizeVerifyOptions","providedOptions","linterOptions","disableInlineConfig","noInlineConfig","ignoreInlineConfig","allowInlineConfig","configNameOfNoInlineConfig","reportUnusedDisableDirectives","disableFixes","Boolean","resolveParserOptions","enabledEnvironments","parserOptionsFromEnv","env","parserOptions","reduce","mergedParserOptions","isModule","sourceType","ecmaFeatures","globalReturn","createLanguageOptions","configuredGlobals","resolveGlobals","providedGlobals","map","stripUnicodeBOM","charCodeAt","getRuleOptions","ruleConfig","Array","isArray","analyzeScope","languageOptions","visitorKeys","analyze","ignoreEval","nodejsScope","impliedStrict","childVisitorKeys","KEYS","fallback","getKeys","parse","filePath","textToParse","replace","shebangPattern","captured","range","raw","tokens","eslintVisitorKeys","eslintScopeManager","parseForESLint","parserServices","services","scopeManager","sourceCode","ex","stack","fatal","lineNumber","getScope","currentNode","inner","node","parent","scope","acquire","childScopes","scopes","markVariableAsUsed","hasGlobalReturn","specialScope","currentScope","initialScope","upper","find","scopeVar","createRuleListeners","ruleContext","getAncestors","ancestorsStartingAtParent","ancestor","reverse","DEPRECATED_SOURCECODE_PASSTHROUGHS","getSource","getSourceLines","getAllComments","getNodeByRangeIndex","getComments","getCommentsBefore","getCommentsAfter","getCommentsInside","getJSDocComment","getFirstToken","getFirstTokens","getLastToken","getLastTokens","getTokenAfter","getTokenBefore","getTokenByRangeStart","getTokens","getTokensAfter","getTokensBefore","getTokensBetween","BASE_TRAVERSAL_CONTEXT","freeze","contextInfo","methodName","getSourceCode","runRules","parserName","settings","cwd","physicalFilename","emitter","nodeQueue","traverse","enter","isEntering","leave","sharedTraversalContext","getDeclaredVariables","bind","getCwd","getFilename","getPhysicalFilename","parserPath","lintingProblems","getRuleSeverity","messageIds","meta","messages","reportTranslator","report","problem","fix","fixable","Error","suggestions","hasSuggestions","docs","suggestion","ruleListeners","addRuleErrorHandler","ruleListener","ruleErrorHandler","e","selector","enabled","time","on","eventGenerator","traversalInfo","enterNode","leaveNode","ensureText","textOrSourceCode","hasBOM","bom","String","getEnv","slots","envId","lastConfigArray","pluginEnvironments","getRule","pluginRules","ruleMap","normalizeCwd","process","undefined","internalSlotsMap","WeakMap","assertEslintrcConfig","linter","configType","Linter","constructor","lastSourceCode","lastSuppressedMessages","parserMap","Map","version","_verifyWithoutProcessors","providedConfig","definition","has","envInFile","resolvedEnvConfig","builtin","enabledEnvs","envName","commentDirectives","concat","sort","problemA","problemB","verify","filenameOrOptions","configArray","getConfig","normalizeSync","_distinguishSuppressedMessages","_verifyWithFlatConfigArray","extractConfig","_verifyWithConfigArray","preprocess","postprocess","_verifyWithProcessor","_verifyWithFlatConfigArrayAndProcessor","configForRecursive","filenameToExpose","rawText","messagesList","flat","filterCodeBlock","blockFilename","originalExtname","extname","messageLists","block","i","_verifyWithFlatConfigArrayAndWithoutProcessors","blockText","blockName","commonjs","processor","pluginProcessors","supportsAutofix","firstCall","suppressedMessages","suppressions","getSuppressedMessages","defineRule","ruleModule","define","defineRules","rulesToDefine","getOwnPropertyNames","getRules","defineParser","parserId","parserModule","verifyAndFix","fixedResult","fixed","passNumber","currentText","debugTextDescription","shouldFix","applyFixes","output","module","exports","getLinterInternalSlots","instance"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Main Linter Class\r\n * @author Gyandeep Singh\r\n * @author aladdin-add\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst\r\n    path = require(\"path\"),\r\n    eslintScope = require(\"eslint-scope\"),\r\n    evk = require(\"eslint-visitor-keys\"),\r\n    espree = require(\"espree\"),\r\n    merge = require(\"lodash.merge\"),\r\n    pkg = require(\"../../package.json\"),\r\n    astUtils = require(\"../shared/ast-utils\"),\r\n    {\r\n        Legacy: {\r\n            ConfigOps,\r\n            ConfigValidator,\r\n            environments: BuiltInEnvironments\r\n        }\r\n    } = require(\"@eslint/eslintrc/universal\"),\r\n    Traverser = require(\"../shared/traverser\"),\r\n    { SourceCode } = require(\"../source-code\"),\r\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\r\n    applyDisableDirectives = require(\"./apply-disable-directives\"),\r\n    ConfigCommentParser = require(\"./config-comment-parser\"),\r\n    NodeEventGenerator = require(\"./node-event-generator\"),\r\n    createReportTranslator = require(\"./report-translator\"),\r\n    Rules = require(\"./rules\"),\r\n    createEmitter = require(\"./safe-emitter\"),\r\n    SourceCodeFixer = require(\"./source-code-fixer\"),\r\n    timing = require(\"./timing\"),\r\n    ruleReplacements = require(\"../../conf/replacements.json\");\r\nconst { getRuleFromConfig } = require(\"../config/flat-config-helpers\");\r\nconst { FlatConfigArray } = require(\"../config/flat-config-array\");\r\n\r\nconst debug = require(\"debug\")(\"eslint:linter\");\r\nconst MAX_AUTOFIX_PASSES = 10;\r\nconst DEFAULT_PARSER_NAME = \"espree\";\r\nconst DEFAULT_ECMA_VERSION = 5;\r\nconst commentParser = new ConfigCommentParser();\r\nconst DEFAULT_ERROR_LOC = { start: { line: 1, column: 0 }, end: { line: 1, column: 1 } };\r\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\r\nconst globals = require(\"../../conf/globals\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ConfigArray>} ConfigArray */\r\n/** @typedef {InstanceType<import(\"../cli-engine/config-array\").ExtractedConfig>} ExtractedConfig */\r\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\r\n/** @typedef {import(\"../shared/types\").Environment} Environment */\r\n/** @typedef {import(\"../shared/types\").GlobalConf} GlobalConf */\r\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\r\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\r\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\r\n/** @typedef {import(\"../shared/types\").LanguageOptions} LanguageOptions */\r\n/** @typedef {import(\"../shared/types\").Processor} Processor */\r\n/** @typedef {import(\"../shared/types\").Rule} Rule */\r\n\r\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\r\n/**\r\n * @template T\r\n * @typedef {{ [P in keyof T]-?: T[P] }} Required\r\n */\r\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\r\n\r\n/**\r\n * @typedef {Object} DisableDirective\r\n * @property {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} type Type of directive\r\n * @property {number} line The line number\r\n * @property {number} column The column number\r\n * @property {(string|null)} ruleId The rule ID\r\n * @property {string} justification The justification of directive\r\n */\r\n\r\n/**\r\n * The private data for `Linter` instance.\r\n * @typedef {Object} LinterInternalSlots\r\n * @property {ConfigArray|null} lastConfigArray The `ConfigArray` instance that the last `verify()` call used.\r\n * @property {SourceCode|null} lastSourceCode The `SourceCode` instance that the last `verify()` call used.\r\n * @property {SuppressedLintMessage[]} lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.\r\n * @property {Map<string, Parser>} parserMap The loaded parsers.\r\n * @property {Rules} ruleMap The loaded rules.\r\n */\r\n\r\n/**\r\n * @typedef {Object} VerifyOptions\r\n * @property {boolean} [allowInlineConfig] Allow/disallow inline comments' ability\r\n *      to change config once it is set. Defaults to true if not supplied.\r\n *      Useful if you want to validate JS without comments overriding rules.\r\n * @property {boolean} [disableFixes] if `true` then the linter doesn't make `fix`\r\n *      properties into the lint result.\r\n * @property {string} [filename] the filename of the source code.\r\n * @property {boolean | \"off\" | \"warn\" | \"error\"} [reportUnusedDisableDirectives] Adds reported errors for\r\n *      unused `eslint-disable` directives.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ProcessorOptions\r\n * @property {(filename:string, text:string) => boolean} [filterCodeBlock] the\r\n *      predicate function that selects adopt code blocks.\r\n * @property {Processor.postprocess} [postprocess] postprocessor for report\r\n *      messages. If provided, this should accept an array of the message lists\r\n *      for each code block returned from the preprocessor, apply a mapping to\r\n *      the messages as appropriate, and return a one-dimensional array of\r\n *      messages.\r\n * @property {Processor.preprocess} [preprocess] preprocessor for source text.\r\n *      If provided, this should accept a string of source text, and return an\r\n *      array of code blocks to lint.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FixOptions\r\n * @property {boolean | ((message: LintMessage) => boolean)} [fix] Determines\r\n *      whether fixes should be applied.\r\n */\r\n\r\n/**\r\n * @typedef {Object} InternalOptions\r\n * @property {string | null} warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.\r\n * @property {\"off\" | \"warn\" | \"error\"} reportUnusedDisableDirectives (boolean values were normalized)\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if a given object is Espree.\r\n * @param {Object} parser The parser to check.\r\n * @returns {boolean} True if the parser is Espree or false if not.\r\n */\r\nfunction isEspree(parser) {\r\n    return !!(parser === espree || parser[parserSymbol] === espree);\r\n}\r\n\r\n/**\r\n * Retrieves globals for the given ecmaVersion.\r\n * @param {number} ecmaVersion The version to retrieve globals for.\r\n * @returns {Object} The globals for the given ecmaVersion.\r\n */\r\nfunction getGlobalsForEcmaVersion(ecmaVersion) {\r\n\r\n    switch (ecmaVersion) {\r\n        case 3:\r\n            return globals.es3;\r\n\r\n        case 5:\r\n            return globals.es5;\r\n\r\n        default:\r\n            if (ecmaVersion < 2015) {\r\n                return globals[`es${ecmaVersion + 2009}`];\r\n            }\r\n\r\n            return globals[`es${ecmaVersion}`];\r\n    }\r\n}\r\n\r\n/**\r\n * Ensures that variables representing built-in properties of the Global Object,\r\n * and any globals declared by special block comments, are present in the global\r\n * scope.\r\n * @param {Scope} globalScope The global scope.\r\n * @param {Object} configGlobals The globals declared in configuration\r\n * @param {{exportedVariables: Object, enabledGlobals: Object}} commentDirectives Directives from comment configuration\r\n * @returns {void}\r\n */\r\nfunction addDeclaredGlobals(globalScope, configGlobals, { exportedVariables, enabledGlobals }) {\r\n\r\n    // Define configured global variables.\r\n    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {\r\n\r\n        /*\r\n         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would\r\n         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).\r\n         */\r\n        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);\r\n        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;\r\n        const value = commentValue || configValue;\r\n        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;\r\n\r\n        if (value === \"off\") {\r\n            continue;\r\n        }\r\n\r\n        let variable = globalScope.set.get(id);\r\n\r\n        if (!variable) {\r\n            variable = new eslintScope.Variable(id, globalScope);\r\n\r\n            globalScope.variables.push(variable);\r\n            globalScope.set.set(id, variable);\r\n        }\r\n\r\n        variable.eslintImplicitGlobalSetting = configValue;\r\n        variable.eslintExplicitGlobal = sourceComments !== void 0;\r\n        variable.eslintExplicitGlobalComments = sourceComments;\r\n        variable.writeable = (value === \"writable\");\r\n    }\r\n\r\n    // mark all exported variables as such\r\n    Object.keys(exportedVariables).forEach(name => {\r\n        const variable = globalScope.set.get(name);\r\n\r\n        if (variable) {\r\n            variable.eslintUsed = true;\r\n        }\r\n    });\r\n\r\n    /*\r\n     * \"through\" contains all references which definitions cannot be found.\r\n     * Since we augment the global scope using configuration, we need to update\r\n     * references and remove the ones that were added by configuration.\r\n     */\r\n    globalScope.through = globalScope.through.filter(reference => {\r\n        const name = reference.identifier.name;\r\n        const variable = globalScope.set.get(name);\r\n\r\n        if (variable) {\r\n\r\n            /*\r\n             * Links the variable and the reference.\r\n             * And this reference is removed from `Scope#through`.\r\n             */\r\n            reference.resolved = variable;\r\n            variable.references.push(reference);\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    });\r\n}\r\n\r\n/**\r\n * creates a missing-rule message.\r\n * @param {string} ruleId the ruleId to create\r\n * @returns {string} created error message\r\n * @private\r\n */\r\nfunction createMissingRuleMessage(ruleId) {\r\n    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId)\r\n        ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(\", \")}`\r\n        : `Definition for rule '${ruleId}' was not found.`;\r\n}\r\n\r\n/**\r\n * creates a linting problem\r\n * @param {Object} options to create linting error\r\n * @param {string} [options.ruleId] the ruleId to report\r\n * @param {Object} [options.loc] the loc to report\r\n * @param {string} [options.message] the error message to report\r\n * @param {string} [options.severity] the error message to report\r\n * @returns {LintMessage} created problem, returns a missing-rule problem if only provided ruleId.\r\n * @private\r\n */\r\nfunction createLintingProblem(options) {\r\n    const {\r\n        ruleId = null,\r\n        loc = DEFAULT_ERROR_LOC,\r\n        message = createMissingRuleMessage(options.ruleId),\r\n        severity = 2\r\n    } = options;\r\n\r\n    return {\r\n        ruleId,\r\n        message,\r\n        line: loc.start.line,\r\n        column: loc.start.column + 1,\r\n        endLine: loc.end.line,\r\n        endColumn: loc.end.column + 1,\r\n        severity,\r\n        nodeType: null\r\n    };\r\n}\r\n\r\n/**\r\n * Creates a collection of disable directives from a comment\r\n * @param {Object} options to create disable directives\r\n * @param {(\"disable\"|\"enable\"|\"disable-line\"|\"disable-next-line\")} options.type The type of directive comment\r\n * @param {token} options.commentToken The Comment token\r\n * @param {string} options.value The value after the directive in the comment\r\n * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)\r\n * @param {string} options.justification The justification of the directive\r\n * @param {function(string): {create: Function}} options.ruleMapper A map from rule IDs to defined rules\r\n * @returns {Object} Directives and problems from the comment\r\n */\r\nfunction createDisableDirectives(options) {\r\n    const { commentToken, type, value, justification, ruleMapper } = options;\r\n    const ruleIds = Object.keys(commentParser.parseListConfig(value));\r\n    const directiveRules = ruleIds.length ? ruleIds : [null];\r\n    const result = {\r\n        directives: [], // valid disable directives\r\n        directiveProblems: [] // problems in directives\r\n    };\r\n\r\n    const parentComment = { commentToken, ruleIds };\r\n\r\n    for (const ruleId of directiveRules) {\r\n\r\n        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)\r\n        if (ruleId === null || !!ruleMapper(ruleId)) {\r\n            if (type === \"disable-next-line\") {\r\n                result.directives.push({\r\n                    parentComment,\r\n                    type,\r\n                    line: commentToken.loc.end.line,\r\n                    column: commentToken.loc.end.column + 1,\r\n                    ruleId,\r\n                    justification\r\n                });\r\n            } else {\r\n                result.directives.push({\r\n                    parentComment,\r\n                    type,\r\n                    line: commentToken.loc.start.line,\r\n                    column: commentToken.loc.start.column + 1,\r\n                    ruleId,\r\n                    justification\r\n                });\r\n            }\r\n        } else {\r\n            result.directiveProblems.push(createLintingProblem({ ruleId, loc: commentToken.loc }));\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Extract the directive and the justification from a given directive comment and trim them.\r\n * @param {string} value The comment text to extract.\r\n * @returns {{directivePart: string, justificationPart: string}} The extracted directive and justification.\r\n */\r\nfunction extractDirectiveComment(value) {\r\n    const match = /\\s-{2,}\\s/u.exec(value);\r\n\r\n    if (!match) {\r\n        return { directivePart: value.trim(), justificationPart: \"\" };\r\n    }\r\n\r\n    const directive = value.slice(0, match.index).trim();\r\n    const justification = value.slice(match.index + match[0].length).trim();\r\n\r\n    return { directivePart: directive, justificationPart: justification };\r\n}\r\n\r\n/**\r\n * Parses comments in file to extract file-specific config of rules, globals\r\n * and environments and merges them with global config; also code blocks\r\n * where reporting is disabled or enabled and merges them with reporting config.\r\n * @param {ASTNode} ast The top node of the AST.\r\n * @param {function(string): {create: Function}} ruleMapper A map from rule IDs to defined rules\r\n * @param {string|null} warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.\r\n * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token}[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]}}\r\n * A collection of the directive comments that were found, along with any problems that occurred when parsing\r\n */\r\nfunction getDirectiveComments(ast, ruleMapper, warnInlineConfig) {\r\n    const configuredRules = {};\r\n    const enabledGlobals = Object.create(null);\r\n    const exportedVariables = {};\r\n    const problems = [];\r\n    const disableDirectives = [];\r\n    const validator = new ConfigValidator({\r\n        builtInRules: Rules\r\n    });\r\n\r\n    ast.comments.filter(token => token.type !== \"Shebang\").forEach(comment => {\r\n        const { directivePart, justificationPart } = extractDirectiveComment(comment.value);\r\n\r\n        const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\\s|$)/u.exec(directivePart);\r\n\r\n        if (!match) {\r\n            return;\r\n        }\r\n        const directiveText = match[1];\r\n        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);\r\n\r\n        if (comment.type === \"Line\" && !lineCommentSupported) {\r\n            return;\r\n        }\r\n\r\n        if (warnInlineConfig) {\r\n            const kind = comment.type === \"Block\" ? `/*${directiveText}*/` : `//${directiveText}`;\r\n\r\n            problems.push(createLintingProblem({\r\n                ruleId: null,\r\n                message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,\r\n                loc: comment.loc,\r\n                severity: 1\r\n            }));\r\n            return;\r\n        }\r\n\r\n        if (directiveText === \"eslint-disable-line\" && comment.loc.start.line !== comment.loc.end.line) {\r\n            const message = `${directiveText} comment should not span multiple lines.`;\r\n\r\n            problems.push(createLintingProblem({\r\n                ruleId: null,\r\n                message,\r\n                loc: comment.loc\r\n            }));\r\n            return;\r\n        }\r\n\r\n        const directiveValue = directivePart.slice(match.index + directiveText.length);\r\n\r\n        switch (directiveText) {\r\n            case \"eslint-disable\":\r\n            case \"eslint-enable\":\r\n            case \"eslint-disable-next-line\":\r\n            case \"eslint-disable-line\": {\r\n                const directiveType = directiveText.slice(\"eslint-\".length);\r\n                const options = { commentToken: comment, type: directiveType, value: directiveValue, justification: justificationPart, ruleMapper };\r\n                const { directives, directiveProblems } = createDisableDirectives(options);\r\n\r\n                disableDirectives.push(...directives);\r\n                problems.push(...directiveProblems);\r\n                break;\r\n            }\r\n\r\n            case \"exported\":\r\n                Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));\r\n                break;\r\n\r\n            case \"globals\":\r\n            case \"global\":\r\n                for (const [id, { value }] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {\r\n                    let normalizedValue;\r\n\r\n                    try {\r\n                        normalizedValue = ConfigOps.normalizeConfigGlobal(value);\r\n                    } catch (err) {\r\n                        problems.push(createLintingProblem({\r\n                            ruleId: null,\r\n                            loc: comment.loc,\r\n                            message: err.message\r\n                        }));\r\n                        continue;\r\n                    }\r\n\r\n                    if (enabledGlobals[id]) {\r\n                        enabledGlobals[id].comments.push(comment);\r\n                        enabledGlobals[id].value = normalizedValue;\r\n                    } else {\r\n                        enabledGlobals[id] = {\r\n                            comments: [comment],\r\n                            value: normalizedValue\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"eslint\": {\r\n                const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);\r\n\r\n                if (parseResult.success) {\r\n                    Object.keys(parseResult.config).forEach(name => {\r\n                        const rule = ruleMapper(name);\r\n                        const ruleValue = parseResult.config[name];\r\n\r\n                        if (!rule) {\r\n                            problems.push(createLintingProblem({ ruleId: name, loc: comment.loc }));\r\n                            return;\r\n                        }\r\n\r\n                        try {\r\n                            validator.validateRuleOptions(rule, name, ruleValue);\r\n                        } catch (err) {\r\n                            problems.push(createLintingProblem({\r\n                                ruleId: name,\r\n                                message: err.message,\r\n                                loc: comment.loc\r\n                            }));\r\n\r\n                            // do not apply the config, if found invalid options.\r\n                            return;\r\n                        }\r\n\r\n                        configuredRules[name] = ruleValue;\r\n                    });\r\n                } else {\r\n                    problems.push(parseResult.error);\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            // no default\r\n        }\r\n    });\r\n\r\n    return {\r\n        configuredRules,\r\n        enabledGlobals,\r\n        exportedVariables,\r\n        problems,\r\n        disableDirectives\r\n    };\r\n}\r\n\r\n/**\r\n * Normalize ECMAScript version from the initial config\r\n * @param {Parser} parser The parser which uses this options.\r\n * @param {number} ecmaVersion ECMAScript version from the initial config\r\n * @returns {number} normalized ECMAScript version\r\n */\r\nfunction normalizeEcmaVersion(parser, ecmaVersion) {\r\n\r\n    if (isEspree(parser)) {\r\n        if (ecmaVersion === \"latest\") {\r\n            return espree.latestEcmaVersion;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Calculate ECMAScript edition number from official year version starting with\r\n     * ES2015, which corresponds with ES6 (or a difference of 2009).\r\n     */\r\n    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;\r\n}\r\n\r\n/**\r\n * Normalize ECMAScript version from the initial config into languageOptions (year)\r\n * format.\r\n * @param {any} [ecmaVersion] ECMAScript version from the initial config\r\n * @returns {number} normalized ECMAScript version\r\n */\r\nfunction normalizeEcmaVersionForLanguageOptions(ecmaVersion) {\r\n\r\n    switch (ecmaVersion) {\r\n        case 3:\r\n            return 3;\r\n\r\n        // void 0 = no ecmaVersion specified so use the default\r\n        case 5:\r\n        case void 0:\r\n            return 5;\r\n\r\n        default:\r\n            if (typeof ecmaVersion === \"number\") {\r\n                return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;\r\n            }\r\n    }\r\n\r\n    /*\r\n     * We default to the latest supported ecmaVersion for everything else.\r\n     * Remember, this is for languageOptions.ecmaVersion, which sets the version\r\n     * that is used for a number of processes inside of ESLint. It's normally\r\n     * safe to assume people want the latest unless otherwise specified.\r\n     */\r\n    return espree.latestEcmaVersion + 2009;\r\n}\r\n\r\nconst eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)(?:\\*\\/|$)/gsu;\r\n\r\n/**\r\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\r\n * @param {string} text A source code text to check.\r\n * @returns {Object|null} A result of parseListConfig() with \"eslint-env *\" comment.\r\n */\r\nfunction findEslintEnv(text) {\r\n    let match, retv;\r\n\r\n    eslintEnvPattern.lastIndex = 0;\r\n\r\n    while ((match = eslintEnvPattern.exec(text)) !== null) {\r\n        if (match[0].endsWith(\"*/\")) {\r\n            retv = Object.assign(\r\n                retv || {},\r\n                commentParser.parseListConfig(extractDirectiveComment(match[1]).directivePart)\r\n            );\r\n        }\r\n    }\r\n\r\n    return retv;\r\n}\r\n\r\n/**\r\n * Convert \"/path/to/<text>\" to \"<text>\".\r\n * `CLIEngine#executeOnText()` method gives \"/path/to/<text>\" if the filename\r\n * was omitted because `configArray.extractConfig()` requires an absolute path.\r\n * But the linter should pass `<text>` to `RuleContext#getFilename()` in that\r\n * case.\r\n * Also, code blocks can have their virtual filename. If the parent filename was\r\n * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,\r\n * it's not an absolute path).\r\n * @param {string} filename The filename to normalize.\r\n * @returns {string} The normalized filename.\r\n */\r\nfunction normalizeFilename(filename) {\r\n    const parts = filename.split(path.sep);\r\n    const index = parts.lastIndexOf(\"<text>\");\r\n\r\n    return index === -1 ? filename : parts.slice(index).join(path.sep);\r\n}\r\n\r\n/**\r\n * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a\r\n * consistent shape.\r\n * @param {VerifyOptions} providedOptions Options\r\n * @param {ConfigData} config Config.\r\n * @returns {Required<VerifyOptions> & InternalOptions} Normalized options\r\n */\r\nfunction normalizeVerifyOptions(providedOptions, config) {\r\n\r\n    const linterOptions = config.linterOptions || config;\r\n\r\n    // .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat\r\n    const disableInlineConfig = linterOptions.noInlineConfig === true;\r\n    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;\r\n    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig\r\n        ? ` (${config.configNameOfNoInlineConfig})`\r\n        : \"\";\r\n\r\n    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;\r\n\r\n    if (typeof reportUnusedDisableDirectives === \"boolean\") {\r\n        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? \"error\" : \"off\";\r\n    }\r\n    if (typeof reportUnusedDisableDirectives !== \"string\") {\r\n        reportUnusedDisableDirectives =\r\n            linterOptions.reportUnusedDisableDirectives\r\n                ? \"warn\" : \"off\";\r\n    }\r\n\r\n    return {\r\n        filename: normalizeFilename(providedOptions.filename || \"<input>\"),\r\n        allowInlineConfig: !ignoreInlineConfig,\r\n        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig\r\n            ? `your config${configNameOfNoInlineConfig}`\r\n            : null,\r\n        reportUnusedDisableDirectives,\r\n        disableFixes: Boolean(providedOptions.disableFixes)\r\n    };\r\n}\r\n\r\n/**\r\n * Combines the provided parserOptions with the options from environments\r\n * @param {Parser} parser The parser which uses this options.\r\n * @param {ParserOptions} providedOptions The provided 'parserOptions' key in a config\r\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\r\n * @returns {ParserOptions} Resulting parser options after merge\r\n */\r\nfunction resolveParserOptions(parser, providedOptions, enabledEnvironments) {\r\n\r\n    const parserOptionsFromEnv = enabledEnvironments\r\n        .filter(env => env.parserOptions)\r\n        .reduce((parserOptions, env) => merge(parserOptions, env.parserOptions), {});\r\n    const mergedParserOptions = merge(parserOptionsFromEnv, providedOptions || {});\r\n    const isModule = mergedParserOptions.sourceType === \"module\";\r\n\r\n    if (isModule) {\r\n\r\n        /*\r\n         * can't have global return inside of modules\r\n         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)\r\n         */\r\n        mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, { globalReturn: false });\r\n    }\r\n\r\n    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(parser, mergedParserOptions.ecmaVersion);\r\n\r\n    return mergedParserOptions;\r\n}\r\n\r\n/**\r\n * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.\r\n * @param {ConfigData} config Config object.\r\n * @param {Object} config.globals Global variable definitions.\r\n * @param {Parser} config.parser The parser to use.\r\n * @param {ParserOptions} config.parserOptions The parserOptions to use.\r\n * @returns {LanguageOptions} The languageOptions equivalent.\r\n */\r\nfunction createLanguageOptions({ globals: configuredGlobals, parser, parserOptions }) {\r\n\r\n    const {\r\n        ecmaVersion,\r\n        sourceType\r\n    } = parserOptions;\r\n\r\n    return {\r\n        globals: configuredGlobals,\r\n        ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),\r\n        sourceType,\r\n        parser,\r\n        parserOptions\r\n    };\r\n}\r\n\r\n/**\r\n * Combines the provided globals object with the globals from environments\r\n * @param {Record<string, GlobalConf>} providedGlobals The 'globals' key in a config\r\n * @param {Environment[]} enabledEnvironments The environments enabled in configuration and with inline comments\r\n * @returns {Record<string, GlobalConf>} The resolved globals object\r\n */\r\nfunction resolveGlobals(providedGlobals, enabledEnvironments) {\r\n    return Object.assign(\r\n        {},\r\n        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),\r\n        providedGlobals\r\n    );\r\n}\r\n\r\n/**\r\n * Strips Unicode BOM from a given text.\r\n * @param {string} text A text to strip.\r\n * @returns {string} The stripped text.\r\n */\r\nfunction stripUnicodeBOM(text) {\r\n\r\n    /*\r\n     * Check Unicode BOM.\r\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\r\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\r\n     */\r\n    if (text.charCodeAt(0) === 0xFEFF) {\r\n        return text.slice(1);\r\n    }\r\n    return text;\r\n}\r\n\r\n/**\r\n * Get the options for a rule (not including severity), if any\r\n * @param {Array|number} ruleConfig rule configuration\r\n * @returns {Array} of rule options, empty Array if none\r\n */\r\nfunction getRuleOptions(ruleConfig) {\r\n    if (Array.isArray(ruleConfig)) {\r\n        return ruleConfig.slice(1);\r\n    }\r\n    return [];\r\n\r\n}\r\n\r\n/**\r\n * Analyze scope of the given AST.\r\n * @param {ASTNode} ast The `Program` node to analyze.\r\n * @param {LanguageOptions} languageOptions The parser options.\r\n * @param {Record<string, string[]>} visitorKeys The visitor keys.\r\n * @returns {ScopeManager} The analysis result.\r\n */\r\nfunction analyzeScope(ast, languageOptions, visitorKeys) {\r\n    const parserOptions = languageOptions.parserOptions;\r\n    const ecmaFeatures = parserOptions.ecmaFeatures || {};\r\n    const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;\r\n\r\n    return eslintScope.analyze(ast, {\r\n        ignoreEval: true,\r\n        nodejsScope: ecmaFeatures.globalReturn,\r\n        impliedStrict: ecmaFeatures.impliedStrict,\r\n        ecmaVersion: typeof ecmaVersion === \"number\" ? ecmaVersion : 6,\r\n        sourceType: languageOptions.sourceType || \"script\",\r\n        childVisitorKeys: visitorKeys || evk.KEYS,\r\n        fallback: Traverser.getKeys\r\n    });\r\n}\r\n\r\n/**\r\n * Parses text into an AST. Moved out here because the try-catch prevents\r\n * optimization of functions, so it's best to keep the try-catch as isolated\r\n * as possible\r\n * @param {string} text The text to parse.\r\n * @param {LanguageOptions} languageOptions Options to pass to the parser\r\n * @param {string} filePath The path to the file being parsed.\r\n * @returns {{success: false, error: Problem}|{success: true, sourceCode: SourceCode}}\r\n * An object containing the AST and parser services if parsing was successful, or the error if parsing failed\r\n * @private\r\n */\r\nfunction parse(text, languageOptions, filePath) {\r\n    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);\r\n    const { ecmaVersion, sourceType, parser } = languageOptions;\r\n    const parserOptions = Object.assign(\r\n        { ecmaVersion, sourceType },\r\n        languageOptions.parserOptions,\r\n        {\r\n            loc: true,\r\n            range: true,\r\n            raw: true,\r\n            tokens: true,\r\n            comment: true,\r\n            eslintVisitorKeys: true,\r\n            eslintScopeManager: true,\r\n            filePath\r\n        }\r\n    );\r\n\r\n    /*\r\n     * Check for parsing errors first. If there's a parsing error, nothing\r\n     * else can happen. However, a parsing error does not throw an error\r\n     * from this method - it's just considered a fatal error message, a\r\n     * problem that ESLint identified just like any other.\r\n     */\r\n    try {\r\n        debug(\"Parsing:\", filePath);\r\n        const parseResult = (typeof parser.parseForESLint === \"function\")\r\n            ? parser.parseForESLint(textToParse, parserOptions)\r\n            : { ast: parser.parse(textToParse, parserOptions) };\r\n\r\n        debug(\"Parsing successful:\", filePath);\r\n        const ast = parseResult.ast;\r\n        const parserServices = parseResult.services || {};\r\n        const visitorKeys = parseResult.visitorKeys || evk.KEYS;\r\n\r\n        debug(\"Scope analysis:\", filePath);\r\n        const scopeManager = parseResult.scopeManager || analyzeScope(ast, languageOptions, visitorKeys);\r\n\r\n        debug(\"Scope analysis successful:\", filePath);\r\n\r\n        return {\r\n            success: true,\r\n\r\n            /*\r\n             * Save all values that `parseForESLint()` returned.\r\n             * If a `SourceCode` object is given as the first parameter instead of source code text,\r\n             * linter skips the parsing process and reuses the source code object.\r\n             * In that case, linter needs all the values that `parseForESLint()` returned.\r\n             */\r\n            sourceCode: new SourceCode({\r\n                text,\r\n                ast,\r\n                parserServices,\r\n                scopeManager,\r\n                visitorKeys\r\n            })\r\n        };\r\n    } catch (ex) {\r\n\r\n        // If the message includes a leading line number, strip it:\r\n        const message = `Parsing error: ${ex.message.replace(/^line \\d+:/iu, \"\").trim()}`;\r\n\r\n        debug(\"%s\\n%s\", message, ex.stack);\r\n\r\n        return {\r\n            success: false,\r\n            error: {\r\n                ruleId: null,\r\n                fatal: true,\r\n                severity: 2,\r\n                message,\r\n                line: ex.lineNumber,\r\n                column: ex.column\r\n            }\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the scope for the current node\r\n * @param {ScopeManager} scopeManager The scope manager for this AST\r\n * @param {ASTNode} currentNode The node to get the scope of\r\n * @returns {eslint-scope.Scope} The scope information for this node\r\n */\r\nfunction getScope(scopeManager, currentNode) {\r\n\r\n    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.\r\n    const inner = currentNode.type !== \"Program\";\r\n\r\n    for (let node = currentNode; node; node = node.parent) {\r\n        const scope = scopeManager.acquire(node, inner);\r\n\r\n        if (scope) {\r\n            if (scope.type === \"function-expression-name\") {\r\n                return scope.childScopes[0];\r\n            }\r\n            return scope;\r\n        }\r\n    }\r\n\r\n    return scopeManager.scopes[0];\r\n}\r\n\r\n/**\r\n * Marks a variable as used in the current scope\r\n * @param {ScopeManager} scopeManager The scope manager for this AST. The scope may be mutated by this function.\r\n * @param {ASTNode} currentNode The node currently being traversed\r\n * @param {LanguageOptions} languageOptions The options used to parse this text\r\n * @param {string} name The name of the variable that should be marked as used.\r\n * @returns {boolean} True if the variable was found and marked as used, false if not.\r\n */\r\nfunction markVariableAsUsed(scopeManager, currentNode, languageOptions, name) {\r\n    const parserOptions = languageOptions.parserOptions;\r\n    const sourceType = languageOptions.sourceType;\r\n    const hasGlobalReturn =\r\n        (parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn) ||\r\n        sourceType === \"commonjs\";\r\n    const specialScope = hasGlobalReturn || sourceType === \"module\";\r\n    const currentScope = getScope(scopeManager, currentNode);\r\n\r\n    // Special Node.js scope means we need to start one level deeper\r\n    const initialScope = currentScope.type === \"global\" && specialScope ? currentScope.childScopes[0] : currentScope;\r\n\r\n    for (let scope = initialScope; scope; scope = scope.upper) {\r\n        const variable = scope.variables.find(scopeVar => scopeVar.name === name);\r\n\r\n        if (variable) {\r\n            variable.eslintUsed = true;\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Runs a rule, and gets its listeners\r\n * @param {Rule} rule A normalized rule with a `create` method\r\n * @param {Context} ruleContext The context that should be passed to the rule\r\n * @throws {any} Any error during the rule's `create`\r\n * @returns {Object} A map of selector listeners provided by the rule\r\n */\r\nfunction createRuleListeners(rule, ruleContext) {\r\n    try {\r\n        return rule.create(ruleContext);\r\n    } catch (ex) {\r\n        ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;\r\n        throw ex;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets all the ancestors of a given node\r\n * @param {ASTNode} node The node\r\n * @returns {ASTNode[]} All the ancestor nodes in the AST, not including the provided node, starting\r\n * from the root node and going inwards to the parent node.\r\n */\r\nfunction getAncestors(node) {\r\n    const ancestorsStartingAtParent = [];\r\n\r\n    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\r\n        ancestorsStartingAtParent.push(ancestor);\r\n    }\r\n\r\n    return ancestorsStartingAtParent.reverse();\r\n}\r\n\r\n// methods that exist on SourceCode object\r\nconst DEPRECATED_SOURCECODE_PASSTHROUGHS = {\r\n    getSource: \"getText\",\r\n    getSourceLines: \"getLines\",\r\n    getAllComments: \"getAllComments\",\r\n    getNodeByRangeIndex: \"getNodeByRangeIndex\",\r\n    getComments: \"getComments\",\r\n    getCommentsBefore: \"getCommentsBefore\",\r\n    getCommentsAfter: \"getCommentsAfter\",\r\n    getCommentsInside: \"getCommentsInside\",\r\n    getJSDocComment: \"getJSDocComment\",\r\n    getFirstToken: \"getFirstToken\",\r\n    getFirstTokens: \"getFirstTokens\",\r\n    getLastToken: \"getLastToken\",\r\n    getLastTokens: \"getLastTokens\",\r\n    getTokenAfter: \"getTokenAfter\",\r\n    getTokenBefore: \"getTokenBefore\",\r\n    getTokenByRangeStart: \"getTokenByRangeStart\",\r\n    getTokens: \"getTokens\",\r\n    getTokensAfter: \"getTokensAfter\",\r\n    getTokensBefore: \"getTokensBefore\",\r\n    getTokensBetween: \"getTokensBetween\"\r\n};\r\n\r\nconst BASE_TRAVERSAL_CONTEXT = Object.freeze(\r\n    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(\r\n        (contextInfo, methodName) =>\r\n            Object.assign(contextInfo, {\r\n                [methodName](...args) {\r\n                    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);\r\n                }\r\n            }),\r\n        {}\r\n    )\r\n);\r\n\r\n/**\r\n * Runs the given rules on the given SourceCode object\r\n * @param {SourceCode} sourceCode A SourceCode object for the given text\r\n * @param {Object} configuredRules The rules configuration\r\n * @param {function(string): Rule} ruleMapper A mapper function from rule names to rules\r\n * @param {string | undefined} parserName The name of the parser in the config\r\n * @param {LanguageOptions} languageOptions The options for parsing the code.\r\n * @param {Object} settings The settings that were enabled in the config\r\n * @param {string} filename The reported filename of the code\r\n * @param {boolean} disableFixes If true, it doesn't make `fix` properties.\r\n * @param {string | undefined} cwd cwd of the cli\r\n * @param {string} physicalFilename The full path of the file on disk without any code block information\r\n * @returns {Problem[]} An array of reported problems\r\n */\r\nfunction runRules(sourceCode, configuredRules, ruleMapper, parserName, languageOptions, settings, filename, disableFixes, cwd, physicalFilename) {\r\n    const emitter = createEmitter();\r\n    const nodeQueue = [];\r\n    let currentNode = sourceCode.ast;\r\n\r\n    Traverser.traverse(sourceCode.ast, {\r\n        enter(node, parent) {\r\n            node.parent = parent;\r\n            nodeQueue.push({ isEntering: true, node });\r\n        },\r\n        leave(node) {\r\n            nodeQueue.push({ isEntering: false, node });\r\n        },\r\n        visitorKeys: sourceCode.visitorKeys\r\n    });\r\n\r\n    /*\r\n     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.\r\n     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the\r\n     * properties once for each rule.\r\n     */\r\n    const sharedTraversalContext = Object.freeze(\r\n        Object.assign(\r\n            Object.create(BASE_TRAVERSAL_CONTEXT),\r\n            {\r\n                getAncestors: () => getAncestors(currentNode),\r\n                getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),\r\n                getCwd: () => cwd,\r\n                getFilename: () => filename,\r\n                getPhysicalFilename: () => physicalFilename || filename,\r\n                getScope: () => getScope(sourceCode.scopeManager, currentNode),\r\n                getSourceCode: () => sourceCode,\r\n                markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, languageOptions, name),\r\n                parserOptions: {\r\n                    ...languageOptions.parserOptions\r\n                },\r\n                parserPath: parserName,\r\n                languageOptions,\r\n                parserServices: sourceCode.parserServices,\r\n                settings\r\n            }\r\n        )\r\n    );\r\n\r\n    const lintingProblems = [];\r\n\r\n    Object.keys(configuredRules).forEach(ruleId => {\r\n        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);\r\n\r\n        // not load disabled rules\r\n        if (severity === 0) {\r\n            return;\r\n        }\r\n\r\n        const rule = ruleMapper(ruleId);\r\n\r\n        if (!rule) {\r\n            lintingProblems.push(createLintingProblem({ ruleId }));\r\n            return;\r\n        }\r\n\r\n        const messageIds = rule.meta && rule.meta.messages;\r\n        let reportTranslator = null;\r\n        const ruleContext = Object.freeze(\r\n            Object.assign(\r\n                Object.create(sharedTraversalContext),\r\n                {\r\n                    id: ruleId,\r\n                    options: getRuleOptions(configuredRules[ruleId]),\r\n                    report(...args) {\r\n\r\n                        /*\r\n                         * Create a report translator lazily.\r\n                         * In a vast majority of cases, any given rule reports zero errors on a given\r\n                         * piece of code. Creating a translator lazily avoids the performance cost of\r\n                         * creating a new translator function for each rule that usually doesn't get\r\n                         * called.\r\n                         *\r\n                         * Using lazy report translators improves end-to-end performance by about 3%\r\n                         * with Node 8.4.0.\r\n                         */\r\n                        if (reportTranslator === null) {\r\n                            reportTranslator = createReportTranslator({\r\n                                ruleId,\r\n                                severity,\r\n                                sourceCode,\r\n                                messageIds,\r\n                                disableFixes\r\n                            });\r\n                        }\r\n                        const problem = reportTranslator(...args);\r\n\r\n                        if (problem.fix && !(rule.meta && rule.meta.fixable)) {\r\n                            throw new Error(\"Fixable rules must set the `meta.fixable` property to \\\"code\\\" or \\\"whitespace\\\".\");\r\n                        }\r\n                        if (problem.suggestions && !(rule.meta && rule.meta.hasSuggestions === true)) {\r\n                            if (rule.meta && rule.meta.docs && typeof rule.meta.docs.suggestion !== \"undefined\") {\r\n\r\n                                // Encourage migration from the former property name.\r\n                                throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.\");\r\n                            }\r\n                            throw new Error(\"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.\");\r\n                        }\r\n                        lintingProblems.push(problem);\r\n                    }\r\n                }\r\n            )\r\n        );\r\n\r\n        const ruleListeners = createRuleListeners(rule, ruleContext);\r\n\r\n        /**\r\n         * Include `ruleId` in error logs\r\n         * @param {Function} ruleListener A rule method that listens for a node.\r\n         * @returns {Function} ruleListener wrapped in error handler\r\n         */\r\n        function addRuleErrorHandler(ruleListener) {\r\n            return function ruleErrorHandler(...listenerArgs) {\r\n                try {\r\n                    return ruleListener(...listenerArgs);\r\n                } catch (e) {\r\n                    e.ruleId = ruleId;\r\n                    throw e;\r\n                }\r\n            };\r\n        }\r\n\r\n        // add all the selectors from the rule as listeners\r\n        Object.keys(ruleListeners).forEach(selector => {\r\n            const ruleListener = timing.enabled\r\n                ? timing.time(ruleId, ruleListeners[selector])\r\n                : ruleListeners[selector];\r\n\r\n            emitter.on(\r\n                selector,\r\n                addRuleErrorHandler(ruleListener)\r\n            );\r\n        });\r\n    });\r\n\r\n    // only run code path analyzer if the top level node is \"Program\", skip otherwise\r\n    const eventGenerator = nodeQueue[0].node.type === \"Program\"\r\n        ? new CodePathAnalyzer(new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys }))\r\n        : new NodeEventGenerator(emitter, { visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys });\r\n\r\n    nodeQueue.forEach(traversalInfo => {\r\n        currentNode = traversalInfo.node;\r\n\r\n        try {\r\n            if (traversalInfo.isEntering) {\r\n                eventGenerator.enterNode(currentNode);\r\n            } else {\r\n                eventGenerator.leaveNode(currentNode);\r\n            }\r\n        } catch (err) {\r\n            err.currentNode = currentNode;\r\n            throw err;\r\n        }\r\n    });\r\n\r\n    return lintingProblems;\r\n}\r\n\r\n/**\r\n * Ensure the source code to be a string.\r\n * @param {string|SourceCode} textOrSourceCode The text or source code object.\r\n * @returns {string} The source code text.\r\n */\r\nfunction ensureText(textOrSourceCode) {\r\n    if (typeof textOrSourceCode === \"object\") {\r\n        const { hasBOM, text } = textOrSourceCode;\r\n        const bom = hasBOM ? \"\\uFEFF\" : \"\";\r\n\r\n        return bom + text;\r\n    }\r\n\r\n    return String(textOrSourceCode);\r\n}\r\n\r\n/**\r\n * Get an environment.\r\n * @param {LinterInternalSlots} slots The internal slots of Linter.\r\n * @param {string} envId The environment ID to get.\r\n * @returns {Environment|null} The environment.\r\n */\r\nfunction getEnv(slots, envId) {\r\n    return (\r\n        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||\r\n        BuiltInEnvironments.get(envId) ||\r\n        null\r\n    );\r\n}\r\n\r\n/**\r\n * Get a rule.\r\n * @param {LinterInternalSlots} slots The internal slots of Linter.\r\n * @param {string} ruleId The rule ID to get.\r\n * @returns {Rule|null} The rule.\r\n */\r\nfunction getRule(slots, ruleId) {\r\n    return (\r\n        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||\r\n        slots.ruleMap.get(ruleId)\r\n    );\r\n}\r\n\r\n/**\r\n * Normalize the value of the cwd\r\n * @param {string | undefined} cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.\r\n * @returns {string | undefined} normalized cwd\r\n */\r\nfunction normalizeCwd(cwd) {\r\n    if (cwd) {\r\n        return cwd;\r\n    }\r\n    if (typeof process === \"object\") {\r\n        return process.cwd();\r\n    }\r\n\r\n    // It's more explicit to assign the undefined\r\n    // eslint-disable-next-line no-undefined -- Consistently returning a value\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * The map to store private data.\r\n * @type {WeakMap<Linter, LinterInternalSlots>}\r\n */\r\nconst internalSlotsMap = new WeakMap();\r\n\r\n/**\r\n * Throws an error when the given linter is in flat config mode.\r\n * @param {Linter} linter The linter to check.\r\n * @returns {void}\r\n * @throws {Error} If the linter is in flat config mode.\r\n */\r\nfunction assertEslintrcConfig(linter) {\r\n    const { configType } = internalSlotsMap.get(linter);\r\n\r\n    if (configType === \"flat\") {\r\n        throw new Error(\"This method cannot be used with flat config. Add your entries directly into the config array.\");\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Object that is responsible for verifying JavaScript text\r\n * @name Linter\r\n */\r\nclass Linter {\r\n\r\n    /**\r\n     * Initialize the Linter.\r\n     * @param {Object} [config] the config object\r\n     * @param {string} [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.\r\n     * @param {\"flat\"|\"eslintrc\"} [config.configType=\"eslintrc\"] the type of config used.\r\n     */\r\n    constructor({ cwd, configType } = {}) {\r\n        internalSlotsMap.set(this, {\r\n            cwd: normalizeCwd(cwd),\r\n            lastConfigArray: null,\r\n            lastSourceCode: null,\r\n            lastSuppressedMessages: [],\r\n            configType, // TODO: Remove after flat config conversion\r\n            parserMap: new Map([[\"espree\", espree]]),\r\n            ruleMap: new Rules()\r\n        });\r\n\r\n        this.version = pkg.version;\r\n    }\r\n\r\n    /**\r\n     * Getter for package version.\r\n     * @static\r\n     * @returns {string} The version from package.json.\r\n     */\r\n    static get version() {\r\n        return pkg.version;\r\n    }\r\n\r\n    /**\r\n     * Same as linter.verify, except without support for processors.\r\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n     * @param {ConfigData} providedConfig An ESLintConfig instance to configure everything.\r\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\r\n     * @throws {Error} If during rule execution.\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\r\n     */\r\n    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\r\n        const slots = internalSlotsMap.get(this);\r\n        const config = providedConfig || {};\r\n        const options = normalizeVerifyOptions(providedOptions, config);\r\n        let text;\r\n\r\n        // evaluate arguments\r\n        if (typeof textOrSourceCode === \"string\") {\r\n            slots.lastSourceCode = null;\r\n            text = textOrSourceCode;\r\n        } else {\r\n            slots.lastSourceCode = textOrSourceCode;\r\n            text = textOrSourceCode.text;\r\n        }\r\n\r\n        // Resolve parser.\r\n        let parserName = DEFAULT_PARSER_NAME;\r\n        let parser = espree;\r\n\r\n        if (typeof config.parser === \"object\" && config.parser !== null) {\r\n            parserName = config.parser.filePath;\r\n            parser = config.parser.definition;\r\n        } else if (typeof config.parser === \"string\") {\r\n            if (!slots.parserMap.has(config.parser)) {\r\n                return [{\r\n                    ruleId: null,\r\n                    fatal: true,\r\n                    severity: 2,\r\n                    message: `Configured parser '${config.parser}' was not found.`,\r\n                    line: 0,\r\n                    column: 0\r\n                }];\r\n            }\r\n            parserName = config.parser;\r\n            parser = slots.parserMap.get(config.parser);\r\n        }\r\n\r\n        // search and apply \"eslint-env *\".\r\n        const envInFile = options.allowInlineConfig && !options.warnInlineConfig\r\n            ? findEslintEnv(text)\r\n            : {};\r\n        const resolvedEnvConfig = Object.assign({ builtin: true }, config.env, envInFile);\r\n        const enabledEnvs = Object.keys(resolvedEnvConfig)\r\n            .filter(envName => resolvedEnvConfig[envName])\r\n            .map(envName => getEnv(slots, envName))\r\n            .filter(env => env);\r\n\r\n        const parserOptions = resolveParserOptions(parser, config.parserOptions || {}, enabledEnvs);\r\n        const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);\r\n        const settings = config.settings || {};\r\n        const languageOptions = createLanguageOptions({\r\n            globals: config.globals,\r\n            parser,\r\n            parserOptions\r\n        });\r\n\r\n        if (!slots.lastSourceCode) {\r\n            const parseResult = parse(\r\n                text,\r\n                languageOptions,\r\n                options.filename\r\n            );\r\n\r\n            if (!parseResult.success) {\r\n                return [parseResult.error];\r\n            }\r\n\r\n            slots.lastSourceCode = parseResult.sourceCode;\r\n        } else {\r\n\r\n            /*\r\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\r\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\r\n             */\r\n            if (!slots.lastSourceCode.scopeManager) {\r\n                slots.lastSourceCode = new SourceCode({\r\n                    text: slots.lastSourceCode.text,\r\n                    ast: slots.lastSourceCode.ast,\r\n                    parserServices: slots.lastSourceCode.parserServices,\r\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\r\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\r\n                });\r\n            }\r\n        }\r\n\r\n        const sourceCode = slots.lastSourceCode;\r\n        const commentDirectives = options.allowInlineConfig\r\n            ? getDirectiveComments(sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig)\r\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\r\n\r\n        // augment global scope with declared global variables\r\n        addDeclaredGlobals(\r\n            sourceCode.scopeManager.scopes[0],\r\n            configuredGlobals,\r\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\r\n        );\r\n\r\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\r\n\r\n        let lintingProblems;\r\n\r\n        try {\r\n            lintingProblems = runRules(\r\n                sourceCode,\r\n                configuredRules,\r\n                ruleId => getRule(slots, ruleId),\r\n                parserName,\r\n                languageOptions,\r\n                settings,\r\n                options.filename,\r\n                options.disableFixes,\r\n                slots.cwd,\r\n                providedOptions.physicalFilename\r\n            );\r\n        } catch (err) {\r\n            err.message += `\\nOccurred while linting ${options.filename}`;\r\n            debug(\"An error occurred while traversing\");\r\n            debug(\"Filename:\", options.filename);\r\n            if (err.currentNode) {\r\n                const { line } = err.currentNode.loc.start;\r\n\r\n                debug(\"Line:\", line);\r\n                err.message += `:${line}`;\r\n            }\r\n            debug(\"Parser Options:\", parserOptions);\r\n            debug(\"Parser Path:\", parserName);\r\n            debug(\"Settings:\", settings);\r\n\r\n            if (err.ruleId) {\r\n                err.message += `\\nRule: \"${err.ruleId}\"`;\r\n            }\r\n\r\n            throw err;\r\n        }\r\n\r\n        return applyDisableDirectives({\r\n            directives: commentDirectives.disableDirectives,\r\n            disableFixes: options.disableFixes,\r\n            problems: lintingProblems\r\n                .concat(commentDirectives.problems)\r\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\r\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verifies the text against the rules specified by the second argument.\r\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n     * @param {ConfigData|ConfigArray} config An ESLintConfig instance to configure everything.\r\n     * @param {(string|(VerifyOptions&ProcessorOptions))} [filenameOrOptions] The optional filename of the file being checked.\r\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\r\n     *      an object, then it has \"filename\", \"allowInlineConfig\", and some properties.\r\n     * @returns {LintMessage[]} The results as an array of messages or an empty array if no messages.\r\n     */\r\n    verify(textOrSourceCode, config, filenameOrOptions) {\r\n        debug(\"Verify\");\r\n\r\n        const { configType } = internalSlotsMap.get(this);\r\n\r\n        const options = typeof filenameOrOptions === \"string\"\r\n            ? { filename: filenameOrOptions }\r\n            : filenameOrOptions || {};\r\n\r\n        if (config) {\r\n            if (configType === \"flat\") {\r\n\r\n                /*\r\n                 * Because of how Webpack packages up the files, we can't\r\n                 * compare directly to `FlatConfigArray` using `instanceof`\r\n                 * because it's not the same `FlatConfigArray` as in the tests.\r\n                 * So, we work around it by assuming an array is, in fact, a\r\n                 * `FlatConfigArray` if it has a `getConfig()` method.\r\n                 */\r\n                let configArray = config;\r\n\r\n                if (!Array.isArray(config) || typeof config.getConfig !== \"function\") {\r\n                    configArray = new FlatConfigArray(config);\r\n                    configArray.normalizeSync();\r\n                }\r\n\r\n                return this._distinguishSuppressedMessages(this._verifyWithFlatConfigArray(textOrSourceCode, configArray, options, true));\r\n            }\r\n\r\n            if (typeof config.extractConfig === \"function\") {\r\n                return this._distinguishSuppressedMessages(this._verifyWithConfigArray(textOrSourceCode, config, options));\r\n            }\r\n        }\r\n\r\n        /*\r\n         * If we get to here, it means `config` is just an object rather\r\n         * than a config array so we can go right into linting.\r\n         */\r\n\r\n        /*\r\n         * `Linter` doesn't support `overrides` property in configuration.\r\n         * So we cannot apply multiple processors.\r\n         */\r\n        if (options.preprocess || options.postprocess) {\r\n            return this._distinguishSuppressedMessages(this._verifyWithProcessor(textOrSourceCode, config, options));\r\n        }\r\n        return this._distinguishSuppressedMessages(this._verifyWithoutProcessors(textOrSourceCode, config, options));\r\n    }\r\n\r\n    /**\r\n     * Verify with a processor.\r\n     * @param {string|SourceCode} textOrSourceCode The source code.\r\n     * @param {FlatConfig} config The config array.\r\n     * @param {VerifyOptions&ProcessorOptions} options The options.\r\n     * @param {FlatConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n     */\r\n    _verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options, configForRecursive) {\r\n        const filename = options.filename || \"<input>\";\r\n        const filenameToExpose = normalizeFilename(filename);\r\n        const physicalFilename = options.physicalFilename || filenameToExpose;\r\n        const text = ensureText(textOrSourceCode);\r\n        const preprocess = options.preprocess || (rawText => [rawText]);\r\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\r\n        const filterCodeBlock =\r\n            options.filterCodeBlock ||\r\n            (blockFilename => blockFilename.endsWith(\".js\"));\r\n        const originalExtname = path.extname(filename);\r\n        const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\r\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\r\n\r\n            // Keep the legacy behavior.\r\n            if (typeof block === \"string\") {\r\n                return this._verifyWithFlatConfigArrayAndWithoutProcessors(block, config, options);\r\n            }\r\n\r\n            const blockText = block.text;\r\n            const blockName = path.join(filename, `${i}_${block.filename}`);\r\n\r\n            // Skip this block if filtered.\r\n            if (!filterCodeBlock(blockName, blockText)) {\r\n                debug(\"This code block was skipped.\");\r\n                return [];\r\n            }\r\n\r\n            // Resolve configuration again if the file content or extension was changed.\r\n            if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\r\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\r\n                return this._verifyWithFlatConfigArray(\r\n                    blockText,\r\n                    configForRecursive,\r\n                    { ...options, filename: blockName, physicalFilename }\r\n                );\r\n            }\r\n\r\n            // Does lint.\r\n            return this._verifyWithFlatConfigArrayAndWithoutProcessors(\r\n                blockText,\r\n                config,\r\n                { ...options, filename: blockName, physicalFilename }\r\n            );\r\n        });\r\n\r\n        return postprocess(messageLists, filenameToExpose);\r\n    }\r\n\r\n    /**\r\n     * Same as linter.verify, except without support for processors.\r\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\r\n     * @param {FlatConfig} providedConfig An ESLintConfig instance to configure everything.\r\n     * @param {VerifyOptions} [providedOptions] The optional filename of the file being checked.\r\n     * @throws {Error} If during rule execution.\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The results as an array of messages or an empty array if no messages.\r\n     */\r\n    _verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {\r\n        const slots = internalSlotsMap.get(this);\r\n        const config = providedConfig || {};\r\n        const options = normalizeVerifyOptions(providedOptions, config);\r\n        let text;\r\n\r\n        // evaluate arguments\r\n        if (typeof textOrSourceCode === \"string\") {\r\n            slots.lastSourceCode = null;\r\n            text = textOrSourceCode;\r\n        } else {\r\n            slots.lastSourceCode = textOrSourceCode;\r\n            text = textOrSourceCode.text;\r\n        }\r\n\r\n        const languageOptions = config.languageOptions;\r\n\r\n        languageOptions.ecmaVersion = normalizeEcmaVersionForLanguageOptions(\r\n            languageOptions.ecmaVersion\r\n        );\r\n\r\n        // add configured globals and language globals\r\n        const configuredGlobals = {\r\n            ...(getGlobalsForEcmaVersion(languageOptions.ecmaVersion)),\r\n            ...(languageOptions.sourceType === \"commonjs\" ? globals.commonjs : void 0),\r\n            ...languageOptions.globals\r\n        };\r\n\r\n        // Espree expects this information to be passed in\r\n        if (isEspree(languageOptions.parser)) {\r\n            const parserOptions = languageOptions.parserOptions;\r\n\r\n            if (languageOptions.sourceType) {\r\n\r\n                parserOptions.sourceType = languageOptions.sourceType;\r\n\r\n                if (\r\n                    parserOptions.sourceType === \"module\" &&\r\n                    parserOptions.ecmaFeatures &&\r\n                    parserOptions.ecmaFeatures.globalReturn\r\n                ) {\r\n                    parserOptions.ecmaFeatures.globalReturn = false;\r\n                }\r\n            }\r\n        }\r\n\r\n        const settings = config.settings || {};\r\n\r\n        if (!slots.lastSourceCode) {\r\n            const parseResult = parse(\r\n                text,\r\n                languageOptions,\r\n                options.filename\r\n            );\r\n\r\n            if (!parseResult.success) {\r\n                return [parseResult.error];\r\n            }\r\n\r\n            slots.lastSourceCode = parseResult.sourceCode;\r\n        } else {\r\n\r\n            /*\r\n             * If the given source code object as the first argument does not have scopeManager, analyze the scope.\r\n             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).\r\n             */\r\n            if (!slots.lastSourceCode.scopeManager) {\r\n                slots.lastSourceCode = new SourceCode({\r\n                    text: slots.lastSourceCode.text,\r\n                    ast: slots.lastSourceCode.ast,\r\n                    parserServices: slots.lastSourceCode.parserServices,\r\n                    visitorKeys: slots.lastSourceCode.visitorKeys,\r\n                    scopeManager: analyzeScope(slots.lastSourceCode.ast, languageOptions)\r\n                });\r\n            }\r\n        }\r\n\r\n        const sourceCode = slots.lastSourceCode;\r\n        const commentDirectives = options.allowInlineConfig\r\n            ? getDirectiveComments(\r\n                sourceCode.ast,\r\n                ruleId => getRuleFromConfig(ruleId, config),\r\n                options.warnInlineConfig\r\n            )\r\n            : { configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: [] };\r\n\r\n        // augment global scope with declared global variables\r\n        addDeclaredGlobals(\r\n            sourceCode.scopeManager.scopes[0],\r\n            configuredGlobals,\r\n            { exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals }\r\n        );\r\n\r\n        const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);\r\n\r\n        let lintingProblems;\r\n\r\n        try {\r\n            lintingProblems = runRules(\r\n                sourceCode,\r\n                configuredRules,\r\n                ruleId => getRuleFromConfig(ruleId, config),\r\n                void 0,\r\n                languageOptions,\r\n                settings,\r\n                options.filename,\r\n                options.disableFixes,\r\n                slots.cwd,\r\n                providedOptions.physicalFilename\r\n            );\r\n        } catch (err) {\r\n            err.message += `\\nOccurred while linting ${options.filename}`;\r\n            debug(\"An error occurred while traversing\");\r\n            debug(\"Filename:\", options.filename);\r\n            if (err.currentNode) {\r\n                const { line } = err.currentNode.loc.start;\r\n\r\n                debug(\"Line:\", line);\r\n                err.message += `:${line}`;\r\n            }\r\n            debug(\"Parser Options:\", languageOptions.parserOptions);\r\n\r\n            // debug(\"Parser Path:\", parserName);\r\n            debug(\"Settings:\", settings);\r\n\r\n            if (err.ruleId) {\r\n                err.message += `\\nRule: \"${err.ruleId}\"`;\r\n            }\r\n\r\n            throw err;\r\n        }\r\n\r\n        return applyDisableDirectives({\r\n            directives: commentDirectives.disableDirectives,\r\n            disableFixes: options.disableFixes,\r\n            problems: lintingProblems\r\n                .concat(commentDirectives.problems)\r\n                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),\r\n            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Verify a given code with `ConfigArray`.\r\n     * @param {string|SourceCode} textOrSourceCode The source code.\r\n     * @param {ConfigArray} configArray The config array.\r\n     * @param {VerifyOptions&ProcessorOptions} options The options.\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n     */\r\n    _verifyWithConfigArray(textOrSourceCode, configArray, options) {\r\n        debug(\"With ConfigArray: %s\", options.filename);\r\n\r\n        // Store the config array in order to get plugin envs and rules later.\r\n        internalSlotsMap.get(this).lastConfigArray = configArray;\r\n\r\n        // Extract the final config for this file.\r\n        const config = configArray.extractConfig(options.filename);\r\n        const processor =\r\n            config.processor &&\r\n            configArray.pluginProcessors.get(config.processor);\r\n\r\n        // Verify.\r\n        if (processor) {\r\n            debug(\"Apply the processor: %o\", config.processor);\r\n            const { preprocess, postprocess, supportsAutofix } = processor;\r\n            const disableFixes = options.disableFixes || !supportsAutofix;\r\n\r\n            return this._verifyWithProcessor(\r\n                textOrSourceCode,\r\n                config,\r\n                { ...options, disableFixes, postprocess, preprocess },\r\n                configArray\r\n            );\r\n        }\r\n        return this._verifyWithoutProcessors(textOrSourceCode, config, options);\r\n    }\r\n\r\n    /**\r\n     * Verify a given code with a flat config.\r\n     * @param {string|SourceCode} textOrSourceCode The source code.\r\n     * @param {FlatConfigArray} configArray The config array.\r\n     * @param {VerifyOptions&ProcessorOptions} options The options.\r\n     * @param {boolean} [firstCall=false] Indicates if this is being called directly\r\n     *      from verify(). (TODO: Remove once eslintrc is removed.)\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n     */\r\n    _verifyWithFlatConfigArray(textOrSourceCode, configArray, options, firstCall = false) {\r\n        debug(\"With flat config: %s\", options.filename);\r\n\r\n        // we need a filename to match configs against\r\n        const filename = options.filename || \"<input>\";\r\n\r\n        // Store the config array in order to get plugin envs and rules later.\r\n        internalSlotsMap.get(this).lastConfigArray = configArray;\r\n        const config = configArray.getConfig(filename);\r\n\r\n        // Verify.\r\n        if (config.processor) {\r\n            debug(\"Apply the processor: %o\", config.processor);\r\n            const { preprocess, postprocess, supportsAutofix } = config.processor;\r\n            const disableFixes = options.disableFixes || !supportsAutofix;\r\n\r\n            return this._verifyWithFlatConfigArrayAndProcessor(\r\n                textOrSourceCode,\r\n                config,\r\n                { ...options, filename, disableFixes, postprocess, preprocess },\r\n                configArray\r\n            );\r\n        }\r\n\r\n        // check for options-based processing\r\n        if (firstCall && (options.preprocess || options.postprocess)) {\r\n            return this._verifyWithFlatConfigArrayAndProcessor(textOrSourceCode, config, options);\r\n        }\r\n\r\n        return this._verifyWithFlatConfigArrayAndWithoutProcessors(textOrSourceCode, config, options);\r\n    }\r\n\r\n    /**\r\n     * Verify with a processor.\r\n     * @param {string|SourceCode} textOrSourceCode The source code.\r\n     * @param {ConfigData|ExtractedConfig} config The config array.\r\n     * @param {VerifyOptions&ProcessorOptions} options The options.\r\n     * @param {ConfigArray} [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.\r\n     * @returns {(LintMessage|SuppressedLintMessage)[]} The found problems.\r\n     */\r\n    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {\r\n        const filename = options.filename || \"<input>\";\r\n        const filenameToExpose = normalizeFilename(filename);\r\n        const physicalFilename = options.physicalFilename || filenameToExpose;\r\n        const text = ensureText(textOrSourceCode);\r\n        const preprocess = options.preprocess || (rawText => [rawText]);\r\n\r\n        const postprocess = options.postprocess || (messagesList => messagesList.flat());\r\n        const filterCodeBlock =\r\n            options.filterCodeBlock ||\r\n            (blockFilename => blockFilename.endsWith(\".js\"));\r\n        const originalExtname = path.extname(filename);\r\n        const messageLists = preprocess(text, filenameToExpose).map((block, i) => {\r\n            debug(\"A code block was found: %o\", block.filename || \"(unnamed)\");\r\n\r\n            // Keep the legacy behavior.\r\n            if (typeof block === \"string\") {\r\n                return this._verifyWithoutProcessors(block, config, options);\r\n            }\r\n\r\n            const blockText = block.text;\r\n            const blockName = path.join(filename, `${i}_${block.filename}`);\r\n\r\n            // Skip this block if filtered.\r\n            if (!filterCodeBlock(blockName, blockText)) {\r\n                debug(\"This code block was skipped.\");\r\n                return [];\r\n            }\r\n\r\n            // Resolve configuration again if the file content or extension was changed.\r\n            if (configForRecursive && (text !== blockText || path.extname(blockName) !== originalExtname)) {\r\n                debug(\"Resolving configuration again because the file content or extension was changed.\");\r\n                return this._verifyWithConfigArray(\r\n                    blockText,\r\n                    configForRecursive,\r\n                    { ...options, filename: blockName, physicalFilename }\r\n                );\r\n            }\r\n\r\n            // Does lint.\r\n            return this._verifyWithoutProcessors(\r\n                blockText,\r\n                config,\r\n                { ...options, filename: blockName, physicalFilename }\r\n            );\r\n        });\r\n\r\n        return postprocess(messageLists, filenameToExpose);\r\n    }\r\n\r\n    /**\r\n     * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.\r\n     * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.\r\n     * @param {Problem[]} problems A list of reported problems.\r\n     * @returns {LintMessage[]} A list of LintMessage.\r\n     */\r\n    _distinguishSuppressedMessages(problems) {\r\n        const messages = [];\r\n        const suppressedMessages = [];\r\n        const slots = internalSlotsMap.get(this);\r\n\r\n        for (const problem of problems) {\r\n            if (problem.suppressions) {\r\n                suppressedMessages.push(problem);\r\n            } else {\r\n                messages.push(problem);\r\n            }\r\n        }\r\n\r\n        slots.lastSuppressedMessages = suppressedMessages;\r\n\r\n        return messages;\r\n    }\r\n\r\n    /**\r\n     * Gets the SourceCode object representing the parsed source.\r\n     * @returns {SourceCode} The SourceCode object.\r\n     */\r\n    getSourceCode() {\r\n        return internalSlotsMap.get(this).lastSourceCode;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of SuppressedLintMessage produced in the last running.\r\n     * @returns {SuppressedLintMessage[]} The list of SuppressedLintMessage\r\n     */\r\n    getSuppressedMessages() {\r\n        return internalSlotsMap.get(this).lastSuppressedMessages;\r\n    }\r\n\r\n    /**\r\n     * Defines a new linting rule.\r\n     * @param {string} ruleId A unique rule identifier\r\n     * @param {Function | Rule} ruleModule Function from context to object mapping AST node types to event handlers\r\n     * @returns {void}\r\n     */\r\n    defineRule(ruleId, ruleModule) {\r\n        assertEslintrcConfig(this);\r\n        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);\r\n    }\r\n\r\n    /**\r\n     * Defines many new linting rules.\r\n     * @param {Record<string, Function | Rule>} rulesToDefine map from unique rule identifier to rule\r\n     * @returns {void}\r\n     */\r\n    defineRules(rulesToDefine) {\r\n        assertEslintrcConfig(this);\r\n        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {\r\n            this.defineRule(ruleId, rulesToDefine[ruleId]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets an object with all loaded rules.\r\n     * @returns {Map<string, Rule>} All loaded rules\r\n     */\r\n    getRules() {\r\n        assertEslintrcConfig(this);\r\n        const { lastConfigArray, ruleMap } = internalSlotsMap.get(this);\r\n\r\n        return new Map(function *() {\r\n            yield* ruleMap;\r\n\r\n            if (lastConfigArray) {\r\n                yield* lastConfigArray.pluginRules;\r\n            }\r\n        }());\r\n    }\r\n\r\n    /**\r\n     * Define a new parser module\r\n     * @param {string} parserId Name of the parser\r\n     * @param {Parser} parserModule The parser object\r\n     * @returns {void}\r\n     */\r\n    defineParser(parserId, parserModule) {\r\n        assertEslintrcConfig(this);\r\n        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);\r\n    }\r\n\r\n    /**\r\n     * Performs multiple autofix passes over the text until as many fixes as possible\r\n     * have been applied.\r\n     * @param {string} text The source text to apply fixes to.\r\n     * @param {ConfigData|ConfigArray|FlatConfigArray} config The ESLint config object to use.\r\n     * @param {VerifyOptions&ProcessorOptions&FixOptions} options The ESLint options object to use.\r\n     * @returns {{fixed:boolean,messages:LintMessage[],output:string}} The result of the fix operation as returned from the\r\n     *      SourceCodeFixer.\r\n     */\r\n    verifyAndFix(text, config, options) {\r\n        let messages = [],\r\n            fixedResult,\r\n            fixed = false,\r\n            passNumber = 0,\r\n            currentText = text;\r\n        const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;\r\n        const shouldFix = options && typeof options.fix !== \"undefined\" ? options.fix : true;\r\n\r\n        /**\r\n         * This loop continues until one of the following is true:\r\n         *\r\n         * 1. No more fixes have been applied.\r\n         * 2. Ten passes have been made.\r\n         *\r\n         * That means anytime a fix is successfully applied, there will be another pass.\r\n         * Essentially, guaranteeing a minimum of two passes.\r\n         */\r\n        do {\r\n            passNumber++;\r\n\r\n            debug(`Linting code for ${debugTextDescription} (pass ${passNumber})`);\r\n            messages = this.verify(currentText, config, options);\r\n\r\n            debug(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);\r\n            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);\r\n\r\n            /*\r\n             * stop if there are any syntax errors.\r\n             * 'fixedResult.output' is a empty string.\r\n             */\r\n            if (messages.length === 1 && messages[0].fatal) {\r\n                break;\r\n            }\r\n\r\n            // keep track if any fixes were ever applied - important for return value\r\n            fixed = fixed || fixedResult.fixed;\r\n\r\n            // update to use the fixed output instead of the original text\r\n            currentText = fixedResult.output;\r\n\r\n        } while (\r\n            fixedResult.fixed &&\r\n            passNumber < MAX_AUTOFIX_PASSES\r\n        );\r\n\r\n        /*\r\n         * If the last result had fixes, we need to lint again to be sure we have\r\n         * the most up-to-date information.\r\n         */\r\n        if (fixedResult.fixed) {\r\n            fixedResult.messages = this.verify(currentText, config, options);\r\n        }\r\n\r\n        // ensure the last result properly reflects if fixes were done\r\n        fixedResult.fixed = fixed;\r\n        fixedResult.output = currentText;\r\n\r\n        return fixedResult;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    Linter,\r\n\r\n    /**\r\n     * Get the internal slots of a given Linter instance for tests.\r\n     * @param {Linter} instance The Linter instance to get.\r\n     * @returns {LinterInternalSlots} The internal slots.\r\n     */\r\n    getLinterInternalSlots(instance) {\r\n        return internalSlotsMap.get(instance);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}