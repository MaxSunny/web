{"ast":null,"code":"/**\r\n * @fileoverview Disallow trailing spaces at the end of lines.\r\n * @author Nodeca Team <https://github.com/nodeca>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow trailing whitespace at the end of lines\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipBlankLines: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreComments: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      trailingSpace: \"Trailing spaces not allowed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\n          SKIP_BLANK = `^${BLANK_CLASS}*$`,\n          NONBLANK = `${BLANK_CLASS}+$`;\n    const options = context.options[0] || {},\n          skipBlankLines = options.skipBlankLines || false,\n          ignoreComments = options.ignoreComments || false;\n    /**\r\n     * Report the error message\r\n     * @param {ASTNode} node node to report\r\n     * @param {int[]} location range information\r\n     * @param {int[]} fixRange Range based on the whole program\r\n     * @returns {void}\r\n     */\n\n    function report(node, location, fixRange) {\n      /*\r\n       * Passing node is a bit dirty, because message data will contain big\r\n       * text in `source`. But... who cares :) ?\r\n       * One more kludge will not make worse the bloody wizardry of this\r\n       * plugin.\r\n       */\n      context.report({\n        node,\n        loc: location,\n        messageId: \"trailingSpace\",\n\n        fix(fixer) {\n          return fixer.removeRange(fixRange);\n        }\n\n      });\n    }\n    /**\r\n     * Given a list of comment nodes, return the line numbers for those comments.\r\n     * @param {Array} comments An array of comment nodes.\r\n     * @returns {number[]} An array of line numbers containing comments.\r\n     */\n\n\n    function getCommentLineNumbers(comments) {\n      const lines = new Set();\n      comments.forEach(comment => {\n        const endLine = comment.type === \"Block\" ? comment.loc.end.line - 1 : comment.loc.end.line;\n\n        for (let i = comment.loc.start.line; i <= endLine; i++) {\n          lines.add(i);\n        }\n      });\n      return lines;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkTrailingSpaces(node) {\n        /*\r\n         * Let's hack. Since Espree does not return whitespace nodes,\r\n         * fetch the source code and do matching via regexps.\r\n         */\n        const re = new RegExp(NONBLANK, \"u\"),\n              skipMatch = new RegExp(SKIP_BLANK, \"u\"),\n              lines = sourceCode.lines,\n              linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\n              comments = sourceCode.getAllComments(),\n              commentLineNumbers = getCommentLineNumbers(comments);\n        let totalLength = 0,\n            fixRange = [];\n\n        for (let i = 0, ii = lines.length; i < ii; i++) {\n          const lineNumber = i + 1;\n          /*\r\n           * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\r\n           * Because during the fix time they also reserve one spot in the array.\r\n           * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\r\n           */\n\n          const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n          const lineLength = lines[i].length + linebreakLength;\n          const matches = re.exec(lines[i]);\n\n          if (matches) {\n            const location = {\n              start: {\n                line: lineNumber,\n                column: matches.index\n              },\n              end: {\n                line: lineNumber,\n                column: lineLength - linebreakLength\n              }\n            };\n            const rangeStart = totalLength + location.start.column;\n            const rangeEnd = totalLength + location.end.column;\n            const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n            if (containingNode && containingNode.type === \"TemplateElement\" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {\n              totalLength += lineLength;\n              continue;\n            }\n            /*\r\n             * If the line has only whitespace, and skipBlankLines\r\n             * is true, don't report it\r\n             */\n\n\n            if (skipBlankLines && skipMatch.test(lines[i])) {\n              totalLength += lineLength;\n              continue;\n            }\n\n            fixRange = [rangeStart, rangeEnd];\n\n            if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\n              report(node, location, fixRange);\n            }\n          }\n\n          totalLength += lineLength;\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-trailing-spaces.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","skipBlankLines","default","ignoreComments","additionalProperties","messages","trailingSpace","create","context","sourceCode","getSourceCode","BLANK_CLASS","SKIP_BLANK","NONBLANK","options","report","node","location","fixRange","loc","messageId","fix","fixer","removeRange","getCommentLineNumbers","comments","lines","Set","forEach","comment","endLine","end","line","i","start","add","Program","checkTrailingSpaces","re","RegExp","skipMatch","linebreaks","getText","match","createGlobalLinebreakMatcher","getAllComments","commentLineNumbers","totalLength","ii","length","lineNumber","linebreakLength","lineLength","matches","exec","column","index","rangeStart","rangeEnd","containingNode","getNodeByRangeIndex","parent","range","test","has"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallow trailing spaces at the end of lines.\r\n * @author Nodeca Team <https://github.com/nodeca>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"disallow trailing whitespace at the end of lines\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-trailing-spaces\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    skipBlankLines: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoreComments: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            trailingSpace: \"Trailing spaces not allowed.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u3000]\",\r\n            SKIP_BLANK = `^${BLANK_CLASS}*$`,\r\n            NONBLANK = `${BLANK_CLASS}+$`;\r\n\r\n        const options = context.options[0] || {},\r\n            skipBlankLines = options.skipBlankLines || false,\r\n            ignoreComments = options.ignoreComments || false;\r\n\r\n        /**\r\n         * Report the error message\r\n         * @param {ASTNode} node node to report\r\n         * @param {int[]} location range information\r\n         * @param {int[]} fixRange Range based on the whole program\r\n         * @returns {void}\r\n         */\r\n        function report(node, location, fixRange) {\r\n\r\n            /*\r\n             * Passing node is a bit dirty, because message data will contain big\r\n             * text in `source`. But... who cares :) ?\r\n             * One more kludge will not make worse the bloody wizardry of this\r\n             * plugin.\r\n             */\r\n            context.report({\r\n                node,\r\n                loc: location,\r\n                messageId: \"trailingSpace\",\r\n                fix(fixer) {\r\n                    return fixer.removeRange(fixRange);\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Given a list of comment nodes, return the line numbers for those comments.\r\n         * @param {Array} comments An array of comment nodes.\r\n         * @returns {number[]} An array of line numbers containing comments.\r\n         */\r\n        function getCommentLineNumbers(comments) {\r\n            const lines = new Set();\r\n\r\n            comments.forEach(comment => {\r\n                const endLine = comment.type === \"Block\"\r\n                    ? comment.loc.end.line - 1\r\n                    : comment.loc.end.line;\r\n\r\n                for (let i = comment.loc.start.line; i <= endLine; i++) {\r\n                    lines.add(i);\r\n                }\r\n            });\r\n\r\n            return lines;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            Program: function checkTrailingSpaces(node) {\r\n\r\n                /*\r\n                 * Let's hack. Since Espree does not return whitespace nodes,\r\n                 * fetch the source code and do matching via regexps.\r\n                 */\r\n\r\n                const re = new RegExp(NONBLANK, \"u\"),\r\n                    skipMatch = new RegExp(SKIP_BLANK, \"u\"),\r\n                    lines = sourceCode.lines,\r\n                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),\r\n                    comments = sourceCode.getAllComments(),\r\n                    commentLineNumbers = getCommentLineNumbers(comments);\r\n\r\n                let totalLength = 0,\r\n                    fixRange = [];\r\n\r\n                for (let i = 0, ii = lines.length; i < ii; i++) {\r\n                    const lineNumber = i + 1;\r\n\r\n                    /*\r\n                     * Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\r\n                     * Because during the fix time they also reserve one spot in the array.\r\n                     * Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\r\n                     */\r\n                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\r\n                    const lineLength = lines[i].length + linebreakLength;\r\n\r\n                    const matches = re.exec(lines[i]);\r\n\r\n                    if (matches) {\r\n                        const location = {\r\n                            start: {\r\n                                line: lineNumber,\r\n                                column: matches.index\r\n                            },\r\n                            end: {\r\n                                line: lineNumber,\r\n                                column: lineLength - linebreakLength\r\n                            }\r\n                        };\r\n\r\n                        const rangeStart = totalLength + location.start.column;\r\n                        const rangeEnd = totalLength + location.end.column;\r\n                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\r\n\r\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\r\n                          rangeStart > containingNode.parent.range[0] &&\r\n                          rangeEnd < containingNode.parent.range[1]) {\r\n                            totalLength += lineLength;\r\n                            continue;\r\n                        }\r\n\r\n                        /*\r\n                         * If the line has only whitespace, and skipBlankLines\r\n                         * is true, don't report it\r\n                         */\r\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\r\n                            totalLength += lineLength;\r\n                            continue;\r\n                        }\r\n\r\n                        fixRange = [rangeStart, rangeEnd];\r\n\r\n                        if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {\r\n                            report(node, location, fixRange);\r\n                        }\r\n                    }\r\n\r\n                    totalLength += lineLength;\r\n                }\r\n            }\r\n\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}