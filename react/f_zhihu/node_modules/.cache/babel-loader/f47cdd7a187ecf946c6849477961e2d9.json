{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag non-matching identifiers\r\n * @author Matthieu Larcher\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require identifiers to match a specified regular expression\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-match\"\n    },\n    schema: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        properties: {\n          type: \"boolean\",\n          default: false\n        },\n        classFields: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyDeclarations: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\n      notMatchPrivate: \"Identifier '#{{name}}' does not match the pattern '{{pattern}}'.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n    const pattern = context.options[0] || \"^.+$\",\n          regexp = new RegExp(pattern, \"u\");\n    const options = context.options[1] || {},\n          checkProperties = !!options.properties,\n          checkClassFields = !!options.classFields,\n          onlyDeclarations = !!options.onlyDeclarations,\n          ignoreDestructuring = !!options.ignoreDestructuring;\n    let globalScope; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n    const reportedNodes = new Set();\n    const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\n    const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\n    const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\n    /**\r\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n     * @param {ASTNode} node `Identifier` node to check.\r\n     * @returns {boolean} `true` if the node is a reference to a global variable.\r\n     */\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\r\n     * Checks if a string matches the provided pattern\r\n     * @param {string} name The string to check.\r\n     * @returns {boolean} if the string is a match\r\n     * @private\r\n     */\n\n\n    function isInvalid(name) {\n      return !regexp.test(name);\n    }\n    /**\r\n     * Checks if a parent of a node is an ObjectPattern.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} if the node is inside an ObjectPattern\r\n     * @private\r\n     */\n\n\n    function isInsideObjectPattern(node) {\n      let {\n        parent\n      } = node;\n\n      while (parent) {\n        if (parent.type === \"ObjectPattern\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\r\n     * Verifies if we should report an error or not based on the effective\r\n     * parent node and the identifier name.\r\n     * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\r\n     * @param {string} name The identifier name of the identifier node\r\n     * @returns {boolean} whether an error should be reported or not\r\n     */\n\n\n    function shouldReport(effectiveParent, name) {\n      return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\n    }\n    /**\r\n     * Reports an AST node as a rule violation.\r\n     * @param {ASTNode} node The node to report.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(node) {\n      /*\r\n       * We used the range instead of the node because it's possible\r\n       * for the same identifier to be represented by two different\r\n       * nodes, with the most clear example being shorthand properties:\r\n       * { foo }\r\n       * In this case, \"foo\" is represented by one node for the name\r\n       * and one for the value. The only way to know they are the same\r\n       * is to look at the range.\r\n       */\n      if (!reportedNodes.has(node.range.toString())) {\n        const messageId = node.type === \"PrivateIdentifier\" ? \"notMatchPrivate\" : \"notMatch\";\n        context.report({\n          node,\n          messageId,\n          data: {\n            name: node.name,\n            pattern\n          }\n        });\n        reportedNodes.add(node.range.toString());\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      Identifier(node) {\n        const name = node.name,\n              parent = node.parent,\n              effectiveParent = parent.type === \"MemberExpression\" ? parent.parent : parent;\n\n        if (isReferenceToGlobalVariable(node)) {\n          return;\n        }\n\n        if (parent.type === \"MemberExpression\") {\n          if (!checkProperties) {\n            return;\n          } // Always check object names\n\n\n          if (parent.object.type === \"Identifier\" && parent.object.name === name) {\n            if (isInvalid(name)) {\n              report(node);\n            } // Report AssignmentExpressions left side's assigned variable id\n\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.left.type === \"MemberExpression\" && effectiveParent.left.property.name === node.name) {\n            if (isInvalid(name)) {\n              report(node);\n            } // Report AssignmentExpressions only if they are the left side of the assignment\n\n          } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\n            if (isInvalid(name)) {\n              report(node);\n            }\n          } // For https://github.com/eslint/eslint/issues/15123\n\n        } else if (parent.type === \"Property\" && parent.parent.type === \"ObjectExpression\" && parent.key === node && !parent.computed) {\n          if (checkProperties && isInvalid(name)) {\n            report(node);\n          }\n          /*\r\n           * Properties have their own rules, and\r\n           * AssignmentPattern nodes can be treated like Properties:\r\n           * e.g.: const { no_camelcased = false } = bar;\r\n           */\n\n        } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\n          if (parent.parent && parent.parent.type === \"ObjectPattern\") {\n            if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {\n              report(node);\n            }\n\n            const assignmentKeyEqualsValue = parent.key.name === parent.value.name; // prevent checking righthand side of destructured object\n\n            if (!assignmentKeyEqualsValue && parent.key === node) {\n              return;\n            }\n\n            const valueIsInvalid = parent.value.name && isInvalid(name); // ignore destructuring if the option is set, unless a new identifier is created\n\n            if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\n              report(node);\n            }\n          } // never check properties or always ignore destructuring\n\n\n          if (!checkProperties && !parent.computed || ignoreDestructuring && isInsideObjectPattern(node)) {\n            return;\n          } // don't check right hand side of AssignmentExpression to prevent duplicate warnings\n\n\n          if (parent.right !== node && shouldReport(effectiveParent, name)) {\n            report(node);\n          } // Check if it's an import specifier\n\n        } else if (IMPORT_TYPES.has(parent.type)) {\n          // Report only if the local imported identifier is invalid\n          if (parent.local && parent.local.name === node.name && isInvalid(name)) {\n            report(node);\n          }\n        } else if (parent.type === \"PropertyDefinition\") {\n          if (checkClassFields && isInvalid(name)) {\n            report(node);\n          } // Report anything that is invalid that isn't a CallExpression\n\n        } else if (shouldReport(effectiveParent, name)) {\n          report(node);\n        }\n      },\n\n      \"PrivateIdentifier\"(node) {\n        const isClassField = node.parent.type === \"PropertyDefinition\";\n\n        if (isClassField && !checkClassFields) {\n          return;\n        }\n\n        if (isInvalid(node.name)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/id-match.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","default","classFields","onlyDeclarations","ignoreDestructuring","additionalProperties","messages","notMatch","notMatchPrivate","create","context","pattern","options","regexp","RegExp","checkProperties","checkClassFields","globalScope","reportedNodes","Set","ALLOWED_PARENT_TYPES","DECLARATION_TYPES","IMPORT_TYPES","isReferenceToGlobalVariable","node","variable","set","get","name","defs","length","references","some","ref","identifier","isInvalid","test","isInsideObjectPattern","parent","shouldReport","effectiveParent","has","report","range","toString","messageId","data","add","Program","getScope","Identifier","object","left","property","right","key","computed","shorthand","value","assignmentKeyEqualsValue","valueIsInvalid","local","isClassField"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;;AACAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,6DADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CACJ;AACIL,MAAAA,IAAI,EAAE;AADV,KADI,EAIJ;AACIA,MAAAA,IAAI,EAAE,QADV;AAEIM,MAAAA,UAAU,EAAE;AACRA,QAAAA,UAAU,EAAE;AACRN,UAAAA,IAAI,EAAE,SADE;AAERO,UAAAA,OAAO,EAAE;AAFD,SADJ;AAKRC,QAAAA,WAAW,EAAE;AACTR,UAAAA,IAAI,EAAE,SADG;AAETO,UAAAA,OAAO,EAAE;AAFA,SALL;AASRE,QAAAA,gBAAgB,EAAE;AACdT,UAAAA,IAAI,EAAE,SADQ;AAEdO,UAAAA,OAAO,EAAE;AAFK,SATV;AAaRG,QAAAA,mBAAmB,EAAE;AACjBV,UAAAA,IAAI,EAAE,SADW;AAEjBO,UAAAA,OAAO,EAAE;AAFQ;AAbb,OAFhB;AAoBII,MAAAA,oBAAoB,EAAE;AApB1B,KAJI,CATN;AAoCFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE,iEADJ;AAENC,MAAAA,eAAe,EAAE;AAFX;AApCR,GADO;;AA2CbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ;AACA;AACA;AACA,UAAMC,OAAO,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsB,MAAtC;AAAA,UACIC,MAAM,GAAG,IAAIC,MAAJ,CAAWH,OAAX,EAAoB,GAApB,CADb;AAGA,UAAMC,OAAO,GAAGF,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;AAAA,UACIG,eAAe,GAAG,CAAC,CAACH,OAAO,CAACZ,UADhC;AAAA,UAEIgB,gBAAgB,GAAG,CAAC,CAACJ,OAAO,CAACV,WAFjC;AAAA,UAGIC,gBAAgB,GAAG,CAAC,CAACS,OAAO,CAACT,gBAHjC;AAAA,UAIIC,mBAAmB,GAAG,CAAC,CAACQ,OAAO,CAACR,mBAJpC;AAMA,QAAIa,WAAJ,CAdY,CAgBZ;AACA;AACA;AAEA;;AACA,UAAMC,aAAa,GAAG,IAAIC,GAAJ,EAAtB;AACA,UAAMC,oBAAoB,GAAG,IAAID,GAAJ,CAAQ,CAAC,gBAAD,EAAmB,eAAnB,CAAR,CAA7B;AACA,UAAME,iBAAiB,GAAG,IAAIF,GAAJ,CAAQ,CAAC,qBAAD,EAAwB,oBAAxB,CAAR,CAA1B;AACA,UAAMG,YAAY,GAAG,IAAIH,GAAJ,CAAQ,CAAC,iBAAD,EAAoB,0BAApB,EAAgD,wBAAhD,CAAR,CAArB;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,aAASI,2BAAT,CAAqCC,IAArC,EAA2C;AACvC,YAAMC,QAAQ,GAAGR,WAAW,CAACS,GAAZ,CAAgBC,GAAhB,CAAoBH,IAAI,CAACI,IAAzB,CAAjB;AAEA,aAAOH,QAAQ,IAAIA,QAAQ,CAACI,IAAT,CAAcC,MAAd,KAAyB,CAArC,IACHL,QAAQ,CAACM,UAAT,CAAoBC,IAApB,CAAyBC,GAAG,IAAIA,GAAG,CAACC,UAAJ,KAAmBV,IAAnD,CADJ;AAEH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASW,SAAT,CAAmBP,IAAnB,EAAyB;AACrB,aAAO,CAACf,MAAM,CAACuB,IAAP,CAAYR,IAAZ,CAAR;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASS,qBAAT,CAA+Bb,IAA/B,EAAqC;AACjC,UAAI;AAAEc,QAAAA;AAAF,UAAad,IAAjB;;AAEA,aAAOc,MAAP,EAAe;AACX,YAAIA,MAAM,CAAC5C,IAAP,KAAgB,eAApB,EAAqC;AACjC,iBAAO,IAAP;AACH;;AAED4C,QAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;AACH;;AAED,aAAO,KAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASC,YAAT,CAAsBC,eAAtB,EAAuCZ,IAAvC,EAA6C;AACzC,aAAO,CAAC,CAACzB,gBAAD,IAAqBkB,iBAAiB,CAACoB,GAAlB,CAAsBD,eAAe,CAAC9C,IAAtC,CAAtB,KACH,CAAC0B,oBAAoB,CAACqB,GAArB,CAAyBD,eAAe,CAAC9C,IAAzC,CADE,IACgDyC,SAAS,CAACP,IAAD,CADhE;AAEH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASc,MAAT,CAAgBlB,IAAhB,EAAsB;AAElB;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,UAAI,CAACN,aAAa,CAACuB,GAAd,CAAkBjB,IAAI,CAACmB,KAAL,CAAWC,QAAX,EAAlB,CAAL,EAA+C;AAE3C,cAAMC,SAAS,GAAIrB,IAAI,CAAC9B,IAAL,KAAc,mBAAf,GACZ,iBADY,GACQ,UAD1B;AAGAgB,QAAAA,OAAO,CAACgC,MAAR,CAAe;AACXlB,UAAAA,IADW;AAEXqB,UAAAA,SAFW;AAGXC,UAAAA,IAAI,EAAE;AACFlB,YAAAA,IAAI,EAAEJ,IAAI,CAACI,IADT;AAEFjB,YAAAA;AAFE;AAHK,SAAf;AAQAO,QAAAA,aAAa,CAAC6B,GAAd,CAAkBvB,IAAI,CAACmB,KAAL,CAAWC,QAAX,EAAlB;AACH;AACJ;;AAED,WAAO;AAEHI,MAAAA,OAAO,GAAG;AACN/B,QAAAA,WAAW,GAAGP,OAAO,CAACuC,QAAR,EAAd;AACH,OAJE;;AAMHC,MAAAA,UAAU,CAAC1B,IAAD,EAAO;AACb,cAAMI,IAAI,GAAGJ,IAAI,CAACI,IAAlB;AAAA,cACIU,MAAM,GAAGd,IAAI,CAACc,MADlB;AAAA,cAEIE,eAAe,GAAIF,MAAM,CAAC5C,IAAP,KAAgB,kBAAjB,GAAuC4C,MAAM,CAACA,MAA9C,GAAuDA,MAF7E;;AAIA,YAAIf,2BAA2B,CAACC,IAAD,CAA/B,EAAuC;AACnC;AACH;;AAED,YAAIc,MAAM,CAAC5C,IAAP,KAAgB,kBAApB,EAAwC;AAEpC,cAAI,CAACqB,eAAL,EAAsB;AAClB;AACH,WAJmC,CAMpC;;;AACA,cAAIuB,MAAM,CAACa,MAAP,CAAczD,IAAd,KAAuB,YAAvB,IACA4C,MAAM,CAACa,MAAP,CAAcvB,IAAd,KAAuBA,IAD3B,EACiC;AAC7B,gBAAIO,SAAS,CAACP,IAAD,CAAb,EAAqB;AACjBc,cAAAA,MAAM,CAAClB,IAAD,CAAN;AACH,aAH4B,CAKjC;;AACC,WAPD,MAOO,IAAIgB,eAAe,CAAC9C,IAAhB,KAAyB,sBAAzB,IACP8C,eAAe,CAACY,IAAhB,CAAqB1D,IAArB,KAA8B,kBADvB,IAEP8C,eAAe,CAACY,IAAhB,CAAqBC,QAArB,CAA8BzB,IAA9B,KAAuCJ,IAAI,CAACI,IAFzC,EAE+C;AAClD,gBAAIO,SAAS,CAACP,IAAD,CAAb,EAAqB;AACjBc,cAAAA,MAAM,CAAClB,IAAD,CAAN;AACH,aAHiD,CAKtD;;AACC,WARM,MAQA,IAAIgB,eAAe,CAAC9C,IAAhB,KAAyB,sBAAzB,IAAmD8C,eAAe,CAACc,KAAhB,CAAsB5D,IAAtB,KAA+B,kBAAtF,EAA0G;AAC7G,gBAAIyC,SAAS,CAACP,IAAD,CAAb,EAAqB;AACjBc,cAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AACJ,WA1BmC,CA4BxC;;AACC,SA7BD,MA6BO,IACHc,MAAM,CAAC5C,IAAP,KAAgB,UAAhB,IACA4C,MAAM,CAACA,MAAP,CAAc5C,IAAd,KAAuB,kBADvB,IAEA4C,MAAM,CAACiB,GAAP,KAAe/B,IAFf,IAGA,CAACc,MAAM,CAACkB,QAJL,EAKL;AACE,cAAIzC,eAAe,IAAIoB,SAAS,CAACP,IAAD,CAAhC,EAAwC;AACpCc,YAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AAEL;AAChB;AACA;AACA;AACA;;AACiB,SAfM,MAeA,IAAIc,MAAM,CAAC5C,IAAP,KAAgB,UAAhB,IAA8B4C,MAAM,CAAC5C,IAAP,KAAgB,mBAAlD,EAAuE;AAE1E,cAAI4C,MAAM,CAACA,MAAP,IAAiBA,MAAM,CAACA,MAAP,CAAc5C,IAAd,KAAuB,eAA5C,EAA6D;AACzD,gBAAI,CAACU,mBAAD,IAAwBkC,MAAM,CAACmB,SAA/B,IAA4CnB,MAAM,CAACoB,KAAP,CAAaN,IAAzD,IAAiEjB,SAAS,CAACP,IAAD,CAA9E,EAAsF;AAClFc,cAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;;AAED,kBAAMmC,wBAAwB,GAAGrB,MAAM,CAACiB,GAAP,CAAW3B,IAAX,KAAoBU,MAAM,CAACoB,KAAP,CAAa9B,IAAlE,CALyD,CAOzD;;AACA,gBAAI,CAAC+B,wBAAD,IAA6BrB,MAAM,CAACiB,GAAP,KAAe/B,IAAhD,EAAsD;AAClD;AACH;;AAED,kBAAMoC,cAAc,GAAGtB,MAAM,CAACoB,KAAP,CAAa9B,IAAb,IAAqBO,SAAS,CAACP,IAAD,CAArD,CAZyD,CAczD;;AACA,gBAAIgC,cAAc,IAAI,EAAED,wBAAwB,IAAIvD,mBAA9B,CAAtB,EAA0E;AACtEsC,cAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AACJ,WApByE,CAsB1E;;;AACA,cAAK,CAACT,eAAD,IAAoB,CAACuB,MAAM,CAACkB,QAA7B,IAA2CpD,mBAAmB,IAAIiC,qBAAqB,CAACb,IAAD,CAA3F,EAAoG;AAChG;AACH,WAzByE,CA2B1E;;;AACA,cAAIc,MAAM,CAACgB,KAAP,KAAiB9B,IAAjB,IAAyBe,YAAY,CAACC,eAAD,EAAkBZ,IAAlB,CAAzC,EAAkE;AAC9Dc,YAAAA,MAAM,CAAClB,IAAD,CAAN;AACH,WA9ByE,CAgC9E;;AACC,SAjCM,MAiCA,IAAIF,YAAY,CAACmB,GAAb,CAAiBH,MAAM,CAAC5C,IAAxB,CAAJ,EAAmC;AAEtC;AACA,cAAI4C,MAAM,CAACuB,KAAP,IAAgBvB,MAAM,CAACuB,KAAP,CAAajC,IAAb,KAAsBJ,IAAI,CAACI,IAA3C,IAAmDO,SAAS,CAACP,IAAD,CAAhE,EAAwE;AACpEc,YAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AAEJ,SAPM,MAOA,IAAIc,MAAM,CAAC5C,IAAP,KAAgB,oBAApB,EAA0C;AAE7C,cAAIsB,gBAAgB,IAAImB,SAAS,CAACP,IAAD,CAAjC,EAAyC;AACrCc,YAAAA,MAAM,CAAClB,IAAD,CAAN;AACH,WAJ4C,CAMjD;;AACC,SAPM,MAOA,IAAIe,YAAY,CAACC,eAAD,EAAkBZ,IAAlB,CAAhB,EAAyC;AAC5Cc,UAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AACJ,OA7GE;;AA+GH,0BAAoBA,IAApB,EAA0B;AAEtB,cAAMsC,YAAY,GAAGtC,IAAI,CAACc,MAAL,CAAY5C,IAAZ,KAAqB,oBAA1C;;AAEA,YAAIoE,YAAY,IAAI,CAAC9C,gBAArB,EAAuC;AACnC;AACH;;AAED,YAAImB,SAAS,CAACX,IAAI,CAACI,IAAN,CAAb,EAA0B;AACtBc,UAAAA,MAAM,CAAClB,IAAD,CAAN;AACH;AACJ;;AA1HE,KAAP;AA8HH;;AA5RY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag non-matching identifiers\r\n * @author Matthieu Larcher\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require identifiers to match a specified regular expression\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/id-match\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"string\"\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    properties: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    classFields: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    onlyDeclarations: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoreDestructuring: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            notMatch: \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\",\r\n            notMatchPrivate: \"Identifier '#{{name}}' does not match the pattern '{{pattern}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Options\r\n        //--------------------------------------------------------------------------\r\n        const pattern = context.options[0] || \"^.+$\",\r\n            regexp = new RegExp(pattern, \"u\");\r\n\r\n        const options = context.options[1] || {},\r\n            checkProperties = !!options.properties,\r\n            checkClassFields = !!options.classFields,\r\n            onlyDeclarations = !!options.onlyDeclarations,\r\n            ignoreDestructuring = !!options.ignoreDestructuring;\r\n\r\n        let globalScope;\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\r\n        const reportedNodes = new Set();\r\n        const ALLOWED_PARENT_TYPES = new Set([\"CallExpression\", \"NewExpression\"]);\r\n        const DECLARATION_TYPES = new Set([\"FunctionDeclaration\", \"VariableDeclarator\"]);\r\n        const IMPORT_TYPES = new Set([\"ImportSpecifier\", \"ImportNamespaceSpecifier\", \"ImportDefaultSpecifier\"]);\r\n\r\n        /**\r\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n         * @param {ASTNode} node `Identifier` node to check.\r\n         * @returns {boolean} `true` if the node is a reference to a global variable.\r\n         */\r\n        function isReferenceToGlobalVariable(node) {\r\n            const variable = globalScope.set.get(node.name);\r\n\r\n            return variable && variable.defs.length === 0 &&\r\n                variable.references.some(ref => ref.identifier === node);\r\n        }\r\n\r\n        /**\r\n         * Checks if a string matches the provided pattern\r\n         * @param {string} name The string to check.\r\n         * @returns {boolean} if the string is a match\r\n         * @private\r\n         */\r\n        function isInvalid(name) {\r\n            return !regexp.test(name);\r\n        }\r\n\r\n        /**\r\n         * Checks if a parent of a node is an ObjectPattern.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} if the node is inside an ObjectPattern\r\n         * @private\r\n         */\r\n        function isInsideObjectPattern(node) {\r\n            let { parent } = node;\r\n\r\n            while (parent) {\r\n                if (parent.type === \"ObjectPattern\") {\r\n                    return true;\r\n                }\r\n\r\n                parent = parent.parent;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Verifies if we should report an error or not based on the effective\r\n         * parent node and the identifier name.\r\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\r\n         * @param {string} name The identifier name of the identifier node\r\n         * @returns {boolean} whether an error should be reported or not\r\n         */\r\n        function shouldReport(effectiveParent, name) {\r\n            return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) &&\r\n                !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);\r\n        }\r\n\r\n        /**\r\n         * Reports an AST node as a rule violation.\r\n         * @param {ASTNode} node The node to report.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node) {\r\n\r\n            /*\r\n             * We used the range instead of the node because it's possible\r\n             * for the same identifier to be represented by two different\r\n             * nodes, with the most clear example being shorthand properties:\r\n             * { foo }\r\n             * In this case, \"foo\" is represented by one node for the name\r\n             * and one for the value. The only way to know they are the same\r\n             * is to look at the range.\r\n             */\r\n            if (!reportedNodes.has(node.range.toString())) {\r\n\r\n                const messageId = (node.type === \"PrivateIdentifier\")\r\n                    ? \"notMatchPrivate\" : \"notMatch\";\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId,\r\n                    data: {\r\n                        name: node.name,\r\n                        pattern\r\n                    }\r\n                });\r\n                reportedNodes.add(node.range.toString());\r\n            }\r\n        }\r\n\r\n        return {\r\n\r\n            Program() {\r\n                globalScope = context.getScope();\r\n            },\r\n\r\n            Identifier(node) {\r\n                const name = node.name,\r\n                    parent = node.parent,\r\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\r\n\r\n                if (isReferenceToGlobalVariable(node)) {\r\n                    return;\r\n                }\r\n\r\n                if (parent.type === \"MemberExpression\") {\r\n\r\n                    if (!checkProperties) {\r\n                        return;\r\n                    }\r\n\r\n                    // Always check object names\r\n                    if (parent.object.type === \"Identifier\" &&\r\n                        parent.object.name === name) {\r\n                        if (isInvalid(name)) {\r\n                            report(node);\r\n                        }\r\n\r\n                    // Report AssignmentExpressions left side's assigned variable id\r\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\r\n                        effectiveParent.left.type === \"MemberExpression\" &&\r\n                        effectiveParent.left.property.name === node.name) {\r\n                        if (isInvalid(name)) {\r\n                            report(node);\r\n                        }\r\n\r\n                    // Report AssignmentExpressions only if they are the left side of the assignment\r\n                    } else if (effectiveParent.type === \"AssignmentExpression\" && effectiveParent.right.type !== \"MemberExpression\") {\r\n                        if (isInvalid(name)) {\r\n                            report(node);\r\n                        }\r\n                    }\r\n\r\n                // For https://github.com/eslint/eslint/issues/15123\r\n                } else if (\r\n                    parent.type === \"Property\" &&\r\n                    parent.parent.type === \"ObjectExpression\" &&\r\n                    parent.key === node &&\r\n                    !parent.computed\r\n                ) {\r\n                    if (checkProperties && isInvalid(name)) {\r\n                        report(node);\r\n                    }\r\n\r\n                /*\r\n                 * Properties have their own rules, and\r\n                 * AssignmentPattern nodes can be treated like Properties:\r\n                 * e.g.: const { no_camelcased = false } = bar;\r\n                 */\r\n                } else if (parent.type === \"Property\" || parent.type === \"AssignmentPattern\") {\r\n\r\n                    if (parent.parent && parent.parent.type === \"ObjectPattern\") {\r\n                        if (!ignoreDestructuring && parent.shorthand && parent.value.left && isInvalid(name)) {\r\n                            report(node);\r\n                        }\r\n\r\n                        const assignmentKeyEqualsValue = parent.key.name === parent.value.name;\r\n\r\n                        // prevent checking righthand side of destructured object\r\n                        if (!assignmentKeyEqualsValue && parent.key === node) {\r\n                            return;\r\n                        }\r\n\r\n                        const valueIsInvalid = parent.value.name && isInvalid(name);\r\n\r\n                        // ignore destructuring if the option is set, unless a new identifier is created\r\n                        if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {\r\n                            report(node);\r\n                        }\r\n                    }\r\n\r\n                    // never check properties or always ignore destructuring\r\n                    if ((!checkProperties && !parent.computed) || (ignoreDestructuring && isInsideObjectPattern(node))) {\r\n                        return;\r\n                    }\r\n\r\n                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings\r\n                    if (parent.right !== node && shouldReport(effectiveParent, name)) {\r\n                        report(node);\r\n                    }\r\n\r\n                // Check if it's an import specifier\r\n                } else if (IMPORT_TYPES.has(parent.type)) {\r\n\r\n                    // Report only if the local imported identifier is invalid\r\n                    if (parent.local && parent.local.name === node.name && isInvalid(name)) {\r\n                        report(node);\r\n                    }\r\n\r\n                } else if (parent.type === \"PropertyDefinition\") {\r\n\r\n                    if (checkClassFields && isInvalid(name)) {\r\n                        report(node);\r\n                    }\r\n\r\n                // Report anything that is invalid that isn't a CallExpression\r\n                } else if (shouldReport(effectiveParent, name)) {\r\n                    report(node);\r\n                }\r\n            },\r\n\r\n            \"PrivateIdentifier\"(node) {\r\n\r\n                const isClassField = node.parent.type === \"PropertyDefinition\";\r\n\r\n                if (isClassField && !checkClassFields) {\r\n                    return;\r\n                }\r\n\r\n                if (isInvalid(node.name)) {\r\n                    report(node);\r\n                }\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}