{"ast":null,"code":"/**\r\n * @fileoverview Disallows multiple blank lines.\r\n * implementation adapted from the no-trailing-spaces rule.\r\n * @author Greg Cochard\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow multiple empty lines\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        max: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxEOF: {\n          type: \"integer\",\n          minimum: 0\n        },\n        maxBOF: {\n          type: \"integer\",\n          minimum: 0\n        }\n      },\n      required: [\"max\"],\n      additionalProperties: false\n    }],\n    messages: {\n      blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\n      blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\n      consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\n    }\n  },\n\n  create(context) {\n    // Use options.max or 2 as default\n    let max = 2,\n        maxEOF = max,\n        maxBOF = max;\n\n    if (context.options.length) {\n      max = context.options[0].max;\n      maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n      maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n    }\n\n    const sourceCode = context.getSourceCode(); // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\n\n    const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\n    const templateLiteralLines = new Set(); //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    return {\n      TemplateLiteral(node) {\n        node.quasis.forEach(literalPart => {\n          // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\n          for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\n            templateLiteralLines.add(ignoredLine);\n          }\n        });\n      },\n\n      \"Program:exit\"(node) {\n        return allLines // Given a list of lines, first get a list of line numbers that are non-empty.\n        .reduce((nonEmptyLineNumbers, line, index) => {\n          if (line.trim() || templateLiteralLines.has(index + 1)) {\n            nonEmptyLineNumbers.push(index + 1);\n          }\n\n          return nonEmptyLineNumbers;\n        }, []) // Add a value at the end to allow trailing empty lines to be checked.\n        .concat(allLines.length + 1) // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\n        .reduce((lastLineNumber, lineNumber) => {\n          let messageId, maxAllowed;\n\n          if (lastLineNumber === 0) {\n            messageId = \"blankBeginningOfFile\";\n            maxAllowed = maxBOF;\n          } else if (lineNumber === allLines.length + 1) {\n            messageId = \"blankEndOfFile\";\n            maxAllowed = maxEOF;\n          } else {\n            messageId = \"consecutiveBlank\";\n            maxAllowed = max;\n          }\n\n          if (lineNumber - lastLineNumber - 1 > maxAllowed) {\n            context.report({\n              node,\n              loc: {\n                start: {\n                  line: lastLineNumber + maxAllowed + 1,\n                  column: 0\n                },\n                end: {\n                  line: lineNumber,\n                  column: 0\n                }\n              },\n              messageId,\n              data: {\n                max: maxAllowed,\n                pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\n              },\n\n              fix(fixer) {\n                const rangeStart = sourceCode.getIndexFromLoc({\n                  line: lastLineNumber + 1,\n                  column: 0\n                });\n                /*\r\n                 * The end of the removal range is usually the start index of the next line.\r\n                 * However, at the end of the file there is no next line, so the end of the\r\n                 * range is just the length of the text.\r\n                 */\n\n                const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\n                const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({\n                  line: lineNumberAfterRemovedLines,\n                  column: 0\n                }) : sourceCode.text.length;\n                return fixer.removeRange([rangeStart, rangeEnd]);\n              }\n\n            });\n          }\n\n          return lineNumber;\n        }, 0);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-multiple-empty-lines.js"],"names":["module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","max","minimum","maxEOF","maxBOF","required","additionalProperties","messages","blankBeginningOfFile","blankEndOfFile","consecutiveBlank","create","context","options","length","sourceCode","getSourceCode","allLines","lines","slice","templateLiteralLines","Set","TemplateLiteral","node","quasis","forEach","literalPart","ignoredLine","loc","start","line","end","add","reduce","nonEmptyLineNumbers","index","trim","has","push","concat","lastLineNumber","lineNumber","messageId","maxAllowed","report","column","data","pluralizedLines","fix","fixer","rangeStart","getIndexFromLoc","lineNumberAfterRemovedLines","rangeEnd","text","removeRange"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallows multiple blank lines.\r\n * implementation adapted from the no-trailing-spaces rule.\r\n * @author Greg Cochard\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"disallow multiple empty lines\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-multiple-empty-lines\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    max: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    maxEOF: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    maxBOF: {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    }\r\n                },\r\n                required: [\"max\"],\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            blankBeginningOfFile: \"Too many blank lines at the beginning of file. Max of {{max}} allowed.\",\r\n            blankEndOfFile: \"Too many blank lines at the end of file. Max of {{max}} allowed.\",\r\n            consecutiveBlank: \"More than {{max}} blank {{pluralizedLines}} not allowed.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        // Use options.max or 2 as default\r\n        let max = 2,\r\n            maxEOF = max,\r\n            maxBOF = max;\r\n\r\n        if (context.options.length) {\r\n            max = context.options[0].max;\r\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\r\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\r\n        }\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue\r\n        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === \"\" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;\r\n        const templateLiteralLines = new Set();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            TemplateLiteral(node) {\r\n                node.quasis.forEach(literalPart => {\r\n\r\n                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.\r\n                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {\r\n                        templateLiteralLines.add(ignoredLine);\r\n                    }\r\n                });\r\n            },\r\n            \"Program:exit\"(node) {\r\n                return allLines\r\n\r\n                    // Given a list of lines, first get a list of line numbers that are non-empty.\r\n                    .reduce((nonEmptyLineNumbers, line, index) => {\r\n                        if (line.trim() || templateLiteralLines.has(index + 1)) {\r\n                            nonEmptyLineNumbers.push(index + 1);\r\n                        }\r\n                        return nonEmptyLineNumbers;\r\n                    }, [])\r\n\r\n                    // Add a value at the end to allow trailing empty lines to be checked.\r\n                    .concat(allLines.length + 1)\r\n\r\n                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.\r\n                    .reduce((lastLineNumber, lineNumber) => {\r\n                        let messageId, maxAllowed;\r\n\r\n                        if (lastLineNumber === 0) {\r\n                            messageId = \"blankBeginningOfFile\";\r\n                            maxAllowed = maxBOF;\r\n                        } else if (lineNumber === allLines.length + 1) {\r\n                            messageId = \"blankEndOfFile\";\r\n                            maxAllowed = maxEOF;\r\n                        } else {\r\n                            messageId = \"consecutiveBlank\";\r\n                            maxAllowed = max;\r\n                        }\r\n\r\n                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {\r\n                            context.report({\r\n                                node,\r\n                                loc: {\r\n                                    start: { line: lastLineNumber + maxAllowed + 1, column: 0 },\r\n                                    end: { line: lineNumber, column: 0 }\r\n                                },\r\n                                messageId,\r\n                                data: {\r\n                                    max: maxAllowed,\r\n                                    pluralizedLines: maxAllowed === 1 ? \"line\" : \"lines\"\r\n                                },\r\n                                fix(fixer) {\r\n                                    const rangeStart = sourceCode.getIndexFromLoc({ line: lastLineNumber + 1, column: 0 });\r\n\r\n                                    /*\r\n                                     * The end of the removal range is usually the start index of the next line.\r\n                                     * However, at the end of the file there is no next line, so the end of the\r\n                                     * range is just the length of the text.\r\n                                     */\r\n                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;\r\n                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length\r\n                                        ? sourceCode.getIndexFromLoc({ line: lineNumberAfterRemovedLines, column: 0 })\r\n                                        : sourceCode.text.length;\r\n\r\n                                    return fixer.removeRange([rangeStart, rangeEnd]);\r\n                                }\r\n                            });\r\n                        }\r\n\r\n                        return lineNumber;\r\n                    }, 0);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}