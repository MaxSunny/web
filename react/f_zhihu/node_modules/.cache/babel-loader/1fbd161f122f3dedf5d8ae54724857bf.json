{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\r\n * @author Raphael Pigulla\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent naming when capturing the current execution context\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-this\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\",\n        minLength: 1\n      },\n      uniqueItems: true\n    },\n    messages: {\n      aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\n      unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\n    }\n  },\n\n  create(context) {\n    let aliases = [];\n\n    if (context.options.length === 0) {\n      aliases.push(\"that\");\n    } else {\n      aliases = context.options;\n    }\n    /**\r\n     * Reports that a variable declarator or assignment expression is assigning\r\n     * a non-'this' value to the specified alias.\r\n     * @param {ASTNode} node The assigning node.\r\n     * @param {string} name the name of the alias that was incorrectly used.\r\n     * @returns {void}\r\n     */\n\n\n    function reportBadAssignment(node, name) {\n      context.report({\n        node,\n        messageId: \"aliasNotAssignedToThis\",\n        data: {\n          name\n        }\n      });\n    }\n    /**\r\n     * Checks that an assignment to an identifier only assigns 'this' to the\r\n     * appropriate alias, and the alias is only assigned to 'this'.\r\n     * @param {ASTNode} node The assigning node.\r\n     * @param {Identifier} name The name of the variable assigned to.\r\n     * @param {Expression} value The value of the assignment.\r\n     * @returns {void}\r\n     */\n\n\n    function checkAssignment(node, name, value) {\n      const isThis = value.type === \"ThisExpression\";\n\n      if (aliases.indexOf(name) !== -1) {\n        if (!isThis || node.operator && node.operator !== \"=\") {\n          reportBadAssignment(node, name);\n        }\n      } else if (isThis) {\n        context.report({\n          node,\n          messageId: \"unexpectedAlias\",\n          data: {\n            name\n          }\n        });\n      }\n    }\n    /**\r\n     * Ensures that a variable declaration of the alias in a program or function\r\n     * is assigned to the correct value.\r\n     * @param {string} alias alias the check the assignment of.\r\n     * @param {Object} scope scope of the current code we are checking.\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    function checkWasAssigned(alias, scope) {\n      const variable = scope.set.get(alias);\n\n      if (!variable) {\n        return;\n      }\n\n      if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" && def.node.init !== null)) {\n        return;\n      }\n      /*\r\n       * The alias has been declared and not assigned: check it was\r\n       * assigned later in the same scope.\r\n       */\n\n\n      if (!variable.references.some(reference => {\n        const write = reference.writeExpr;\n        return reference.from === scope && write && write.type === \"ThisExpression\" && write.parent.operator === \"=\";\n      })) {\n        variable.defs.map(def => def.node).forEach(node => {\n          reportBadAssignment(node, alias);\n        });\n      }\n    }\n    /**\r\n     * Check each alias to ensure that is was assigned to the correct value.\r\n     * @returns {void}\r\n     */\n\n\n    function ensureWasAssigned() {\n      const scope = context.getScope();\n      aliases.forEach(alias => {\n        checkWasAssigned(alias, scope);\n      });\n    }\n\n    return {\n      \"Program:exit\": ensureWasAssigned,\n      \"FunctionExpression:exit\": ensureWasAssigned,\n      \"FunctionDeclaration:exit\": ensureWasAssigned,\n\n      VariableDeclarator(node) {\n        const id = node.id;\n        const isDestructuring = id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\n\n        if (node.init !== null && !isDestructuring) {\n          checkAssignment(node, id.name, node.init);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.left.type === \"Identifier\") {\n          checkAssignment(node, node.left.name, node.right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/consistent-this.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","items","minLength","uniqueItems","messages","aliasNotAssignedToThis","unexpectedAlias","create","context","aliases","options","length","push","reportBadAssignment","node","name","report","messageId","data","checkAssignment","value","isThis","indexOf","operator","checkWasAssigned","alias","scope","variable","set","get","defs","some","def","init","references","reference","write","writeExpr","from","parent","map","forEach","ensureWasAssigned","getScope","VariableDeclarator","id","isDestructuring","AssignmentExpression","left","right"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce consistent naming of \"this\" context variables\r\n * @author Raphael Pigulla\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent naming when capturing the current execution context\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/consistent-this\"\r\n        },\r\n\r\n        schema: {\r\n            type: \"array\",\r\n            items: {\r\n                type: \"string\",\r\n                minLength: 1\r\n            },\r\n            uniqueItems: true\r\n        },\r\n\r\n        messages: {\r\n            aliasNotAssignedToThis: \"Designated alias '{{name}}' is not assigned to 'this'.\",\r\n            unexpectedAlias: \"Unexpected alias '{{name}}' for 'this'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        let aliases = [];\r\n\r\n        if (context.options.length === 0) {\r\n            aliases.push(\"that\");\r\n        } else {\r\n            aliases = context.options;\r\n        }\r\n\r\n        /**\r\n         * Reports that a variable declarator or assignment expression is assigning\r\n         * a non-'this' value to the specified alias.\r\n         * @param {ASTNode} node The assigning node.\r\n         * @param {string} name the name of the alias that was incorrectly used.\r\n         * @returns {void}\r\n         */\r\n        function reportBadAssignment(node, name) {\r\n            context.report({ node, messageId: \"aliasNotAssignedToThis\", data: { name } });\r\n        }\r\n\r\n        /**\r\n         * Checks that an assignment to an identifier only assigns 'this' to the\r\n         * appropriate alias, and the alias is only assigned to 'this'.\r\n         * @param {ASTNode} node The assigning node.\r\n         * @param {Identifier} name The name of the variable assigned to.\r\n         * @param {Expression} value The value of the assignment.\r\n         * @returns {void}\r\n         */\r\n        function checkAssignment(node, name, value) {\r\n            const isThis = value.type === \"ThisExpression\";\r\n\r\n            if (aliases.indexOf(name) !== -1) {\r\n                if (!isThis || node.operator && node.operator !== \"=\") {\r\n                    reportBadAssignment(node, name);\r\n                }\r\n            } else if (isThis) {\r\n                context.report({ node, messageId: \"unexpectedAlias\", data: { name } });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Ensures that a variable declaration of the alias in a program or function\r\n         * is assigned to the correct value.\r\n         * @param {string} alias alias the check the assignment of.\r\n         * @param {Object} scope scope of the current code we are checking.\r\n         * @private\r\n         * @returns {void}\r\n         */\r\n        function checkWasAssigned(alias, scope) {\r\n            const variable = scope.set.get(alias);\r\n\r\n            if (!variable) {\r\n                return;\r\n            }\r\n\r\n            if (variable.defs.some(def => def.node.type === \"VariableDeclarator\" &&\r\n                def.node.init !== null)) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * The alias has been declared and not assigned: check it was\r\n             * assigned later in the same scope.\r\n             */\r\n            if (!variable.references.some(reference => {\r\n                const write = reference.writeExpr;\r\n\r\n                return (\r\n                    reference.from === scope &&\r\n                    write && write.type === \"ThisExpression\" &&\r\n                    write.parent.operator === \"=\"\r\n                );\r\n            })) {\r\n                variable.defs.map(def => def.node).forEach(node => {\r\n                    reportBadAssignment(node, alias);\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check each alias to ensure that is was assigned to the correct value.\r\n         * @returns {void}\r\n         */\r\n        function ensureWasAssigned() {\r\n            const scope = context.getScope();\r\n\r\n            aliases.forEach(alias => {\r\n                checkWasAssigned(alias, scope);\r\n            });\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\": ensureWasAssigned,\r\n            \"FunctionExpression:exit\": ensureWasAssigned,\r\n            \"FunctionDeclaration:exit\": ensureWasAssigned,\r\n\r\n            VariableDeclarator(node) {\r\n                const id = node.id;\r\n                const isDestructuring =\r\n                    id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\";\r\n\r\n                if (node.init !== null && !isDestructuring) {\r\n                    checkAssignment(node, id.name, node.init);\r\n                }\r\n            },\r\n\r\n            AssignmentExpression(node) {\r\n                if (node.left.type === \"Identifier\") {\r\n                    checkAssignment(node, node.left.name, node.right);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}