{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\n/**\r\n * Determines whether the given node is the first node in the code path to which a loop statement\r\n * 'loops' for the next iteration.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a looping target.\r\n */\n\nfunction isLoopingTarget(node) {\n  const parent = node.parent;\n\n  if (parent) {\n    switch (parent.type) {\n      case \"WhileStatement\":\n        return node === parent.test;\n\n      case \"DoWhileStatement\":\n        return node === parent.body;\n\n      case \"ForStatement\":\n        return node === (parent.update || parent.test || parent.body);\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        return node === parent.left;\n      // no default\n    }\n  }\n\n  return false;\n}\n/**\r\n * Creates an array with elements from the first given array that are not included in the second given array.\r\n * @param {Array} arrA The array to compare from.\r\n * @param {Array} arrB The array to compare against.\r\n * @returns {Array} a new array that represents `arrA \\ arrB`.\r\n */\n\n\nfunction getDifference(arrA, arrB) {\n  return arrA.filter(a => !arrB.includes(a));\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow loops with a body that allows only one iteration\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignore: {\n          type: \"array\",\n          items: {\n            enum: allLoopTypes\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalid: \"Invalid loop. Its body allows only one iteration.\"\n    }\n  },\n\n  create(context) {\n    const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\n          loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\n          loopSelector = loopTypesToCheck.join(\",\"),\n          loopsByTargetSegments = new Map(),\n          loopsToReport = new Set();\n    let currentCodePath = null;\n    return {\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      [loopSelector](node) {\n        /**\r\n         * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\r\n         * For unreachable segments, the code path analysis does not raise events required for this implementation.\r\n         */\n        if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\n          loopsToReport.add(node);\n        }\n      },\n\n      onCodePathSegmentStart(segment, node) {\n        if (isLoopingTarget(node)) {\n          const loop = node.parent;\n          loopsByTargetSegments.set(segment, loop);\n        }\n      },\n\n      onCodePathSegmentLoop(_, toSegment, node) {\n        const loop = loopsByTargetSegments.get(toSegment);\n        /**\r\n         * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\r\n         * only if there is at least one loop event with the appropriate target (which has been already\r\n         * determined in the `loopsByTargetSegments` map), raised from either:\r\n         *\r\n         * - the end of the loop's body (in which case `node === loop`)\r\n         * - a `continue` statement\r\n         *\r\n         * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\r\n         */\n\n        if (node === loop || node.type === \"ContinueStatement\") {\n          // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\n          loopsToReport.delete(loop);\n        }\n      },\n\n      \"Program:exit\"() {\n        loopsToReport.forEach(node => context.report({\n          node,\n          messageId: \"invalid\"\n        }));\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unreachable-loop.js"],"names":["allLoopTypes","isLoopingTarget","node","parent","type","test","body","update","left","getDifference","arrA","arrB","filter","a","includes","module","exports","meta","docs","description","recommended","url","schema","properties","ignore","items","enum","uniqueItems","additionalProperties","messages","invalid","create","context","ignoredLoopTypes","options","loopTypesToCheck","loopSelector","join","loopsByTargetSegments","Map","loopsToReport","Set","currentCodePath","onCodePathStart","codePath","onCodePathEnd","upper","currentSegments","some","segment","reachable","add","onCodePathSegmentStart","loop","set","onCodePathSegmentLoop","_","toSegment","get","delete","forEach","report","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow loops with a body that allows only one iteration\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst allLoopTypes = [\"WhileStatement\", \"DoWhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\"];\r\n\r\n/**\r\n * Determines whether the given node is the first node in the code path to which a loop statement\r\n * 'loops' for the next iteration.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a looping target.\r\n */\r\nfunction isLoopingTarget(node) {\r\n    const parent = node.parent;\r\n\r\n    if (parent) {\r\n        switch (parent.type) {\r\n            case \"WhileStatement\":\r\n                return node === parent.test;\r\n            case \"DoWhileStatement\":\r\n                return node === parent.body;\r\n            case \"ForStatement\":\r\n                return node === (parent.update || parent.test || parent.body);\r\n            case \"ForInStatement\":\r\n            case \"ForOfStatement\":\r\n                return node === parent.left;\r\n\r\n            // no default\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Creates an array with elements from the first given array that are not included in the second given array.\r\n * @param {Array} arrA The array to compare from.\r\n * @param {Array} arrB The array to compare against.\r\n * @returns {Array} a new array that represents `arrA \\ arrB`.\r\n */\r\nfunction getDifference(arrA, arrB) {\r\n    return arrA.filter(a => !arrB.includes(a));\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow loops with a body that allows only one iteration\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-unreachable-loop\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                ignore: {\r\n                    type: \"array\",\r\n                    items: {\r\n                        enum: allLoopTypes\r\n                    },\r\n                    uniqueItems: true\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            invalid: \"Invalid loop. Its body allows only one iteration.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const ignoredLoopTypes = context.options[0] && context.options[0].ignore || [],\r\n            loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes),\r\n            loopSelector = loopTypesToCheck.join(\",\"),\r\n            loopsByTargetSegments = new Map(),\r\n            loopsToReport = new Set();\r\n\r\n        let currentCodePath = null;\r\n\r\n        return {\r\n            onCodePathStart(codePath) {\r\n                currentCodePath = codePath;\r\n            },\r\n\r\n            onCodePathEnd() {\r\n                currentCodePath = currentCodePath.upper;\r\n            },\r\n\r\n            [loopSelector](node) {\r\n\r\n                /**\r\n                 * Ignore unreachable loop statements to avoid unnecessary complexity in the implementation, or false positives otherwise.\r\n                 * For unreachable segments, the code path analysis does not raise events required for this implementation.\r\n                 */\r\n                if (currentCodePath.currentSegments.some(segment => segment.reachable)) {\r\n                    loopsToReport.add(node);\r\n                }\r\n            },\r\n\r\n            onCodePathSegmentStart(segment, node) {\r\n                if (isLoopingTarget(node)) {\r\n                    const loop = node.parent;\r\n\r\n                    loopsByTargetSegments.set(segment, loop);\r\n                }\r\n            },\r\n\r\n            onCodePathSegmentLoop(_, toSegment, node) {\r\n                const loop = loopsByTargetSegments.get(toSegment);\r\n\r\n                /**\r\n                 * The second iteration is reachable, meaning that the loop is valid by the logic of this rule,\r\n                 * only if there is at least one loop event with the appropriate target (which has been already\r\n                 * determined in the `loopsByTargetSegments` map), raised from either:\r\n                 *\r\n                 * - the end of the loop's body (in which case `node === loop`)\r\n                 * - a `continue` statement\r\n                 *\r\n                 * This condition skips loop events raised from `ForInStatement > .right` and `ForOfStatement > .right` nodes.\r\n                 */\r\n                if (node === loop || node.type === \"ContinueStatement\") {\r\n\r\n                    // Removes loop if it exists in the set. Otherwise, `Set#delete` has no effect and doesn't throw.\r\n                    loopsToReport.delete(loop);\r\n                }\r\n            },\r\n\r\n            \"Program:exit\"() {\r\n                loopsToReport.forEach(\r\n                    node => context.report({ node, messageId: \"invalid\" })\r\n                );\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}