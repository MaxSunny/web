{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag statements without curly braces\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent brace style for all control statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/curly\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n        }, {\n          enum: [\"consistent\"]\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      missingCurlyAfter: \"Expected { after '{{name}}'.\",\n      missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\n      unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\n      unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\n    }\n  },\n\n  create(context) {\n    const multiOnly = context.options[0] === \"multi\";\n    const multiLine = context.options[0] === \"multi-line\";\n    const multiOrNest = context.options[0] === \"multi-or-nest\";\n    const consistent = context.options[1] === \"consistent\";\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Determines if a given node is a one-liner that's on the same line as it's preceding code.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\r\n     * @private\r\n     */\n\n    function isCollapsedOneLiner(node) {\n      const before = sourceCode.getTokenBefore(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\r\n     * Determines if a given node is a one-liner.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} True if the node is a one-liner.\r\n     * @private\r\n     */\n\n\n    function isOneLiner(node) {\n      if (node.type === \"EmptyStatement\") {\n        return true;\n      }\n\n      const first = sourceCode.getFirstToken(node);\n      const last = sourceCode.getLastToken(node);\n      const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\n      return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\n    }\n    /**\r\n     * Determines if the given node is a lexical declaration (let, const, function, or class)\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} True if the node is a lexical declaration\r\n     * @private\r\n     */\n\n\n    function isLexicalDeclaration(node) {\n      if (node.type === \"VariableDeclaration\") {\n        return node.kind === \"const\" || node.kind === \"let\";\n      }\n\n      return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\n    }\n    /**\r\n     * Checks if the given token is an `else` token or not.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} `true` if the token is an `else` token.\r\n     */\n\n\n    function isElseKeywordToken(token) {\n      return token.value === \"else\" && token.type === \"Keyword\";\n    }\n    /**\r\n     * Determines whether the given node has an `else` keyword token as the first token after.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node is followed by an `else` keyword token.\r\n     */\n\n\n    function isFollowedByElseKeyword(node) {\n      const nextToken = sourceCode.getTokenAfter(node);\n      return Boolean(nextToken) && isElseKeywordToken(nextToken);\n    }\n    /**\r\n     * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\r\n     * @param {Token} closingBracket The } token\r\n     * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\r\n     */\n\n\n    function needsSemicolon(closingBracket) {\n      const tokenBefore = sourceCode.getTokenBefore(closingBracket);\n      const tokenAfter = sourceCode.getTokenAfter(closingBracket);\n      const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\n\n      if (astUtils.isSemicolonToken(tokenBefore)) {\n        // If the last statement already has a semicolon, don't add another one.\n        return false;\n      }\n\n      if (!tokenAfter) {\n        // If there are no statements after this block, there is no need to add a semicolon.\n        return false;\n      }\n\n      if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\n        /*\r\n         * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\r\n         * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\r\n         * a SyntaxError if it was followed by `else`.\r\n         */\n        return false;\n      }\n\n      if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\n        // If the next token is on the same line, insert a semicolon.\n        return true;\n      }\n\n      if (/^[([/`+-]/u.test(tokenAfter.value)) {\n        // If the next token starts with a character that would disrupt ASI, insert a semicolon.\n        return true;\n      }\n\n      if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\n        // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\n        return true;\n      } // Otherwise, do not insert a semicolon.\n\n\n      return false;\n    }\n    /**\r\n     * Determines whether the code represented by the given node contains an `if` statement\r\n     * that would become associated with an `else` keyword directly appended to that code.\r\n     *\r\n     * Examples where it returns `true`:\r\n     *\r\n     *    if (a)\r\n     *        foo();\r\n     *\r\n     *    if (a) {\r\n     *        foo();\r\n     *    }\r\n     *\r\n     *    if (a)\r\n     *        foo();\r\n     *    else if (b)\r\n     *        bar();\r\n     *\r\n     *    while (a)\r\n     *        if (b)\r\n     *            if(c)\r\n     *                foo();\r\n     *            else\r\n     *                bar();\r\n     *\r\n     * Examples where it returns `false`:\r\n     *\r\n     *    if (a)\r\n     *        foo();\r\n     *    else\r\n     *        bar();\r\n     *\r\n     *    while (a) {\r\n     *        if (b)\r\n     *            if(c)\r\n     *                foo();\r\n     *            else\r\n     *                bar();\r\n     *    }\r\n     *\r\n     *    while (a)\r\n     *        if (b) {\r\n     *            if(c)\r\n     *                foo();\r\n     *        }\r\n     *        else\r\n     *            bar();\r\n     * @param {ASTNode} node Node representing the code to check.\r\n     * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\r\n     */\n\n\n    function hasUnsafeIf(node) {\n      switch (node.type) {\n        case \"IfStatement\":\n          if (!node.alternate) {\n            return true;\n          }\n\n          return hasUnsafeIf(node.alternate);\n\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n        case \"LabeledStatement\":\n        case \"WithStatement\":\n        case \"WhileStatement\":\n          return hasUnsafeIf(node.body);\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\r\n     * The braces, which make the given block body, are necessary in either of the following situations:\r\n     *\r\n     * 1. The statement is a lexical declaration.\r\n     * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\r\n     *\r\n     *     if (a) {\r\n     *         if (b)\r\n     *             foo();\r\n     *     }\r\n     *     else\r\n     *         bar();\r\n     *\r\n     *     if (a)\r\n     *         while (b)\r\n     *             while (c) {\r\n     *                 while (d)\r\n     *                     if (e)\r\n     *                         while(f)\r\n     *                             foo();\r\n     *            }\r\n     *     else\r\n     *         bar();\r\n     * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\r\n     * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\r\n     * would change the semantics of the code or produce a syntax error.\r\n     */\n\n\n    function areBracesNecessary(node) {\n      const statement = node.body[0];\n      return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\n    }\n    /**\r\n     * Prepares to check the body of a node to see if it's a block statement.\r\n     * @param {ASTNode} node The node to report if there's a problem.\r\n     * @param {ASTNode} body The body node to check for blocks.\r\n     * @param {string} name The name to report if there's a problem.\r\n     * @param {{ condition: boolean }} opts Options to pass to the report functions\r\n     * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\r\n     *   \"actual\" will be `true` or `false` whether the body is already a block statement.\r\n     *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\r\n     *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\r\n     *   the final behavior of \"check\".\r\n     *   \"check\" will be a function reporting appropriate problems depending on the other\r\n     *   properties.\r\n     */\n\n\n    function prepareCheck(node, body, name, opts) {\n      const hasBlock = body.type === \"BlockStatement\";\n      let expected = null;\n\n      if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\n        expected = true;\n      } else if (multiOnly) {\n        expected = false;\n      } else if (multiLine) {\n        if (!isCollapsedOneLiner(body)) {\n          expected = true;\n        } // otherwise, the body is allowed to have braces or not to have braces\n\n      } else if (multiOrNest) {\n        if (hasBlock) {\n          const statement = body.body[0];\n          const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\n          expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\n        } else {\n          expected = !isOneLiner(body);\n        }\n      } else {\n        // default \"all\"\n        expected = true;\n      }\n\n      return {\n        actual: hasBlock,\n        expected,\n\n        check() {\n          if (this.expected !== null && this.expected !== this.actual) {\n            if (this.expected) {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\n                data: {\n                  name\n                },\n                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\n              });\n            } else {\n              context.report({\n                node,\n                loc: body.loc,\n                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\n                data: {\n                  name\n                },\n\n                fix(fixer) {\n                  /*\r\n                   * `do while` expressions sometimes need a space to be inserted after `do`.\r\n                   * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\r\n                   */\n                  const needsPrecedingSpace = node.type === \"DoWhileStatement\" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, {\n                    skip: 1\n                  }));\n                  const openingBracket = sourceCode.getFirstToken(body);\n                  const closingBracket = sourceCode.getLastToken(body);\n                  const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\n\n                  if (needsSemicolon(closingBracket)) {\n                    /*\r\n                     * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\r\n                     * change the semantics of the code due to ASI), don't perform a fix.\r\n                     */\n                    return null;\n                  }\n\n                  const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\n                  return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\n                }\n\n              });\n            }\n          }\n        }\n\n      };\n    }\n    /**\r\n     * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\r\n     * @param {ASTNode} node The first IfStatement node of the chain.\r\n     * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\r\n     *   information.\r\n     */\n\n\n    function prepareIfChecks(node) {\n      const preparedChecks = [];\n\n      for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\n        preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", {\n          condition: true\n        }));\n\n        if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\n          preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\n          break;\n        }\n      }\n\n      if (consistent) {\n        /*\r\n         * If any node should have or already have braces, make sure they\r\n         * all have braces.\r\n         * If all nodes shouldn't have braces, make sure they don't.\r\n         */\n        const expected = preparedChecks.some(preparedCheck => {\n          if (preparedCheck.expected !== null) {\n            return preparedCheck.expected;\n          }\n\n          return preparedCheck.actual;\n        });\n        preparedChecks.forEach(preparedCheck => {\n          preparedCheck.expected = expected;\n        });\n      }\n\n      return preparedChecks;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      IfStatement(node) {\n        const parent = node.parent;\n        const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\n\n        if (!isElseIf) {\n          // This is a top `if`, check the whole `if-else-if` chain\n          prepareIfChecks(node).forEach(preparedCheck => {\n            preparedCheck.check();\n          });\n        } // Skip `else if`, it's already checked (when the top `if` was visited)\n\n      },\n\n      WhileStatement(node) {\n        prepareCheck(node, node.body, \"while\", {\n          condition: true\n        }).check();\n      },\n\n      DoWhileStatement(node) {\n        prepareCheck(node, node.body, \"do\").check();\n      },\n\n      ForStatement(node) {\n        prepareCheck(node, node.body, \"for\", {\n          condition: true\n        }).check();\n      },\n\n      ForInStatement(node) {\n        prepareCheck(node, node.body, \"for-in\").check();\n      },\n\n      ForOfStatement(node) {\n        prepareCheck(node, node.body, \"for-of\").check();\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/curly.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","anyOf","items","enum","minItems","maxItems","fixable","messages","missingCurlyAfter","missingCurlyAfterCondition","unexpectedCurlyAfter","unexpectedCurlyAfterCondition","create","context","multiOnly","options","multiLine","multiOrNest","consistent","sourceCode","getSourceCode","isCollapsedOneLiner","node","before","getTokenBefore","last","getLastToken","lastExcludingSemicolon","isSemicolonToken","loc","start","line","end","isOneLiner","first","getFirstToken","isLexicalDeclaration","kind","isElseKeywordToken","token","value","isFollowedByElseKeyword","nextToken","getTokenAfter","Boolean","needsSemicolon","closingBracket","tokenBefore","tokenAfter","lastBlockNode","getNodeByRangeIndex","range","parent","test","hasUnsafeIf","alternate","body","areBracesNecessary","statement","prepareCheck","name","opts","hasBlock","expected","length","leadingCommentsInBlock","getCommentsBefore","actual","check","report","messageId","condition","data","fix","fixer","replaceText","getText","needsPrecedingSpace","canTokensBeAdjacent","skip","openingBracket","lastTokenInBlock","resultingBodyText","slice","prepareIfChecks","preparedChecks","currentNode","push","consequent","some","preparedCheck","forEach","IfStatement","isElseIf","WhileStatement","DoWhileStatement","ForStatement","ForInStatement","ForOfStatement"],"mappings":"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O,WAAW,CAACpD,IAAZ,KAAqB,YAArB,KAAsCoD,WAAW,CAACP,KAAZ,KAAsB,IAAtB,IAA8BO,WAAW,CAACP,KAAZ,KAAsB,IAA1F,CAAJ,EAAqG;AAEjG;AACA,eAAO,IAAP;AACH,OA3CmC,CA6CpC;;;AACA,aAAO,KAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASc,WAAT,CAAqBhC,IAArB,EAA2B;AACvB,cAAQA,IAAI,CAAC3B,IAAb;AACI,aAAK,aAAL;AACI,cAAI,CAAC2B,IAAI,CAACiC,SAAV,EAAqB;AACjB,mBAAO,IAAP;AACH;;AACD,iBAAOD,WAAW,CAAChC,IAAI,CAACiC,SAAN,CAAlB;;AACJ,aAAK,cAAL;AACA,aAAK,gBAAL;AACA,aAAK,gBAAL;AACA,aAAK,kBAAL;AACA,aAAK,eAAL;AACA,aAAK,gBAAL;AACI,iBAAOD,WAAW,CAAChC,IAAI,CAACkC,IAAN,CAAlB;;AACJ;AACI,iBAAO,KAAP;AAdR;AAgBH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASC,kBAAT,CAA4BnC,IAA5B,EAAkC;AAC9B,YAAMoC,SAAS,GAAGpC,IAAI,CAACkC,IAAL,CAAU,CAAV,CAAlB;AAEA,aAAOpB,oBAAoB,CAACsB,SAAD,CAApB,IACHJ,WAAW,CAACI,SAAD,CAAX,IAA0BjB,uBAAuB,CAACnB,IAAD,CADrD;AAEH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASqC,YAAT,CAAsBrC,IAAtB,EAA4BkC,IAA5B,EAAkCI,IAAlC,EAAwCC,IAAxC,EAA8C;AAC1C,YAAMC,QAAQ,GAAIN,IAAI,CAAC7D,IAAL,KAAc,gBAAhC;AACA,UAAIoE,QAAQ,GAAG,IAAf;;AAEA,UAAID,QAAQ,KAAKN,IAAI,CAACA,IAAL,CAAUQ,MAAV,KAAqB,CAArB,IAA0BP,kBAAkB,CAACD,IAAD,CAAjD,CAAZ,EAAsE;AAClEO,QAAAA,QAAQ,GAAG,IAAX;AACH,OAFD,MAEO,IAAIjD,SAAJ,EAAe;AAClBiD,QAAAA,QAAQ,GAAG,KAAX;AACH,OAFM,MAEA,IAAI/C,SAAJ,EAAe;AAClB,YAAI,CAACK,mBAAmB,CAACmC,IAAD,CAAxB,EAAgC;AAC5BO,UAAAA,QAAQ,GAAG,IAAX;AACH,SAHiB,CAKlB;;AAEH,OAPM,MAOA,IAAI9C,WAAJ,EAAiB;AACpB,YAAI6C,QAAJ,EAAc;AACV,gBAAMJ,SAAS,GAAGF,IAAI,CAACA,IAAL,CAAU,CAAV,CAAlB;AACA,gBAAMS,sBAAsB,GAAG9C,UAAU,CAAC+C,iBAAX,CAA6BR,SAA7B,CAA/B;AAEAK,UAAAA,QAAQ,GAAG,CAAC9B,UAAU,CAACyB,SAAD,CAAX,IAA0BO,sBAAsB,CAACD,MAAvB,GAAgC,CAArE;AACH,SALD,MAKO;AACHD,UAAAA,QAAQ,GAAG,CAAC9B,UAAU,CAACuB,IAAD,CAAtB;AACH;AACJ,OATM,MASA;AAEH;AACAO,QAAAA,QAAQ,GAAG,IAAX;AACH;;AAED,aAAO;AACHI,QAAAA,MAAM,EAAEL,QADL;AAEHC,QAAAA,QAFG;;AAGHK,QAAAA,KAAK,GAAG;AACJ,cAAI,KAAKL,QAAL,KAAkB,IAAlB,IAA0B,KAAKA,QAAL,KAAkB,KAAKI,MAArD,EAA6D;AACzD,gBAAI,KAAKJ,QAAT,EAAmB;AACflD,cAAAA,OAAO,CAACwD,MAAR,CAAe;AACX/C,gBAAAA,IADW;AAEXO,gBAAAA,GAAG,EAAE2B,IAAI,CAAC3B,GAFC;AAGXyC,gBAAAA,SAAS,EAAET,IAAI,IAAIA,IAAI,CAACU,SAAb,GAAyB,4BAAzB,GAAwD,mBAHxD;AAIXC,gBAAAA,IAAI,EAAE;AACFZ,kBAAAA;AADE,iBAJK;AAOXa,gBAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBnB,IAAlB,EAAyB,IAAGrC,UAAU,CAACyD,OAAX,CAAmBpB,IAAnB,CAAyB,GAArD;AAPH,eAAf;AASH,aAVD,MAUO;AACH3C,cAAAA,OAAO,CAACwD,MAAR,CAAe;AACX/C,gBAAAA,IADW;AAEXO,gBAAAA,GAAG,EAAE2B,IAAI,CAAC3B,GAFC;AAGXyC,gBAAAA,SAAS,EAAET,IAAI,IAAIA,IAAI,CAACU,SAAb,GAAyB,+BAAzB,GAA2D,sBAH3D;AAIXC,gBAAAA,IAAI,EAAE;AACFZ,kBAAAA;AADE,iBAJK;;AAOXa,gBAAAA,GAAG,CAACC,KAAD,EAAQ;AAEP;AACpC;AACA;AACA;AACoC,wBAAMG,mBAAmB,GAAGvD,IAAI,CAAC3B,IAAL,KAAc,kBAAd,IACxBwB,UAAU,CAACK,cAAX,CAA0BgC,IAA1B,EAAgCL,KAAhC,CAAsC,CAAtC,MAA6CK,IAAI,CAACL,KAAL,CAAW,CAAX,CADrB,IAExB,CAAC7D,QAAQ,CAACwF,mBAAT,CAA6B,IAA7B,EAAmC3D,UAAU,CAACgB,aAAX,CAAyBqB,IAAzB,EAA+B;AAAEuB,oBAAAA,IAAI,EAAE;AAAR,mBAA/B,CAAnC,CAFL;AAIA,wBAAMC,cAAc,GAAG7D,UAAU,CAACgB,aAAX,CAAyBqB,IAAzB,CAAvB;AACA,wBAAMV,cAAc,GAAG3B,UAAU,CAACO,YAAX,CAAwB8B,IAAxB,CAAvB;AACA,wBAAMyB,gBAAgB,GAAG9D,UAAU,CAACK,cAAX,CAA0BsB,cAA1B,CAAzB;;AAEA,sBAAID,cAAc,CAACC,cAAD,CAAlB,EAAoC;AAEhC;AACxC;AACA;AACA;AACwC,2BAAO,IAAP;AACH;;AAED,wBAAMoC,iBAAiB,GAAG/D,UAAU,CAACyD,OAAX,GAAqBO,KAArB,CAA2BH,cAAc,CAAC7B,KAAf,CAAqB,CAArB,CAA3B,EAAoD8B,gBAAgB,CAAC9B,KAAjB,CAAuB,CAAvB,CAApD,IACtBhC,UAAU,CAACyD,OAAX,CAAmBK,gBAAnB,CADsB,GAEtB9D,UAAU,CAACyD,OAAX,GAAqBO,KAArB,CAA2BF,gBAAgB,CAAC9B,KAAjB,CAAuB,CAAvB,CAA3B,EAAsDL,cAAc,CAACK,KAAf,CAAqB,CAArB,CAAtD,CAFJ;AAIA,yBAAOuB,KAAK,CAACC,WAAN,CAAkBnB,IAAlB,EAAwB,CAACqB,mBAAmB,GAAG,GAAH,GAAS,EAA7B,IAAmCK,iBAA3D,CAAP;AACH;;AAnCU,eAAf;AAqCH;AACJ;AACJ;;AAvDE,OAAP;AAyDH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASE,eAAT,CAAyB9D,IAAzB,EAA+B;AAC3B,YAAM+D,cAAc,GAAG,EAAvB;;AAEA,WAAK,IAAIC,WAAW,GAAGhE,IAAvB,EAA6BgE,WAA7B,EAA0CA,WAAW,GAAGA,WAAW,CAAC/B,SAApE,EAA+E;AAC3E8B,QAAAA,cAAc,CAACE,IAAf,CAAoB5B,YAAY,CAAC2B,WAAD,EAAcA,WAAW,CAACE,UAA1B,EAAsC,IAAtC,EAA4C;AAAEjB,UAAAA,SAAS,EAAE;AAAb,SAA5C,CAAhC;;AACA,YAAIe,WAAW,CAAC/B,SAAZ,IAAyB+B,WAAW,CAAC/B,SAAZ,CAAsB5D,IAAtB,KAA+B,aAA5D,EAA2E;AACvE0F,UAAAA,cAAc,CAACE,IAAf,CAAoB5B,YAAY,CAAC2B,WAAD,EAAcA,WAAW,CAAC/B,SAA1B,EAAqC,MAArC,CAAhC;AACA;AACH;AACJ;;AAED,UAAIrC,UAAJ,EAAgB;AAEZ;AAChB;AACA;AACA;AACA;AACgB,cAAM6C,QAAQ,GAAGsB,cAAc,CAACI,IAAf,CAAoBC,aAAa,IAAI;AAClD,cAAIA,aAAa,CAAC3B,QAAd,KAA2B,IAA/B,EAAqC;AACjC,mBAAO2B,aAAa,CAAC3B,QAArB;AACH;;AACD,iBAAO2B,aAAa,CAACvB,MAArB;AACH,SALgB,CAAjB;AAOAkB,QAAAA,cAAc,CAACM,OAAf,CAAuBD,aAAa,IAAI;AACpCA,UAAAA,aAAa,CAAC3B,QAAd,GAAyBA,QAAzB;AACH,SAFD;AAGH;;AAED,aAAOsB,cAAP;AACH,KAzXW,CA2XZ;AACA;AACA;;;AAEA,WAAO;AACHO,MAAAA,WAAW,CAACtE,IAAD,EAAO;AACd,cAAM8B,MAAM,GAAG9B,IAAI,CAAC8B,MAApB;AACA,cAAMyC,QAAQ,GAAGzC,MAAM,CAACzD,IAAP,KAAgB,aAAhB,IAAiCyD,MAAM,CAACG,SAAP,KAAqBjC,IAAvE;;AAEA,YAAI,CAACuE,QAAL,EAAe;AAEX;AACAT,UAAAA,eAAe,CAAC9D,IAAD,CAAf,CAAsBqE,OAAtB,CAA8BD,aAAa,IAAI;AAC3CA,YAAAA,aAAa,CAACtB,KAAd;AACH,WAFD;AAGH,SAVa,CAYd;;AACH,OAdE;;AAgBH0B,MAAAA,cAAc,CAACxE,IAAD,EAAO;AACjBqC,QAAAA,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,OAAlB,EAA2B;AAAEe,UAAAA,SAAS,EAAE;AAAb,SAA3B,CAAZ,CAA4DH,KAA5D;AACH,OAlBE;;AAoBH2B,MAAAA,gBAAgB,CAACzE,IAAD,EAAO;AACnBqC,QAAAA,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,IAAlB,CAAZ,CAAoCY,KAApC;AACH,OAtBE;;AAwBH4B,MAAAA,YAAY,CAAC1E,IAAD,EAAO;AACfqC,QAAAA,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,KAAlB,EAAyB;AAAEe,UAAAA,SAAS,EAAE;AAAb,SAAzB,CAAZ,CAA0DH,KAA1D;AACH,OA1BE;;AA4BH6B,MAAAA,cAAc,CAAC3E,IAAD,EAAO;AACjBqC,QAAAA,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,QAAlB,CAAZ,CAAwCY,KAAxC;AACH,OA9BE;;AAgCH8B,MAAAA,cAAc,CAAC5E,IAAD,EAAO;AACjBqC,QAAAA,YAAY,CAACrC,IAAD,EAAOA,IAAI,CAACkC,IAAZ,EAAkB,QAAlB,CAAZ,CAAwCY,KAAxC;AACH;;AAlCE,KAAP;AAoCH;;AAndY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag statements without curly braces\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent brace style for all control statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/curly\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"all\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 1\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\r\n                        },\r\n                        {\r\n                            enum: [\"consistent\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            missingCurlyAfter: \"Expected { after '{{name}}'.\",\r\n            missingCurlyAfterCondition: \"Expected { after '{{name}}' condition.\",\r\n            unexpectedCurlyAfter: \"Unnecessary { after '{{name}}'.\",\r\n            unexpectedCurlyAfterCondition: \"Unnecessary { after '{{name}}' condition.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const multiOnly = (context.options[0] === \"multi\");\r\n        const multiLine = (context.options[0] === \"multi-line\");\r\n        const multiOrNest = (context.options[0] === \"multi-or-nest\");\r\n        const consistent = (context.options[1] === \"consistent\");\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\r\n         * @private\r\n         */\r\n        function isCollapsedOneLiner(node) {\r\n            const before = sourceCode.getTokenBefore(node);\r\n            const last = sourceCode.getLastToken(node);\r\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\r\n\r\n            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;\r\n        }\r\n\r\n        /**\r\n         * Determines if a given node is a one-liner.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} True if the node is a one-liner.\r\n         * @private\r\n         */\r\n        function isOneLiner(node) {\r\n            if (node.type === \"EmptyStatement\") {\r\n                return true;\r\n            }\r\n\r\n            const first = sourceCode.getFirstToken(node);\r\n            const last = sourceCode.getLastToken(node);\r\n            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;\r\n\r\n            return first.loc.start.line === lastExcludingSemicolon.loc.end.line;\r\n        }\r\n\r\n        /**\r\n         * Determines if the given node is a lexical declaration (let, const, function, or class)\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} True if the node is a lexical declaration\r\n         * @private\r\n         */\r\n        function isLexicalDeclaration(node) {\r\n            if (node.type === \"VariableDeclaration\") {\r\n                return node.kind === \"const\" || node.kind === \"let\";\r\n            }\r\n\r\n            return node.type === \"FunctionDeclaration\" || node.type === \"ClassDeclaration\";\r\n        }\r\n\r\n        /**\r\n         * Checks if the given token is an `else` token or not.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} `true` if the token is an `else` token.\r\n         */\r\n        function isElseKeywordToken(token) {\r\n            return token.value === \"else\" && token.type === \"Keyword\";\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given node has an `else` keyword token as the first token after.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} `true` if the node is followed by an `else` keyword token.\r\n         */\r\n        function isFollowedByElseKeyword(node) {\r\n            const nextToken = sourceCode.getTokenAfter(node);\r\n\r\n            return Boolean(nextToken) && isElseKeywordToken(nextToken);\r\n        }\r\n\r\n        /**\r\n         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.\r\n         * @param {Token} closingBracket The } token\r\n         * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.\r\n         */\r\n        function needsSemicolon(closingBracket) {\r\n            const tokenBefore = sourceCode.getTokenBefore(closingBracket);\r\n            const tokenAfter = sourceCode.getTokenAfter(closingBracket);\r\n            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);\r\n\r\n            if (astUtils.isSemicolonToken(tokenBefore)) {\r\n\r\n                // If the last statement already has a semicolon, don't add another one.\r\n                return false;\r\n            }\r\n\r\n            if (!tokenAfter) {\r\n\r\n                // If there are no statements after this block, there is no need to add a semicolon.\r\n                return false;\r\n            }\r\n\r\n            if (lastBlockNode.type === \"BlockStatement\" && lastBlockNode.parent.type !== \"FunctionExpression\" && lastBlockNode.parent.type !== \"ArrowFunctionExpression\") {\r\n\r\n                /*\r\n                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),\r\n                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause\r\n                 * a SyntaxError if it was followed by `else`.\r\n                 */\r\n                return false;\r\n            }\r\n\r\n            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {\r\n\r\n                // If the next token is on the same line, insert a semicolon.\r\n                return true;\r\n            }\r\n\r\n            if (/^[([/`+-]/u.test(tokenAfter.value)) {\r\n\r\n                // If the next token starts with a character that would disrupt ASI, insert a semicolon.\r\n                return true;\r\n            }\r\n\r\n            if (tokenBefore.type === \"Punctuator\" && (tokenBefore.value === \"++\" || tokenBefore.value === \"--\")) {\r\n\r\n                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.\r\n                return true;\r\n            }\r\n\r\n            // Otherwise, do not insert a semicolon.\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines whether the code represented by the given node contains an `if` statement\r\n         * that would become associated with an `else` keyword directly appended to that code.\r\n         *\r\n         * Examples where it returns `true`:\r\n         *\r\n         *    if (a)\r\n         *        foo();\r\n         *\r\n         *    if (a) {\r\n         *        foo();\r\n         *    }\r\n         *\r\n         *    if (a)\r\n         *        foo();\r\n         *    else if (b)\r\n         *        bar();\r\n         *\r\n         *    while (a)\r\n         *        if (b)\r\n         *            if(c)\r\n         *                foo();\r\n         *            else\r\n         *                bar();\r\n         *\r\n         * Examples where it returns `false`:\r\n         *\r\n         *    if (a)\r\n         *        foo();\r\n         *    else\r\n         *        bar();\r\n         *\r\n         *    while (a) {\r\n         *        if (b)\r\n         *            if(c)\r\n         *                foo();\r\n         *            else\r\n         *                bar();\r\n         *    }\r\n         *\r\n         *    while (a)\r\n         *        if (b) {\r\n         *            if(c)\r\n         *                foo();\r\n         *        }\r\n         *        else\r\n         *            bar();\r\n         * @param {ASTNode} node Node representing the code to check.\r\n         * @returns {boolean} `true` if an `if` statement within the code would become associated with an `else` appended to that code.\r\n         */\r\n        function hasUnsafeIf(node) {\r\n            switch (node.type) {\r\n                case \"IfStatement\":\r\n                    if (!node.alternate) {\r\n                        return true;\r\n                    }\r\n                    return hasUnsafeIf(node.alternate);\r\n                case \"ForStatement\":\r\n                case \"ForInStatement\":\r\n                case \"ForOfStatement\":\r\n                case \"LabeledStatement\":\r\n                case \"WithStatement\":\r\n                case \"WhileStatement\":\r\n                    return hasUnsafeIf(node.body);\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Determines whether the existing curly braces around the single statement are necessary to preserve the semantics of the code.\r\n         * The braces, which make the given block body, are necessary in either of the following situations:\r\n         *\r\n         * 1. The statement is a lexical declaration.\r\n         * 2. Without the braces, an `if` within the statement would become associated with an `else` after the closing brace:\r\n         *\r\n         *     if (a) {\r\n         *         if (b)\r\n         *             foo();\r\n         *     }\r\n         *     else\r\n         *         bar();\r\n         *\r\n         *     if (a)\r\n         *         while (b)\r\n         *             while (c) {\r\n         *                 while (d)\r\n         *                     if (e)\r\n         *                         while(f)\r\n         *                             foo();\r\n         *            }\r\n         *     else\r\n         *         bar();\r\n         * @param {ASTNode} node `BlockStatement` body with exactly one statement directly inside. The statement can have its own nested statements.\r\n         * @returns {boolean} `true` if the braces are necessary - removing them (replacing the given `BlockStatement` body with its single statement content)\r\n         * would change the semantics of the code or produce a syntax error.\r\n         */\r\n        function areBracesNecessary(node) {\r\n            const statement = node.body[0];\r\n\r\n            return isLexicalDeclaration(statement) ||\r\n                hasUnsafeIf(statement) && isFollowedByElseKeyword(node);\r\n        }\r\n\r\n        /**\r\n         * Prepares to check the body of a node to see if it's a block statement.\r\n         * @param {ASTNode} node The node to report if there's a problem.\r\n         * @param {ASTNode} body The body node to check for blocks.\r\n         * @param {string} name The name to report if there's a problem.\r\n         * @param {{ condition: boolean }} opts Options to pass to the report functions\r\n         * @returns {Object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\r\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\r\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\r\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\r\n         *   the final behavior of \"check\".\r\n         *   \"check\" will be a function reporting appropriate problems depending on the other\r\n         *   properties.\r\n         */\r\n        function prepareCheck(node, body, name, opts) {\r\n            const hasBlock = (body.type === \"BlockStatement\");\r\n            let expected = null;\r\n\r\n            if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {\r\n                expected = true;\r\n            } else if (multiOnly) {\r\n                expected = false;\r\n            } else if (multiLine) {\r\n                if (!isCollapsedOneLiner(body)) {\r\n                    expected = true;\r\n                }\r\n\r\n                // otherwise, the body is allowed to have braces or not to have braces\r\n\r\n            } else if (multiOrNest) {\r\n                if (hasBlock) {\r\n                    const statement = body.body[0];\r\n                    const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);\r\n\r\n                    expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;\r\n                } else {\r\n                    expected = !isOneLiner(body);\r\n                }\r\n            } else {\r\n\r\n                // default \"all\"\r\n                expected = true;\r\n            }\r\n\r\n            return {\r\n                actual: hasBlock,\r\n                expected,\r\n                check() {\r\n                    if (this.expected !== null && this.expected !== this.actual) {\r\n                        if (this.expected) {\r\n                            context.report({\r\n                                node,\r\n                                loc: body.loc,\r\n                                messageId: opts && opts.condition ? \"missingCurlyAfterCondition\" : \"missingCurlyAfter\",\r\n                                data: {\r\n                                    name\r\n                                },\r\n                                fix: fixer => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)\r\n                            });\r\n                        } else {\r\n                            context.report({\r\n                                node,\r\n                                loc: body.loc,\r\n                                messageId: opts && opts.condition ? \"unexpectedCurlyAfterCondition\" : \"unexpectedCurlyAfter\",\r\n                                data: {\r\n                                    name\r\n                                },\r\n                                fix(fixer) {\r\n\r\n                                    /*\r\n                                     * `do while` expressions sometimes need a space to be inserted after `do`.\r\n                                     * e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`\r\n                                     */\r\n                                    const needsPrecedingSpace = node.type === \"DoWhileStatement\" &&\r\n                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&\r\n                                        !astUtils.canTokensBeAdjacent(\"do\", sourceCode.getFirstToken(body, { skip: 1 }));\r\n\r\n                                    const openingBracket = sourceCode.getFirstToken(body);\r\n                                    const closingBracket = sourceCode.getLastToken(body);\r\n                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);\r\n\r\n                                    if (needsSemicolon(closingBracket)) {\r\n\r\n                                        /*\r\n                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or\r\n                                         * change the semantics of the code due to ASI), don't perform a fix.\r\n                                         */\r\n                                        return null;\r\n                                    }\r\n\r\n                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +\r\n                                        sourceCode.getText(lastTokenInBlock) +\r\n                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);\r\n\r\n                                    return fixer.replaceText(body, (needsPrecedingSpace ? \" \" : \"\") + resultingBodyText);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\r\n         * @param {ASTNode} node The first IfStatement node of the chain.\r\n         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more\r\n         *   information.\r\n         */\r\n        function prepareIfChecks(node) {\r\n            const preparedChecks = [];\r\n\r\n            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {\r\n                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, \"if\", { condition: true }));\r\n                if (currentNode.alternate && currentNode.alternate.type !== \"IfStatement\") {\r\n                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, \"else\"));\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (consistent) {\r\n\r\n                /*\r\n                 * If any node should have or already have braces, make sure they\r\n                 * all have braces.\r\n                 * If all nodes shouldn't have braces, make sure they don't.\r\n                 */\r\n                const expected = preparedChecks.some(preparedCheck => {\r\n                    if (preparedCheck.expected !== null) {\r\n                        return preparedCheck.expected;\r\n                    }\r\n                    return preparedCheck.actual;\r\n                });\r\n\r\n                preparedChecks.forEach(preparedCheck => {\r\n                    preparedCheck.expected = expected;\r\n                });\r\n            }\r\n\r\n            return preparedChecks;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            IfStatement(node) {\r\n                const parent = node.parent;\r\n                const isElseIf = parent.type === \"IfStatement\" && parent.alternate === node;\r\n\r\n                if (!isElseIf) {\r\n\r\n                    // This is a top `if`, check the whole `if-else-if` chain\r\n                    prepareIfChecks(node).forEach(preparedCheck => {\r\n                        preparedCheck.check();\r\n                    });\r\n                }\r\n\r\n                // Skip `else if`, it's already checked (when the top `if` was visited)\r\n            },\r\n\r\n            WhileStatement(node) {\r\n                prepareCheck(node, node.body, \"while\", { condition: true }).check();\r\n            },\r\n\r\n            DoWhileStatement(node) {\r\n                prepareCheck(node, node.body, \"do\").check();\r\n            },\r\n\r\n            ForStatement(node) {\r\n                prepareCheck(node, node.body, \"for\", { condition: true }).check();\r\n            },\r\n\r\n            ForInStatement(node) {\r\n                prepareCheck(node, node.body, \"for-in\").check();\r\n            },\r\n\r\n            ForOfStatement(node) {\r\n                prepareCheck(node, node.body, \"for-of\").check();\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}