{"ast":null,"code":"/**\r\n * @fileoverview Rule Validator\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst ajv = require(\"../shared/ajv\")();\n\nconst {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n} = require(\"./flat-config-helpers\");\n\nconst ruleReplacements = require(\"../../conf/replacements.json\"); //-----------------------------------------------------------------------------\n// Helpers\n//-----------------------------------------------------------------------------\n\n/**\r\n * Throws a helpful error when a rule cannot be found.\r\n * @param {Object} ruleId The rule identifier.\r\n * @param {string} ruleId.pluginName The ID of the rule to find.\r\n * @param {string} ruleId.ruleName The ID of the rule to find.\r\n * @param {Object} config The config to search in.\r\n * @throws {TypeError} For missing plugin or rule.\r\n * @returns {void}\r\n */\n\n\nfunction throwRuleNotFoundError(_ref, config) {\n  let {\n    pluginName,\n    ruleName\n  } = _ref;\n  const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\n  const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\n  let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`; // if the plugin exists then we need to check if the rule exists\n\n  if (config.plugins && config.plugins[pluginName]) {\n    const replacementRuleName = ruleReplacements.rules[ruleName];\n\n    if (pluginName === \"@\" && replacementRuleName) {\n      errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\n    } else {\n      errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`; // otherwise, let's see if we can find the rule name elsewhere\n\n      for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\n        if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\n          errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\n          break;\n        }\n      }\n    } // falls through to throw error\n\n  }\n\n  throw new TypeError(errorMessage);\n} //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\r\n * Implements validation functionality for the rules portion of a config.\r\n */\n\n\nclass RuleValidator {\n  /**\r\n   * Creates a new instance.\r\n   */\n  constructor() {\n    /**\r\n     * A collection of compiled validators for rules that have already\r\n     * been validated.\r\n     * @type {WeakMap}\r\n     */\n    this.validators = new WeakMap();\n  }\n  /**\r\n   * Validates all of the rule configurations in a config against each\r\n   * rule's schema.\r\n   * @param {Object} config The full config to validate. This object must\r\n   *      contain both the rules section and the plugins section.\r\n   * @returns {void}\r\n   * @throws {Error} If a rule's configuration does not match its schema.\r\n   */\n\n\n  validate(config) {\n    if (!config.rules) {\n      return;\n    }\n\n    for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\n      // check for edge case\n      if (ruleId === \"__proto__\") {\n        continue;\n      }\n      /*\r\n       * If a rule is disabled, we don't do any validation. This allows\r\n       * users to safely set any value to 0 or \"off\" without worrying\r\n       * that it will cause a validation error.\r\n       *\r\n       * Note: ruleOptions is always an array at this point because\r\n       * this validation occurs after FlatConfigArray has merged and\r\n       * normalized values.\r\n       */\n\n\n      if (ruleOptions[0] === 0) {\n        continue;\n      }\n\n      const rule = getRuleFromConfig(ruleId, config);\n\n      if (!rule) {\n        throwRuleNotFoundError(parseRuleId(ruleId), config);\n      } // Precompile and cache validator the first time\n\n\n      if (!this.validators.has(rule)) {\n        const schema = getRuleOptionsSchema(rule);\n\n        if (schema) {\n          this.validators.set(rule, ajv.compile(schema));\n        }\n      }\n\n      const validateRule = this.validators.get(rule);\n\n      if (validateRule) {\n        validateRule(ruleOptions.slice(1));\n\n        if (validateRule.errors) {\n          throw new Error(`Key \"rules\": Key \"${ruleId}\": ${validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\")}`);\n        }\n      }\n    }\n  }\n\n}\n\nexports.RuleValidator = RuleValidator;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/config/rule-validator.js"],"names":["ajv","require","parseRuleId","getRuleFromConfig","getRuleOptionsSchema","ruleReplacements","throwRuleNotFoundError","config","pluginName","ruleName","ruleId","errorMessageHeader","errorMessage","plugins","replacementRuleName","rules","otherPluginName","otherPlugin","Object","entries","TypeError","RuleValidator","constructor","validators","WeakMap","validate","ruleOptions","rule","has","schema","set","compile","validateRule","get","slice","errors","Error","map","error","JSON","stringify","data","message","join","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule Validator\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Requirements\r\n//-----------------------------------------------------------------------------\r\n\r\nconst ajv = require(\"../shared/ajv\")();\r\nconst {\r\n    parseRuleId,\r\n    getRuleFromConfig,\r\n    getRuleOptionsSchema\r\n} = require(\"./flat-config-helpers\");\r\nconst ruleReplacements = require(\"../../conf/replacements.json\");\r\n\r\n//-----------------------------------------------------------------------------\r\n// Helpers\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Throws a helpful error when a rule cannot be found.\r\n * @param {Object} ruleId The rule identifier.\r\n * @param {string} ruleId.pluginName The ID of the rule to find.\r\n * @param {string} ruleId.ruleName The ID of the rule to find.\r\n * @param {Object} config The config to search in.\r\n * @throws {TypeError} For missing plugin or rule.\r\n * @returns {void}\r\n */\r\nfunction throwRuleNotFoundError({ pluginName, ruleName }, config) {\r\n\r\n    const ruleId = pluginName === \"@\" ? ruleName : `${pluginName}/${ruleName}`;\r\n\r\n    const errorMessageHeader = `Key \"rules\": Key \"${ruleId}\"`;\r\n    let errorMessage = `${errorMessageHeader}: Could not find plugin \"${pluginName}\".`;\r\n\r\n    // if the plugin exists then we need to check if the rule exists\r\n    if (config.plugins && config.plugins[pluginName]) {\r\n        const replacementRuleName = ruleReplacements.rules[ruleName];\r\n\r\n        if (pluginName === \"@\" && replacementRuleName) {\r\n\r\n            errorMessage = `${errorMessageHeader}: Rule \"${ruleName}\" was removed and replaced by \"${replacementRuleName}\".`;\r\n\r\n        } else {\r\n\r\n            errorMessage = `${errorMessageHeader}: Could not find \"${ruleName}\" in plugin \"${pluginName}\".`;\r\n\r\n            // otherwise, let's see if we can find the rule name elsewhere\r\n            for (const [otherPluginName, otherPlugin] of Object.entries(config.plugins)) {\r\n                if (otherPlugin.rules && otherPlugin.rules[ruleName]) {\r\n                    errorMessage += ` Did you mean \"${otherPluginName}/${ruleName}\"?`;\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // falls through to throw error\r\n    }\r\n\r\n    throw new TypeError(errorMessage);\r\n}\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Implements validation functionality for the rules portion of a config.\r\n */\r\nclass RuleValidator {\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    constructor() {\r\n\r\n        /**\r\n         * A collection of compiled validators for rules that have already\r\n         * been validated.\r\n         * @type {WeakMap}\r\n         */\r\n        this.validators = new WeakMap();\r\n    }\r\n\r\n    /**\r\n     * Validates all of the rule configurations in a config against each\r\n     * rule's schema.\r\n     * @param {Object} config The full config to validate. This object must\r\n     *      contain both the rules section and the plugins section.\r\n     * @returns {void}\r\n     * @throws {Error} If a rule's configuration does not match its schema.\r\n     */\r\n    validate(config) {\r\n\r\n        if (!config.rules) {\r\n            return;\r\n        }\r\n\r\n        for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {\r\n\r\n            // check for edge case\r\n            if (ruleId === \"__proto__\") {\r\n                continue;\r\n            }\r\n\r\n            /*\r\n             * If a rule is disabled, we don't do any validation. This allows\r\n             * users to safely set any value to 0 or \"off\" without worrying\r\n             * that it will cause a validation error.\r\n             *\r\n             * Note: ruleOptions is always an array at this point because\r\n             * this validation occurs after FlatConfigArray has merged and\r\n             * normalized values.\r\n             */\r\n            if (ruleOptions[0] === 0) {\r\n                continue;\r\n            }\r\n\r\n            const rule = getRuleFromConfig(ruleId, config);\r\n\r\n            if (!rule) {\r\n                throwRuleNotFoundError(parseRuleId(ruleId), config);\r\n            }\r\n\r\n            // Precompile and cache validator the first time\r\n            if (!this.validators.has(rule)) {\r\n                const schema = getRuleOptionsSchema(rule);\r\n\r\n                if (schema) {\r\n                    this.validators.set(rule, ajv.compile(schema));\r\n                }\r\n            }\r\n\r\n            const validateRule = this.validators.get(rule);\r\n\r\n            if (validateRule) {\r\n\r\n                validateRule(ruleOptions.slice(1));\r\n\r\n                if (validateRule.errors) {\r\n                    throw new Error(`Key \"rules\": Key \"${ruleId}\": ${\r\n                        validateRule.errors.map(\r\n                            error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\r\n                        ).join(\"\")\r\n                    }`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexports.RuleValidator = RuleValidator;\r\n"]},"metadata":{},"sourceType":"script"}