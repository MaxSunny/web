{"ast":null,"code":"/**\r\n * @fileoverview Rule to check for the usage of var.\r\n * @author Jamund Ferguson\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Check whether a given variable is a global variable or not.\r\n * @param {eslint-scope.Variable} variable The variable to check.\r\n * @returns {boolean} `true` if the variable is a global variable.\r\n */\n\n\nfunction isGlobal(variable) {\n  return Boolean(variable.scope) && variable.scope.type === \"global\";\n}\n/**\r\n * Finds the nearest function scope or global scope walking up the scope\r\n * hierarchy.\r\n * @param {eslint-scope.Scope} scope The scope to traverse.\r\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\r\n *      scope.\r\n */\n\n\nfunction getEnclosingFunctionScope(scope) {\n  let currentScope = scope;\n\n  while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\n    currentScope = currentScope.upper;\n  }\n\n  return currentScope;\n}\n/**\r\n * Checks whether the given variable has any references from a more specific\r\n * function expression (i.e. a closure).\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is used from a closure.\r\n */\n\n\nfunction isReferencedInClosure(variable) {\n  const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\n  return variable.references.some(reference => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\n}\n/**\r\n * Checks whether the given node is the assignee of a loop.\r\n * @param {ASTNode} node A VariableDeclaration node to check.\r\n * @returns {boolean} `true` if the declaration is assigned as part of loop\r\n *      iteration.\r\n */\n\n\nfunction isLoopAssignee(node) {\n  return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") && node === node.parent.left;\n}\n/**\r\n * Checks whether the given variable declaration is immediately initialized.\r\n * @param {ASTNode} node A VariableDeclaration node to check.\r\n * @returns {boolean} `true` if the declaration has an initializer.\r\n */\n\n\nfunction isDeclarationInitialized(node) {\n  return node.declarations.every(declarator => declarator.init !== null);\n}\n\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\n/**\r\n * Gets the scope node which directly contains a given node.\r\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\r\n *      an `Identifier`.\r\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\r\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\r\n *      `ForOfStatement`.\r\n */\n\nfunction getScopeNode(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (SCOPE_NODE_TYPE.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n  /* istanbul ignore next : unreachable */\n\n\n  return null;\n}\n/**\r\n * Checks whether a given variable is redeclared or not.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is redeclared.\r\n */\n\n\nfunction isRedeclared(variable) {\n  return variable.defs.length >= 2;\n}\n/**\r\n * Checks whether a given variable is used from outside of the specified scope.\r\n * @param {ASTNode} scopeNode A scope node to check.\r\n * @returns {Function} The predicate function which checks whether a given\r\n *      variable is used from outside of the specified scope.\r\n */\n\n\nfunction isUsedFromOutsideOf(scopeNode) {\n  /**\r\n   * Checks whether a given reference is inside of the specified scope or not.\r\n   * @param {eslint-scope.Reference} reference A reference to check.\r\n   * @returns {boolean} `true` if the reference is inside of the specified\r\n   *      scope.\r\n   */\n  function isOutsideOfScope(reference) {\n    const scope = scopeNode.range;\n    const id = reference.identifier.range;\n    return id[0] < scope[0] || id[1] > scope[1];\n  }\n\n  return function (variable) {\n    return variable.references.some(isOutsideOfScope);\n  };\n}\n/**\r\n * Creates the predicate function which checks whether a variable has their references in TDZ.\r\n *\r\n * The predicate function would return `true`:\r\n *\r\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\r\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\r\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\r\n * @param {ASTNode} node The initializer node of VariableDeclarator.\r\n * @returns {Function} The predicate function.\r\n * @private\r\n */\n\n\nfunction hasReferenceInTDZ(node) {\n  const initStart = node.range[0];\n  const initEnd = node.range[1];\n  return variable => {\n    const id = variable.defs[0].name;\n    const idStart = id.range[0];\n    const defaultValue = id.parent.type === \"AssignmentPattern\" ? id.parent.right : null;\n    const defaultStart = defaultValue && defaultValue.range[0];\n    const defaultEnd = defaultValue && defaultValue.range[1];\n    return variable.references.some(reference => {\n      const start = reference.identifier.range[0];\n      const end = reference.identifier.range[1];\n      return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);\n    });\n  };\n}\n/**\r\n * Checks whether a given variable has name that is allowed for 'var' declarations,\r\n * but disallowed for `let` declarations.\r\n * @param {eslint-scope.Variable} variable The variable to check.\r\n * @returns {boolean} `true` if the variable has a disallowed name.\r\n */\n\n\nfunction hasNameDisallowedForLetDeclarations(variable) {\n  return variable.name === \"let\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `let` or `const` instead of `var`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-var\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedVar: \"Unexpected var, use let or const instead.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\r\n     * @param {ASTNode} declarator The VariableDeclarator node to check.\r\n     * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\r\n     */\n\n    function hasSelfReferenceInTDZ(declarator) {\n      if (!declarator.init) {\n        return false;\n      }\n\n      const variables = context.getDeclaredVariables(declarator);\n      return variables.some(hasReferenceInTDZ(declarator.init));\n    }\n    /**\r\n     * Checks whether it can fix a given variable declaration or not.\r\n     * It cannot fix if the following cases:\r\n     *\r\n     * - A variable is a global variable.\r\n     * - A variable is declared on a SwitchCase node.\r\n     * - A variable is redeclared.\r\n     * - A variable is used from outside the scope.\r\n     * - A variable is used from a closure within a loop.\r\n     * - A variable might be used before it is assigned within a loop.\r\n     * - A variable might be used in TDZ.\r\n     * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\r\n     * - A variable has name that is disallowed for `let` declarations.\r\n     *\r\n     * ## A variable is declared on a SwitchCase node.\r\n     *\r\n     * If this rule modifies 'var' declarations on a SwitchCase node, it\r\n     * would generate the warnings of 'no-case-declarations' rule. And the\r\n     * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\r\n     * this rule doesn't modify those declarations.\r\n     *\r\n     * ## A variable is redeclared.\r\n     *\r\n     * The language spec disallows redeclarations of `let` declarations.\r\n     * Those variables would cause syntax errors.\r\n     *\r\n     * ## A variable is used from outside the scope.\r\n     *\r\n     * The language spec disallows accesses from outside of the scope for\r\n     * `let` declarations. Those variables would cause reference errors.\r\n     *\r\n     * ## A variable is used from a closure within a loop.\r\n     *\r\n     * A `var` declaration within a loop shares the same variable instance\r\n     * across all loop iterations, while a `let` declaration creates a new\r\n     * instance for each iteration. This means if a variable in a loop is\r\n     * referenced by any closure, changing it from `var` to `let` would\r\n     * change the behavior in a way that is generally unsafe.\r\n     *\r\n     * ## A variable might be used before it is assigned within a loop.\r\n     *\r\n     * Within a loop, a `let` declaration without an initializer will be\r\n     * initialized to null, while a `var` declaration will retain its value\r\n     * from the previous iteration, so it is only safe to change `var` to\r\n     * `let` if we can statically determine that the variable is always\r\n     * assigned a value before its first access in the loop body. To keep\r\n     * the implementation simple, we only convert `var` to `let` within\r\n     * loops when the variable is a loop assignee or the declaration has an\r\n     * initializer.\r\n     * @param {ASTNode} node A variable declaration node to check.\r\n     * @returns {boolean} `true` if it can fix the node.\r\n     */\n\n\n    function canFix(node) {\n      const variables = context.getDeclaredVariables(node);\n      const scopeNode = getScopeNode(node);\n\n      if (node.parent.type === \"SwitchCase\" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {\n        return false;\n      }\n\n      if (astUtils.isInLoop(node)) {\n        if (variables.some(isReferencedInClosure)) {\n          return false;\n        }\n\n        if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\n          return false;\n        }\n      }\n\n      if (!isLoopAssignee(node) && !(node.parent.type === \"ForStatement\" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n        // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Reports a given variable declaration node.\r\n     * @param {ASTNode} node A variable declaration node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"unexpectedVar\",\n\n        fix(fixer) {\n          const varToken = sourceCode.getFirstToken(node, {\n            filter: t => t.value === \"var\"\n          });\n          return canFix(node) ? fixer.replaceText(varToken, \"let\") : null;\n        }\n\n      });\n    }\n\n    return {\n      \"VariableDeclaration:exit\"(node) {\n        if (node.kind === \"var\") {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-var.js"],"names":["astUtils","require","isGlobal","variable","Boolean","scope","type","getEnclosingFunctionScope","currentScope","upper","isReferencedInClosure","enclosingFunctionScope","references","some","reference","from","isLoopAssignee","node","parent","left","isDeclarationInitialized","declarations","every","declarator","init","SCOPE_NODE_TYPE","getScopeNode","currentNode","test","isRedeclared","defs","length","isUsedFromOutsideOf","scopeNode","isOutsideOfScope","range","id","identifier","hasReferenceInTDZ","initStart","initEnd","name","idStart","defaultValue","right","defaultStart","defaultEnd","start","end","hasNameDisallowedForLetDeclarations","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","unexpectedVar","create","context","sourceCode","getSourceCode","hasSelfReferenceInTDZ","variables","getDeclaredVariables","canFix","isInLoop","STATEMENT_LIST_PARENTS","has","report","messageId","fix","fixer","varToken","getFirstToken","filter","t","value","replaceText","kind"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check for the usage of var.\r\n * @author Jamund Ferguson\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Check whether a given variable is a global variable or not.\r\n * @param {eslint-scope.Variable} variable The variable to check.\r\n * @returns {boolean} `true` if the variable is a global variable.\r\n */\r\nfunction isGlobal(variable) {\r\n    return Boolean(variable.scope) && variable.scope.type === \"global\";\r\n}\r\n\r\n/**\r\n * Finds the nearest function scope or global scope walking up the scope\r\n * hierarchy.\r\n * @param {eslint-scope.Scope} scope The scope to traverse.\r\n * @returns {eslint-scope.Scope} a function scope or global scope containing the given\r\n *      scope.\r\n */\r\nfunction getEnclosingFunctionScope(scope) {\r\n    let currentScope = scope;\r\n\r\n    while (currentScope.type !== \"function\" && currentScope.type !== \"global\") {\r\n        currentScope = currentScope.upper;\r\n    }\r\n    return currentScope;\r\n}\r\n\r\n/**\r\n * Checks whether the given variable has any references from a more specific\r\n * function expression (i.e. a closure).\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is used from a closure.\r\n */\r\nfunction isReferencedInClosure(variable) {\r\n    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);\r\n\r\n    return variable.references.some(reference =>\r\n        getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);\r\n}\r\n\r\n/**\r\n * Checks whether the given node is the assignee of a loop.\r\n * @param {ASTNode} node A VariableDeclaration node to check.\r\n * @returns {boolean} `true` if the declaration is assigned as part of loop\r\n *      iteration.\r\n */\r\nfunction isLoopAssignee(node) {\r\n    return (node.parent.type === \"ForOfStatement\" || node.parent.type === \"ForInStatement\") &&\r\n        node === node.parent.left;\r\n}\r\n\r\n/**\r\n * Checks whether the given variable declaration is immediately initialized.\r\n * @param {ASTNode} node A VariableDeclaration node to check.\r\n * @returns {boolean} `true` if the declaration has an initializer.\r\n */\r\nfunction isDeclarationInitialized(node) {\r\n    return node.declarations.every(declarator => declarator.init !== null);\r\n}\r\n\r\nconst SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;\r\n\r\n/**\r\n * Gets the scope node which directly contains a given node.\r\n * @param {ASTNode} node A node to get. This is a `VariableDeclaration` or\r\n *      an `Identifier`.\r\n * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,\r\n *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and\r\n *      `ForOfStatement`.\r\n */\r\nfunction getScopeNode(node) {\r\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\r\n        if (SCOPE_NODE_TYPE.test(currentNode.type)) {\r\n            return currentNode;\r\n        }\r\n    }\r\n\r\n    /* istanbul ignore next : unreachable */\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks whether a given variable is redeclared or not.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is redeclared.\r\n */\r\nfunction isRedeclared(variable) {\r\n    return variable.defs.length >= 2;\r\n}\r\n\r\n/**\r\n * Checks whether a given variable is used from outside of the specified scope.\r\n * @param {ASTNode} scopeNode A scope node to check.\r\n * @returns {Function} The predicate function which checks whether a given\r\n *      variable is used from outside of the specified scope.\r\n */\r\nfunction isUsedFromOutsideOf(scopeNode) {\r\n\r\n    /**\r\n     * Checks whether a given reference is inside of the specified scope or not.\r\n     * @param {eslint-scope.Reference} reference A reference to check.\r\n     * @returns {boolean} `true` if the reference is inside of the specified\r\n     *      scope.\r\n     */\r\n    function isOutsideOfScope(reference) {\r\n        const scope = scopeNode.range;\r\n        const id = reference.identifier.range;\r\n\r\n        return id[0] < scope[0] || id[1] > scope[1];\r\n    }\r\n\r\n    return function(variable) {\r\n        return variable.references.some(isOutsideOfScope);\r\n    };\r\n}\r\n\r\n/**\r\n * Creates the predicate function which checks whether a variable has their references in TDZ.\r\n *\r\n * The predicate function would return `true`:\r\n *\r\n * - if a reference is before the declarator. E.g. (var a = b, b = 1;)(var {a = b, b} = {};)\r\n * - if a reference is in the expression of their default value.  E.g. (var {a = a} = {};)\r\n * - if a reference is in the expression of their initializer.  E.g. (var a = a;)\r\n * @param {ASTNode} node The initializer node of VariableDeclarator.\r\n * @returns {Function} The predicate function.\r\n * @private\r\n */\r\nfunction hasReferenceInTDZ(node) {\r\n    const initStart = node.range[0];\r\n    const initEnd = node.range[1];\r\n\r\n    return variable => {\r\n        const id = variable.defs[0].name;\r\n        const idStart = id.range[0];\r\n        const defaultValue = (id.parent.type === \"AssignmentPattern\" ? id.parent.right : null);\r\n        const defaultStart = defaultValue && defaultValue.range[0];\r\n        const defaultEnd = defaultValue && defaultValue.range[1];\r\n\r\n        return variable.references.some(reference => {\r\n            const start = reference.identifier.range[0];\r\n            const end = reference.identifier.range[1];\r\n\r\n            return !reference.init && (\r\n                start < idStart ||\r\n                (defaultValue !== null && start >= defaultStart && end <= defaultEnd) ||\r\n                (start >= initStart && end <= initEnd)\r\n            );\r\n        });\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether a given variable has name that is allowed for 'var' declarations,\r\n * but disallowed for `let` declarations.\r\n * @param {eslint-scope.Variable} variable The variable to check.\r\n * @returns {boolean} `true` if the variable has a disallowed name.\r\n */\r\nfunction hasNameDisallowedForLetDeclarations(variable) {\r\n    return variable.name === \"let\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require `let` or `const` instead of `var`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-var\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpectedVar: \"Unexpected var, use let or const instead.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Checks whether the variables which are defined by the given declarator node have their references in TDZ.\r\n         * @param {ASTNode} declarator The VariableDeclarator node to check.\r\n         * @returns {boolean} `true` if one of the variables which are defined by the given declarator node have their references in TDZ.\r\n         */\r\n        function hasSelfReferenceInTDZ(declarator) {\r\n            if (!declarator.init) {\r\n                return false;\r\n            }\r\n            const variables = context.getDeclaredVariables(declarator);\r\n\r\n            return variables.some(hasReferenceInTDZ(declarator.init));\r\n        }\r\n\r\n        /**\r\n         * Checks whether it can fix a given variable declaration or not.\r\n         * It cannot fix if the following cases:\r\n         *\r\n         * - A variable is a global variable.\r\n         * - A variable is declared on a SwitchCase node.\r\n         * - A variable is redeclared.\r\n         * - A variable is used from outside the scope.\r\n         * - A variable is used from a closure within a loop.\r\n         * - A variable might be used before it is assigned within a loop.\r\n         * - A variable might be used in TDZ.\r\n         * - A variable is declared in statement position (e.g. a single-line `IfStatement`)\r\n         * - A variable has name that is disallowed for `let` declarations.\r\n         *\r\n         * ## A variable is declared on a SwitchCase node.\r\n         *\r\n         * If this rule modifies 'var' declarations on a SwitchCase node, it\r\n         * would generate the warnings of 'no-case-declarations' rule. And the\r\n         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so\r\n         * this rule doesn't modify those declarations.\r\n         *\r\n         * ## A variable is redeclared.\r\n         *\r\n         * The language spec disallows redeclarations of `let` declarations.\r\n         * Those variables would cause syntax errors.\r\n         *\r\n         * ## A variable is used from outside the scope.\r\n         *\r\n         * The language spec disallows accesses from outside of the scope for\r\n         * `let` declarations. Those variables would cause reference errors.\r\n         *\r\n         * ## A variable is used from a closure within a loop.\r\n         *\r\n         * A `var` declaration within a loop shares the same variable instance\r\n         * across all loop iterations, while a `let` declaration creates a new\r\n         * instance for each iteration. This means if a variable in a loop is\r\n         * referenced by any closure, changing it from `var` to `let` would\r\n         * change the behavior in a way that is generally unsafe.\r\n         *\r\n         * ## A variable might be used before it is assigned within a loop.\r\n         *\r\n         * Within a loop, a `let` declaration without an initializer will be\r\n         * initialized to null, while a `var` declaration will retain its value\r\n         * from the previous iteration, so it is only safe to change `var` to\r\n         * `let` if we can statically determine that the variable is always\r\n         * assigned a value before its first access in the loop body. To keep\r\n         * the implementation simple, we only convert `var` to `let` within\r\n         * loops when the variable is a loop assignee or the declaration has an\r\n         * initializer.\r\n         * @param {ASTNode} node A variable declaration node to check.\r\n         * @returns {boolean} `true` if it can fix the node.\r\n         */\r\n        function canFix(node) {\r\n            const variables = context.getDeclaredVariables(node);\r\n            const scopeNode = getScopeNode(node);\r\n\r\n            if (node.parent.type === \"SwitchCase\" ||\r\n                node.declarations.some(hasSelfReferenceInTDZ) ||\r\n                variables.some(isGlobal) ||\r\n                variables.some(isRedeclared) ||\r\n                variables.some(isUsedFromOutsideOf(scopeNode)) ||\r\n                variables.some(hasNameDisallowedForLetDeclarations)\r\n            ) {\r\n                return false;\r\n            }\r\n\r\n            if (astUtils.isInLoop(node)) {\r\n                if (variables.some(isReferencedInClosure)) {\r\n                    return false;\r\n                }\r\n                if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            if (\r\n                !isLoopAssignee(node) &&\r\n                !(node.parent.type === \"ForStatement\" && node.parent.init === node) &&\r\n                !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)\r\n            ) {\r\n\r\n                // If the declaration is not in a block, e.g. `if (foo) var bar = 1;`, then it can't be fixed.\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Reports a given variable declaration node.\r\n         * @param {ASTNode} node A variable declaration node to report.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"unexpectedVar\",\r\n\r\n                fix(fixer) {\r\n                    const varToken = sourceCode.getFirstToken(node, { filter: t => t.value === \"var\" });\r\n\r\n                    return canFix(node)\r\n                        ? fixer.replaceText(varToken, \"let\")\r\n                        : null;\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            \"VariableDeclaration:exit\"(node) {\r\n                if (node.kind === \"var\") {\r\n                    report(node);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}