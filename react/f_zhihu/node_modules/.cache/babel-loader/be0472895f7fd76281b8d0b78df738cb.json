{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce a single linebreak style.\r\n * @author Erik Mueller\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/linebreak-style\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"unix\", \"windows\"]\n    }],\n    messages: {\n      expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\n      expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Builds a fix function that replaces text at the specified range in the source text.\r\n     * @param {int[]} range The range to replace\r\n     * @param {string} text The text to insert.\r\n     * @returns {Function} Fixer function\r\n     * @private\r\n     */\n\n    function createFix(range, text) {\n      return function (fixer) {\n        return fixer.replaceTextRange(range, text);\n      };\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: function checkForLinebreakStyle(node) {\n        const linebreakStyle = context.options[0] || \"unix\",\n              expectedLF = linebreakStyle === \"unix\",\n              expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\n              source = sourceCode.getText(),\n              pattern = astUtils.createGlobalLinebreakMatcher();\n        let match;\n        let i = 0;\n\n        while ((match = pattern.exec(source)) !== null) {\n          i++;\n\n          if (match[0] === expectedLFChars) {\n            continue;\n          }\n\n          const index = match.index;\n          const range = [index, index + match[0].length];\n          context.report({\n            node,\n            loc: {\n              start: {\n                line: i,\n                column: sourceCode.lines[i - 1].length\n              },\n              end: {\n                line: i + 1,\n                column: 0\n              }\n            },\n            messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\n            fix: createFix(range, expectedLFChars)\n          });\n        }\n      }\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/linebreak-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","messages","expectedLF","expectedCRLF","create","context","sourceCode","getSourceCode","createFix","range","text","fixer","replaceTextRange","Program","checkForLinebreakStyle","node","linebreakStyle","options","expectedLFChars","source","getText","pattern","createGlobalLinebreakMatcher","match","i","exec","index","length","report","loc","start","line","column","lines","end","messageId","fix"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,oCADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,OAAO,EAAE,YATP;AAWFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,MAAD,EAAS,SAAT;AADV,KADI,CAXN;AAgBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE,kDADN;AAENC,MAAAA,YAAY,EAAE;AAFR;AAhBR,GADO;;AAuBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB,CADY,CAGZ;AACA;AACA;;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;;AACQ,aAASC,SAAT,CAAmBC,KAAnB,EAA0BC,IAA1B,EAAgC;AAC5B,aAAO,UAASC,KAAT,EAAgB;AACnB,eAAOA,KAAK,CAACC,gBAAN,CAAuBH,KAAvB,EAA8BC,IAA9B,CAAP;AACH,OAFD;AAGH,KAlBW,CAoBZ;AACA;AACA;;;AAEA,WAAO;AACHG,MAAAA,OAAO,EAAE,SAASC,sBAAT,CAAgCC,IAAhC,EAAsC;AAC3C,cAAMC,cAAc,GAAGX,OAAO,CAACY,OAAR,CAAgB,CAAhB,KAAsB,MAA7C;AAAA,cACIf,UAAU,GAAGc,cAAc,KAAK,MADpC;AAAA,cAEIE,eAAe,GAAGhB,UAAU,GAAG,IAAH,GAAU,MAF1C;AAAA,cAGIiB,MAAM,GAAGb,UAAU,CAACc,OAAX,EAHb;AAAA,cAIIC,OAAO,GAAGjC,QAAQ,CAACkC,4BAAT,EAJd;AAKA,YAAIC,KAAJ;AAEA,YAAIC,CAAC,GAAG,CAAR;;AAEA,eAAO,CAACD,KAAK,GAAGF,OAAO,CAACI,IAAR,CAAaN,MAAb,CAAT,MAAmC,IAA1C,EAAgD;AAC5CK,UAAAA,CAAC;;AACD,cAAID,KAAK,CAAC,CAAD,CAAL,KAAaL,eAAjB,EAAkC;AAC9B;AACH;;AAED,gBAAMQ,KAAK,GAAGH,KAAK,CAACG,KAApB;AACA,gBAAMjB,KAAK,GAAG,CAACiB,KAAD,EAAQA,KAAK,GAAGH,KAAK,CAAC,CAAD,CAAL,CAASI,MAAzB,CAAd;AAEAtB,UAAAA,OAAO,CAACuB,MAAR,CAAe;AACXb,YAAAA,IADW;AAEXc,YAAAA,GAAG,EAAE;AACDC,cAAAA,KAAK,EAAE;AACHC,gBAAAA,IAAI,EAAEP,CADH;AAEHQ,gBAAAA,MAAM,EAAE1B,UAAU,CAAC2B,KAAX,CAAiBT,CAAC,GAAG,CAArB,EAAwBG;AAF7B,eADN;AAKDO,cAAAA,GAAG,EAAE;AACDH,gBAAAA,IAAI,EAAEP,CAAC,GAAG,CADT;AAEDQ,gBAAAA,MAAM,EAAE;AAFP;AALJ,aAFM;AAYXG,YAAAA,SAAS,EAAEjC,UAAU,GAAG,YAAH,GAAkB,cAZ5B;AAaXkC,YAAAA,GAAG,EAAE5B,SAAS,CAACC,KAAD,EAAQS,eAAR;AAbH,WAAf;AAeH;AACJ;AApCE,KAAP;AAsCH;;AArFY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to enforce a single linebreak style.\r\n * @author Erik Mueller\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent linebreak style\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/linebreak-style\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"unix\", \"windows\"]\r\n            }\r\n        ],\r\n        messages: {\r\n            expectedLF: \"Expected linebreaks to be 'LF' but found 'CRLF'.\",\r\n            expectedCRLF: \"Expected linebreaks to be 'CRLF' but found 'LF'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Builds a fix function that replaces text at the specified range in the source text.\r\n         * @param {int[]} range The range to replace\r\n         * @param {string} text The text to insert.\r\n         * @returns {Function} Fixer function\r\n         * @private\r\n         */\r\n        function createFix(range, text) {\r\n            return function(fixer) {\r\n                return fixer.replaceTextRange(range, text);\r\n            };\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: function checkForLinebreakStyle(node) {\r\n                const linebreakStyle = context.options[0] || \"unix\",\r\n                    expectedLF = linebreakStyle === \"unix\",\r\n                    expectedLFChars = expectedLF ? \"\\n\" : \"\\r\\n\",\r\n                    source = sourceCode.getText(),\r\n                    pattern = astUtils.createGlobalLinebreakMatcher();\r\n                let match;\r\n\r\n                let i = 0;\r\n\r\n                while ((match = pattern.exec(source)) !== null) {\r\n                    i++;\r\n                    if (match[0] === expectedLFChars) {\r\n                        continue;\r\n                    }\r\n\r\n                    const index = match.index;\r\n                    const range = [index, index + match[0].length];\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            start: {\r\n                                line: i,\r\n                                column: sourceCode.lines[i - 1].length\r\n                            },\r\n                            end: {\r\n                                line: i + 1,\r\n                                column: 0\r\n                            }\r\n                        },\r\n                        messageId: expectedLF ? \"expectedLF\" : \"expectedCRLF\",\r\n                        fix: createFix(range, expectedLFChars)\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}