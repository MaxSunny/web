{"ast":null,"code":"/**\r\n * @fileoverview Rule to check empty newline between class members\r\n * @author 薛定谔的猫<hh_2013@foxmail.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line between class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-between-class-members\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptAfterSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      never: \"Unexpected blank line between class members.\",\n      always: \"Expected blank line between class members.\"\n    }\n  },\n\n  create(context) {\n    const options = [];\n    options[0] = context.options[0] || \"always\";\n    options[1] = context.options[1] || {\n      exceptAfterSingleLine: false\n    };\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Gets a pair of tokens that should be used to check lines between two class member nodes.\r\n     *\r\n     * In most cases, this returns the very last token of the current node and\r\n     * the very first token of the next node.\r\n     * For example:\r\n     *\r\n     *     class C {\r\n     *         x = 1;   // curLast: `;` nextFirst: `in`\r\n     *         in = 2\r\n     *     }\r\n     *\r\n     * There is only one exception. If the given node ends with a semicolon, and it looks like\r\n     * a semicolon-less style's semicolon - one that is not on the same line as the preceding\r\n     * token, but is on the line where the next class member starts - this returns the preceding\r\n     * token and the semicolon as boundary tokens.\r\n     * For example:\r\n     *\r\n     *     class C {\r\n     *         x = 1    // curLast: `1` nextFirst: `;`\r\n     *         ;in = 2\r\n     *     }\r\n     * When determining the desired layout of the code, we should treat this semicolon as\r\n     * a part of the next class member node instead of the one it technically belongs to.\r\n     * @param {ASTNode} curNode Current class member node.\r\n     * @param {ASTNode} nextNode Next class member node.\r\n     * @returns {Token} The actual last token of `node`.\r\n     * @private\r\n     */\n\n    function getBoundaryTokens(curNode, nextNode) {\n      const lastToken = sourceCode.getLastToken(curNode);\n      const prevToken = sourceCode.getTokenBefore(lastToken);\n      const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\n\n      const isSemicolonLessStyle = astUtils.isSemicolonToken(lastToken) && !astUtils.isTokenOnSameLine(prevToken, lastToken) && astUtils.isTokenOnSameLine(lastToken, nextToken);\n      return isSemicolonLessStyle ? {\n        curLast: prevToken,\n        nextFirst: lastToken\n      } : {\n        curLast: lastToken,\n        nextFirst: nextToken\n      };\n    }\n    /**\r\n     * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\r\n     * @param {Token} prevLastToken The last token in the previous member node.\r\n     * @param {Token} nextFirstToken The first token in the next member node.\r\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\r\n     * @returns {Token} The last token among the consecutive tokens.\r\n     */\n\n\n    function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\n      const after = sourceCode.getTokenAfter(prevLastToken, {\n        includeComments: true\n      });\n\n      if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\n        return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\n      }\n\n      return prevLastToken;\n    }\n    /**\r\n     * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\r\n     * @param {Token} nextFirstToken The first token in the next member node.\r\n     * @param {Token} prevLastToken The last token in the previous member node.\r\n     * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\r\n     * @returns {Token} The first token among the consecutive tokens.\r\n     */\n\n\n    function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\n      const before = sourceCode.getTokenBefore(nextFirstToken, {\n        includeComments: true\n      });\n\n      if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\n        return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\n      }\n\n      return nextFirstToken;\n    }\n    /**\r\n     * Checks if there is a token or comment between two tokens.\r\n     * @param {Token} before The token before.\r\n     * @param {Token} after The token after.\r\n     * @returns {boolean} True if there is a token or comment between two tokens.\r\n     */\n\n\n    function hasTokenOrCommentBetween(before, after) {\n      return sourceCode.getTokensBetween(before, after, {\n        includeComments: true\n      }).length !== 0;\n    }\n\n    return {\n      ClassBody(node) {\n        const body = node.body;\n\n        for (let i = 0; i < body.length - 1; i++) {\n          const curFirst = sourceCode.getFirstToken(body[i]);\n          const {\n            curLast,\n            nextFirst\n          } = getBoundaryTokens(body[i], body[i + 1]);\n          const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\n          const skip = !isMulti && options[1].exceptAfterSingleLine;\n          const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\n          const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\n          const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\n          const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\n          const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\n\n          if (options[0] === \"always\" && !skip && !isPadded || options[0] === \"never\" && isPadded) {\n            context.report({\n              node: body[i + 1],\n              messageId: isPadded ? \"never\" : \"always\",\n\n              fix(fixer) {\n                if (hasTokenInPadding) {\n                  return null;\n                }\n\n                return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\") : fixer.insertTextAfter(curLineLastToken, \"\\n\");\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/lines-between-class-members.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","properties","exceptAfterSingleLine","default","additionalProperties","messages","never","always","create","context","options","sourceCode","getSourceCode","getBoundaryTokens","curNode","nextNode","lastToken","getLastToken","prevToken","getTokenBefore","nextToken","getFirstToken","isSemicolonLessStyle","isSemicolonToken","isTokenOnSameLine","curLast","nextFirst","findLastConsecutiveTokenAfter","prevLastToken","nextFirstToken","maxLine","after","getTokenAfter","includeComments","loc","start","line","end","findFirstConsecutiveTokenBefore","before","hasTokenOrCommentBetween","getTokensBetween","length","ClassBody","node","body","i","curFirst","isMulti","skip","beforePadding","afterPadding","isPadded","hasTokenInPadding","curLineLastToken","report","messageId","fix","fixer","replaceTextRange","range","insertTextAfter"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check empty newline between class members\r\n * @author 薛定谔的猫<hh_2013@foxmail.com>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow an empty line between class members\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/lines-between-class-members\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptAfterSingleLine: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            never: \"Unexpected blank line between class members.\",\r\n            always: \"Expected blank line between class members.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = [];\r\n\r\n        options[0] = context.options[0] || \"always\";\r\n        options[1] = context.options[1] || { exceptAfterSingleLine: false };\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Gets a pair of tokens that should be used to check lines between two class member nodes.\r\n         *\r\n         * In most cases, this returns the very last token of the current node and\r\n         * the very first token of the next node.\r\n         * For example:\r\n         *\r\n         *     class C {\r\n         *         x = 1;   // curLast: `;` nextFirst: `in`\r\n         *         in = 2\r\n         *     }\r\n         *\r\n         * There is only one exception. If the given node ends with a semicolon, and it looks like\r\n         * a semicolon-less style's semicolon - one that is not on the same line as the preceding\r\n         * token, but is on the line where the next class member starts - this returns the preceding\r\n         * token and the semicolon as boundary tokens.\r\n         * For example:\r\n         *\r\n         *     class C {\r\n         *         x = 1    // curLast: `1` nextFirst: `;`\r\n         *         ;in = 2\r\n         *     }\r\n         * When determining the desired layout of the code, we should treat this semicolon as\r\n         * a part of the next class member node instead of the one it technically belongs to.\r\n         * @param {ASTNode} curNode Current class member node.\r\n         * @param {ASTNode} nextNode Next class member node.\r\n         * @returns {Token} The actual last token of `node`.\r\n         * @private\r\n         */\r\n        function getBoundaryTokens(curNode, nextNode) {\r\n            const lastToken = sourceCode.getLastToken(curNode);\r\n            const prevToken = sourceCode.getTokenBefore(lastToken);\r\n            const nextToken = sourceCode.getFirstToken(nextNode); // skip possible lone `;` between nodes\r\n\r\n            const isSemicolonLessStyle = (\r\n                astUtils.isSemicolonToken(lastToken) &&\r\n                !astUtils.isTokenOnSameLine(prevToken, lastToken) &&\r\n                astUtils.isTokenOnSameLine(lastToken, nextToken)\r\n            );\r\n\r\n            return isSemicolonLessStyle\r\n                ? { curLast: prevToken, nextFirst: lastToken }\r\n                : { curLast: lastToken, nextFirst: nextToken };\r\n        }\r\n\r\n        /**\r\n         * Return the last token among the consecutive tokens that have no exceed max line difference in between, before the first token in the next member.\r\n         * @param {Token} prevLastToken The last token in the previous member node.\r\n         * @param {Token} nextFirstToken The first token in the next member node.\r\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\r\n         * @returns {Token} The last token among the consecutive tokens.\r\n         */\r\n        function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {\r\n            const after = sourceCode.getTokenAfter(prevLastToken, { includeComments: true });\r\n\r\n            if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {\r\n                return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);\r\n            }\r\n            return prevLastToken;\r\n        }\r\n\r\n        /**\r\n         * Return the first token among the consecutive tokens that have no exceed max line difference in between, after the last token in the previous member.\r\n         * @param {Token} nextFirstToken The first token in the next member node.\r\n         * @param {Token} prevLastToken The last token in the previous member node.\r\n         * @param {number} maxLine The maximum number of allowed line difference between consecutive tokens.\r\n         * @returns {Token} The first token among the consecutive tokens.\r\n         */\r\n        function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {\r\n            const before = sourceCode.getTokenBefore(nextFirstToken, { includeComments: true });\r\n\r\n            if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {\r\n                return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);\r\n            }\r\n            return nextFirstToken;\r\n        }\r\n\r\n        /**\r\n         * Checks if there is a token or comment between two tokens.\r\n         * @param {Token} before The token before.\r\n         * @param {Token} after The token after.\r\n         * @returns {boolean} True if there is a token or comment between two tokens.\r\n         */\r\n        function hasTokenOrCommentBetween(before, after) {\r\n            return sourceCode.getTokensBetween(before, after, { includeComments: true }).length !== 0;\r\n        }\r\n\r\n        return {\r\n            ClassBody(node) {\r\n                const body = node.body;\r\n\r\n                for (let i = 0; i < body.length - 1; i++) {\r\n                    const curFirst = sourceCode.getFirstToken(body[i]);\r\n                    const { curLast, nextFirst } = getBoundaryTokens(body[i], body[i + 1]);\r\n                    const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);\r\n                    const skip = !isMulti && options[1].exceptAfterSingleLine;\r\n                    const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);\r\n                    const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);\r\n                    const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;\r\n                    const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);\r\n                    const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);\r\n\r\n                    if ((options[0] === \"always\" && !skip && !isPadded) ||\r\n                        (options[0] === \"never\" && isPadded)) {\r\n                        context.report({\r\n                            node: body[i + 1],\r\n                            messageId: isPadded ? \"never\" : \"always\",\r\n                            fix(fixer) {\r\n                                if (hasTokenInPadding) {\r\n                                    return null;\r\n                                }\r\n                                return isPadded\r\n                                    ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], \"\\n\")\r\n                                    : fixer.insertTextAfter(curLineLastToken, \"\\n\");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}