{"ast":null,"code":"/**\r\n * @fileoverview Enforces empty lines around comments.\r\n * @author Jamund Ferguson\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Return an array with with any line numbers that are empty.\r\n * @param {Array} lines An array of each line of the file.\r\n * @returns {Array} An array of line numbers.\r\n */\n\n\nfunction getEmptyLineNums(lines) {\n  const emptyLines = lines.map((line, i) => ({\n    code: line.trim(),\n    num: i + 1\n  })).filter(line => !line.code).map(line => line.num);\n  return emptyLines;\n}\n/**\r\n * Return an array with with any line numbers that contain comments.\r\n * @param {Array} comments An array of comment tokens.\r\n * @returns {Array} An array of line numbers.\r\n */\n\n\nfunction getCommentLineNums(comments) {\n  const lines = [];\n  comments.forEach(token => {\n    const start = token.loc.start.line;\n    const end = token.loc.end.line;\n    lines.push(start, end);\n  });\n  return lines;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require empty lines around comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/lines-around-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        beforeBlockComment: {\n          type: \"boolean\",\n          default: true\n        },\n        afterBlockComment: {\n          type: \"boolean\",\n          default: false\n        },\n        beforeLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        afterLineComment: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockStart: {\n          type: \"boolean\",\n          default: false\n        },\n        allowBlockEnd: {\n          type: \"boolean\",\n          default: false\n        },\n        allowClassStart: {\n          type: \"boolean\"\n        },\n        allowClassEnd: {\n          type: \"boolean\"\n        },\n        allowObjectStart: {\n          type: \"boolean\"\n        },\n        allowObjectEnd: {\n          type: \"boolean\"\n        },\n        allowArrayStart: {\n          type: \"boolean\"\n        },\n        allowArrayEnd: {\n          type: \"boolean\"\n        },\n        ignorePattern: {\n          type: \"string\"\n        },\n        applyDefaultIgnorePatterns: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      after: \"Expected line after comment.\",\n      before: \"Expected line before comment.\"\n    }\n  },\n\n  create(context) {\n    const options = Object.assign({}, context.options[0]);\n    const ignorePattern = options.ignorePattern;\n    const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\n    const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\n    const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\n    options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines,\n          numLines = lines.length + 1,\n          comments = sourceCode.getAllComments(),\n          commentLines = getCommentLineNums(comments),\n          emptyLines = getEmptyLineNums(lines),\n          commentAndEmptyLines = commentLines.concat(emptyLines);\n    /**\r\n     * Returns whether or not comments are on lines starting with or ending with code\r\n     * @param {token} token The comment token to check.\r\n     * @returns {boolean} True if the comment is not alone.\r\n     */\n\n    function codeAroundComment(token) {\n      let currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\n        return true;\n      }\n\n      currentToken = token;\n\n      do {\n        currentToken = sourceCode.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      } while (currentToken && astUtils.isCommentToken(currentToken));\n\n      if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Returns whether or not comments are inside a node type or not.\r\n     * @param {ASTNode} parent The Comment parent node.\r\n     * @param {string} nodeType The parent type to check against.\r\n     * @returns {boolean} True if the comment is inside nodeType.\r\n     */\n\n\n    function isParentNodeType(parent, nodeType) {\n      return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;\n    }\n    /**\r\n     * Returns the parent node that contains the given token.\r\n     * @param {token} token The token to check.\r\n     * @returns {ASTNode|null} The parent node that contains the given token.\r\n     */\n\n\n    function getParentNodeOfToken(token) {\n      const node = sourceCode.getNodeByRangeIndex(token.range[0]);\n      /*\r\n       * For the purpose of this rule, the comment token is in a `StaticBlock` node only\r\n       * if it's inside the braces of that `StaticBlock` node.\r\n       *\r\n       * Example where this function returns `null`:\r\n       *\r\n       *   static\r\n       *   // comment\r\n       *   {\r\n       *   }\r\n       *\r\n       * Example where this function returns `StaticBlock` node:\r\n       *\r\n       *   static\r\n       *   {\r\n       *   // comment\r\n       *   }\r\n       *\r\n       */\n\n      if (node && node.type === \"StaticBlock\") {\n        const openingBrace = sourceCode.getFirstToken(node, {\n          skip: 1\n        }); // skip the `static` token\n\n        return token.range[0] >= openingBrace.range[0] ? node : null;\n      }\n\n      return node;\n    }\n    /**\r\n     * Returns whether or not comments are at the parent start or not.\r\n     * @param {token} token The Comment token.\r\n     * @param {string} nodeType The parent type to check against.\r\n     * @returns {boolean} True if the comment is at parent start.\r\n     */\n\n\n    function isCommentAtParentStart(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n\n      if (parent && isParentNodeType(parent, nodeType)) {\n        const parentStartNodeOrToken = parent.type === \"StaticBlock\" ? sourceCode.getFirstToken(parent, {\n          skip: 1\n        }) // opening brace of the static block\n        : parent;\n        return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;\n      }\n\n      return false;\n    }\n    /**\r\n     * Returns whether or not comments are at the parent end or not.\r\n     * @param {token} token The Comment token.\r\n     * @param {string} nodeType The parent type to check against.\r\n     * @returns {boolean} True if the comment is at parent end.\r\n     */\n\n\n    function isCommentAtParentEnd(token, nodeType) {\n      const parent = getParentNodeOfToken(token);\n      return !!parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;\n    }\n    /**\r\n     * Returns whether or not comments are at the block start or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at block start.\r\n     */\n\n\n    function isCommentAtBlockStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\") || isCommentAtParentStart(token, \"BlockStatement\") || isCommentAtParentStart(token, \"StaticBlock\") || isCommentAtParentStart(token, \"SwitchCase\");\n    }\n    /**\r\n     * Returns whether or not comments are at the block end or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at block end.\r\n     */\n\n\n    function isCommentAtBlockEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\") || isCommentAtParentEnd(token, \"BlockStatement\") || isCommentAtParentEnd(token, \"StaticBlock\") || isCommentAtParentEnd(token, \"SwitchCase\") || isCommentAtParentEnd(token, \"SwitchStatement\");\n    }\n    /**\r\n     * Returns whether or not comments are at the class start or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at class start.\r\n     */\n\n\n    function isCommentAtClassStart(token) {\n      return isCommentAtParentStart(token, \"ClassBody\");\n    }\n    /**\r\n     * Returns whether or not comments are at the class end or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at class end.\r\n     */\n\n\n    function isCommentAtClassEnd(token) {\n      return isCommentAtParentEnd(token, \"ClassBody\");\n    }\n    /**\r\n     * Returns whether or not comments are at the object start or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at object start.\r\n     */\n\n\n    function isCommentAtObjectStart(token) {\n      return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\n    }\n    /**\r\n     * Returns whether or not comments are at the object end or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at object end.\r\n     */\n\n\n    function isCommentAtObjectEnd(token) {\n      return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\n    }\n    /**\r\n     * Returns whether or not comments are at the array start or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at array start.\r\n     */\n\n\n    function isCommentAtArrayStart(token) {\n      return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\n    }\n    /**\r\n     * Returns whether or not comments are at the array end or not.\r\n     * @param {token} token The Comment token.\r\n     * @returns {boolean} True if the comment is at array end.\r\n     */\n\n\n    function isCommentAtArrayEnd(token) {\n      return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\n    }\n    /**\r\n     * Checks if a comment token has lines around it (ignores inline comments)\r\n     * @param {token} token The Comment token.\r\n     * @param {Object} opts Options to determine the newline.\r\n     * @param {boolean} opts.after Should have a newline after this line.\r\n     * @param {boolean} opts.before Should have a newline before this line.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForEmptyLine(token, opts) {\n      if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      if (ignorePattern && customIgnoreRegExp.test(token.value)) {\n        return;\n      }\n\n      let after = opts.after,\n          before = opts.before;\n      const prevLineNum = token.loc.start.line - 1,\n            nextLineNum = token.loc.end.line + 1,\n            commentIsNotAlone = codeAroundComment(token);\n      const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)),\n            blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\n            classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\n            classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\n            objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\n            objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\n            arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\n            arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\n      const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\n      const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed; // ignore top of the file and bottom of the file\n\n      if (prevLineNum < 1) {\n        before = false;\n      }\n\n      if (nextLineNum >= numLines) {\n        after = false;\n      } // we ignore all inline comments\n\n\n      if (commentIsNotAlone) {\n        return;\n      }\n\n      const previousTokenOrComment = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      const nextTokenOrComment = sourceCode.getTokenAfter(token, {\n        includeComments: true\n      }); // check for newline before\n\n      if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\n        const lineStart = token.range[0] - token.loc.start.column;\n        const range = [lineStart, lineStart];\n        context.report({\n          node: token,\n          messageId: \"before\",\n\n          fix(fixer) {\n            return fixer.insertTextBeforeRange(range, \"\\n\");\n          }\n\n        });\n      } // check for newline after\n\n\n      if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\n        context.report({\n          node: token,\n          messageId: \"after\",\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \"\\n\");\n          }\n\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        comments.forEach(token => {\n          if (token.type === \"Line\") {\n            if (options.beforeLineComment || options.afterLineComment) {\n              checkForEmptyLine(token, {\n                after: options.afterLineComment,\n                before: options.beforeLineComment\n              });\n            }\n          } else if (token.type === \"Block\") {\n            if (options.beforeBlockComment || options.afterBlockComment) {\n              checkForEmptyLine(token, {\n                after: options.afterBlockComment,\n                before: options.beforeBlockComment\n              });\n            }\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/lines-around-comment.js"],"names":["astUtils","require","getEmptyLineNums","lines","emptyLines","map","line","i","code","trim","num","filter","getCommentLineNums","comments","forEach","token","start","loc","end","push","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","beforeBlockComment","default","afterBlockComment","beforeLineComment","afterLineComment","allowBlockStart","allowBlockEnd","allowClassStart","allowClassEnd","allowObjectStart","allowObjectEnd","allowArrayStart","allowArrayEnd","ignorePattern","applyDefaultIgnorePatterns","additionalProperties","messages","after","before","create","context","options","Object","assign","defaultIgnoreRegExp","COMMENTS_IGNORE_PATTERN","customIgnoreRegExp","RegExp","sourceCode","getSourceCode","numLines","length","getAllComments","commentLines","commentAndEmptyLines","concat","codeAroundComment","currentToken","getTokenBefore","includeComments","isCommentToken","isTokenOnSameLine","getTokenAfter","isParentNodeType","parent","nodeType","body","consequent","getParentNodeOfToken","node","getNodeByRangeIndex","range","openingBrace","getFirstToken","skip","isCommentAtParentStart","parentStartNodeOrToken","isCommentAtParentEnd","isCommentAtBlockStart","isCommentAtBlockEnd","isCommentAtClassStart","isCommentAtClassEnd","isCommentAtObjectStart","isCommentAtObjectEnd","isCommentAtArrayStart","isCommentAtArrayEnd","checkForEmptyLine","opts","test","value","prevLineNum","nextLineNum","commentIsNotAlone","blockStartAllowed","blockEndAllowed","classStartAllowed","classEndAllowed","objectStartAllowed","objectEndAllowed","arrayStartAllowed","arrayEndAllowed","exceptionStartAllowed","exceptionEndAllowed","previousTokenOrComment","nextTokenOrComment","includes","lineStart","column","report","messageId","fix","fixer","insertTextBeforeRange","insertTextAfter","Program"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Enforces empty lines around comments.\r\n * @author Jamund Ferguson\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Return an array with with any line numbers that are empty.\r\n * @param {Array} lines An array of each line of the file.\r\n * @returns {Array} An array of line numbers.\r\n */\r\nfunction getEmptyLineNums(lines) {\r\n    const emptyLines = lines.map((line, i) => ({\r\n        code: line.trim(),\r\n        num: i + 1\r\n    })).filter(line => !line.code).map(line => line.num);\r\n\r\n    return emptyLines;\r\n}\r\n\r\n/**\r\n * Return an array with with any line numbers that contain comments.\r\n * @param {Array} comments An array of comment tokens.\r\n * @returns {Array} An array of line numbers.\r\n */\r\nfunction getCommentLineNums(comments) {\r\n    const lines = [];\r\n\r\n    comments.forEach(token => {\r\n        const start = token.loc.start.line;\r\n        const end = token.loc.end.line;\r\n\r\n        lines.push(start, end);\r\n    });\r\n    return lines;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require empty lines around comments\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/lines-around-comment\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    beforeBlockComment: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    afterBlockComment: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    beforeLineComment: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    afterLineComment: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowBlockStart: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowBlockEnd: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowClassStart: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    allowClassEnd: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    allowObjectStart: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    allowObjectEnd: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    allowArrayStart: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    allowArrayEnd: {\r\n                        type: \"boolean\"\r\n                    },\r\n                    ignorePattern: {\r\n                        type: \"string\"\r\n                    },\r\n                    applyDefaultIgnorePatterns: {\r\n                        type: \"boolean\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            after: \"Expected line after comment.\",\r\n            before: \"Expected line before comment.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = Object.assign({}, context.options[0]);\r\n        const ignorePattern = options.ignorePattern;\r\n        const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;\r\n        const customIgnoreRegExp = new RegExp(ignorePattern, \"u\");\r\n        const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;\r\n\r\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const lines = sourceCode.lines,\r\n            numLines = lines.length + 1,\r\n            comments = sourceCode.getAllComments(),\r\n            commentLines = getCommentLineNums(comments),\r\n            emptyLines = getEmptyLineNums(lines),\r\n            commentAndEmptyLines = commentLines.concat(emptyLines);\r\n\r\n        /**\r\n         * Returns whether or not comments are on lines starting with or ending with code\r\n         * @param {token} token The comment token to check.\r\n         * @returns {boolean} True if the comment is not alone.\r\n         */\r\n        function codeAroundComment(token) {\r\n            let currentToken = token;\r\n\r\n            do {\r\n                currentToken = sourceCode.getTokenBefore(currentToken, { includeComments: true });\r\n            } while (currentToken && astUtils.isCommentToken(currentToken));\r\n\r\n            if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {\r\n                return true;\r\n            }\r\n\r\n            currentToken = token;\r\n            do {\r\n                currentToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\r\n            } while (currentToken && astUtils.isCommentToken(currentToken));\r\n\r\n            if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are inside a node type or not.\r\n         * @param {ASTNode} parent The Comment parent node.\r\n         * @param {string} nodeType The parent type to check against.\r\n         * @returns {boolean} True if the comment is inside nodeType.\r\n         */\r\n        function isParentNodeType(parent, nodeType) {\r\n            return parent.type === nodeType ||\r\n                (parent.body && parent.body.type === nodeType) ||\r\n                (parent.consequent && parent.consequent.type === nodeType);\r\n        }\r\n\r\n        /**\r\n         * Returns the parent node that contains the given token.\r\n         * @param {token} token The token to check.\r\n         * @returns {ASTNode|null} The parent node that contains the given token.\r\n         */\r\n        function getParentNodeOfToken(token) {\r\n            const node = sourceCode.getNodeByRangeIndex(token.range[0]);\r\n\r\n            /*\r\n             * For the purpose of this rule, the comment token is in a `StaticBlock` node only\r\n             * if it's inside the braces of that `StaticBlock` node.\r\n             *\r\n             * Example where this function returns `null`:\r\n             *\r\n             *   static\r\n             *   // comment\r\n             *   {\r\n             *   }\r\n             *\r\n             * Example where this function returns `StaticBlock` node:\r\n             *\r\n             *   static\r\n             *   {\r\n             *   // comment\r\n             *   }\r\n             *\r\n             */\r\n            if (node && node.type === \"StaticBlock\") {\r\n                const openingBrace = sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\r\n\r\n                return token.range[0] >= openingBrace.range[0]\r\n                    ? node\r\n                    : null;\r\n            }\r\n\r\n            return node;\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the parent start or not.\r\n         * @param {token} token The Comment token.\r\n         * @param {string} nodeType The parent type to check against.\r\n         * @returns {boolean} True if the comment is at parent start.\r\n         */\r\n        function isCommentAtParentStart(token, nodeType) {\r\n            const parent = getParentNodeOfToken(token);\r\n\r\n            if (parent && isParentNodeType(parent, nodeType)) {\r\n                const parentStartNodeOrToken = parent.type === \"StaticBlock\"\r\n                    ? sourceCode.getFirstToken(parent, { skip: 1 }) // opening brace of the static block\r\n                    : parent;\r\n\r\n                return token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the parent end or not.\r\n         * @param {token} token The Comment token.\r\n         * @param {string} nodeType The parent type to check against.\r\n         * @returns {boolean} True if the comment is at parent end.\r\n         */\r\n        function isCommentAtParentEnd(token, nodeType) {\r\n            const parent = getParentNodeOfToken(token);\r\n\r\n            return !!parent && isParentNodeType(parent, nodeType) &&\r\n                    parent.loc.end.line - token.loc.end.line === 1;\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the block start or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at block start.\r\n         */\r\n        function isCommentAtBlockStart(token) {\r\n            return (\r\n                isCommentAtParentStart(token, \"ClassBody\") ||\r\n                isCommentAtParentStart(token, \"BlockStatement\") ||\r\n                isCommentAtParentStart(token, \"StaticBlock\") ||\r\n                isCommentAtParentStart(token, \"SwitchCase\")\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the block end or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at block end.\r\n         */\r\n        function isCommentAtBlockEnd(token) {\r\n            return (\r\n                isCommentAtParentEnd(token, \"ClassBody\") ||\r\n                isCommentAtParentEnd(token, \"BlockStatement\") ||\r\n                isCommentAtParentEnd(token, \"StaticBlock\") ||\r\n                isCommentAtParentEnd(token, \"SwitchCase\") ||\r\n                isCommentAtParentEnd(token, \"SwitchStatement\")\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the class start or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at class start.\r\n         */\r\n        function isCommentAtClassStart(token) {\r\n            return isCommentAtParentStart(token, \"ClassBody\");\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the class end or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at class end.\r\n         */\r\n        function isCommentAtClassEnd(token) {\r\n            return isCommentAtParentEnd(token, \"ClassBody\");\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the object start or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at object start.\r\n         */\r\n        function isCommentAtObjectStart(token) {\r\n            return isCommentAtParentStart(token, \"ObjectExpression\") || isCommentAtParentStart(token, \"ObjectPattern\");\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the object end or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at object end.\r\n         */\r\n        function isCommentAtObjectEnd(token) {\r\n            return isCommentAtParentEnd(token, \"ObjectExpression\") || isCommentAtParentEnd(token, \"ObjectPattern\");\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the array start or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at array start.\r\n         */\r\n        function isCommentAtArrayStart(token) {\r\n            return isCommentAtParentStart(token, \"ArrayExpression\") || isCommentAtParentStart(token, \"ArrayPattern\");\r\n        }\r\n\r\n        /**\r\n         * Returns whether or not comments are at the array end or not.\r\n         * @param {token} token The Comment token.\r\n         * @returns {boolean} True if the comment is at array end.\r\n         */\r\n        function isCommentAtArrayEnd(token) {\r\n            return isCommentAtParentEnd(token, \"ArrayExpression\") || isCommentAtParentEnd(token, \"ArrayPattern\");\r\n        }\r\n\r\n        /**\r\n         * Checks if a comment token has lines around it (ignores inline comments)\r\n         * @param {token} token The Comment token.\r\n         * @param {Object} opts Options to determine the newline.\r\n         * @param {boolean} opts.after Should have a newline after this line.\r\n         * @param {boolean} opts.before Should have a newline before this line.\r\n         * @returns {void}\r\n         */\r\n        function checkForEmptyLine(token, opts) {\r\n            if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {\r\n                return;\r\n            }\r\n\r\n            if (ignorePattern && customIgnoreRegExp.test(token.value)) {\r\n                return;\r\n            }\r\n\r\n            let after = opts.after,\r\n                before = opts.before;\r\n\r\n            const prevLineNum = token.loc.start.line - 1,\r\n                nextLineNum = token.loc.end.line + 1,\r\n                commentIsNotAlone = codeAroundComment(token);\r\n\r\n            const blockStartAllowed = options.allowBlockStart &&\r\n                    isCommentAtBlockStart(token) &&\r\n                    !(options.allowClassStart === false &&\r\n                    isCommentAtClassStart(token)),\r\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)),\r\n                classStartAllowed = options.allowClassStart && isCommentAtClassStart(token),\r\n                classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token),\r\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token),\r\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token),\r\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token),\r\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);\r\n\r\n            const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;\r\n            const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;\r\n\r\n            // ignore top of the file and bottom of the file\r\n            if (prevLineNum < 1) {\r\n                before = false;\r\n            }\r\n            if (nextLineNum >= numLines) {\r\n                after = false;\r\n            }\r\n\r\n            // we ignore all inline comments\r\n            if (commentIsNotAlone) {\r\n                return;\r\n            }\r\n\r\n            const previousTokenOrComment = sourceCode.getTokenBefore(token, { includeComments: true });\r\n            const nextTokenOrComment = sourceCode.getTokenAfter(token, { includeComments: true });\r\n\r\n            // check for newline before\r\n            if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) &&\r\n                    !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {\r\n                const lineStart = token.range[0] - token.loc.start.column;\r\n                const range = [lineStart, lineStart];\r\n\r\n                context.report({\r\n                    node: token,\r\n                    messageId: \"before\",\r\n                    fix(fixer) {\r\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\r\n                    }\r\n                });\r\n            }\r\n\r\n            // check for newline after\r\n            if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) &&\r\n                    !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {\r\n                context.report({\r\n                    node: token,\r\n                    messageId: \"after\",\r\n                    fix(fixer) {\r\n                        return fixer.insertTextAfter(token, \"\\n\");\r\n                    }\r\n                });\r\n            }\r\n\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program() {\r\n                comments.forEach(token => {\r\n                    if (token.type === \"Line\") {\r\n                        if (options.beforeLineComment || options.afterLineComment) {\r\n                            checkForEmptyLine(token, {\r\n                                after: options.afterLineComment,\r\n                                before: options.beforeLineComment\r\n                            });\r\n                        }\r\n                    } else if (token.type === \"Block\") {\r\n                        if (options.beforeBlockComment || options.afterBlockComment) {\r\n                            checkForEmptyLine(token, {\r\n                                after: options.afterBlockComment,\r\n                                before: options.beforeBlockComment\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}