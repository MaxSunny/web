{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag `else` after a `return` in `if`\r\n * @author Ian Christian Myers\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `else` blocks after `return` statements in `if` statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-else-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowElseIf: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Unnecessary 'else' after 'return'.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Checks whether the given names can be safely used to declare block-scoped variables\r\n     * in the given scope. Name collisions can produce redeclaration syntax errors,\r\n     * or silently change references and modify behavior of the original code.\r\n     *\r\n     * This is not a generic function. In particular, it is assumed that the scope is a function scope or\r\n     * a function's inner scope, and that the names can be valid identifiers in the given scope.\r\n     * @param {string[]} names Array of variable names.\r\n     * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\r\n     * @returns {boolean} True if all names can be safely declared, false otherwise.\r\n     */\n    function isSafeToDeclare(names, scope) {\n      if (names.length === 0) {\n        return true;\n      }\n\n      const functionScope = scope.variableScope;\n      /*\r\n       * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\r\n       * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\r\n       * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\r\n       *\r\n       * Redeclaring any of these would cause a syntax error, except for the implicit variables.\r\n       */\n\n      const declaredVariables = scope.variables.filter(_ref => {\n        let {\n          defs\n        } = _ref;\n        return defs.length > 0;\n      });\n\n      if (declaredVariables.some(_ref2 => {\n        let {\n          name\n        } = _ref2;\n        return names.includes(name);\n      })) {\n        return false;\n      } // Redeclaring a catch variable would also cause a syntax error.\n\n\n      if (scope !== functionScope && scope.upper.type === \"catch\") {\n        if (scope.upper.variables.some(_ref3 => {\n          let {\n            name\n          } = _ref3;\n          return names.includes(name);\n        })) {\n          return false;\n        }\n      }\n      /*\r\n       * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\r\n       * However, if the variable was used, declaring a new one with the same name would change references\r\n       * and modify behavior.\r\n       */\n\n\n      const usedImplicitVariables = scope.variables.filter(_ref4 => {\n        let {\n          defs,\n          references\n        } = _ref4;\n        return defs.length === 0 && references.length > 0;\n      });\n\n      if (usedImplicitVariables.some(_ref5 => {\n        let {\n          name\n        } = _ref5;\n        return names.includes(name);\n      })) {\n        return false;\n      }\n      /*\r\n       * Declaring a variable with a name that was already used to reference a variable from an upper scope\r\n       * would change references and modify behavior.\r\n       */\n\n\n      if (scope.through.some(t => names.includes(t.identifier.name))) {\n        return false;\n      }\n      /*\r\n       * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\r\n       * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\r\n       *\r\n       * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\r\n       * function foo() { if (bar) { let a; if (baz) { var a; } } }\r\n       */\n\n\n      if (scope !== functionScope) {\n        const scopeNodeRange = scope.block.range;\n        const variablesToCheck = functionScope.variables.filter(_ref6 => {\n          let {\n            name\n          } = _ref6;\n          return names.includes(name);\n        });\n\n        if (variablesToCheck.some(v => v.defs.some(_ref7 => {\n          let {\n            node: {\n              range\n            }\n          } = _ref7;\n          return scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1];\n        }))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\r\n     * Checks whether the removal of `else` and its braces is safe from variable name collisions.\r\n     * @param {Node} node The 'else' node.\r\n     * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\r\n     * @returns {boolean} True if it is safe, false otherwise.\r\n     */\n\n\n    function isSafeFromNameCollisions(node, scope) {\n      if (node.type === \"FunctionDeclaration\") {\n        // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\n        return false;\n      }\n\n      if (node.type !== \"BlockStatement\") {\n        return true;\n      }\n\n      const elseBlockScope = scope.childScopes.find(_ref8 => {\n        let {\n          block\n        } = _ref8;\n        return block === node;\n      });\n\n      if (!elseBlockScope) {\n        // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\n        return true;\n      }\n      /*\r\n       * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\r\n       * only block-scoped variables (such as let and const variables or class and function declarations)\r\n       * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\r\n       */\n\n\n      const namesToCheck = elseBlockScope.variables.map(_ref9 => {\n        let {\n          name\n        } = _ref9;\n        return name;\n      });\n      return isSafeToDeclare(namesToCheck, scope);\n    }\n    /**\r\n     * Display the context report if rule is violated\r\n     * @param {Node} node The 'else' node\r\n     * @returns {void}\r\n     */\n\n\n    function displayReport(node) {\n      const currentScope = context.getScope();\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        fix: fixer => {\n          if (!isSafeFromNameCollisions(node, currentScope)) {\n            return null;\n          }\n\n          const sourceCode = context.getSourceCode();\n          const startToken = sourceCode.getFirstToken(node);\n          const elseToken = sourceCode.getTokenBefore(startToken);\n          const source = sourceCode.getText(node);\n          const lastIfToken = sourceCode.getTokenBefore(elseToken);\n          let fixedSource, firstTokenOfElseBlock;\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\n          } else {\n            firstTokenOfElseBlock = startToken;\n          }\n          /*\r\n           * If the if block does not have curly braces and does not end in a semicolon\r\n           * and the else block starts with (, [, /, +, ` or -, then it is not\r\n           * safe to remove the else keyword, because ASI will not add a semicolon\r\n           * after the if block\r\n           */\n\n\n          const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\n          const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\n\n          if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\n            return null;\n          }\n\n          const endToken = sourceCode.getLastToken(node);\n          const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\n\n          if (lastTokenOfElseBlock.value !== \";\") {\n            const nextToken = sourceCode.getTokenAfter(endToken);\n            const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\n            const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\n            /*\r\n             * If the else block contents does not end in a semicolon,\r\n             * and the else block starts with (, [, /, +, ` or -, then it is not\r\n             * safe to remove the else block, because ASI will not add a semicolon\r\n             * after the remaining else block contents\r\n             */\n\n            if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== \"}\") {\n              return null;\n            }\n          }\n\n          if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\n            fixedSource = source.slice(1, -1);\n          } else {\n            fixedSource = source;\n          }\n          /*\r\n           * Extend the replacement range to include the entire\r\n           * function to avoid conflicting with no-useless-return.\r\n           * https://github.com/eslint/eslint/issues/8026\r\n           *\r\n           * Also, to avoid name collisions between two else blocks.\r\n           */\n\n\n          return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\n        }\n      });\n    }\n    /**\r\n     * Check to see if the node is a ReturnStatement\r\n     * @param {Node} node The node being evaluated\r\n     * @returns {boolean} True if node is a return\r\n     */\n\n\n    function checkForReturn(node) {\n      return node.type === \"ReturnStatement\";\n    }\n    /**\r\n     * Naive return checking, does not iterate through the whole\r\n     * BlockStatement because we make the assumption that the ReturnStatement\r\n     * will be the last node in the body of the BlockStatement.\r\n     * @param {Node} node The consequent/alternate node\r\n     * @returns {boolean} True if it has a return\r\n     */\n\n\n    function naiveHasReturn(node) {\n      if (node.type === \"BlockStatement\") {\n        const body = node.body,\n              lastChildNode = body[body.length - 1];\n        return lastChildNode && checkForReturn(lastChildNode);\n      }\n\n      return checkForReturn(node);\n    }\n    /**\r\n     * Check to see if the node is valid for evaluation,\r\n     * meaning it has an else.\r\n     * @param {Node} node The node being evaluated\r\n     * @returns {boolean} True if the node is valid\r\n     */\n\n\n    function hasElse(node) {\n      return node.alternate && node.consequent;\n    }\n    /**\r\n     * If the consequent is an IfStatement, check to see if it has an else\r\n     * and both its consequent and alternate path return, meaning this is\r\n     * a nested case of rule violation.  If-Else not considered currently.\r\n     * @param {Node} node The consequent node\r\n     * @returns {boolean} True if this is a nested rule violation\r\n     */\n\n\n    function checkForIf(node) {\n      return node.type === \"IfStatement\" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n    }\n    /**\r\n     * Check the consequent/body node to make sure it is not\r\n     * a ReturnStatement or an IfStatement that returns on both\r\n     * code paths.\r\n     * @param {Node} node The consequent or body node\r\n     * @returns {boolean} `true` if it is a Return/If node that always returns.\r\n     */\n\n\n    function checkForReturnOrIf(node) {\n      return checkForReturn(node) || checkForIf(node);\n    }\n    /**\r\n     * Check whether a node returns in every codepath.\r\n     * @param {Node} node The node to be checked\r\n     * @returns {boolean} `true` if it returns on every codepath.\r\n     */\n\n\n    function alwaysReturns(node) {\n      if (node.type === \"BlockStatement\") {\n        // If we have a BlockStatement, check each consequent body node.\n        return node.body.some(checkForReturnOrIf);\n      }\n      /*\r\n       * If not a block statement, make sure the consequent isn't a\r\n       * ReturnStatement or an IfStatement with returns on both paths.\r\n       */\n\n\n      return checkForReturnOrIf(node);\n    }\n    /**\r\n     * Check the if statement, but don't catch else-if blocks.\r\n     * @returns {void}\r\n     * @param {Node} node The node for the if statement to check\r\n     * @private\r\n     */\n\n\n    function checkIfWithoutElse(node) {\n      const parent = node.parent;\n      /*\r\n       * Fixing this would require splitting one statement into two, so no error should\r\n       * be reported if this node is in a position where only one statement is allowed.\r\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const consequents = [];\n      let alternate;\n\n      for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\n        if (!currentNode.alternate) {\n          return;\n        }\n\n        consequents.push(currentNode.consequent);\n        alternate = currentNode.alternate;\n      }\n\n      if (consequents.every(alwaysReturns)) {\n        displayReport(alternate);\n      }\n    }\n    /**\r\n     * Check the if statement\r\n     * @returns {void}\r\n     * @param {Node} node The node for the if statement to check\r\n     * @private\r\n     */\n\n\n    function checkIfWithElse(node) {\n      const parent = node.parent;\n      /*\r\n       * Fixing this would require splitting one statement into two, so no error should\r\n       * be reported if this node is in a position where only one statement is allowed.\r\n       */\n\n      if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\n        return;\n      }\n\n      const alternate = node.alternate;\n\n      if (alternate && alwaysReturns(node.consequent)) {\n        displayReport(alternate);\n      }\n    }\n\n    const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false); //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n    return {\n      \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-else-return.js"],"names":["astUtils","require","FixTracker","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowElseIf","default","additionalProperties","fixable","messages","unexpected","create","context","isSafeToDeclare","names","scope","length","functionScope","variableScope","declaredVariables","variables","filter","defs","some","name","includes","upper","usedImplicitVariables","references","through","t","identifier","scopeNodeRange","block","range","variablesToCheck","v","node","isSafeFromNameCollisions","elseBlockScope","childScopes","find","namesToCheck","map","displayReport","currentScope","getScope","report","messageId","fix","fixer","sourceCode","getSourceCode","startToken","getFirstToken","elseToken","getTokenBefore","source","getText","lastIfToken","fixedSource","firstTokenOfElseBlock","value","getTokenAfter","ifBlockMaybeUnsafe","parent","consequent","elseBlockUnsafe","test","endToken","getLastToken","lastTokenOfElseBlock","nextToken","nextTokenUnsafe","nextTokenOnSameLine","loc","start","line","slice","retainEnclosingFunction","replaceTextRange","checkForReturn","naiveHasReturn","body","lastChildNode","hasElse","alternate","checkForIf","checkForReturnOrIf","alwaysReturns","checkIfWithoutElse","STATEMENT_LIST_PARENTS","has","consequents","currentNode","push","every","checkIfWithElse","options"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag `else` after a `return` in `if`\r\n * @author Ian Christian Myers\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst FixTracker = require(\"./utils/fix-tracker\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-else-return\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                allowElseIf: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpected: \"Unnecessary 'else' after 'return'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Checks whether the given names can be safely used to declare block-scoped variables\r\n         * in the given scope. Name collisions can produce redeclaration syntax errors,\r\n         * or silently change references and modify behavior of the original code.\r\n         *\r\n         * This is not a generic function. In particular, it is assumed that the scope is a function scope or\r\n         * a function's inner scope, and that the names can be valid identifiers in the given scope.\r\n         * @param {string[]} names Array of variable names.\r\n         * @param {eslint-scope.Scope} scope Function scope or a function's inner scope.\r\n         * @returns {boolean} True if all names can be safely declared, false otherwise.\r\n         */\r\n        function isSafeToDeclare(names, scope) {\r\n\r\n            if (names.length === 0) {\r\n                return true;\r\n            }\r\n\r\n            const functionScope = scope.variableScope;\r\n\r\n            /*\r\n             * If this is a function scope, scope.variables will contain parameters, implicit variables such as \"arguments\",\r\n             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.\r\n             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.\r\n             *\r\n             * Redeclaring any of these would cause a syntax error, except for the implicit variables.\r\n             */\r\n            const declaredVariables = scope.variables.filter(({ defs }) => defs.length > 0);\r\n\r\n            if (declaredVariables.some(({ name }) => names.includes(name))) {\r\n                return false;\r\n            }\r\n\r\n            // Redeclaring a catch variable would also cause a syntax error.\r\n            if (scope !== functionScope && scope.upper.type === \"catch\") {\r\n                if (scope.upper.variables.some(({ name }) => names.includes(name))) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            /*\r\n             * Redeclaring an implicit variable, such as \"arguments\", would not cause a syntax error.\r\n             * However, if the variable was used, declaring a new one with the same name would change references\r\n             * and modify behavior.\r\n             */\r\n            const usedImplicitVariables = scope.variables.filter(({ defs, references }) =>\r\n                defs.length === 0 && references.length > 0);\r\n\r\n            if (usedImplicitVariables.some(({ name }) => names.includes(name))) {\r\n                return false;\r\n            }\r\n\r\n            /*\r\n             * Declaring a variable with a name that was already used to reference a variable from an upper scope\r\n             * would change references and modify behavior.\r\n             */\r\n            if (scope.through.some(t => names.includes(t.identifier.name))) {\r\n                return false;\r\n            }\r\n\r\n            /*\r\n             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside\r\n             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.\r\n             *\r\n             * For example, this would be a syntax error \"Identifier 'a' has already been declared\":\r\n             * function foo() { if (bar) { let a; if (baz) { var a; } } }\r\n             */\r\n            if (scope !== functionScope) {\r\n                const scopeNodeRange = scope.block.range;\r\n                const variablesToCheck = functionScope.variables.filter(({ name }) => names.includes(name));\r\n\r\n                if (variablesToCheck.some(v => v.defs.some(({ node: { range } }) =>\r\n                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n\r\n        /**\r\n         * Checks whether the removal of `else` and its braces is safe from variable name collisions.\r\n         * @param {Node} node The 'else' node.\r\n         * @param {eslint-scope.Scope} scope The scope in which the node and the whole 'if' statement is.\r\n         * @returns {boolean} True if it is safe, false otherwise.\r\n         */\r\n        function isSafeFromNameCollisions(node, scope) {\r\n\r\n            if (node.type === \"FunctionDeclaration\") {\r\n\r\n                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.\r\n                return false;\r\n            }\r\n\r\n            if (node.type !== \"BlockStatement\") {\r\n                return true;\r\n            }\r\n\r\n            const elseBlockScope = scope.childScopes.find(({ block }) => block === node);\r\n\r\n            if (!elseBlockScope) {\r\n\r\n                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.\r\n                return true;\r\n            }\r\n\r\n            /*\r\n             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains\r\n             * only block-scoped variables (such as let and const variables or class and function declarations)\r\n             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.\r\n             */\r\n            const namesToCheck = elseBlockScope.variables.map(({ name }) => name);\r\n\r\n            return isSafeToDeclare(namesToCheck, scope);\r\n        }\r\n\r\n        /**\r\n         * Display the context report if rule is violated\r\n         * @param {Node} node The 'else' node\r\n         * @returns {void}\r\n         */\r\n        function displayReport(node) {\r\n            const currentScope = context.getScope();\r\n\r\n            context.report({\r\n                node,\r\n                messageId: \"unexpected\",\r\n                fix: fixer => {\r\n\r\n                    if (!isSafeFromNameCollisions(node, currentScope)) {\r\n                        return null;\r\n                    }\r\n\r\n                    const sourceCode = context.getSourceCode();\r\n                    const startToken = sourceCode.getFirstToken(node);\r\n                    const elseToken = sourceCode.getTokenBefore(startToken);\r\n                    const source = sourceCode.getText(node);\r\n                    const lastIfToken = sourceCode.getTokenBefore(elseToken);\r\n                    let fixedSource, firstTokenOfElseBlock;\r\n\r\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\r\n                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);\r\n                    } else {\r\n                        firstTokenOfElseBlock = startToken;\r\n                    }\r\n\r\n                    /*\r\n                     * If the if block does not have curly braces and does not end in a semicolon\r\n                     * and the else block starts with (, [, /, +, ` or -, then it is not\r\n                     * safe to remove the else keyword, because ASI will not add a semicolon\r\n                     * after the if block\r\n                     */\r\n                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== \"BlockStatement\" && lastIfToken.value !== \";\";\r\n                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);\r\n\r\n                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) {\r\n                        return null;\r\n                    }\r\n\r\n                    const endToken = sourceCode.getLastToken(node);\r\n                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);\r\n\r\n                    if (lastTokenOfElseBlock.value !== \";\") {\r\n                        const nextToken = sourceCode.getTokenAfter(endToken);\r\n\r\n                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);\r\n                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;\r\n\r\n                        /*\r\n                         * If the else block contents does not end in a semicolon,\r\n                         * and the else block starts with (, [, /, +, ` or -, then it is not\r\n                         * safe to remove the else block, because ASI will not add a semicolon\r\n                         * after the remaining else block contents\r\n                         */\r\n                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== \"}\")) {\r\n                            return null;\r\n                        }\r\n                    }\r\n\r\n                    if (startToken.type === \"Punctuator\" && startToken.value === \"{\") {\r\n                        fixedSource = source.slice(1, -1);\r\n                    } else {\r\n                        fixedSource = source;\r\n                    }\r\n\r\n                    /*\r\n                     * Extend the replacement range to include the entire\r\n                     * function to avoid conflicting with no-useless-return.\r\n                     * https://github.com/eslint/eslint/issues/8026\r\n                     *\r\n                     * Also, to avoid name collisions between two else blocks.\r\n                     */\r\n                    return new FixTracker(fixer, sourceCode)\r\n                        .retainEnclosingFunction(node)\r\n                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check to see if the node is a ReturnStatement\r\n         * @param {Node} node The node being evaluated\r\n         * @returns {boolean} True if node is a return\r\n         */\r\n        function checkForReturn(node) {\r\n            return node.type === \"ReturnStatement\";\r\n        }\r\n\r\n        /**\r\n         * Naive return checking, does not iterate through the whole\r\n         * BlockStatement because we make the assumption that the ReturnStatement\r\n         * will be the last node in the body of the BlockStatement.\r\n         * @param {Node} node The consequent/alternate node\r\n         * @returns {boolean} True if it has a return\r\n         */\r\n        function naiveHasReturn(node) {\r\n            if (node.type === \"BlockStatement\") {\r\n                const body = node.body,\r\n                    lastChildNode = body[body.length - 1];\r\n\r\n                return lastChildNode && checkForReturn(lastChildNode);\r\n            }\r\n            return checkForReturn(node);\r\n        }\r\n\r\n        /**\r\n         * Check to see if the node is valid for evaluation,\r\n         * meaning it has an else.\r\n         * @param {Node} node The node being evaluated\r\n         * @returns {boolean} True if the node is valid\r\n         */\r\n        function hasElse(node) {\r\n            return node.alternate && node.consequent;\r\n        }\r\n\r\n        /**\r\n         * If the consequent is an IfStatement, check to see if it has an else\r\n         * and both its consequent and alternate path return, meaning this is\r\n         * a nested case of rule violation.  If-Else not considered currently.\r\n         * @param {Node} node The consequent node\r\n         * @returns {boolean} True if this is a nested rule violation\r\n         */\r\n        function checkForIf(node) {\r\n            return node.type === \"IfStatement\" && hasElse(node) &&\r\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\r\n        }\r\n\r\n        /**\r\n         * Check the consequent/body node to make sure it is not\r\n         * a ReturnStatement or an IfStatement that returns on both\r\n         * code paths.\r\n         * @param {Node} node The consequent or body node\r\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\r\n         */\r\n        function checkForReturnOrIf(node) {\r\n            return checkForReturn(node) || checkForIf(node);\r\n        }\r\n\r\n\r\n        /**\r\n         * Check whether a node returns in every codepath.\r\n         * @param {Node} node The node to be checked\r\n         * @returns {boolean} `true` if it returns on every codepath.\r\n         */\r\n        function alwaysReturns(node) {\r\n            if (node.type === \"BlockStatement\") {\r\n\r\n                // If we have a BlockStatement, check each consequent body node.\r\n                return node.body.some(checkForReturnOrIf);\r\n            }\r\n\r\n            /*\r\n             * If not a block statement, make sure the consequent isn't a\r\n             * ReturnStatement or an IfStatement with returns on both paths.\r\n             */\r\n            return checkForReturnOrIf(node);\r\n        }\r\n\r\n\r\n        /**\r\n         * Check the if statement, but don't catch else-if blocks.\r\n         * @returns {void}\r\n         * @param {Node} node The node for the if statement to check\r\n         * @private\r\n         */\r\n        function checkIfWithoutElse(node) {\r\n            const parent = node.parent;\r\n\r\n            /*\r\n             * Fixing this would require splitting one statement into two, so no error should\r\n             * be reported if this node is in a position where only one statement is allowed.\r\n             */\r\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\r\n                return;\r\n            }\r\n\r\n            const consequents = [];\r\n            let alternate;\r\n\r\n            for (let currentNode = node; currentNode.type === \"IfStatement\"; currentNode = currentNode.alternate) {\r\n                if (!currentNode.alternate) {\r\n                    return;\r\n                }\r\n                consequents.push(currentNode.consequent);\r\n                alternate = currentNode.alternate;\r\n            }\r\n\r\n            if (consequents.every(alwaysReturns)) {\r\n                displayReport(alternate);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check the if statement\r\n         * @returns {void}\r\n         * @param {Node} node The node for the if statement to check\r\n         * @private\r\n         */\r\n        function checkIfWithElse(node) {\r\n            const parent = node.parent;\r\n\r\n\r\n            /*\r\n             * Fixing this would require splitting one statement into two, so no error should\r\n             * be reported if this node is in a position where only one statement is allowed.\r\n             */\r\n            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {\r\n                return;\r\n            }\r\n\r\n            const alternate = node.alternate;\r\n\r\n            if (alternate && alwaysReturns(node.consequent)) {\r\n                displayReport(alternate);\r\n            }\r\n        }\r\n\r\n        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            \"IfStatement:exit\": allowElseIf ? checkIfWithoutElse : checkIfWithElse\r\n\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}