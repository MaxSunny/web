{"ast":null,"code":"/**\r\n * @fileoverview Restrict usage of specified node imports.\r\n * @author Guy Ellis\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst ignore = require(\"ignore\");\n\nconst arrayOfStringsOrObjects = {\n  type: \"array\",\n  items: {\n    anyOf: [{\n      type: \"string\"\n    }, {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\"\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        importNames: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false,\n      required: [\"name\"]\n    }]\n  },\n  uniqueItems: true\n};\nconst arrayOfStringsOrObjectPatterns = {\n  anyOf: [{\n    type: \"array\",\n    items: {\n      type: \"string\"\n    },\n    uniqueItems: true\n  }, {\n    type: \"array\",\n    items: {\n      type: \"object\",\n      properties: {\n        group: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          minItems: 1,\n          uniqueItems: true\n        },\n        message: {\n          type: \"string\",\n          minLength: 1\n        },\n        caseSensitive: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false,\n      required: [\"group\"]\n    },\n    uniqueItems: true\n  }]\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified modules when loaded by `import`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-restricted-imports\"\n    },\n    messages: {\n      path: \"'{{importSource}}' import is restricted from being used.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\n      patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\n      everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\n      importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\n      // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\n      importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\n    },\n    schema: {\n      anyOf: [arrayOfStringsOrObjects, {\n        type: \"array\",\n        items: [{\n          type: \"object\",\n          properties: {\n            paths: arrayOfStringsOrObjects,\n            patterns: arrayOfStringsOrObjectPatterns\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }]\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = Array.isArray(context.options) ? context.options : [];\n    const isPathAndPatternsObject = typeof options[0] === \"object\" && (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\n    const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\n    const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\n      if (typeof importSource === \"string\") {\n        memo[importSource] = {\n          message: null\n        };\n      } else {\n        memo[importSource.name] = {\n          message: importSource.message,\n          importNames: importSource.importNames\n        };\n      }\n\n      return memo;\n    }, {}); // Handle patterns too, either as strings or groups\n\n    let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || []; // standardize to array of objects if we have an array of strings\n\n    if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\n      restrictedPatterns = [{\n        group: restrictedPatterns\n      }];\n    } // relative paths are supported for this rule\n\n\n    const restrictedPatternGroups = restrictedPatterns.map(_ref => {\n      let {\n        group,\n        message,\n        caseSensitive\n      } = _ref;\n      return {\n        matcher: ignore({\n          allowRelativePaths: true,\n          ignorecase: !caseSensitive\n        }).add(group),\n        customMessage: message\n      };\n    }); // if no imports are restricted we don't need to check\n\n    if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\n      return {};\n    }\n    /**\r\n     * Report a restricted path.\r\n     * @param {string} importSource path of the import\r\n     * @param {Map<string,Object[]>} importNames Map of import names that are being imported\r\n     * @param {node} node representing the restricted path reference\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkRestrictedPathAndReport(importSource, importNames, node) {\n      if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\n        return;\n      }\n\n      const customMessage = restrictedPathMessages[importSource].message;\n      const restrictedImportNames = restrictedPathMessages[importSource].importNames;\n\n      if (restrictedImportNames) {\n        if (importNames.has(\"*\")) {\n          const specifierData = importNames.get(\"*\")[0];\n          context.report({\n            node,\n            messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\n            loc: specifierData.loc,\n            data: {\n              importSource,\n              importNames: restrictedImportNames,\n              customMessage\n            }\n          });\n        }\n\n        restrictedImportNames.forEach(importName => {\n          if (importNames.has(importName)) {\n            const specifiers = importNames.get(importName);\n            specifiers.forEach(specifier => {\n              context.report({\n                node,\n                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\n                loc: specifier.loc,\n                data: {\n                  importSource,\n                  customMessage,\n                  importName\n                }\n              });\n            });\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\n          data: {\n            importSource,\n            customMessage\n          }\n        });\n      }\n    }\n    /**\r\n     * Report a restricted path specifically for patterns.\r\n     * @param {node} node representing the restricted path reference\r\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function reportPathForPatterns(node, group) {\n      const importSource = node.source.value.trim();\n      context.report({\n        node,\n        messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\n        data: {\n          importSource,\n          customMessage: group.customMessage\n        }\n      });\n    }\n    /**\r\n     * Check if the given importSource is restricted by a pattern.\r\n     * @param {string} importSource path of the import\r\n     * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\r\n     * @returns {boolean} whether the variable is a restricted pattern or not\r\n     * @private\r\n     */\n\n\n    function isRestrictedPattern(importSource, group) {\n      return group.matcher.ignores(importSource);\n    }\n    /**\r\n     * Checks a node to see if any problems should be reported.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkNode(node) {\n      const importSource = node.source.value.trim();\n      const importNames = new Map();\n\n      if (node.type === \"ExportAllDeclaration\") {\n        const starToken = sourceCode.getFirstToken(node, 1);\n        importNames.set(\"*\", [{\n          loc: starToken.loc\n        }]);\n      } else if (node.specifiers) {\n        for (const specifier of node.specifiers) {\n          let name;\n          const specifierData = {\n            loc: specifier.loc\n          };\n\n          if (specifier.type === \"ImportDefaultSpecifier\") {\n            name = \"default\";\n          } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n            name = \"*\";\n          } else if (specifier.imported) {\n            name = astUtils.getModuleExportName(specifier.imported);\n          } else if (specifier.local) {\n            name = astUtils.getModuleExportName(specifier.local);\n          }\n\n          if (typeof name === \"string\") {\n            if (importNames.has(name)) {\n              importNames.get(name).push(specifierData);\n            } else {\n              importNames.set(name, [specifierData]);\n            }\n          }\n        }\n      }\n\n      checkRestrictedPathAndReport(importSource, importNames, node);\n      restrictedPatternGroups.forEach(group => {\n        if (isRestrictedPattern(importSource, group)) {\n          reportPathForPatterns(node, group);\n        }\n      });\n    }\n\n    return {\n      ImportDeclaration: checkNode,\n\n      ExportNamedDeclaration(node) {\n        if (node.source) {\n          checkNode(node);\n        }\n      },\n\n      ExportAllDeclaration: checkNode\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-restricted-imports.js"],"names":["astUtils","require","ignore","arrayOfStringsOrObjects","type","items","anyOf","properties","name","message","minLength","importNames","additionalProperties","required","uniqueItems","arrayOfStringsOrObjectPatterns","group","minItems","caseSensitive","module","exports","meta","docs","description","recommended","url","messages","path","pathWithCustomMessage","patterns","patternWithCustomMessage","everything","everythingWithCustomMessage","importName","importNameWithCustomMessage","schema","paths","additionalItems","create","context","sourceCode","getSourceCode","options","Array","isArray","isPathAndPatternsObject","Object","prototype","hasOwnProperty","call","restrictedPaths","restrictedPathMessages","reduce","memo","importSource","restrictedPatterns","length","restrictedPatternGroups","map","matcher","allowRelativePaths","ignorecase","add","customMessage","keys","checkRestrictedPathAndReport","node","restrictedImportNames","has","specifierData","get","report","messageId","loc","data","forEach","specifiers","specifier","reportPathForPatterns","source","value","trim","isRestrictedPattern","ignores","checkNode","Map","starToken","getFirstToken","set","imported","getModuleExportName","local","push","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Restrict usage of specified node imports.\r\n * @author Guy Ellis\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst ignore = require(\"ignore\");\r\n\r\nconst arrayOfStringsOrObjects = {\r\n    type: \"array\",\r\n    items: {\r\n        anyOf: [\r\n            { type: \"string\" },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    name: { type: \"string\" },\r\n                    message: {\r\n                        type: \"string\",\r\n                        minLength: 1\r\n                    },\r\n                    importNames: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    }\r\n                },\r\n                additionalProperties: false,\r\n                required: [\"name\"]\r\n            }\r\n        ]\r\n    },\r\n    uniqueItems: true\r\n};\r\n\r\nconst arrayOfStringsOrObjectPatterns = {\r\n    anyOf: [\r\n        {\r\n            type: \"array\",\r\n            items: {\r\n                type: \"string\"\r\n            },\r\n            uniqueItems: true\r\n        },\r\n        {\r\n            type: \"array\",\r\n            items: {\r\n                type: \"object\",\r\n                properties: {\r\n                    group: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        },\r\n                        minItems: 1,\r\n                        uniqueItems: true\r\n                    },\r\n                    message: {\r\n                        type: \"string\",\r\n                        minLength: 1\r\n                    },\r\n                    caseSensitive: {\r\n                        type: \"boolean\"\r\n                    }\r\n                },\r\n                additionalProperties: false,\r\n                required: [\"group\"]\r\n            },\r\n            uniqueItems: true\r\n        }\r\n    ]\r\n};\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow specified modules when loaded by `import`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-restricted-imports\"\r\n        },\r\n\r\n        messages: {\r\n            path: \"'{{importSource}}' import is restricted from being used.\",\r\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\r\n            pathWithCustomMessage: \"'{{importSource}}' import is restricted from being used. {{customMessage}}\",\r\n\r\n            patterns: \"'{{importSource}}' import is restricted from being used by a pattern.\",\r\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\r\n            patternWithCustomMessage: \"'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}\",\r\n\r\n            everything: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.\",\r\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\r\n            everythingWithCustomMessage: \"* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}\",\r\n\r\n            importName: \"'{{importName}}' import from '{{importSource}}' is restricted.\",\r\n            // eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period\r\n            importNameWithCustomMessage: \"'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                arrayOfStringsOrObjects,\r\n                {\r\n                    type: \"array\",\r\n                    items: [{\r\n                        type: \"object\",\r\n                        properties: {\r\n                            paths: arrayOfStringsOrObjects,\r\n                            patterns: arrayOfStringsOrObjectPatterns\r\n                        },\r\n                        additionalProperties: false\r\n                    }],\r\n                    additionalItems: false\r\n                }\r\n            ]\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const options = Array.isArray(context.options) ? context.options : [];\r\n        const isPathAndPatternsObject =\r\n            typeof options[0] === \"object\" &&\r\n            (Object.prototype.hasOwnProperty.call(options[0], \"paths\") || Object.prototype.hasOwnProperty.call(options[0], \"patterns\"));\r\n\r\n        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];\r\n        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {\r\n            if (typeof importSource === \"string\") {\r\n                memo[importSource] = { message: null };\r\n            } else {\r\n                memo[importSource.name] = {\r\n                    message: importSource.message,\r\n                    importNames: importSource.importNames\r\n                };\r\n            }\r\n            return memo;\r\n        }, {});\r\n\r\n        // Handle patterns too, either as strings or groups\r\n        let restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];\r\n\r\n        // standardize to array of objects if we have an array of strings\r\n        if (restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === \"string\") {\r\n            restrictedPatterns = [{ group: restrictedPatterns }];\r\n        }\r\n\r\n        // relative paths are supported for this rule\r\n        const restrictedPatternGroups = restrictedPatterns.map(({ group, message, caseSensitive }) => ({\r\n            matcher: ignore({ allowRelativePaths: true, ignorecase: !caseSensitive }).add(group),\r\n            customMessage: message\r\n        }));\r\n\r\n        // if no imports are restricted we don't need to check\r\n        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {\r\n            return {};\r\n        }\r\n\r\n        /**\r\n         * Report a restricted path.\r\n         * @param {string} importSource path of the import\r\n         * @param {Map<string,Object[]>} importNames Map of import names that are being imported\r\n         * @param {node} node representing the restricted path reference\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkRestrictedPathAndReport(importSource, importNames, node) {\r\n            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {\r\n                return;\r\n            }\r\n\r\n            const customMessage = restrictedPathMessages[importSource].message;\r\n            const restrictedImportNames = restrictedPathMessages[importSource].importNames;\r\n\r\n            if (restrictedImportNames) {\r\n                if (importNames.has(\"*\")) {\r\n                    const specifierData = importNames.get(\"*\")[0];\r\n\r\n                    context.report({\r\n                        node,\r\n                        messageId: customMessage ? \"everythingWithCustomMessage\" : \"everything\",\r\n                        loc: specifierData.loc,\r\n                        data: {\r\n                            importSource,\r\n                            importNames: restrictedImportNames,\r\n                            customMessage\r\n                        }\r\n                    });\r\n                }\r\n\r\n                restrictedImportNames.forEach(importName => {\r\n                    if (importNames.has(importName)) {\r\n                        const specifiers = importNames.get(importName);\r\n\r\n                        specifiers.forEach(specifier => {\r\n                            context.report({\r\n                                node,\r\n                                messageId: customMessage ? \"importNameWithCustomMessage\" : \"importName\",\r\n                                loc: specifier.loc,\r\n                                data: {\r\n                                    importSource,\r\n                                    customMessage,\r\n                                    importName\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                });\r\n            } else {\r\n                context.report({\r\n                    node,\r\n                    messageId: customMessage ? \"pathWithCustomMessage\" : \"path\",\r\n                    data: {\r\n                        importSource,\r\n                        customMessage\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Report a restricted path specifically for patterns.\r\n         * @param {node} node representing the restricted path reference\r\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function reportPathForPatterns(node, group) {\r\n            const importSource = node.source.value.trim();\r\n\r\n            context.report({\r\n                node,\r\n                messageId: group.customMessage ? \"patternWithCustomMessage\" : \"patterns\",\r\n                data: {\r\n                    importSource,\r\n                    customMessage: group.customMessage\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check if the given importSource is restricted by a pattern.\r\n         * @param {string} importSource path of the import\r\n         * @param {Object} group contains a Ignore instance for paths, and the customMessage to show if it fails\r\n         * @returns {boolean} whether the variable is a restricted pattern or not\r\n         * @private\r\n         */\r\n        function isRestrictedPattern(importSource, group) {\r\n            return group.matcher.ignores(importSource);\r\n        }\r\n\r\n        /**\r\n         * Checks a node to see if any problems should be reported.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkNode(node) {\r\n            const importSource = node.source.value.trim();\r\n            const importNames = new Map();\r\n\r\n            if (node.type === \"ExportAllDeclaration\") {\r\n                const starToken = sourceCode.getFirstToken(node, 1);\r\n\r\n                importNames.set(\"*\", [{ loc: starToken.loc }]);\r\n            } else if (node.specifiers) {\r\n                for (const specifier of node.specifiers) {\r\n                    let name;\r\n                    const specifierData = { loc: specifier.loc };\r\n\r\n                    if (specifier.type === \"ImportDefaultSpecifier\") {\r\n                        name = \"default\";\r\n                    } else if (specifier.type === \"ImportNamespaceSpecifier\") {\r\n                        name = \"*\";\r\n                    } else if (specifier.imported) {\r\n                        name = astUtils.getModuleExportName(specifier.imported);\r\n                    } else if (specifier.local) {\r\n                        name = astUtils.getModuleExportName(specifier.local);\r\n                    }\r\n\r\n                    if (typeof name === \"string\") {\r\n                        if (importNames.has(name)) {\r\n                            importNames.get(name).push(specifierData);\r\n                        } else {\r\n                            importNames.set(name, [specifierData]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            checkRestrictedPathAndReport(importSource, importNames, node);\r\n            restrictedPatternGroups.forEach(group => {\r\n                if (isRestrictedPattern(importSource, group)) {\r\n                    reportPathForPatterns(node, group);\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            ImportDeclaration: checkNode,\r\n            ExportNamedDeclaration(node) {\r\n                if (node.source) {\r\n                    checkNode(node);\r\n                }\r\n            },\r\n            ExportAllDeclaration: checkNode\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}