{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag consistent return values\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  upperCaseFirst\n} = require(\"../shared/string-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given code path segment is unreachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is unreachable.\r\n */\n\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n/**\r\n * Checks whether a given node is a `constructor` method in an ES6 class\r\n * @param {ASTNode} node A node to check\r\n * @returns {boolean} `true` if the node is a `constructor` method\r\n */\n\n\nfunction isClassConstructor(node) {\n  return node.type === \"FunctionExpression\" && node.parent && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements to either always or never specify values\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/consistent-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        treatUndefinedAsUnspecified: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingReturn: \"Expected to return a value at the end of {{name}}.\",\n      missingReturnValue: \"{{name}} expected a return value.\",\n      unexpectedReturnValue: \"{{name}} expected no return value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n    let funcInfo = null;\n    /**\r\n     * Checks whether of not the implicit returning is consistent if the last\r\n     * code path segment is reachable.\r\n     * @param {ASTNode} node A program/function node to check.\r\n     * @returns {void}\r\n     */\n\n    function checkLastSegment(node) {\n      let loc, name;\n      /*\r\n       * Skip if it expected no return value or unreachable.\r\n       * When unreachable, all paths are returned or thrown.\r\n       */\n\n      if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {\n        return;\n      } // Adjust a location and a message.\n\n\n      if (node.type === \"Program\") {\n        // The head of program.\n        loc = {\n          line: 1,\n          column: 0\n        };\n        name = \"program\";\n      } else if (node.type === \"ArrowFunctionExpression\") {\n        // `=>` token\n        loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc;\n      } else if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        // Method name.\n        loc = node.parent.key.loc;\n      } else {\n        // Function name or `function` keyword.\n        loc = (node.id || context.getSourceCode().getFirstToken(node)).loc;\n      }\n\n      if (!name) {\n        name = astUtils.getFunctionNameWithKind(node);\n      } // Reports.\n\n\n      context.report({\n        node,\n        loc,\n        messageId: \"missingReturn\",\n        data: {\n          name\n        }\n      });\n    }\n\n    return {\n      // Initializes/Disposes state of each code path.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          hasReturnValue: false,\n          messageId: \"\",\n          node\n        };\n      },\n\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Reports a given return statement if it's inconsistent.\n      ReturnStatement(node) {\n        const argument = node.argument;\n        let hasReturnValue = Boolean(argument);\n\n        if (treatUndefinedAsUnspecified && hasReturnValue) {\n          hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\n        }\n\n        if (!funcInfo.hasReturn) {\n          funcInfo.hasReturn = true;\n          funcInfo.hasReturnValue = hasReturnValue;\n          funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\n          funcInfo.data = {\n            name: funcInfo.node.type === \"Program\" ? \"Program\" : upperCaseFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\n          };\n        } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n          context.report({\n            node,\n            messageId: funcInfo.messageId,\n            data: funcInfo.data\n          });\n        }\n      },\n\n      // Reports a given program/function if the implicit returning is not consistent.\n      \"Program:exit\": checkLastSegment,\n      \"FunctionDeclaration:exit\": checkLastSegment,\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/consistent-return.js"],"names":["astUtils","require","upperCaseFirst","isUnreachable","segment","reachable","isClassConstructor","node","type","parent","kind","module","exports","meta","docs","description","recommended","url","schema","properties","treatUndefinedAsUnspecified","default","additionalProperties","messages","missingReturn","missingReturnValue","unexpectedReturnValue","create","context","options","funcInfo","checkLastSegment","loc","name","hasReturnValue","codePath","currentSegments","every","isES5Constructor","line","column","getSourceCode","getTokenBefore","body","isArrowToken","method","key","id","getFirstToken","getFunctionNameWithKind","report","messageId","data","onCodePathStart","upper","hasReturn","onCodePathEnd","ReturnStatement","argument","Boolean","isSpecificId","operator"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAqBD,OAAO,CAAC,wBAAD,CAAlC,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASE,aAAT,CAAuBC,OAAvB,EAAgC;AAC5B,SAAO,CAACA,OAAO,CAACC,SAAhB;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BC,IAA5B,EAAkC;AAC9B,SAAOA,IAAI,CAACC,IAAL,KAAc,oBAAd,IACHD,IAAI,CAACE,MADF,IAEHF,IAAI,CAACE,MAAL,CAAYD,IAAZ,KAAqB,kBAFlB,IAGHD,IAAI,CAACE,MAAL,CAAYC,IAAZ,KAAqB,aAHzB;AAIH,C,CAED;AACA;AACA;;AAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFL,IAAAA,IAAI,EAAE,YADJ;AAGFM,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,sEADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CAAC;AACLV,MAAAA,IAAI,EAAE,QADD;AAELW,MAAAA,UAAU,EAAE;AACRC,QAAAA,2BAA2B,EAAE;AACzBZ,UAAAA,IAAI,EAAE,SADmB;AAEzBa,UAAAA,OAAO,EAAE;AAFgB;AADrB,OAFP;AAQLC,MAAAA,oBAAoB,EAAE;AARjB,KAAD,CATN;AAoBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,aAAa,EAAE,oDADT;AAENC,MAAAA,kBAAkB,EAAE,mCAFd;AAGNC,MAAAA,qBAAqB,EAAE;AAHjB;AApBR,GADO;;AA4BbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;AACA,UAAMT,2BAA2B,GAAGS,OAAO,CAACT,2BAAR,KAAwC,IAA5E;AACA,QAAIU,QAAQ,GAAG,IAAf;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,aAASC,gBAAT,CAA0BxB,IAA1B,EAAgC;AAC5B,UAAIyB,GAAJ,EAASC,IAAT;AAEA;AACZ;AACA;AACA;;AACY,UAAI,CAACH,QAAQ,CAACI,cAAV,IACAJ,QAAQ,CAACK,QAAT,CAAkBC,eAAlB,CAAkCC,KAAlC,CAAwClC,aAAxC,CADA,IAEAH,QAAQ,CAACsC,gBAAT,CAA0B/B,IAA1B,CAFA,IAGAD,kBAAkB,CAACC,IAAD,CAHtB,EAIE;AACE;AACH,OAb2B,CAe5B;;;AACA,UAAIA,IAAI,CAACC,IAAL,KAAc,SAAlB,EAA6B;AAEzB;AACAwB,QAAAA,GAAG,GAAG;AAAEO,UAAAA,IAAI,EAAE,CAAR;AAAWC,UAAAA,MAAM,EAAE;AAAnB,SAAN;AACAP,QAAAA,IAAI,GAAG,SAAP;AACH,OALD,MAKO,IAAI1B,IAAI,CAACC,IAAL,KAAc,yBAAlB,EAA6C;AAEhD;AACAwB,QAAAA,GAAG,GAAGJ,OAAO,CAACa,aAAR,GAAwBC,cAAxB,CAAuCnC,IAAI,CAACoC,IAA5C,EAAkD3C,QAAQ,CAAC4C,YAA3D,EAAyEZ,GAA/E;AACH,OAJM,MAIA,IACHzB,IAAI,CAACE,MAAL,CAAYD,IAAZ,KAAqB,kBAArB,IACCD,IAAI,CAACE,MAAL,CAAYD,IAAZ,KAAqB,UAArB,IAAmCD,IAAI,CAACE,MAAL,CAAYoC,MAF7C,EAGL;AAEE;AACAb,QAAAA,GAAG,GAAGzB,IAAI,CAACE,MAAL,CAAYqC,GAAZ,CAAgBd,GAAtB;AACH,OAPM,MAOA;AAEH;AACAA,QAAAA,GAAG,GAAG,CAACzB,IAAI,CAACwC,EAAL,IAAWnB,OAAO,CAACa,aAAR,GAAwBO,aAAxB,CAAsCzC,IAAtC,CAAZ,EAAyDyB,GAA/D;AACH;;AAED,UAAI,CAACC,IAAL,EAAW;AACPA,QAAAA,IAAI,GAAGjC,QAAQ,CAACiD,uBAAT,CAAiC1C,IAAjC,CAAP;AACH,OAxC2B,CA0C5B;;;AACAqB,MAAAA,OAAO,CAACsB,MAAR,CAAe;AACX3C,QAAAA,IADW;AAEXyB,QAAAA,GAFW;AAGXmB,QAAAA,SAAS,EAAE,eAHA;AAIXC,QAAAA,IAAI,EAAE;AAAEnB,UAAAA;AAAF;AAJK,OAAf;AAMH;;AAED,WAAO;AAEH;AACAoB,MAAAA,eAAe,CAAClB,QAAD,EAAW5B,IAAX,EAAiB;AAC5BuB,QAAAA,QAAQ,GAAG;AACPwB,UAAAA,KAAK,EAAExB,QADA;AAEPK,UAAAA,QAFO;AAGPoB,UAAAA,SAAS,EAAE,KAHJ;AAIPrB,UAAAA,cAAc,EAAE,KAJT;AAKPiB,UAAAA,SAAS,EAAE,EALJ;AAMP5C,UAAAA;AANO,SAAX;AAQH,OAZE;;AAaHiD,MAAAA,aAAa,GAAG;AACZ1B,QAAAA,QAAQ,GAAGA,QAAQ,CAACwB,KAApB;AACH,OAfE;;AAiBH;AACAG,MAAAA,eAAe,CAAClD,IAAD,EAAO;AAClB,cAAMmD,QAAQ,GAAGnD,IAAI,CAACmD,QAAtB;AACA,YAAIxB,cAAc,GAAGyB,OAAO,CAACD,QAAD,CAA5B;;AAEA,YAAItC,2BAA2B,IAAIc,cAAnC,EAAmD;AAC/CA,UAAAA,cAAc,GAAG,CAAClC,QAAQ,CAAC4D,YAAT,CAAsBF,QAAtB,EAAgC,WAAhC,CAAD,IAAiDA,QAAQ,CAACG,QAAT,KAAsB,MAAxF;AACH;;AAED,YAAI,CAAC/B,QAAQ,CAACyB,SAAd,EAAyB;AACrBzB,UAAAA,QAAQ,CAACyB,SAAT,GAAqB,IAArB;AACAzB,UAAAA,QAAQ,CAACI,cAAT,GAA0BA,cAA1B;AACAJ,UAAAA,QAAQ,CAACqB,SAAT,GAAqBjB,cAAc,GAAG,oBAAH,GAA0B,uBAA7D;AACAJ,UAAAA,QAAQ,CAACsB,IAAT,GAAgB;AACZnB,YAAAA,IAAI,EAAEH,QAAQ,CAACvB,IAAT,CAAcC,IAAd,KAAuB,SAAvB,GACA,SADA,GAEAN,cAAc,CAACF,QAAQ,CAACiD,uBAAT,CAAiCnB,QAAQ,CAACvB,IAA1C,CAAD;AAHR,WAAhB;AAKH,SATD,MASO,IAAIuB,QAAQ,CAACI,cAAT,KAA4BA,cAAhC,EAAgD;AACnDN,UAAAA,OAAO,CAACsB,MAAR,CAAe;AACX3C,YAAAA,IADW;AAEX4C,YAAAA,SAAS,EAAErB,QAAQ,CAACqB,SAFT;AAGXC,YAAAA,IAAI,EAAEtB,QAAQ,CAACsB;AAHJ,WAAf;AAKH;AACJ,OA1CE;;AA4CH;AACA,sBAAgBrB,gBA7Cb;AA8CH,kCAA4BA,gBA9CzB;AA+CH,iCAA2BA,gBA/CxB;AAgDH,sCAAgCA;AAhD7B,KAAP;AAkDH;;AA5IY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag consistent return values\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given code path segment is unreachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is unreachable.\r\n */\r\nfunction isUnreachable(segment) {\r\n    return !segment.reachable;\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a `constructor` method in an ES6 class\r\n * @param {ASTNode} node A node to check\r\n * @returns {boolean} `true` if the node is a `constructor` method\r\n */\r\nfunction isClassConstructor(node) {\r\n    return node.type === \"FunctionExpression\" &&\r\n        node.parent &&\r\n        node.parent.type === \"MethodDefinition\" &&\r\n        node.parent.kind === \"constructor\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require `return` statements to either always or never specify values\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/consistent-return\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                treatUndefinedAsUnspecified: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            missingReturn: \"Expected to return a value at the end of {{name}}.\",\r\n            missingReturnValue: \"{{name}} expected a return value.\",\r\n            unexpectedReturnValue: \"{{name}} expected no return value.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\r\n        let funcInfo = null;\r\n\r\n        /**\r\n         * Checks whether of not the implicit returning is consistent if the last\r\n         * code path segment is reachable.\r\n         * @param {ASTNode} node A program/function node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkLastSegment(node) {\r\n            let loc, name;\r\n\r\n            /*\r\n             * Skip if it expected no return value or unreachable.\r\n             * When unreachable, all paths are returned or thrown.\r\n             */\r\n            if (!funcInfo.hasReturnValue ||\r\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\r\n                astUtils.isES5Constructor(node) ||\r\n                isClassConstructor(node)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            // Adjust a location and a message.\r\n            if (node.type === \"Program\") {\r\n\r\n                // The head of program.\r\n                loc = { line: 1, column: 0 };\r\n                name = \"program\";\r\n            } else if (node.type === \"ArrowFunctionExpression\") {\r\n\r\n                // `=>` token\r\n                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc;\r\n            } else if (\r\n                node.parent.type === \"MethodDefinition\" ||\r\n                (node.parent.type === \"Property\" && node.parent.method)\r\n            ) {\r\n\r\n                // Method name.\r\n                loc = node.parent.key.loc;\r\n            } else {\r\n\r\n                // Function name or `function` keyword.\r\n                loc = (node.id || context.getSourceCode().getFirstToken(node)).loc;\r\n            }\r\n\r\n            if (!name) {\r\n                name = astUtils.getFunctionNameWithKind(node);\r\n            }\r\n\r\n            // Reports.\r\n            context.report({\r\n                node,\r\n                loc,\r\n                messageId: \"missingReturn\",\r\n                data: { name }\r\n            });\r\n        }\r\n\r\n        return {\r\n\r\n            // Initializes/Disposes state of each code path.\r\n            onCodePathStart(codePath, node) {\r\n                funcInfo = {\r\n                    upper: funcInfo,\r\n                    codePath,\r\n                    hasReturn: false,\r\n                    hasReturnValue: false,\r\n                    messageId: \"\",\r\n                    node\r\n                };\r\n            },\r\n            onCodePathEnd() {\r\n                funcInfo = funcInfo.upper;\r\n            },\r\n\r\n            // Reports a given return statement if it's inconsistent.\r\n            ReturnStatement(node) {\r\n                const argument = node.argument;\r\n                let hasReturnValue = Boolean(argument);\r\n\r\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\r\n                    hasReturnValue = !astUtils.isSpecificId(argument, \"undefined\") && argument.operator !== \"void\";\r\n                }\r\n\r\n                if (!funcInfo.hasReturn) {\r\n                    funcInfo.hasReturn = true;\r\n                    funcInfo.hasReturnValue = hasReturnValue;\r\n                    funcInfo.messageId = hasReturnValue ? \"missingReturnValue\" : \"unexpectedReturnValue\";\r\n                    funcInfo.data = {\r\n                        name: funcInfo.node.type === \"Program\"\r\n                            ? \"Program\"\r\n                            : upperCaseFirst(astUtils.getFunctionNameWithKind(funcInfo.node))\r\n                    };\r\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: funcInfo.messageId,\r\n                        data: funcInfo.data\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Reports a given program/function if the implicit returning is not consistent.\r\n            \"Program:exit\": checkLastSegment,\r\n            \"FunctionDeclaration:exit\": checkLastSegment,\r\n            \"FunctionExpression:exit\": checkLastSegment,\r\n            \"ArrowFunctionExpression:exit\": checkLastSegment\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}