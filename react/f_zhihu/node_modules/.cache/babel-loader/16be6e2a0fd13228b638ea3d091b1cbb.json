{"ast":null,"code":"/**\r\n * @fileoverview Rule to check empty newline after \"var\" statement\r\n * @author Gopal Venkatesan\r\n * @deprecated in ESLint v4.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow an empty line after variable declarations\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-after-var\"\n    },\n    schema: [{\n      enum: [\"never\", \"always\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expected: \"Expected blank line after variable declarations.\",\n      unexpected: \"Unexpected blank line after variable declarations.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Default `mode` to \"always\".\n\n    const mode = context.options[0] === \"never\" ? \"never\" : \"always\"; // Cache starting and ending line numbers of comments for faster lookup\n\n    const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\n      result[token.loc.start.line] = token.loc.end.line;\n      return result;\n    }, {}); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Gets a token from the given node to compare line to the next statement.\r\n     *\r\n     * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\r\n     *\r\n     * - The last token is semicolon.\r\n     * - The semicolon is on a different line from the previous token of the semicolon.\r\n     *\r\n     * This behavior would address semicolon-less style code. e.g.:\r\n     *\r\n     *     var foo = 1\r\n     *\r\n     *     ;(a || b).doSomething()\r\n     * @param {ASTNode} node The node to get.\r\n     * @returns {Token} The token to compare line to the next statement.\r\n     */\n\n    function getLastToken(node) {\n      const lastToken = sourceCode.getLastToken(node);\n\n      if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\n        const prevToken = sourceCode.getTokenBefore(lastToken);\n\n        if (prevToken.loc.end.line !== lastToken.loc.start.line) {\n          return prevToken;\n        }\n      }\n\n      return lastToken;\n    }\n    /**\r\n     * Determine if provided keyword is a variable declaration\r\n     * @private\r\n     * @param {string} keyword keyword to test\r\n     * @returns {boolean} True if `keyword` is a type of var\r\n     */\n\n\n    function isVar(keyword) {\n      return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n    }\n    /**\r\n     * Determine if provided keyword is a variant of for specifiers\r\n     * @private\r\n     * @param {string} keyword keyword to test\r\n     * @returns {boolean} True if `keyword` is a variant of for specifier\r\n     */\n\n\n    function isForTypeSpecifier(keyword) {\n      return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n    }\n    /**\r\n     * Determine if provided keyword is an export specifiers\r\n     * @private\r\n     * @param {string} nodeType nodeType to test\r\n     * @returns {boolean} True if `nodeType` is an export specifier\r\n     */\n\n\n    function isExportSpecifier(nodeType) {\n      return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" || nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n    }\n    /**\r\n     * Determine if provided node is the last of their parent block.\r\n     * @private\r\n     * @param {ASTNode} node node to test\r\n     * @returns {boolean} True if `node` is last of their parent block.\r\n     */\n\n\n    function isLastNode(node) {\n      const token = sourceCode.getTokenAfter(node);\n      return !token || token.type === \"Punctuator\" && token.value === \"}\";\n    }\n    /**\r\n     * Gets the last line of a group of consecutive comments\r\n     * @param {number} commentStartLine The starting line of the group\r\n     * @returns {number} The number of the last comment line of the group\r\n     */\n\n\n    function getLastCommentLineOfBlock(commentStartLine) {\n      const currentCommentEnd = commentEndLine[commentStartLine];\n      return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\n    }\n    /**\r\n     * Determine if a token starts more than one line after a comment ends\r\n     * @param {token} token The token being checked\r\n     * @param {integer} commentStartLine The line number on which the comment starts\r\n     * @returns {boolean} True if `token` does not start immediately after a comment\r\n     */\n\n\n    function hasBlankLineAfterComment(token, commentStartLine) {\n      return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\n    }\n    /**\r\n     * Checks that a blank line exists after a variable declaration when mode is\r\n     * set to \"always\", or checks that there is no blank line when mode is set\r\n     * to \"never\"\r\n     * @private\r\n     * @param {ASTNode} node `VariableDeclaration` node to test\r\n     * @returns {void}\r\n     */\n\n\n    function checkForBlankLine(node) {\n      /*\r\n       * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\r\n       * sometimes be second-last if there is a semicolon on a different line.\r\n       */\n      const lastToken = getLastToken(node),\n\n      /*\r\n       * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\r\n       * is the last token of the node.\r\n       */\n      nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\n            nextLineNum = lastToken.loc.end.line + 1; // Ignore if there is no following statement\n\n      if (!nextToken) {\n        return;\n      } // Ignore if parent of node is a for variant\n\n\n      if (isForTypeSpecifier(node.parent.type)) {\n        return;\n      } // Ignore if parent of node is an export specifier\n\n\n      if (isExportSpecifier(node.parent.type)) {\n        return;\n      }\n      /*\r\n       * Some coding styles use multiple `var` statements, so do nothing if\r\n       * the next token is a `var` statement.\r\n       */\n\n\n      if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n        return;\n      } // Ignore if it is last statement in a block\n\n\n      if (isLastNode(node)) {\n        return;\n      } // Next statement is not a `var`...\n\n\n      const noNextLineToken = nextToken.loc.start.line > nextLineNum;\n      const hasNextLineComment = typeof commentEndLine[nextLineNum] !== \"undefined\";\n\n      if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            identifier: node.name\n          },\n\n          fix(fixer) {\n            const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\n            return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\n          }\n\n        });\n      } // Token on the next line, or comment without blank line\n\n\n      if (mode === \"always\" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {\n        context.report({\n          node,\n          messageId: \"expected\",\n          data: {\n            identifier: node.name\n          },\n\n          fix(fixer) {\n            if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\n              return fixer.insertTextBefore(nextToken, \"\\n\\n\");\n            }\n\n            return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\n          }\n\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclaration: checkForBlankLine\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/newline-after-var.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","fixable","messages","expected","unexpected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","mode","options","commentEndLine","getAllComments","reduce","result","token","loc","start","line","end","getLastToken","node","lastToken","value","prevToken","getTokenBefore","isVar","keyword","isForTypeSpecifier","isExportSpecifier","nodeType","isLastNode","getTokenAfter","getLastCommentLineOfBlock","commentStartLine","currentCommentEnd","hasBlankLineAfterComment","checkForBlankLine","nextToken","nextLineNum","parent","noNextLineToken","hasNextLineComment","report","messageId","data","identifier","name","fix","fixer","linesBetween","getText","slice","range","split","LINEBREAK_MATCHER","replaceTextRange","join","length","insertTextBefore","insertTextBeforeRange","column","VariableDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check empty newline after \"var\" statement\r\n * @author Gopal Venkatesan\r\n * @deprecated in ESLint v4.0.0\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow an empty line after variable declarations\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/newline-after-var\"\r\n        },\r\n        schema: [\r\n            {\r\n                enum: [\"never\", \"always\"]\r\n            }\r\n        ],\r\n        fixable: \"whitespace\",\r\n        messages: {\r\n            expected: \"Expected blank line after variable declarations.\",\r\n            unexpected: \"Unexpected blank line after variable declarations.\"\r\n        },\r\n\r\n        deprecated: true,\r\n\r\n        replacedBy: [\"padding-line-between-statements\"]\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        // Default `mode` to \"always\".\r\n        const mode = context.options[0] === \"never\" ? \"never\" : \"always\";\r\n\r\n        // Cache starting and ending line numbers of comments for faster lookup\r\n        const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {\r\n            result[token.loc.start.line] = token.loc.end.line;\r\n            return result;\r\n        }, {});\r\n\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Gets a token from the given node to compare line to the next statement.\r\n         *\r\n         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.\r\n         *\r\n         * - The last token is semicolon.\r\n         * - The semicolon is on a different line from the previous token of the semicolon.\r\n         *\r\n         * This behavior would address semicolon-less style code. e.g.:\r\n         *\r\n         *     var foo = 1\r\n         *\r\n         *     ;(a || b).doSomething()\r\n         * @param {ASTNode} node The node to get.\r\n         * @returns {Token} The token to compare line to the next statement.\r\n         */\r\n        function getLastToken(node) {\r\n            const lastToken = sourceCode.getLastToken(node);\r\n\r\n            if (lastToken.type === \"Punctuator\" && lastToken.value === \";\") {\r\n                const prevToken = sourceCode.getTokenBefore(lastToken);\r\n\r\n                if (prevToken.loc.end.line !== lastToken.loc.start.line) {\r\n                    return prevToken;\r\n                }\r\n            }\r\n\r\n            return lastToken;\r\n        }\r\n\r\n        /**\r\n         * Determine if provided keyword is a variable declaration\r\n         * @private\r\n         * @param {string} keyword keyword to test\r\n         * @returns {boolean} True if `keyword` is a type of var\r\n         */\r\n        function isVar(keyword) {\r\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\r\n        }\r\n\r\n        /**\r\n         * Determine if provided keyword is a variant of for specifiers\r\n         * @private\r\n         * @param {string} keyword keyword to test\r\n         * @returns {boolean} True if `keyword` is a variant of for specifier\r\n         */\r\n        function isForTypeSpecifier(keyword) {\r\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\r\n        }\r\n\r\n        /**\r\n         * Determine if provided keyword is an export specifiers\r\n         * @private\r\n         * @param {string} nodeType nodeType to test\r\n         * @returns {boolean} True if `nodeType` is an export specifier\r\n         */\r\n        function isExportSpecifier(nodeType) {\r\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\r\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\r\n        }\r\n\r\n        /**\r\n         * Determine if provided node is the last of their parent block.\r\n         * @private\r\n         * @param {ASTNode} node node to test\r\n         * @returns {boolean} True if `node` is last of their parent block.\r\n         */\r\n        function isLastNode(node) {\r\n            const token = sourceCode.getTokenAfter(node);\r\n\r\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\r\n        }\r\n\r\n        /**\r\n         * Gets the last line of a group of consecutive comments\r\n         * @param {number} commentStartLine The starting line of the group\r\n         * @returns {number} The number of the last comment line of the group\r\n         */\r\n        function getLastCommentLineOfBlock(commentStartLine) {\r\n            const currentCommentEnd = commentEndLine[commentStartLine];\r\n\r\n            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;\r\n        }\r\n\r\n        /**\r\n         * Determine if a token starts more than one line after a comment ends\r\n         * @param {token} token The token being checked\r\n         * @param {integer} commentStartLine The line number on which the comment starts\r\n         * @returns {boolean} True if `token` does not start immediately after a comment\r\n         */\r\n        function hasBlankLineAfterComment(token, commentStartLine) {\r\n            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;\r\n        }\r\n\r\n        /**\r\n         * Checks that a blank line exists after a variable declaration when mode is\r\n         * set to \"always\", or checks that there is no blank line when mode is set\r\n         * to \"never\"\r\n         * @private\r\n         * @param {ASTNode} node `VariableDeclaration` node to test\r\n         * @returns {void}\r\n         */\r\n        function checkForBlankLine(node) {\r\n\r\n            /*\r\n             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will\r\n             * sometimes be second-last if there is a semicolon on a different line.\r\n             */\r\n            const lastToken = getLastToken(node),\r\n\r\n                /*\r\n                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken\r\n                 * is the last token of the node.\r\n                 */\r\n                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),\r\n                nextLineNum = lastToken.loc.end.line + 1;\r\n\r\n            // Ignore if there is no following statement\r\n            if (!nextToken) {\r\n                return;\r\n            }\r\n\r\n            // Ignore if parent of node is a for variant\r\n            if (isForTypeSpecifier(node.parent.type)) {\r\n                return;\r\n            }\r\n\r\n            // Ignore if parent of node is an export specifier\r\n            if (isExportSpecifier(node.parent.type)) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * Some coding styles use multiple `var` statements, so do nothing if\r\n             * the next token is a `var` statement.\r\n             */\r\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\r\n                return;\r\n            }\r\n\r\n            // Ignore if it is last statement in a block\r\n            if (isLastNode(node)) {\r\n                return;\r\n            }\r\n\r\n            // Next statement is not a `var`...\r\n            const noNextLineToken = nextToken.loc.start.line > nextLineNum;\r\n            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\r\n\r\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpected\",\r\n                    data: { identifier: node.name },\r\n                    fix(fixer) {\r\n                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);\r\n\r\n                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join(\"\")}\\n${linesBetween[linesBetween.length - 1]}`);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Token on the next line, or comment without blank line\r\n            if (\r\n                mode === \"always\" && (\r\n                    !noNextLineToken ||\r\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\r\n                )\r\n            ) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"expected\",\r\n                    data: { identifier: node.name },\r\n                    fix(fixer) {\r\n                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {\r\n                            return fixer.insertTextBefore(nextToken, \"\\n\\n\");\r\n                        }\r\n\r\n                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], \"\\n\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            VariableDeclaration: checkForBlankLine\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}