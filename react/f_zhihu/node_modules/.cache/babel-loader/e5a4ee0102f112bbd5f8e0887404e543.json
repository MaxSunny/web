{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of alert, confirm, prompt\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  getStaticPropertyName: getPropertyName,\n  getVariableByName,\n  skipChainExpression\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks if the given name is a prohibited identifier.\r\n * @param {string} name The name to check\r\n * @returns {boolean} Whether or not the name is prohibited.\r\n */\n\n\nfunction isProhibitedIdentifier(name) {\n  return /^(alert|confirm|prompt)$/u.test(name);\n}\n/**\r\n * Finds the eslint-scope reference in the given scope.\r\n * @param {Object} scope The scope to search.\r\n * @param {ASTNode} node The identifier node.\r\n * @returns {Reference|null} Returns the found reference or null if none were found.\r\n */\n\n\nfunction findReference(scope, node) {\n  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);\n\n  if (references.length === 1) {\n    return references[0];\n  }\n\n  return null;\n}\n/**\r\n * Checks if the given identifier node is shadowed in the given scope.\r\n * @param {Object} scope The current scope.\r\n * @param {string} node The identifier node to check\r\n * @returns {boolean} Whether or not the name is shadowed.\r\n */\n\n\nfunction isShadowed(scope, node) {\n  const reference = findReference(scope, node);\n  return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n/**\r\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\r\n * @param {Object} scope The current scope.\r\n * @param {string} node The identifier node to check\r\n * @returns {boolean} Whether or not the node is a reference to the global object.\r\n */\n\n\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\n  if (scope.type === \"global\" && node.type === \"ThisExpression\") {\n    return true;\n  }\n\n  if (node.type === \"Identifier\" && (node.name === \"window\" || node.name === \"globalThis\" && getVariableByName(scope, \"globalThis\"))) {\n    return !isShadowed(scope, node);\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-alert\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected {{name}}.\"\n    }\n  },\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        const callee = skipChainExpression(node.callee),\n              currentScope = context.getScope(); // without window.\n\n        if (callee.type === \"Identifier\") {\n          const name = callee.name;\n\n          if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                name\n              }\n            });\n          }\n        } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\n          const name = getPropertyName(callee);\n\n          if (isProhibitedIdentifier(name)) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                name\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-alert.js"],"names":["getStaticPropertyName","getPropertyName","getVariableByName","skipChainExpression","require","isProhibitedIdentifier","name","test","findReference","scope","node","references","filter","reference","identifier","range","length","isShadowed","resolved","defs","isGlobalThisReferenceOrGlobalWindow","type","module","exports","meta","docs","description","recommended","url","schema","messages","unexpected","create","context","CallExpression","callee","currentScope","getScope","report","messageId","data","object"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of alert, confirm, prompt\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst {\r\n    getStaticPropertyName: getPropertyName,\r\n    getVariableByName,\r\n    skipChainExpression\r\n} = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks if the given name is a prohibited identifier.\r\n * @param {string} name The name to check\r\n * @returns {boolean} Whether or not the name is prohibited.\r\n */\r\nfunction isProhibitedIdentifier(name) {\r\n    return /^(alert|confirm|prompt)$/u.test(name);\r\n}\r\n\r\n/**\r\n * Finds the eslint-scope reference in the given scope.\r\n * @param {Object} scope The scope to search.\r\n * @param {ASTNode} node The identifier node.\r\n * @returns {Reference|null} Returns the found reference or null if none were found.\r\n */\r\nfunction findReference(scope, node) {\r\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\r\n            reference.identifier.range[1] === node.range[1]);\r\n\r\n    if (references.length === 1) {\r\n        return references[0];\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if the given identifier node is shadowed in the given scope.\r\n * @param {Object} scope The current scope.\r\n * @param {string} node The identifier node to check\r\n * @returns {boolean} Whether or not the name is shadowed.\r\n */\r\nfunction isShadowed(scope, node) {\r\n    const reference = findReference(scope, node);\r\n\r\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\r\n}\r\n\r\n/**\r\n * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.\r\n * @param {Object} scope The current scope.\r\n * @param {string} node The identifier node to check\r\n * @returns {boolean} Whether or not the node is a reference to the global object.\r\n */\r\nfunction isGlobalThisReferenceOrGlobalWindow(scope, node) {\r\n    if (scope.type === \"global\" && node.type === \"ThisExpression\") {\r\n        return true;\r\n    }\r\n    if (\r\n        node.type === \"Identifier\" &&\r\n        (\r\n            node.name === \"window\" ||\r\n            (node.name === \"globalThis\" && getVariableByName(scope, \"globalThis\"))\r\n        )\r\n    ) {\r\n        return !isShadowed(scope, node);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow the use of `alert`, `confirm`, and `prompt`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-alert\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected {{name}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        return {\r\n            CallExpression(node) {\r\n                const callee = skipChainExpression(node.callee),\r\n                    currentScope = context.getScope();\r\n\r\n                // without window.\r\n                if (callee.type === \"Identifier\") {\r\n                    const name = callee.name;\r\n\r\n                    if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"unexpected\",\r\n                            data: { name }\r\n                        });\r\n                    }\r\n\r\n                } else if (callee.type === \"MemberExpression\" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {\r\n                    const name = getPropertyName(callee);\r\n\r\n                    if (isProhibitedIdentifier(name)) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"unexpected\",\r\n                            data: { name }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}