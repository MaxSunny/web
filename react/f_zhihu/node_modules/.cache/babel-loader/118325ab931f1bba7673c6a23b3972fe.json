{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\r\n * @author Jacob Moore\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow literal numbers that lose precision\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\n    },\n    schema: [],\n    messages: {\n      noLossOfPrecision: \"This number literal will lose precision at runtime.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Returns whether the node is number literal\r\n     * @param {Node} node the node literal being evaluated\r\n     * @returns {boolean} true if the node is a number literal\r\n     */\n    function isNumber(node) {\n      return typeof node.value === \"number\";\n    }\n    /**\r\n     * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\r\n     * @param {Node} node the number `Literal` node\r\n     * @returns {string} raw source code of the literal, without numeric separators\r\n     */\n\n\n    function getRaw(node) {\n      return node.raw.replace(/_/gu, \"\");\n    }\n    /**\r\n     * Checks whether the number is  base ten\r\n     * @param {ASTNode} node the node being evaluated\r\n     * @returns {boolean} true if the node is in base ten\r\n     */\n\n\n    function isBaseTen(node) {\n      const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\n      return prefixes.every(prefix => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);\n    }\n    /**\r\n     * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\r\n     * @param {Node} node the node being evaluated\r\n     * @returns {boolean} true if they do not match\r\n     */\n\n\n    function notBaseTenLosesPrecision(node) {\n      const rawString = getRaw(node).toUpperCase();\n      let base = 0;\n\n      if (rawString.startsWith(\"0B\")) {\n        base = 2;\n      } else if (rawString.startsWith(\"0X\")) {\n        base = 16;\n      } else {\n        base = 8;\n      }\n\n      return !rawString.endsWith(node.value.toString(base).toUpperCase());\n    }\n    /**\r\n     * Adds a decimal point to the numeric string at index 1\r\n     * @param {string} stringNumber the numeric string without any decimal point\r\n     * @returns {string} the numeric string with a decimal point in the proper place\r\n     */\n\n\n    function addDecimalPointToNumber(stringNumber) {\n      return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\n    }\n    /**\r\n     * Returns the number stripped of leading zeros\r\n     * @param {string} numberAsString the string representation of the number\r\n     * @returns {string} the stripped string\r\n     */\n\n\n    function removeLeadingZeros(numberAsString) {\n      return numberAsString.replace(/^0*/u, \"\");\n    }\n    /**\r\n     * Returns the number stripped of trailing zeros\r\n     * @param {string} numberAsString the string representation of the number\r\n     * @returns {string} the stripped string\r\n     */\n\n\n    function removeTrailingZeros(numberAsString) {\n      return numberAsString.replace(/0*$/u, \"\");\n    }\n    /**\r\n     * Converts an integer to to an object containing the integer's coefficient and order of magnitude\r\n     * @param {string} stringInteger the string representation of the integer being converted\r\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\r\n     */\n\n\n    function normalizeInteger(stringInteger) {\n      const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\n      return {\n        magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\n        coefficient: addDecimalPointToNumber(significantDigits)\n      };\n    }\n    /**\r\n     *\r\n     * Converts a float to to an object containing the floats's coefficient and order of magnitude\r\n     * @param {string} stringFloat the string representation of the float being converted\r\n     * @returns {Object} the object containing the integer's coefficient and order of magnitude\r\n     */\n\n\n    function normalizeFloat(stringFloat) {\n      const trimmedFloat = removeLeadingZeros(stringFloat);\n\n      if (trimmedFloat.startsWith(\".\")) {\n        const decimalDigits = trimmedFloat.split(\".\").pop();\n        const significantDigits = removeLeadingZeros(decimalDigits);\n        return {\n          magnitude: significantDigits.length - decimalDigits.length - 1,\n          coefficient: addDecimalPointToNumber(significantDigits)\n        };\n      }\n\n      return {\n        magnitude: trimmedFloat.indexOf(\".\") - 1,\n        coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\n      };\n    }\n    /**\r\n     * Converts a base ten number to proper scientific notation\r\n     * @param {string} stringNumber the string representation of the base ten number to be converted\r\n     * @returns {string} the number converted to scientific notation\r\n     */\n\n\n    function convertNumberToScientificNotation(stringNumber) {\n      const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\n      const originalCoefficient = splitNumber[0];\n      const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);\n      const normalizedCoefficient = normalizedNumber.coefficient;\n      const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;\n      return `${normalizedCoefficient}e${magnitude}`;\n    }\n    /**\r\n     * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\r\n     * @param {Node} node the node being evaluated\r\n     * @returns {boolean} true if they do not match\r\n     */\n\n\n    function baseTenLosesPrecision(node) {\n      const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\n      const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\n\n      if (requestedPrecision > 100) {\n        return true;\n      }\n\n      const storedNumber = node.value.toPrecision(requestedPrecision);\n      const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\n      return normalizedRawNumber !== normalizedStoredNumber;\n    }\n    /**\r\n     * Checks that the user-intended number equals the actual number after is has been converted to the Number type\r\n     * @param {Node} node the node being evaluated\r\n     * @returns {boolean} true if they do not match\r\n     */\n\n\n    function losesPrecision(node) {\n      return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\n    }\n\n    return {\n      Literal(node) {\n        if (node.value && isNumber(node) && losesPrecision(node)) {\n          context.report({\n            messageId: \"noLossOfPrecision\",\n            node\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-loss-of-precision.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","noLossOfPrecision","create","context","isNumber","node","value","getRaw","raw","replace","isBaseTen","prefixes","every","prefix","startsWith","test","notBaseTenLosesPrecision","rawString","toUpperCase","base","endsWith","toString","addDecimalPointToNumber","stringNumber","slice","removeLeadingZeros","numberAsString","removeTrailingZeros","normalizeInteger","stringInteger","significantDigits","magnitude","length","coefficient","normalizeFloat","stringFloat","trimmedFloat","decimalDigits","split","pop","indexOf","convertNumberToScientificNotation","splitNumber","originalCoefficient","normalizedNumber","includes","normalizedCoefficient","parseInt","baseTenLosesPrecision","normalizedRawNumber","requestedPrecision","storedNumber","toPrecision","normalizedStoredNumber","losesPrecision","Literal","report","messageId"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;;AACAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,SADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,8CADX;AAEFC,MAAAA,WAAW,EAAE,IAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AAQFC,IAAAA,MAAM,EAAE,EARN;AASFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,iBAAiB,EAAE;AADb;AATR,GADO;;AAebC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ;AACR;AACA;AACA;AACA;AACQ,aAASC,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,aAAO,OAAOA,IAAI,CAACC,KAAZ,KAAsB,QAA7B;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,MAAT,CAAgBF,IAAhB,EAAsB;AAClB,aAAOA,IAAI,CAACG,GAAL,CAASC,OAAT,CAAiB,KAAjB,EAAwB,EAAxB,CAAP;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,SAAT,CAAmBL,IAAnB,EAAyB;AACrB,YAAMM,QAAQ,GAAG,CAAC,IAAD,EAAO,IAAP,EAAa,IAAb,EAAmB,IAAnB,EAAyB,IAAzB,EAA+B,IAA/B,CAAjB;AAEA,aAAOA,QAAQ,CAACC,KAAT,CAAeC,MAAM,IAAI,CAACR,IAAI,CAACG,GAAL,CAASM,UAAT,CAAoBD,MAApB,CAA1B,KACP,CAAC,aAAaE,IAAb,CAAkBV,IAAI,CAACG,GAAvB,CADD;AAEH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASQ,wBAAT,CAAkCX,IAAlC,EAAwC;AACpC,YAAMY,SAAS,GAAGV,MAAM,CAACF,IAAD,CAAN,CAAaa,WAAb,EAAlB;AACA,UAAIC,IAAI,GAAG,CAAX;;AAEA,UAAIF,SAAS,CAACH,UAAV,CAAqB,IAArB,CAAJ,EAAgC;AAC5BK,QAAAA,IAAI,GAAG,CAAP;AACH,OAFD,MAEO,IAAIF,SAAS,CAACH,UAAV,CAAqB,IAArB,CAAJ,EAAgC;AACnCK,QAAAA,IAAI,GAAG,EAAP;AACH,OAFM,MAEA;AACHA,QAAAA,IAAI,GAAG,CAAP;AACH;;AAED,aAAO,CAACF,SAAS,CAACG,QAAV,CAAmBf,IAAI,CAACC,KAAL,CAAWe,QAAX,CAAoBF,IAApB,EAA0BD,WAA1B,EAAnB,CAAR;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASI,uBAAT,CAAiCC,YAAjC,EAA+C;AAC3C,aAAQ,GAAEA,YAAY,CAACC,KAAb,CAAmB,CAAnB,EAAsB,CAAtB,CAAyB,IAAGD,YAAY,CAACC,KAAb,CAAmB,CAAnB,CAAsB,EAA5D;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,kBAAT,CAA4BC,cAA5B,EAA4C;AACxC,aAAOA,cAAc,CAACjB,OAAf,CAAuB,MAAvB,EAA+B,EAA/B,CAAP;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASkB,mBAAT,CAA6BD,cAA7B,EAA6C;AACzC,aAAOA,cAAc,CAACjB,OAAf,CAAuB,MAAvB,EAA+B,EAA/B,CAAP;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASmB,gBAAT,CAA0BC,aAA1B,EAAyC;AACrC,YAAMC,iBAAiB,GAAGH,mBAAmB,CAACF,kBAAkB,CAACI,aAAD,CAAnB,CAA7C;AAEA,aAAO;AACHE,QAAAA,SAAS,EAAEF,aAAa,CAACf,UAAd,CAAyB,GAAzB,IAAgCe,aAAa,CAACG,MAAd,GAAuB,CAAvD,GAA2DH,aAAa,CAACG,MAAd,GAAuB,CAD1F;AAEHC,QAAAA,WAAW,EAAEX,uBAAuB,CAACQ,iBAAD;AAFjC,OAAP;AAIH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASI,cAAT,CAAwBC,WAAxB,EAAqC;AACjC,YAAMC,YAAY,GAAGX,kBAAkB,CAACU,WAAD,CAAvC;;AAEA,UAAIC,YAAY,CAACtB,UAAb,CAAwB,GAAxB,CAAJ,EAAkC;AAC9B,cAAMuB,aAAa,GAAGD,YAAY,CAACE,KAAb,CAAmB,GAAnB,EAAwBC,GAAxB,EAAtB;AACA,cAAMT,iBAAiB,GAAGL,kBAAkB,CAACY,aAAD,CAA5C;AAEA,eAAO;AACHN,UAAAA,SAAS,EAAED,iBAAiB,CAACE,MAAlB,GAA2BK,aAAa,CAACL,MAAzC,GAAkD,CAD1D;AAEHC,UAAAA,WAAW,EAAEX,uBAAuB,CAACQ,iBAAD;AAFjC,SAAP;AAKH;;AACD,aAAO;AACHC,QAAAA,SAAS,EAAEK,YAAY,CAACI,OAAb,CAAqB,GAArB,IAA4B,CADpC;AAEHP,QAAAA,WAAW,EAAEX,uBAAuB,CAACc,YAAY,CAAC3B,OAAb,CAAqB,GAArB,EAA0B,EAA1B,CAAD;AAFjC,OAAP;AAKH;AAGD;AACR;AACA;AACA;AACA;;;AACQ,aAASgC,iCAAT,CAA2ClB,YAA3C,EAAyD;AACrD,YAAMmB,WAAW,GAAGnB,YAAY,CAACd,OAAb,CAAqB,GAArB,EAA0B,GAA1B,EAA+B6B,KAA/B,CAAqC,GAArC,CAApB;AACA,YAAMK,mBAAmB,GAAGD,WAAW,CAAC,CAAD,CAAvC;AACA,YAAME,gBAAgB,GAAGrB,YAAY,CAACsB,QAAb,CAAsB,GAAtB,IAA6BX,cAAc,CAACS,mBAAD,CAA3C,GACnBf,gBAAgB,CAACe,mBAAD,CADtB;AAEA,YAAMG,qBAAqB,GAAGF,gBAAgB,CAACX,WAA/C;AACA,YAAMF,SAAS,GAAGW,WAAW,CAACV,MAAZ,GAAqB,CAArB,GAA0Be,QAAQ,CAACL,WAAW,CAAC,CAAD,CAAZ,EAAiB,EAAjB,CAAR,GAA+BE,gBAAgB,CAACb,SAA1E,GACZa,gBAAgB,CAACb,SADvB;AAGA,aAAQ,GAAEe,qBAAsB,IAAGf,SAAU,EAA7C;AAEH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASiB,qBAAT,CAA+B3C,IAA/B,EAAqC;AACjC,YAAM4C,mBAAmB,GAAGR,iCAAiC,CAAClC,MAAM,CAACF,IAAD,CAAP,CAA7D;AACA,YAAM6C,kBAAkB,GAAGD,mBAAmB,CAACX,KAApB,CAA0B,GAA1B,EAA+B,CAA/B,EAAkC7B,OAAlC,CAA0C,GAA1C,EAA+C,EAA/C,EAAmDuB,MAA9E;;AAEA,UAAIkB,kBAAkB,GAAG,GAAzB,EAA8B;AAC1B,eAAO,IAAP;AACH;;AACD,YAAMC,YAAY,GAAG9C,IAAI,CAACC,KAAL,CAAW8C,WAAX,CAAuBF,kBAAvB,CAArB;AACA,YAAMG,sBAAsB,GAAGZ,iCAAiC,CAACU,YAAD,CAAhE;AAEA,aAAOF,mBAAmB,KAAKI,sBAA/B;AACH;AAGD;AACR;AACA;AACA;AACA;;;AACQ,aAASC,cAAT,CAAwBjD,IAAxB,EAA8B;AAC1B,aAAOK,SAAS,CAACL,IAAD,CAAT,GAAkB2C,qBAAqB,CAAC3C,IAAD,CAAvC,GAAgDW,wBAAwB,CAACX,IAAD,CAA/E;AACH;;AAGD,WAAO;AACHkD,MAAAA,OAAO,CAAClD,IAAD,EAAO;AACV,YAAIA,IAAI,CAACC,KAAL,IAAcF,QAAQ,CAACC,IAAD,CAAtB,IAAgCiD,cAAc,CAACjD,IAAD,CAAlD,EAA0D;AACtDF,UAAAA,OAAO,CAACqD,MAAR,CAAe;AACXC,YAAAA,SAAS,EAAE,mBADA;AAEXpD,YAAAA;AAFW,WAAf;AAIH;AACJ;;AARE,KAAP;AAUH;;AAhMY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag numbers that will lose significant figure precision at runtime\r\n * @author Jacob Moore\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow literal numbers that lose precision\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-loss-of-precision\"\r\n        },\r\n        schema: [],\r\n        messages: {\r\n            noLossOfPrecision: \"This number literal will lose precision at runtime.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Returns whether the node is number literal\r\n         * @param {Node} node the node literal being evaluated\r\n         * @returns {boolean} true if the node is a number literal\r\n         */\r\n        function isNumber(node) {\r\n            return typeof node.value === \"number\";\r\n        }\r\n\r\n        /**\r\n         * Gets the source code of the given number literal. Removes `_` numeric separators from the result.\r\n         * @param {Node} node the number `Literal` node\r\n         * @returns {string} raw source code of the literal, without numeric separators\r\n         */\r\n        function getRaw(node) {\r\n            return node.raw.replace(/_/gu, \"\");\r\n        }\r\n\r\n        /**\r\n         * Checks whether the number is  base ten\r\n         * @param {ASTNode} node the node being evaluated\r\n         * @returns {boolean} true if the node is in base ten\r\n         */\r\n        function isBaseTen(node) {\r\n            const prefixes = [\"0x\", \"0X\", \"0b\", \"0B\", \"0o\", \"0O\"];\r\n\r\n            return prefixes.every(prefix => !node.raw.startsWith(prefix)) &&\r\n            !/^0[0-7]+$/u.test(node.raw);\r\n        }\r\n\r\n        /**\r\n         * Checks that the user-intended non-base ten number equals the actual number after is has been converted to the Number type\r\n         * @param {Node} node the node being evaluated\r\n         * @returns {boolean} true if they do not match\r\n         */\r\n        function notBaseTenLosesPrecision(node) {\r\n            const rawString = getRaw(node).toUpperCase();\r\n            let base = 0;\r\n\r\n            if (rawString.startsWith(\"0B\")) {\r\n                base = 2;\r\n            } else if (rawString.startsWith(\"0X\")) {\r\n                base = 16;\r\n            } else {\r\n                base = 8;\r\n            }\r\n\r\n            return !rawString.endsWith(node.value.toString(base).toUpperCase());\r\n        }\r\n\r\n        /**\r\n         * Adds a decimal point to the numeric string at index 1\r\n         * @param {string} stringNumber the numeric string without any decimal point\r\n         * @returns {string} the numeric string with a decimal point in the proper place\r\n         */\r\n        function addDecimalPointToNumber(stringNumber) {\r\n            return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;\r\n        }\r\n\r\n        /**\r\n         * Returns the number stripped of leading zeros\r\n         * @param {string} numberAsString the string representation of the number\r\n         * @returns {string} the stripped string\r\n         */\r\n        function removeLeadingZeros(numberAsString) {\r\n            return numberAsString.replace(/^0*/u, \"\");\r\n        }\r\n\r\n        /**\r\n         * Returns the number stripped of trailing zeros\r\n         * @param {string} numberAsString the string representation of the number\r\n         * @returns {string} the stripped string\r\n         */\r\n        function removeTrailingZeros(numberAsString) {\r\n            return numberAsString.replace(/0*$/u, \"\");\r\n        }\r\n\r\n        /**\r\n         * Converts an integer to to an object containing the integer's coefficient and order of magnitude\r\n         * @param {string} stringInteger the string representation of the integer being converted\r\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\r\n         */\r\n        function normalizeInteger(stringInteger) {\r\n            const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));\r\n\r\n            return {\r\n                magnitude: stringInteger.startsWith(\"0\") ? stringInteger.length - 2 : stringInteger.length - 1,\r\n                coefficient: addDecimalPointToNumber(significantDigits)\r\n            };\r\n        }\r\n\r\n        /**\r\n         *\r\n         * Converts a float to to an object containing the floats's coefficient and order of magnitude\r\n         * @param {string} stringFloat the string representation of the float being converted\r\n         * @returns {Object} the object containing the integer's coefficient and order of magnitude\r\n         */\r\n        function normalizeFloat(stringFloat) {\r\n            const trimmedFloat = removeLeadingZeros(stringFloat);\r\n\r\n            if (trimmedFloat.startsWith(\".\")) {\r\n                const decimalDigits = trimmedFloat.split(\".\").pop();\r\n                const significantDigits = removeLeadingZeros(decimalDigits);\r\n\r\n                return {\r\n                    magnitude: significantDigits.length - decimalDigits.length - 1,\r\n                    coefficient: addDecimalPointToNumber(significantDigits)\r\n                };\r\n\r\n            }\r\n            return {\r\n                magnitude: trimmedFloat.indexOf(\".\") - 1,\r\n                coefficient: addDecimalPointToNumber(trimmedFloat.replace(\".\", \"\"))\r\n\r\n            };\r\n        }\r\n\r\n\r\n        /**\r\n         * Converts a base ten number to proper scientific notation\r\n         * @param {string} stringNumber the string representation of the base ten number to be converted\r\n         * @returns {string} the number converted to scientific notation\r\n         */\r\n        function convertNumberToScientificNotation(stringNumber) {\r\n            const splitNumber = stringNumber.replace(\"E\", \"e\").split(\"e\");\r\n            const originalCoefficient = splitNumber[0];\r\n            const normalizedNumber = stringNumber.includes(\".\") ? normalizeFloat(originalCoefficient)\r\n                : normalizeInteger(originalCoefficient);\r\n            const normalizedCoefficient = normalizedNumber.coefficient;\r\n            const magnitude = splitNumber.length > 1 ? (parseInt(splitNumber[1], 10) + normalizedNumber.magnitude)\r\n                : normalizedNumber.magnitude;\r\n\r\n            return `${normalizedCoefficient}e${magnitude}`;\r\n\r\n        }\r\n\r\n        /**\r\n         * Checks that the user-intended base ten number equals the actual number after is has been converted to the Number type\r\n         * @param {Node} node the node being evaluated\r\n         * @returns {boolean} true if they do not match\r\n         */\r\n        function baseTenLosesPrecision(node) {\r\n            const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));\r\n            const requestedPrecision = normalizedRawNumber.split(\"e\")[0].replace(\".\", \"\").length;\r\n\r\n            if (requestedPrecision > 100) {\r\n                return true;\r\n            }\r\n            const storedNumber = node.value.toPrecision(requestedPrecision);\r\n            const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);\r\n\r\n            return normalizedRawNumber !== normalizedStoredNumber;\r\n        }\r\n\r\n\r\n        /**\r\n         * Checks that the user-intended number equals the actual number after is has been converted to the Number type\r\n         * @param {Node} node the node being evaluated\r\n         * @returns {boolean} true if they do not match\r\n         */\r\n        function losesPrecision(node) {\r\n            return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);\r\n        }\r\n\r\n\r\n        return {\r\n            Literal(node) {\r\n                if (node.value && isNumber(node) && losesPrecision(node)) {\r\n                    context.report({\r\n                        messageId: \"noLossOfPrecision\",\r\n                        node\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}