{"ast":null,"code":"/**\r\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\r\n * @author Annie Zhang, Pavel Strashkin\r\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst esutils = require(\"esutils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\r\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\r\n * @param {ASTNode} pattern The left side of the AssignmentExpression\r\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\r\n */\n\n\nfunction isModuleExports(pattern) {\n  if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\n    // module.exports\n    if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\n      return true;\n    } // module[\"exports\"]\n\n\n    if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * Determines if a string name is a valid identifier\r\n * @param {string} name The string to be checked\r\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\r\n * @returns {boolean} True if the string is a valid identifier\r\n */\n\n\nfunction isIdentifier(name, ecmaVersion) {\n  if (ecmaVersion >= 6) {\n    return esutils.keyword.isIdentifierES6(name);\n  }\n\n  return esutils.keyword.isIdentifierES5(name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst alwaysOrNever = {\n  enum: [\"always\", \"never\"]\n};\nconst optionsObject = {\n  type: \"object\",\n  properties: {\n    considerPropertyDescriptor: {\n      type: \"boolean\"\n    },\n    includeCommonJSModuleExports: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require function names to match the name of the variable or property to which they are assigned\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-name-matching\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        additionalItems: false,\n        items: [alwaysOrNever, optionsObject]\n      }, {\n        type: \"array\",\n        additionalItems: false,\n        items: [optionsObject]\n      }]\n    },\n    messages: {\n      matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\n      matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\n      notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\n      notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\n    const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\n    const considerPropertyDescriptor = options.considerPropertyDescriptor;\n    const includeModuleExports = options.includeCommonJSModuleExports;\n    const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\n    /**\r\n     * Check whether node is a certain CallExpression.\r\n     * @param {string} objName object name\r\n     * @param {string} funcName function name\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} `true` if node matches CallExpression\r\n     */\n\n    function isPropertyCall(objName, funcName, node) {\n      if (!node) {\n        return false;\n      }\n\n      return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\n    }\n    /**\r\n     * Compares identifiers based on the nameMatches option\r\n     * @param {string} x the first identifier\r\n     * @param {string} y the second identifier\r\n     * @returns {boolean} whether the two identifiers should warn.\r\n     */\n\n\n    function shouldWarn(x, y) {\n      return nameMatches === \"always\" && x !== y || nameMatches === \"never\" && x === y;\n    }\n    /**\r\n     * Reports\r\n     * @param {ASTNode} node The node to report\r\n     * @param {string} name The variable or property name\r\n     * @param {string} funcName The function name\r\n     * @param {boolean} isProp True if the reported node is a property assignment\r\n     * @returns {void}\r\n     */\n\n\n    function report(node, name, funcName, isProp) {\n      let messageId;\n\n      if (nameMatches === \"always\" && isProp) {\n        messageId = \"matchProperty\";\n      } else if (nameMatches === \"always\") {\n        messageId = \"matchVariable\";\n      } else if (isProp) {\n        messageId = \"notMatchProperty\";\n      } else {\n        messageId = \"notMatchVariable\";\n      }\n\n      context.report({\n        node,\n        messageId,\n        data: {\n          name,\n          funcName\n        }\n      });\n    }\n    /**\r\n     * Determines whether a given node is a string literal\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} `true` if the node is a string literal\r\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator(node) {\n        if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\n          return;\n        }\n\n        if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\n          report(node, node.id.name, node.init.id.name, false);\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (node.right.type !== \"FunctionExpression\" || node.left.computed && node.left.property.type !== \"Literal\" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\") {\n          return;\n        }\n\n        const isProp = node.left.type === \"MemberExpression\";\n        const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\n\n        if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\n          report(node, name, node.right.id.name, isProp);\n        }\n      },\n\n      \"Property, PropertyDefinition[value]\"(node) {\n        if (!(node.value.type === \"FunctionExpression\" && node.value.id)) {\n          return;\n        }\n\n        if (node.key.type === \"Identifier\" && !node.computed) {\n          const functionName = node.value.id.name;\n          let propertyName = node.key.name;\n\n          if (considerPropertyDescriptor && propertyName === \"value\" && node.parent.type === \"ObjectExpression\") {\n            if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\n              const property = node.parent.parent.arguments[1];\n\n              if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\n                report(node, property.value, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\n              propertyName = node.parent.parent.key.name;\n\n              if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\n                report(node, propertyName, functionName, true);\n              }\n            } else if (shouldWarn(propertyName, functionName)) {\n              report(node, propertyName, functionName, true);\n            }\n          } else if (shouldWarn(propertyName, functionName)) {\n            report(node, propertyName, functionName, true);\n          }\n\n          return;\n        }\n\n        if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {\n          report(node, node.key.value, node.value.id.name, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/func-name-matching.js"],"names":["astUtils","require","esutils","isModuleExports","pattern","type","object","name","property","value","isIdentifier","ecmaVersion","keyword","isIdentifierES6","isIdentifierES5","alwaysOrNever","enum","optionsObject","properties","considerPropertyDescriptor","includeCommonJSModuleExports","additionalProperties","module","exports","meta","docs","description","recommended","url","schema","anyOf","additionalItems","items","messages","matchProperty","matchVariable","notMatchProperty","notMatchVariable","create","context","options","nameMatches","includeModuleExports","parserOptions","isPropertyCall","objName","funcName","node","isSpecificMemberAccess","callee","shouldWarn","x","y","report","isProp","messageId","data","isStringLiteral","VariableDeclarator","init","id","AssignmentExpression","right","left","computed","getStaticPropertyName","key","functionName","propertyName","parent","arguments"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.\r\n * @author Annie Zhang, Pavel Strashkin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//--------------------------------------------------------------------------\r\n// Requirements\r\n//--------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst esutils = require(\"esutils\");\r\n\r\n//--------------------------------------------------------------------------\r\n// Helpers\r\n//--------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if a pattern is `module.exports` or `module[\"exports\"]`\r\n * @param {ASTNode} pattern The left side of the AssignmentExpression\r\n * @returns {boolean} True if the pattern is `module.exports` or `module[\"exports\"]`\r\n */\r\nfunction isModuleExports(pattern) {\r\n    if (pattern.type === \"MemberExpression\" && pattern.object.type === \"Identifier\" && pattern.object.name === \"module\") {\r\n\r\n        // module.exports\r\n        if (pattern.property.type === \"Identifier\" && pattern.property.name === \"exports\") {\r\n            return true;\r\n        }\r\n\r\n        // module[\"exports\"]\r\n        if (pattern.property.type === \"Literal\" && pattern.property.value === \"exports\") {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines if a string name is a valid identifier\r\n * @param {string} name The string to be checked\r\n * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config\r\n * @returns {boolean} True if the string is a valid identifier\r\n */\r\nfunction isIdentifier(name, ecmaVersion) {\r\n    if (ecmaVersion >= 6) {\r\n        return esutils.keyword.isIdentifierES6(name);\r\n    }\r\n    return esutils.keyword.isIdentifierES5(name);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst alwaysOrNever = { enum: [\"always\", \"never\"] };\r\nconst optionsObject = {\r\n    type: \"object\",\r\n    properties: {\r\n        considerPropertyDescriptor: {\r\n            type: \"boolean\"\r\n        },\r\n        includeCommonJSModuleExports: {\r\n            type: \"boolean\"\r\n        }\r\n    },\r\n    additionalProperties: false\r\n};\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require function names to match the name of the variable or property to which they are assigned\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/func-name-matching\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [{\r\n                type: \"array\",\r\n                additionalItems: false,\r\n                items: [alwaysOrNever, optionsObject]\r\n            }, {\r\n                type: \"array\",\r\n                additionalItems: false,\r\n                items: [optionsObject]\r\n            }]\r\n        },\r\n\r\n        messages: {\r\n            matchProperty: \"Function name `{{funcName}}` should match property name `{{name}}`.\",\r\n            matchVariable: \"Function name `{{funcName}}` should match variable name `{{name}}`.\",\r\n            notMatchProperty: \"Function name `{{funcName}}` should not match property name `{{name}}`.\",\r\n            notMatchVariable: \"Function name `{{funcName}}` should not match variable name `{{name}}`.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = (typeof context.options[0] === \"object\" ? context.options[0] : context.options[1]) || {};\r\n        const nameMatches = typeof context.options[0] === \"string\" ? context.options[0] : \"always\";\r\n        const considerPropertyDescriptor = options.considerPropertyDescriptor;\r\n        const includeModuleExports = options.includeCommonJSModuleExports;\r\n        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;\r\n\r\n        /**\r\n         * Check whether node is a certain CallExpression.\r\n         * @param {string} objName object name\r\n         * @param {string} funcName function name\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} `true` if node matches CallExpression\r\n         */\r\n        function isPropertyCall(objName, funcName, node) {\r\n            if (!node) {\r\n                return false;\r\n            }\r\n            return node.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);\r\n        }\r\n\r\n        /**\r\n         * Compares identifiers based on the nameMatches option\r\n         * @param {string} x the first identifier\r\n         * @param {string} y the second identifier\r\n         * @returns {boolean} whether the two identifiers should warn.\r\n         */\r\n        function shouldWarn(x, y) {\r\n            return (nameMatches === \"always\" && x !== y) || (nameMatches === \"never\" && x === y);\r\n        }\r\n\r\n        /**\r\n         * Reports\r\n         * @param {ASTNode} node The node to report\r\n         * @param {string} name The variable or property name\r\n         * @param {string} funcName The function name\r\n         * @param {boolean} isProp True if the reported node is a property assignment\r\n         * @returns {void}\r\n         */\r\n        function report(node, name, funcName, isProp) {\r\n            let messageId;\r\n\r\n            if (nameMatches === \"always\" && isProp) {\r\n                messageId = \"matchProperty\";\r\n            } else if (nameMatches === \"always\") {\r\n                messageId = \"matchVariable\";\r\n            } else if (isProp) {\r\n                messageId = \"notMatchProperty\";\r\n            } else {\r\n                messageId = \"notMatchVariable\";\r\n            }\r\n            context.report({\r\n                node,\r\n                messageId,\r\n                data: {\r\n                    name,\r\n                    funcName\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Determines whether a given node is a string literal\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} `true` if the node is a string literal\r\n         */\r\n        function isStringLiteral(node) {\r\n            return node.type === \"Literal\" && typeof node.value === \"string\";\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            VariableDeclarator(node) {\r\n                if (!node.init || node.init.type !== \"FunctionExpression\" || node.id.type !== \"Identifier\") {\r\n                    return;\r\n                }\r\n                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {\r\n                    report(node, node.id.name, node.init.id.name, false);\r\n                }\r\n            },\r\n\r\n            AssignmentExpression(node) {\r\n                if (\r\n                    node.right.type !== \"FunctionExpression\" ||\r\n                    (node.left.computed && node.left.property.type !== \"Literal\") ||\r\n                    (!includeModuleExports && isModuleExports(node.left)) ||\r\n                    (node.left.type !== \"Identifier\" && node.left.type !== \"MemberExpression\")\r\n                ) {\r\n                    return;\r\n                }\r\n\r\n                const isProp = node.left.type === \"MemberExpression\";\r\n                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;\r\n\r\n                if (node.right.id && name && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {\r\n                    report(node, name, node.right.id.name, isProp);\r\n                }\r\n            },\r\n\r\n            \"Property, PropertyDefinition[value]\"(node) {\r\n                if (!(node.value.type === \"FunctionExpression\" && node.value.id)) {\r\n                    return;\r\n                }\r\n\r\n                if (node.key.type === \"Identifier\" && !node.computed) {\r\n                    const functionName = node.value.id.name;\r\n                    let propertyName = node.key.name;\r\n\r\n                    if (\r\n                        considerPropertyDescriptor &&\r\n                        propertyName === \"value\" &&\r\n                        node.parent.type === \"ObjectExpression\"\r\n                    ) {\r\n                        if (isPropertyCall(\"Object\", \"defineProperty\", node.parent.parent) || isPropertyCall(\"Reflect\", \"defineProperty\", node.parent.parent)) {\r\n                            const property = node.parent.parent.arguments[1];\r\n\r\n                            if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {\r\n                                report(node, property.value, functionName, true);\r\n                            }\r\n                        } else if (isPropertyCall(\"Object\", \"defineProperties\", node.parent.parent.parent.parent)) {\r\n                            propertyName = node.parent.parent.key.name;\r\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\r\n                                report(node, propertyName, functionName, true);\r\n                            }\r\n                        } else if (isPropertyCall(\"Object\", \"create\", node.parent.parent.parent.parent)) {\r\n                            propertyName = node.parent.parent.key.name;\r\n                            if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {\r\n                                report(node, propertyName, functionName, true);\r\n                            }\r\n                        } else if (shouldWarn(propertyName, functionName)) {\r\n                            report(node, propertyName, functionName, true);\r\n                        }\r\n                    } else if (shouldWarn(propertyName, functionName)) {\r\n                        report(node, propertyName, functionName, true);\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (\r\n                    isStringLiteral(node.key) &&\r\n                    isIdentifier(node.key.value, ecmaVersion) &&\r\n                    shouldWarn(node.key.value, node.value.id.name)\r\n                ) {\r\n                    report(node, node.key.value, node.value.id.name, true);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}