{"ast":null,"code":"/**\r\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\r\n * @author Teddy Katz\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst ruleFixer = require(\"./rule-fixer\");\n\nconst interpolate = require(\"./interpolate\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\r\n * An error message description\r\n * @typedef {Object} MessageDescriptor\r\n * @property {ASTNode} [node] The reported node\r\n * @property {Location} loc The location of the problem.\r\n * @property {string} message The problem message.\r\n * @property {Object} [data] Optional data to use to fill in placeholders in the\r\n *      message.\r\n * @property {Function} [fix] The function to call that creates a fix command.\r\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\r\n */\n\n/**\r\n * Information about the report\r\n * @typedef {Object} ReportInfo\r\n * @property {string} ruleId The rule ID\r\n * @property {(0|1|2)} severity Severity of the error\r\n * @property {(string|undefined)} message The message\r\n * @property {(string|undefined)} [messageId] The message ID\r\n * @property {number} line The line number\r\n * @property {number} column The column number\r\n * @property {(number|undefined)} [endLine] The ending line number\r\n * @property {(number|undefined)} [endColumn] The ending column number\r\n * @property {(string|null)} nodeType Type of node\r\n * @property {string} source Source text\r\n * @property {({text: string, range: (number[]|null)}|null)} [fix] The fix object\r\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions] Suggestion info\r\n */\n//------------------------------------------------------------------------------\n// Module Definition\n//------------------------------------------------------------------------------\n\n/**\r\n * Translates a multi-argument context.report() call into a single object argument call\r\n * @param {...*} args A list of arguments passed to `context.report`\r\n * @returns {MessageDescriptor} A normalized object containing report information\r\n */\n\n\nfunction normalizeMultiArgReportCall() {\n  // If there is one argument, it is considered to be a new-style call already.\n  if (arguments.length === 1) {\n    // Shallow clone the object to avoid surprises if reusing the descriptor\n    return Object.assign({}, arguments.length <= 0 ? undefined : arguments[0]);\n  } // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\n\n\n  if (typeof (arguments.length <= 1 ? undefined : arguments[1]) === \"string\") {\n    return {\n      node: arguments.length <= 0 ? undefined : arguments[0],\n      message: arguments.length <= 1 ? undefined : arguments[1],\n      data: arguments.length <= 2 ? undefined : arguments[2],\n      fix: arguments.length <= 3 ? undefined : arguments[3]\n    };\n  } // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\n\n\n  return {\n    node: arguments.length <= 0 ? undefined : arguments[0],\n    loc: arguments.length <= 1 ? undefined : arguments[1],\n    message: arguments.length <= 2 ? undefined : arguments[2],\n    data: arguments.length <= 3 ? undefined : arguments[3],\n    fix: arguments.length <= 4 ? undefined : arguments[4]\n  };\n}\n/**\r\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\r\n * @param {MessageDescriptor} descriptor A descriptor to validate\r\n * @returns {void}\r\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\r\n */\n\n\nfunction assertValidNodeInfo(descriptor) {\n  if (descriptor.node) {\n    assert(typeof descriptor.node === \"object\", \"Node must be an object\");\n  } else {\n    assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\n  }\n}\n/**\r\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\r\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\r\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\r\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\r\n */\n\n\nfunction normalizeReportLoc(descriptor) {\n  if (descriptor.loc) {\n    if (descriptor.loc.start) {\n      return descriptor.loc;\n    }\n\n    return {\n      start: descriptor.loc,\n      end: null\n    };\n  }\n\n  return descriptor.node.loc;\n}\n/**\r\n * Check that a fix has a valid range.\r\n * @param {Fix|null} fix The fix to validate.\r\n * @returns {void}\r\n */\n\n\nfunction assertValidFix(fix) {\n  if (fix) {\n    assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\n  }\n}\n/**\r\n * Compares items in a fixes array by range.\r\n * @param {Fix} a The first message.\r\n * @param {Fix} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\n\n\nfunction compareFixesByRange(a, b) {\n  return a.range[0] - b.range[0] || a.range[1] - b.range[1];\n}\n/**\r\n * Merges the given fixes array into one.\r\n * @param {Fix[]} fixes The fixes to merge.\r\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\r\n * @returns {{text: string, range: number[]}} The merged fixes\r\n */\n\n\nfunction mergeFixes(fixes, sourceCode) {\n  for (const fix of fixes) {\n    assertValidFix(fix);\n  }\n\n  if (fixes.length === 0) {\n    return null;\n  }\n\n  if (fixes.length === 1) {\n    return fixes[0];\n  }\n\n  fixes.sort(compareFixesByRange);\n  const originalText = sourceCode.text;\n  const start = fixes[0].range[0];\n  const end = fixes[fixes.length - 1].range[1];\n  let text = \"\";\n  let lastPos = Number.MIN_SAFE_INTEGER;\n\n  for (const fix of fixes) {\n    assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\n\n    if (fix.range[0] >= 0) {\n      text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\n    }\n\n    text += fix.text;\n    lastPos = fix.range[1];\n  }\n\n  text += originalText.slice(Math.max(0, start, lastPos), end);\n  return {\n    range: [start, end],\n    text\n  };\n}\n/**\r\n * Gets one fix object from the given descriptor.\r\n * If the descriptor retrieves multiple fixes, this merges those to one.\r\n * @param {MessageDescriptor} descriptor The report descriptor.\r\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\r\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\r\n */\n\n\nfunction normalizeFixes(descriptor, sourceCode) {\n  if (typeof descriptor.fix !== \"function\") {\n    return null;\n  } // @type {null | Fix | Fix[] | IterableIterator<Fix>}\n\n\n  const fix = descriptor.fix(ruleFixer); // Merge to one.\n\n  if (fix && Symbol.iterator in fix) {\n    return mergeFixes(Array.from(fix), sourceCode);\n  }\n\n  assertValidFix(fix);\n  return fix;\n}\n/**\r\n * Gets an array of suggestion objects from the given descriptor.\r\n * @param {MessageDescriptor} descriptor The report descriptor.\r\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\r\n * @param {Object} messages Object of meta messages for the rule.\r\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\r\n */\n\n\nfunction mapSuggestions(descriptor, sourceCode, messages) {\n  if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\n    return [];\n  }\n\n  return descriptor.suggest.map(suggestInfo => {\n    const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\n    return { ...suggestInfo,\n      desc: interpolate(computedDesc, suggestInfo.data),\n      fix: normalizeFixes(suggestInfo, sourceCode)\n    };\n  }) // Remove suggestions that didn't provide a fix\n  .filter(_ref => {\n    let {\n      fix\n    } = _ref;\n    return fix;\n  });\n}\n/**\r\n * Creates information about the report from a descriptor\r\n * @param {Object} options Information about the problem\r\n * @param {string} options.ruleId Rule ID\r\n * @param {(0|1|2)} options.severity Rule severity\r\n * @param {(ASTNode|null)} options.node Node\r\n * @param {string} options.message Error message\r\n * @param {string} [options.messageId] The error message ID.\r\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\r\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\r\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\r\n * @returns {function(...args): ReportInfo} Function that returns information about the report\r\n */\n\n\nfunction createProblem(options) {\n  const problem = {\n    ruleId: options.ruleId,\n    severity: options.severity,\n    message: options.message,\n    line: options.loc.start.line,\n    column: options.loc.start.column + 1,\n    nodeType: options.node && options.node.type || null\n  };\n  /*\r\n   * If this isn’t in the conditional, some of the tests fail\r\n   * because `messageId` is present in the problem object\r\n   */\n\n  if (options.messageId) {\n    problem.messageId = options.messageId;\n  }\n\n  if (options.loc.end) {\n    problem.endLine = options.loc.end.line;\n    problem.endColumn = options.loc.end.column + 1;\n  }\n\n  if (options.fix) {\n    problem.fix = options.fix;\n  }\n\n  if (options.suggestions && options.suggestions.length > 0) {\n    problem.suggestions = options.suggestions;\n  }\n\n  return problem;\n}\n/**\r\n * Validates that suggestions are properly defined. Throws if an error is detected.\r\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\r\n * @param {Object} messages Object of meta messages for the rule.\r\n * @returns {void}\r\n */\n\n\nfunction validateSuggestions(suggest, messages) {\n  if (suggest && Array.isArray(suggest)) {\n    suggest.forEach(suggestion => {\n      if (suggestion.messageId) {\n        const {\n          messageId\n        } = suggestion;\n\n        if (!messages) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\n        }\n\n        if (!messages[messageId]) {\n          throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n        }\n\n        if (suggestion.desc) {\n          throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\n        }\n      } else if (!suggestion.desc) {\n        throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\n      }\n\n      if (typeof suggestion.fix !== \"function\") {\n        throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\n      }\n    });\n  }\n}\n/**\r\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\r\n * problem for the Node.js API.\r\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\r\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\r\n * @returns {function(...args): ReportInfo} Function that returns information about the report\r\n */\n\n\nmodule.exports = function createReportTranslator(metadata) {\n  /*\r\n   * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\r\n   * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\r\n   * called every time a rule reports a problem, which happens much less frequently (usually, the vast\r\n   * majority of rules don't report any problems for a given file).\r\n   */\n  return function () {\n    const descriptor = normalizeMultiArgReportCall(...arguments);\n    const messages = metadata.messageIds;\n    assertValidNodeInfo(descriptor);\n    let computedMessage;\n\n    if (descriptor.messageId) {\n      if (!messages) {\n        throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\n      }\n\n      const id = descriptor.messageId;\n\n      if (descriptor.message) {\n        throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\n      }\n\n      if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\n        throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\n      }\n\n      computedMessage = messages[id];\n    } else if (descriptor.message) {\n      computedMessage = descriptor.message;\n    } else {\n      throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\n    }\n\n    validateSuggestions(descriptor.suggest, messages);\n    return createProblem({\n      ruleId: metadata.ruleId,\n      severity: metadata.severity,\n      node: descriptor.node,\n      message: interpolate(computedMessage, descriptor.data),\n      messageId: descriptor.messageId,\n      loc: normalizeReportLoc(descriptor),\n      fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\n      suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\n    });\n  };\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/report-translator.js"],"names":["assert","require","ruleFixer","interpolate","normalizeMultiArgReportCall","length","Object","assign","node","message","data","fix","loc","assertValidNodeInfo","descriptor","normalizeReportLoc","start","end","assertValidFix","range","JSON","stringify","compareFixesByRange","a","b","mergeFixes","fixes","sourceCode","sort","originalText","text","lastPos","Number","MIN_SAFE_INTEGER","slice","Math","max","normalizeFixes","Symbol","iterator","Array","from","mapSuggestions","messages","suggest","isArray","map","suggestInfo","computedDesc","desc","messageId","filter","createProblem","options","problem","ruleId","severity","line","column","nodeType","type","endLine","endColumn","suggestions","validateSuggestions","forEach","suggestion","TypeError","module","exports","createReportTranslator","metadata","messageIds","computedMessage","id","prototype","hasOwnProperty","call","disableFixes"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects\r\n * @author Teddy Katz\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst assert = require(\"assert\");\r\nconst ruleFixer = require(\"./rule-fixer\");\r\nconst interpolate = require(\"./interpolate\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * An error message description\r\n * @typedef {Object} MessageDescriptor\r\n * @property {ASTNode} [node] The reported node\r\n * @property {Location} loc The location of the problem.\r\n * @property {string} message The problem message.\r\n * @property {Object} [data] Optional data to use to fill in placeholders in the\r\n *      message.\r\n * @property {Function} [fix] The function to call that creates a fix command.\r\n * @property {Array<{desc?: string, messageId?: string, fix: Function}>} suggest Suggestion descriptions and functions to create a the associated fixes.\r\n */\r\n\r\n/**\r\n * Information about the report\r\n * @typedef {Object} ReportInfo\r\n * @property {string} ruleId The rule ID\r\n * @property {(0|1|2)} severity Severity of the error\r\n * @property {(string|undefined)} message The message\r\n * @property {(string|undefined)} [messageId] The message ID\r\n * @property {number} line The line number\r\n * @property {number} column The column number\r\n * @property {(number|undefined)} [endLine] The ending line number\r\n * @property {(number|undefined)} [endColumn] The ending column number\r\n * @property {(string|null)} nodeType Type of node\r\n * @property {string} source Source text\r\n * @property {({text: string, range: (number[]|null)}|null)} [fix] The fix object\r\n * @property {Array<{text: string, range: (number[]|null)}|null>} [suggestions] Suggestion info\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Module Definition\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n/**\r\n * Translates a multi-argument context.report() call into a single object argument call\r\n * @param {...*} args A list of arguments passed to `context.report`\r\n * @returns {MessageDescriptor} A normalized object containing report information\r\n */\r\nfunction normalizeMultiArgReportCall(...args) {\r\n\r\n    // If there is one argument, it is considered to be a new-style call already.\r\n    if (args.length === 1) {\r\n\r\n        // Shallow clone the object to avoid surprises if reusing the descriptor\r\n        return Object.assign({}, args[0]);\r\n    }\r\n\r\n    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].\r\n    if (typeof args[1] === \"string\") {\r\n        return {\r\n            node: args[0],\r\n            message: args[1],\r\n            data: args[2],\r\n            fix: args[3]\r\n        };\r\n    }\r\n\r\n    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].\r\n    return {\r\n        node: args[0],\r\n        loc: args[1],\r\n        message: args[2],\r\n        data: args[3],\r\n        fix: args[4]\r\n    };\r\n}\r\n\r\n/**\r\n * Asserts that either a loc or a node was provided, and the node is valid if it was provided.\r\n * @param {MessageDescriptor} descriptor A descriptor to validate\r\n * @returns {void}\r\n * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object\r\n */\r\nfunction assertValidNodeInfo(descriptor) {\r\n    if (descriptor.node) {\r\n        assert(typeof descriptor.node === \"object\", \"Node must be an object\");\r\n    } else {\r\n        assert(descriptor.loc, \"Node must be provided when reporting error if location is not provided\");\r\n    }\r\n}\r\n\r\n/**\r\n * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties\r\n * @param {MessageDescriptor} descriptor A descriptor for the report from a rule.\r\n * @returns {{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties\r\n * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.\r\n */\r\nfunction normalizeReportLoc(descriptor) {\r\n    if (descriptor.loc) {\r\n        if (descriptor.loc.start) {\r\n            return descriptor.loc;\r\n        }\r\n        return { start: descriptor.loc, end: null };\r\n    }\r\n    return descriptor.node.loc;\r\n}\r\n\r\n/**\r\n * Check that a fix has a valid range.\r\n * @param {Fix|null} fix The fix to validate.\r\n * @returns {void}\r\n */\r\nfunction assertValidFix(fix) {\r\n    if (fix) {\r\n        assert(fix.range && typeof fix.range[0] === \"number\" && typeof fix.range[1] === \"number\", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Compares items in a fixes array by range.\r\n * @param {Fix} a The first message.\r\n * @param {Fix} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\r\nfunction compareFixesByRange(a, b) {\r\n    return a.range[0] - b.range[0] || a.range[1] - b.range[1];\r\n}\r\n\r\n/**\r\n * Merges the given fixes array into one.\r\n * @param {Fix[]} fixes The fixes to merge.\r\n * @param {SourceCode} sourceCode The source code object to get the text between fixes.\r\n * @returns {{text: string, range: number[]}} The merged fixes\r\n */\r\nfunction mergeFixes(fixes, sourceCode) {\r\n    for (const fix of fixes) {\r\n        assertValidFix(fix);\r\n    }\r\n\r\n    if (fixes.length === 0) {\r\n        return null;\r\n    }\r\n    if (fixes.length === 1) {\r\n        return fixes[0];\r\n    }\r\n\r\n    fixes.sort(compareFixesByRange);\r\n\r\n    const originalText = sourceCode.text;\r\n    const start = fixes[0].range[0];\r\n    const end = fixes[fixes.length - 1].range[1];\r\n    let text = \"\";\r\n    let lastPos = Number.MIN_SAFE_INTEGER;\r\n\r\n    for (const fix of fixes) {\r\n        assert(fix.range[0] >= lastPos, \"Fix objects must not be overlapped in a report.\");\r\n\r\n        if (fix.range[0] >= 0) {\r\n            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);\r\n        }\r\n        text += fix.text;\r\n        lastPos = fix.range[1];\r\n    }\r\n    text += originalText.slice(Math.max(0, start, lastPos), end);\r\n\r\n    return { range: [start, end], text };\r\n}\r\n\r\n/**\r\n * Gets one fix object from the given descriptor.\r\n * If the descriptor retrieves multiple fixes, this merges those to one.\r\n * @param {MessageDescriptor} descriptor The report descriptor.\r\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\r\n * @returns {({text: string, range: number[]}|null)} The fix for the descriptor\r\n */\r\nfunction normalizeFixes(descriptor, sourceCode) {\r\n    if (typeof descriptor.fix !== \"function\") {\r\n        return null;\r\n    }\r\n\r\n    // @type {null | Fix | Fix[] | IterableIterator<Fix>}\r\n    const fix = descriptor.fix(ruleFixer);\r\n\r\n    // Merge to one.\r\n    if (fix && Symbol.iterator in fix) {\r\n        return mergeFixes(Array.from(fix), sourceCode);\r\n    }\r\n\r\n    assertValidFix(fix);\r\n    return fix;\r\n}\r\n\r\n/**\r\n * Gets an array of suggestion objects from the given descriptor.\r\n * @param {MessageDescriptor} descriptor The report descriptor.\r\n * @param {SourceCode} sourceCode The source code object to get text between fixes.\r\n * @param {Object} messages Object of meta messages for the rule.\r\n * @returns {Array<SuggestionResult>} The suggestions for the descriptor\r\n */\r\nfunction mapSuggestions(descriptor, sourceCode, messages) {\r\n    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {\r\n        return [];\r\n    }\r\n\r\n    return descriptor.suggest\r\n        .map(suggestInfo => {\r\n            const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];\r\n\r\n            return {\r\n                ...suggestInfo,\r\n                desc: interpolate(computedDesc, suggestInfo.data),\r\n                fix: normalizeFixes(suggestInfo, sourceCode)\r\n            };\r\n        })\r\n\r\n        // Remove suggestions that didn't provide a fix\r\n        .filter(({ fix }) => fix);\r\n}\r\n\r\n/**\r\n * Creates information about the report from a descriptor\r\n * @param {Object} options Information about the problem\r\n * @param {string} options.ruleId Rule ID\r\n * @param {(0|1|2)} options.severity Rule severity\r\n * @param {(ASTNode|null)} options.node Node\r\n * @param {string} options.message Error message\r\n * @param {string} [options.messageId] The error message ID.\r\n * @param {{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location\r\n * @param {{text: string, range: (number[]|null)}} options.fix The fix object\r\n * @param {Array<{text: string, range: (number[]|null)}>} options.suggestions The array of suggestions objects\r\n * @returns {function(...args): ReportInfo} Function that returns information about the report\r\n */\r\nfunction createProblem(options) {\r\n    const problem = {\r\n        ruleId: options.ruleId,\r\n        severity: options.severity,\r\n        message: options.message,\r\n        line: options.loc.start.line,\r\n        column: options.loc.start.column + 1,\r\n        nodeType: options.node && options.node.type || null\r\n    };\r\n\r\n    /*\r\n     * If this isn’t in the conditional, some of the tests fail\r\n     * because `messageId` is present in the problem object\r\n     */\r\n    if (options.messageId) {\r\n        problem.messageId = options.messageId;\r\n    }\r\n\r\n    if (options.loc.end) {\r\n        problem.endLine = options.loc.end.line;\r\n        problem.endColumn = options.loc.end.column + 1;\r\n    }\r\n\r\n    if (options.fix) {\r\n        problem.fix = options.fix;\r\n    }\r\n\r\n    if (options.suggestions && options.suggestions.length > 0) {\r\n        problem.suggestions = options.suggestions;\r\n    }\r\n\r\n    return problem;\r\n}\r\n\r\n/**\r\n * Validates that suggestions are properly defined. Throws if an error is detected.\r\n * @param {Array<{ desc?: string, messageId?: string }>} suggest The incoming suggest data.\r\n * @param {Object} messages Object of meta messages for the rule.\r\n * @returns {void}\r\n */\r\nfunction validateSuggestions(suggest, messages) {\r\n    if (suggest && Array.isArray(suggest)) {\r\n        suggest.forEach(suggestion => {\r\n            if (suggestion.messageId) {\r\n                const { messageId } = suggestion;\r\n\r\n                if (!messages) {\r\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);\r\n                }\r\n\r\n                if (!messages[messageId]) {\r\n                    throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\r\n                }\r\n\r\n                if (suggestion.desc) {\r\n                    throw new TypeError(\"context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.\");\r\n                }\r\n            } else if (!suggestion.desc) {\r\n                throw new TypeError(\"context.report() called with a suggest option that doesn't have either a `desc` or `messageId`\");\r\n            }\r\n\r\n            if (typeof suggestion.fix !== \"function\") {\r\n                throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a function that converts the arguments of a `context.report` call from a rule into a reported\r\n * problem for the Node.js API.\r\n * @param {{ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean}} metadata Metadata for the reported problem\r\n * @param {SourceCode} sourceCode The `SourceCode` instance for the text being linted\r\n * @returns {function(...args): ReportInfo} Function that returns information about the report\r\n */\r\n\r\nmodule.exports = function createReportTranslator(metadata) {\r\n\r\n    /*\r\n     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.\r\n     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets\r\n     * called every time a rule reports a problem, which happens much less frequently (usually, the vast\r\n     * majority of rules don't report any problems for a given file).\r\n     */\r\n    return (...args) => {\r\n        const descriptor = normalizeMultiArgReportCall(...args);\r\n        const messages = metadata.messageIds;\r\n\r\n        assertValidNodeInfo(descriptor);\r\n\r\n        let computedMessage;\r\n\r\n        if (descriptor.messageId) {\r\n            if (!messages) {\r\n                throw new TypeError(\"context.report() called with a messageId, but no messages were present in the rule metadata.\");\r\n            }\r\n            const id = descriptor.messageId;\r\n\r\n            if (descriptor.message) {\r\n                throw new TypeError(\"context.report() called with a message and a messageId. Please only pass one.\");\r\n            }\r\n            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {\r\n                throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);\r\n            }\r\n            computedMessage = messages[id];\r\n        } else if (descriptor.message) {\r\n            computedMessage = descriptor.message;\r\n        } else {\r\n            throw new TypeError(\"Missing `message` property in report() call; add a message that describes the linting problem.\");\r\n        }\r\n\r\n        validateSuggestions(descriptor.suggest, messages);\r\n\r\n        return createProblem({\r\n            ruleId: metadata.ruleId,\r\n            severity: metadata.severity,\r\n            node: descriptor.node,\r\n            message: interpolate(computedMessage, descriptor.data),\r\n            messageId: descriptor.messageId,\r\n            loc: normalizeReportLoc(descriptor),\r\n            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),\r\n            suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)\r\n        });\r\n    };\r\n};\r\n"]},"metadata":{},"sourceType":"script"}