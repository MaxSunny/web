{"ast":null,"code":"/**\r\n * @fileoverview Mocha test wrapper\r\n * @author Ilya Volodin\r\n */\n\"use strict\";\n/* eslint-env mocha -- Mocha wrapper */\n\n/*\r\n * This is a wrapper around mocha to allow for DRY unittests for eslint\r\n * Format:\r\n * RuleTester.run(\"{ruleName}\", {\r\n *      valid: [\r\n *          \"{code}\",\r\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\r\n *      ],\r\n *      invalid: [\r\n *          { code: \"{code}\", errors: {numErrors} },\r\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\r\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\r\n *      ]\r\n *  });\r\n *\r\n * Variables:\r\n * {code} - String that represents the code to be tested\r\n * {options} - Arguments that are passed to the configurable rules.\r\n * {globals} - An object representing a list of variables that are\r\n *             registered as globals\r\n * {parser} - String representing the parser to use\r\n * {settings} - An object representing global settings for all rules\r\n * {numErrors} - If failing case doesn't need to check error message,\r\n *               this integer will specify how many errors should be\r\n *               received\r\n * {errorMessage} - Message that is returned by the rule on failure\r\n * {errorNodeType} - AST node type that is returned by they rule as\r\n *                   a cause of the failure.\r\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      path = require(\"path\"),\n      util = require(\"util\"),\n      merge = require(\"lodash.merge\"),\n      equal = require(\"fast-deep-equal\"),\n      Traverser = require(\"../../lib/shared/traverser\"),\n      {\n  getRuleOptionsSchema,\n  validate\n} = require(\"../shared/config-validator\"),\n      {\n  Linter,\n  SourceCodeFixer,\n  interpolate\n} = require(\"../linter\");\n\nconst ajv = require(\"../shared/ajv\")({\n  strictDefaults: true\n});\n\nconst espreePath = require.resolve(\"espree\");\n\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\n\nconst {\n  SourceCode\n} = require(\"../source-code\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../shared/types\").Parser} Parser */\n\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n\n/**\r\n * A test case that is expected to pass lint.\r\n * @typedef {Object} ValidTestCase\r\n * @property {string} [name] Name for the test case.\r\n * @property {string} code Code for the test case.\r\n * @property {any[]} [options] Options for the test case.\r\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\r\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\r\n * @property {string} [parser] The absolute path for the parser.\r\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\r\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\r\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\r\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\r\n */\n\n/**\r\n * A test case that is expected to fail lint.\r\n * @typedef {Object} InvalidTestCase\r\n * @property {string} [name] Name for the test case.\r\n * @property {string} code Code for the test case.\r\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\r\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\r\n * @property {any[]} [options] Options for the test case.\r\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\r\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\r\n * @property {string} [parser] The absolute path for the parser.\r\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\r\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\r\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\r\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\r\n */\n\n/**\r\n * A description of a reported error used in a rule tester test.\r\n * @typedef {Object} TestCaseError\r\n * @property {string | RegExp} [message] Message.\r\n * @property {string} [messageId] Message ID.\r\n * @property {string} [type] The type of the reported AST node.\r\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\r\n * @property {number} [line] The 1-based line number of the reported start location.\r\n * @property {number} [column] The 1-based column number of the reported start location.\r\n * @property {number} [endLine] The 1-based line number of the reported end location.\r\n * @property {number} [endColumn] The 1-based column number of the reported end location.\r\n */\n\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\n//------------------------------------------------------------------------------\n// Private Members\n//------------------------------------------------------------------------------\n\n/*\r\n * testerDefaultConfig must not be modified as it allows to reset the tester to\r\n * the initial default configuration\r\n */\n\n\nconst testerDefaultConfig = {\n  rules: {}\n};\nlet defaultConfig = {\n  rules: {}\n};\n/*\r\n * List every parameters possible on a test case that are not related to eslint\r\n * configuration\r\n */\n\nconst RuleTesterParameters = [\"name\", \"code\", \"filename\", \"options\", \"errors\", \"output\", \"only\"];\n/*\r\n * All allowed property names in error objects.\r\n */\n\nconst errorObjectParameters = new Set([\"message\", \"messageId\", \"data\", \"type\", \"line\", \"column\", \"endLine\", \"endColumn\", \"suggestions\"]);\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\n/*\r\n * All allowed property names in suggestion objects.\r\n */\n\nconst suggestionObjectParameters = new Set([\"desc\", \"messageId\", \"data\", \"output\"]);\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\n/**\r\n * Clones a given value deeply.\r\n * Note: This ignores `parent` property.\r\n * @param {any} x A value to clone.\r\n * @returns {any} A cloned value.\r\n */\n\nfunction cloneDeeplyExcludesParent(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      return x.map(cloneDeeplyExcludesParent);\n    }\n\n    const retv = {};\n\n    for (const key in x) {\n      if (key !== \"parent\" && hasOwnProperty(x, key)) {\n        retv[key] = cloneDeeplyExcludesParent(x[key]);\n      }\n    }\n\n    return retv;\n  }\n\n  return x;\n}\n/**\r\n * Freezes a given value deeply.\r\n * @param {any} x A value to freeze.\r\n * @returns {void}\r\n */\n\n\nfunction freezeDeeply(x) {\n  if (typeof x === \"object\" && x !== null) {\n    if (Array.isArray(x)) {\n      x.forEach(freezeDeeply);\n    } else {\n      for (const key in x) {\n        if (key !== \"parent\" && hasOwnProperty(x, key)) {\n          freezeDeeply(x[key]);\n        }\n      }\n    }\n\n    Object.freeze(x);\n  }\n}\n/**\r\n * Replace control characters by `\\u00xx` form.\r\n * @param {string} text The text to sanitize.\r\n * @returns {string} The sanitized text.\r\n */\n\n\nfunction sanitize(text) {\n  if (typeof text !== \"string\") {\n    return \"\";\n  }\n\n  return text.replace(/[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\n  c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`);\n}\n/**\r\n * Define `start`/`end` properties as throwing error.\r\n * @param {string} objName Object name used for error messages.\r\n * @param {ASTNode} node The node to define.\r\n * @returns {void}\r\n */\n\n\nfunction defineStartEndAsError(objName, node) {\n  Object.defineProperties(node, {\n    start: {\n      get() {\n        throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\n      },\n\n      configurable: true,\n      enumerable: false\n    },\n    end: {\n      get() {\n        throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\n      },\n\n      configurable: true,\n      enumerable: false\n    }\n  });\n}\n/**\r\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\r\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\r\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\r\n * @returns {void}\r\n */\n\n\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\n  Traverser.traverse(ast, {\n    visitorKeys,\n    enter: defineStartEndAsError.bind(null, \"node\")\n  });\n  ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\n  ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\n}\n/**\r\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\r\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\r\n * @param {Parser} parser Parser object.\r\n * @returns {Parser} Wrapped parser object.\r\n */\n\n\nfunction wrapParser(parser) {\n  if (typeof parser.parseForESLint === \"function\") {\n    return {\n      [parserSymbol]: parser,\n\n      parseForESLint() {\n        const ret = parser.parseForESLint(...arguments);\n        defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\n        return ret;\n      }\n\n    };\n  }\n\n  return {\n    [parserSymbol]: parser,\n\n    parse() {\n      const ast = parser.parse(...arguments);\n      defineStartEndAsErrorInTree(ast);\n      return ast;\n    }\n\n  };\n}\n/**\r\n * Function to replace `SourceCode.prototype.getComments`.\r\n * @returns {void}\r\n * @throws {Error} Deprecation message.\r\n */\n\n\nfunction getCommentsDeprecation() {\n  throw new Error(\"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\");\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n// default separators for testing\n\n\nconst DESCRIBE = Symbol(\"describe\");\nconst IT = Symbol(\"it\");\nconst IT_ONLY = Symbol(\"itOnly\");\n/**\r\n * This is `it` default handler if `it` don't exist.\r\n * @this {Mocha}\r\n * @param {string} text The description of the test case.\r\n * @param {Function} method The logic of the test case.\r\n * @throws {Error} Any error upon execution of `method`.\r\n * @returns {any} Returned value of `method`.\r\n */\n\nfunction itDefaultHandler(text, method) {\n  try {\n    return method.call(this);\n  } catch (err) {\n    if (err instanceof assert.AssertionError) {\n      err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\n    }\n\n    throw err;\n  }\n}\n/**\r\n * This is `describe` default handler if `describe` don't exist.\r\n * @this {Mocha}\r\n * @param {string} text The description of the test case.\r\n * @param {Function} method The logic of the test case.\r\n * @returns {any} Returned value of `method`.\r\n */\n\n\nfunction describeDefaultHandler(text, method) {\n  return method.call(this);\n}\n/**\r\n * Mocha test wrapper.\r\n */\n\n\nclass RuleTester {\n  /**\r\n   * Creates a new instance of RuleTester.\r\n   * @param {Object} [testerConfig] Optional, extra configuration for the tester\r\n   */\n  constructor(testerConfig) {\n    /**\r\n     * The configuration to use for this tester. Combination of the tester\r\n     * configuration and the default configuration.\r\n     * @type {Object}\r\n     */\n    this.testerConfig = merge({}, defaultConfig, testerConfig, {\n      rules: {\n        \"rule-tester/validate-ast\": \"error\"\n      }\n    });\n    /**\r\n     * Rule definitions to define before tests.\r\n     * @type {Object}\r\n     */\n\n    this.rules = {};\n    this.linter = new Linter();\n  }\n  /**\r\n   * Set the configuration to use for all future tests\r\n   * @param {Object} config the configuration to use.\r\n   * @throws {TypeError} If non-object config.\r\n   * @returns {void}\r\n   */\n\n\n  static setDefaultConfig(config) {\n    if (typeof config !== \"object\") {\n      throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\n    }\n\n    defaultConfig = config; // Make sure the rules object exists since it is assumed to exist later\n\n    defaultConfig.rules = defaultConfig.rules || {};\n  }\n  /**\r\n   * Get the current configuration used for all tests\r\n   * @returns {Object} the current configuration\r\n   */\n\n\n  static getDefaultConfig() {\n    return defaultConfig;\n  }\n  /**\r\n   * Reset the configuration to the initial configuration of the tester removing\r\n   * any changes made until now.\r\n   * @returns {void}\r\n   */\n\n\n  static resetDefaultConfig() {\n    defaultConfig = merge({}, testerDefaultConfig);\n  }\n  /*\r\n   * If people use `mocha test.js --watch` command, `describe` and `it` function\r\n   * instances are different for each execution. So `describe` and `it` should get fresh instance\r\n   * always.\r\n   */\n\n\n  static get describe() {\n    return this[DESCRIBE] || (typeof describe === \"function\" ? describe : describeDefaultHandler);\n  }\n\n  static set describe(value) {\n    this[DESCRIBE] = value;\n  }\n\n  static get it() {\n    return this[IT] || (typeof it === \"function\" ? it : itDefaultHandler);\n  }\n\n  static set it(value) {\n    this[IT] = value;\n  }\n  /**\r\n   * Adds the `only` property to a test to run it in isolation.\r\n   * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\r\n   * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\r\n   */\n\n\n  static only(item) {\n    if (typeof item === \"string\") {\n      return {\n        code: item,\n        only: true\n      };\n    }\n\n    return { ...item,\n      only: true\n    };\n  }\n\n  static get itOnly() {\n    if (typeof this[IT_ONLY] === \"function\") {\n      return this[IT_ONLY];\n    }\n\n    if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\n      return Function.bind.call(this[IT].only, this[IT]);\n    }\n\n    if (typeof it === \"function\" && typeof it.only === \"function\") {\n      return Function.bind.call(it.only, it);\n    }\n\n    if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\n      throw new Error(\"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" + \"See https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.\");\n    }\n\n    if (typeof it === \"function\") {\n      throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\n    }\n\n    throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\n  }\n\n  static set itOnly(value) {\n    this[IT_ONLY] = value;\n  }\n  /**\r\n   * Define a rule for one particular run of tests.\r\n   * @param {string} name The name of the rule to define.\r\n   * @param {Function} rule The rule definition.\r\n   * @returns {void}\r\n   */\n\n\n  defineRule(name, rule) {\n    this.rules[name] = rule;\n  }\n  /**\r\n   * Adds a new rule test to execute.\r\n   * @param {string} ruleName The name of the rule to run.\r\n   * @param {Function} rule The rule to test.\r\n   * @param {{\r\n   *   valid: (ValidTestCase | string)[],\r\n   *   invalid: InvalidTestCase[]\r\n   * }} test The collection of tests to run.\r\n   * @throws {TypeError|Error} If non-object `test`, or if a required\r\n   * scenario of the given type is missing.\r\n   * @returns {void}\r\n   */\n\n\n  run(ruleName, rule, test) {\n    const testerConfig = this.testerConfig,\n          requiredScenarios = [\"valid\", \"invalid\"],\n          scenarioErrors = [],\n          linter = this.linter;\n\n    if (!test || typeof test !== \"object\") {\n      throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\n    }\n\n    requiredScenarios.forEach(scenarioType => {\n      if (!test[scenarioType]) {\n        scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\n      }\n    });\n\n    if (scenarioErrors.length > 0) {\n      throw new Error([`Test Scenarios for rule ${ruleName} is invalid:`].concat(scenarioErrors).join(\"\\n\"));\n    }\n\n    linter.defineRule(ruleName, Object.assign({}, rule, {\n      // Create a wrapper rule that freezes the `context` properties.\n      create(context) {\n        freezeDeeply(context.options);\n        freezeDeeply(context.settings);\n        freezeDeeply(context.parserOptions);\n        return (typeof rule === \"function\" ? rule : rule.create)(context);\n      }\n\n    }));\n    linter.defineRules(this.rules);\n    /**\r\n     * Run the rule for the given item\r\n     * @param {string|Object} item Item to run the rule against\r\n     * @throws {Error} If an invalid schema.\r\n     * @returns {Object} Eslint run result\r\n     * @private\r\n     */\n\n    function runRuleForItem(item) {\n      let config = merge({}, testerConfig),\n          code,\n          filename,\n          output,\n          beforeAST,\n          afterAST;\n\n      if (typeof item === \"string\") {\n        code = item;\n      } else {\n        code = item.code;\n        /*\r\n         * Assumes everything on the item is a config except for the\r\n         * parameters used by this tester\r\n         */\n\n        const itemConfig = { ...item\n        };\n\n        for (const parameter of RuleTesterParameters) {\n          delete itemConfig[parameter];\n        }\n        /*\r\n         * Create the config object from the tester config and this item\r\n         * specific configurations.\r\n         */\n\n\n        config = merge(config, itemConfig);\n      }\n\n      if (item.filename) {\n        filename = item.filename;\n      }\n\n      if (hasOwnProperty(item, \"options\")) {\n        assert(Array.isArray(item.options), \"options must be an array\");\n        config.rules[ruleName] = [1].concat(item.options);\n      } else {\n        config.rules[ruleName] = 1;\n      }\n\n      const schema = getRuleOptionsSchema(rule);\n      /*\r\n       * Setup AST getters.\r\n       * The goal is to check whether or not AST was modified when\r\n       * running the rule under test.\r\n       */\n\n      linter.defineRule(\"rule-tester/validate-ast\", () => ({\n        Program(node) {\n          beforeAST = cloneDeeplyExcludesParent(node);\n        },\n\n        \"Program:exit\"(node) {\n          afterAST = node;\n        }\n\n      }));\n\n      if (typeof config.parser === \"string\") {\n        assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\n      } else {\n        config.parser = espreePath;\n      }\n\n      linter.defineParser(config.parser, wrapParser(require(config.parser)));\n\n      if (schema) {\n        ajv.validateSchema(schema);\n\n        if (ajv.errors) {\n          const errors = ajv.errors.map(error => {\n            const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n            return `\\t${field}: ${error.message}`;\n          }).join(\"\\n\");\n          throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\n        }\n        /*\r\n         * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\r\n         * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\r\n         * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\r\n         * the schema is compiled here separately from checking for `validateSchema` errors.\r\n         */\n\n\n        try {\n          ajv.compile(schema);\n        } catch (err) {\n          throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\n        }\n      }\n\n      validate(config, \"rule-tester\", id => id === ruleName ? rule : null); // Verify the code.\n\n      const {\n        getComments\n      } = SourceCode.prototype;\n      let messages;\n\n      try {\n        SourceCode.prototype.getComments = getCommentsDeprecation;\n        messages = linter.verify(code, config, filename);\n      } finally {\n        SourceCode.prototype.getComments = getComments;\n      }\n\n      const fatalErrorMessage = messages.find(m => m.fatal);\n      assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`); // Verify if autofix makes a syntax error or not.\n\n      if (messages.some(m => m.fix)) {\n        output = SourceCodeFixer.applyFixes(code, messages).output;\n        const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\n        assert(!errorMessageInFix, [\"A fatal parsing error occurred in autofix.\", `Error: ${errorMessageInFix && errorMessageInFix.message}`, \"Autofix output:\", output].join(\"\\n\"));\n      } else {\n        output = code;\n      }\n\n      return {\n        messages,\n        output,\n        beforeAST,\n        afterAST: cloneDeeplyExcludesParent(afterAST)\n      };\n    }\n    /**\r\n     * Check if the AST was changed\r\n     * @param {ASTNode} beforeAST AST node before running\r\n     * @param {ASTNode} afterAST AST node after running\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function assertASTDidntChange(beforeAST, afterAST) {\n      if (!equal(beforeAST, afterAST)) {\n        assert.fail(\"Rule should not modify AST.\");\n      }\n    }\n    /**\r\n     * Check if the template is valid or not\r\n     * all valid cases go through this\r\n     * @param {string|Object} item Item to run the rule against\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function testValidTemplate(item) {\n      const code = typeof item === \"object\" ? item.code : item;\n      assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\n\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n      assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\", messages.length, util.inspect(messages)));\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /**\r\n     * Asserts that the message matches its expected value. If the expected\r\n     * value is a regular expression, it is checked against the actual\r\n     * value.\r\n     * @param {string} actual Actual value\r\n     * @param {string|RegExp} expected Expected value\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function assertMessageMatches(actual, expected) {\n      if (expected instanceof RegExp) {\n        // assert.js doesn't have a built-in RegExp match function\n        assert.ok(expected.test(actual), `Expected '${actual}' to match ${expected}`);\n      } else {\n        assert.strictEqual(actual, expected);\n      }\n    }\n    /**\r\n     * Check if the template is invalid or not\r\n     * all invalid cases go through this.\r\n     * @param {string|Object} item Item to run the rule against\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function testInvalidTemplate(item) {\n      assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\n\n      if (item.name) {\n        assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\n      }\n\n      assert.ok(item.errors || item.errors === 0, `Did not specify errors for an invalid test of ${ruleName}`);\n\n      if (Array.isArray(item.errors) && item.errors.length === 0) {\n        assert.fail(\"Invalid cases must have at least one error\");\n      }\n\n      const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\n      const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\n      const result = runRuleForItem(item);\n      const messages = result.messages;\n\n      if (typeof item.errors === \"number\") {\n        if (item.errors === 0) {\n          assert.fail(\"Invalid cases must have 'error' value greater than 0\");\n        }\n\n        assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\", item.errors, item.errors === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n      } else {\n        assert.strictEqual(messages.length, item.errors.length, util.format(\"Should have %d error%s but had %d: %s\", item.errors.length, item.errors.length === 1 ? \"\" : \"s\", messages.length, util.inspect(messages)));\n        const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\n\n        for (let i = 0, l = item.errors.length; i < l; i++) {\n          const error = item.errors[i];\n          const message = messages[i];\n          assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\n\n          if (typeof error === \"string\" || error instanceof RegExp) {\n            // Just an error message.\n            assertMessageMatches(message.message, error);\n          } else if (typeof error === \"object\" && error !== null) {\n            /*\r\n             * Error object.\r\n             * This may have a message, messageId, data, node type, line, and/or\r\n             * column.\r\n             */\n            Object.keys(error).forEach(propertyName => {\n              assert.ok(errorObjectParameters.has(propertyName), `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`);\n            });\n\n            if (hasOwnProperty(error, \"message\")) {\n              assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\n              assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\n              assertMessageMatches(message.message, error.message);\n            } else if (hasOwnProperty(error, \"messageId\")) {\n              assert.ok(ruleHasMetaMessages, \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\");\n\n              if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\n                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\n              }\n\n              assert.strictEqual(message.messageId, error.messageId, `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`);\n\n              if (hasOwnProperty(error, \"data\")) {\n                /*\r\n                 *  if data was provided, then directly compare the returned message to a synthetic\r\n                 *  interpolated message using the same message ID and data provided in the test.\r\n                 *  See https://github.com/eslint/eslint/issues/9890 for context.\r\n                 */\n                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\n                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\n                assert.strictEqual(message.message, rehydratedMessage, `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`);\n              }\n            }\n\n            assert.ok(hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true, \"Error must specify 'messageId' if 'data' is used.\");\n\n            if (error.type) {\n              assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\n            }\n\n            if (hasOwnProperty(error, \"line\")) {\n              assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\n            }\n\n            if (hasOwnProperty(error, \"column\")) {\n              assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\n            }\n\n            if (hasOwnProperty(error, \"endLine\")) {\n              assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\n            }\n\n            if (hasOwnProperty(error, \"endColumn\")) {\n              assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\n            }\n\n            if (hasOwnProperty(error, \"suggestions\")) {\n              // Support asserting there are no suggestions\n              if (!error.suggestions || Array.isArray(error.suggestions) && error.suggestions.length === 0) {\n                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\n                  assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\n                }\n              } else {\n                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\n                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\n                error.suggestions.forEach((expectedSuggestion, index) => {\n                  assert.ok(typeof expectedSuggestion === \"object\" && expectedSuggestion !== null, \"Test suggestion in 'suggestions' array must be an object.\");\n                  Object.keys(expectedSuggestion).forEach(propertyName => {\n                    assert.ok(suggestionObjectParameters.has(propertyName), `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`);\n                  });\n                  const actualSuggestion = message.suggestions[index];\n                  const suggestionPrefix = `Error Suggestion at index ${index} :`;\n\n                  if (hasOwnProperty(expectedSuggestion, \"desc\")) {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`);\n                    assert.strictEqual(actualSuggestion.desc, expectedSuggestion.desc, `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`);\n                  }\n\n                  if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\n                    assert.ok(ruleHasMetaMessages, `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`);\n                    assert.ok(hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId), `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`);\n                    assert.strictEqual(actualSuggestion.messageId, expectedSuggestion.messageId, `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`);\n\n                    if (hasOwnProperty(expectedSuggestion, \"data\")) {\n                      const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\n                      const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\n                      assert.strictEqual(actualSuggestion.desc, rehydratedDesc, `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`);\n                    }\n                  } else {\n                    assert.ok(!hasOwnProperty(expectedSuggestion, \"data\"), `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`);\n                  }\n\n                  if (hasOwnProperty(expectedSuggestion, \"output\")) {\n                    const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\n                    assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\n                  }\n                });\n              }\n            }\n          } else {\n            // Message was an unexpected type\n            assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\n          }\n        }\n      }\n\n      if (hasOwnProperty(item, \"output\")) {\n        if (item.output === null) {\n          assert.strictEqual(result.output, item.code, \"Expected no autofixes to be suggested\");\n        } else {\n          assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\n        }\n      } else {\n        assert.strictEqual(result.output, item.code, \"The rule fixed the code. Please add 'output' property.\");\n      }\n\n      assertASTDidntChange(result.beforeAST, result.afterAST);\n    }\n    /*\r\n     * This creates a mocha test suite and pipes all supplied info through\r\n     * one of the templates above.\r\n     */\n\n\n    this.constructor.describe(ruleName, () => {\n      this.constructor.describe(\"valid\", () => {\n        test.valid.forEach(valid => {\n          this.constructor[valid.only ? \"itOnly\" : \"it\"](sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid), () => {\n            testValidTemplate(valid);\n          });\n        });\n      });\n      this.constructor.describe(\"invalid\", () => {\n        test.invalid.forEach(invalid => {\n          this.constructor[invalid.only ? \"itOnly\" : \"it\"](sanitize(invalid.name || invalid.code), () => {\n            testInvalidTemplate(invalid);\n          });\n        });\n      });\n    });\n  }\n\n}\n\nRuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;\nmodule.exports = RuleTester;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rule-tester/rule-tester.js"],"names":["assert","require","path","util","merge","equal","Traverser","getRuleOptionsSchema","validate","Linter","SourceCodeFixer","interpolate","ajv","strictDefaults","espreePath","resolve","parserSymbol","Symbol","for","SourceCode","testerDefaultConfig","rules","defaultConfig","RuleTesterParameters","errorObjectParameters","Set","friendlyErrorObjectParameterList","map","key","join","suggestionObjectParameters","friendlySuggestionObjectParameterList","hasOwnProperty","Function","call","bind","Object","cloneDeeplyExcludesParent","x","Array","isArray","retv","freezeDeeply","forEach","freeze","sanitize","text","replace","c","codePointAt","toString","padStart","defineStartEndAsError","objName","node","defineProperties","start","get","Error","configurable","enumerable","end","defineStartEndAsErrorInTree","ast","visitorKeys","traverse","enter","tokens","comments","wrapParser","parser","parseForESLint","ret","parse","getCommentsDeprecation","DESCRIBE","IT","IT_ONLY","itDefaultHandler","method","err","AssertionError","message","inspect","actual","operator","expected","describeDefaultHandler","RuleTester","constructor","testerConfig","linter","setDefaultConfig","config","TypeError","getDefaultConfig","resetDefaultConfig","describe","value","it","only","item","code","itOnly","defineRule","name","rule","run","ruleName","test","requiredScenarios","scenarioErrors","scenarioType","push","length","concat","assign","create","context","options","settings","parserOptions","defineRules","runRuleForItem","filename","output","beforeAST","afterAST","itemConfig","parameter","schema","Program","isAbsolute","defineParser","validateSchema","errors","error","field","dataPath","slice","compile","id","getComments","prototype","messages","verify","fatalErrorMessage","find","m","fatal","some","fix","applyFixes","errorMessageInFix","assertASTDidntChange","fail","testValidTemplate","ok","result","strictEqual","format","assertMessageMatches","RegExp","testInvalidTemplate","ruleHasMetaMessages","meta","friendlyIDList","keys","hasMessageOfThisRule","ruleId","i","l","propertyName","has","messageId","unformattedOriginalMessage","rehydratedMessage","data","type","nodeType","line","column","endLine","endColumn","suggestions","expectedSuggestion","index","actualSuggestion","suggestionPrefix","desc","unformattedMetaMessage","rehydratedDesc","codeWithAppliedSuggestion","valid","invalid","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Mocha test wrapper\r\n * @author Ilya Volodin\r\n */\r\n\"use strict\";\r\n\r\n/* eslint-env mocha -- Mocha wrapper */\r\n\r\n/*\r\n * This is a wrapper around mocha to allow for DRY unittests for eslint\r\n * Format:\r\n * RuleTester.run(\"{ruleName}\", {\r\n *      valid: [\r\n *          \"{code}\",\r\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings} }\r\n *      ],\r\n *      invalid: [\r\n *          { code: \"{code}\", errors: {numErrors} },\r\n *          { code: \"{code}\", errors: [\"{errorMessage}\"] },\r\n *          { code: \"{code}\", options: {options}, globals: {globals}, parser: \"{parser}\", settings: {settings}, errors: [{ message: \"{errorMessage}\", type: \"{errorNodeType}\"}] }\r\n *      ]\r\n *  });\r\n *\r\n * Variables:\r\n * {code} - String that represents the code to be tested\r\n * {options} - Arguments that are passed to the configurable rules.\r\n * {globals} - An object representing a list of variables that are\r\n *             registered as globals\r\n * {parser} - String representing the parser to use\r\n * {settings} - An object representing global settings for all rules\r\n * {numErrors} - If failing case doesn't need to check error message,\r\n *               this integer will specify how many errors should be\r\n *               received\r\n * {errorMessage} - Message that is returned by the rule on failure\r\n * {errorNodeType} - AST node type that is returned by they rule as\r\n *                   a cause of the failure.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst\r\n    assert = require(\"assert\"),\r\n    path = require(\"path\"),\r\n    util = require(\"util\"),\r\n    merge = require(\"lodash.merge\"),\r\n    equal = require(\"fast-deep-equal\"),\r\n    Traverser = require(\"../../lib/shared/traverser\"),\r\n    { getRuleOptionsSchema, validate } = require(\"../shared/config-validator\"),\r\n    { Linter, SourceCodeFixer, interpolate } = require(\"../linter\");\r\n\r\nconst ajv = require(\"../shared/ajv\")({ strictDefaults: true });\r\n\r\nconst espreePath = require.resolve(\"espree\");\r\nconst parserSymbol = Symbol.for(\"eslint.RuleTester.parser\");\r\n\r\nconst { SourceCode } = require(\"../source-code\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/** @typedef {import(\"../shared/types\").Parser} Parser */\r\n\r\n/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\r\n/**\r\n * A test case that is expected to pass lint.\r\n * @typedef {Object} ValidTestCase\r\n * @property {string} [name] Name for the test case.\r\n * @property {string} code Code for the test case.\r\n * @property {any[]} [options] Options for the test case.\r\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\r\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\r\n * @property {string} [parser] The absolute path for the parser.\r\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\r\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\r\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\r\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\r\n */\r\n\r\n/**\r\n * A test case that is expected to fail lint.\r\n * @typedef {Object} InvalidTestCase\r\n * @property {string} [name] Name for the test case.\r\n * @property {string} code Code for the test case.\r\n * @property {number | Array<TestCaseError | string | RegExp>} errors Expected errors.\r\n * @property {string | null} [output] The expected code after autofixes are applied. If set to `null`, the test runner will assert that no autofix is suggested.\r\n * @property {any[]} [options] Options for the test case.\r\n * @property {{ [name: string]: any }} [settings] Settings for the test case.\r\n * @property {string} [filename] The fake filename for the test case. Useful for rules that make assertion about filenames.\r\n * @property {string} [parser] The absolute path for the parser.\r\n * @property {{ [name: string]: any }} [parserOptions] Options for the parser.\r\n * @property {{ [name: string]: \"readonly\" | \"writable\" | \"off\" }} [globals] The additional global variables.\r\n * @property {{ [name: string]: boolean }} [env] Environments for the test case.\r\n * @property {boolean} [only] Run only this test case or the subset of test cases with this property.\r\n */\r\n\r\n/**\r\n * A description of a reported error used in a rule tester test.\r\n * @typedef {Object} TestCaseError\r\n * @property {string | RegExp} [message] Message.\r\n * @property {string} [messageId] Message ID.\r\n * @property {string} [type] The type of the reported AST node.\r\n * @property {{ [name: string]: string }} [data] The data used to fill the message template.\r\n * @property {number} [line] The 1-based line number of the reported start location.\r\n * @property {number} [column] The 1-based column number of the reported start location.\r\n * @property {number} [endLine] The 1-based line number of the reported end location.\r\n * @property {number} [endColumn] The 1-based column number of the reported end location.\r\n */\r\n/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */\r\n\r\n//------------------------------------------------------------------------------\r\n// Private Members\r\n//------------------------------------------------------------------------------\r\n\r\n/*\r\n * testerDefaultConfig must not be modified as it allows to reset the tester to\r\n * the initial default configuration\r\n */\r\nconst testerDefaultConfig = { rules: {} };\r\nlet defaultConfig = { rules: {} };\r\n\r\n/*\r\n * List every parameters possible on a test case that are not related to eslint\r\n * configuration\r\n */\r\nconst RuleTesterParameters = [\r\n    \"name\",\r\n    \"code\",\r\n    \"filename\",\r\n    \"options\",\r\n    \"errors\",\r\n    \"output\",\r\n    \"only\"\r\n];\r\n\r\n/*\r\n * All allowed property names in error objects.\r\n */\r\nconst errorObjectParameters = new Set([\r\n    \"message\",\r\n    \"messageId\",\r\n    \"data\",\r\n    \"type\",\r\n    \"line\",\r\n    \"column\",\r\n    \"endLine\",\r\n    \"endColumn\",\r\n    \"suggestions\"\r\n]);\r\nconst friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\r\n\r\n/*\r\n * All allowed property names in suggestion objects.\r\n */\r\nconst suggestionObjectParameters = new Set([\r\n    \"desc\",\r\n    \"messageId\",\r\n    \"data\",\r\n    \"output\"\r\n]);\r\nconst friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map(key => `'${key}'`).join(\", \")}]`;\r\n\r\nconst hasOwnProperty = Function.call.bind(Object.hasOwnProperty);\r\n\r\n/**\r\n * Clones a given value deeply.\r\n * Note: This ignores `parent` property.\r\n * @param {any} x A value to clone.\r\n * @returns {any} A cloned value.\r\n */\r\nfunction cloneDeeplyExcludesParent(x) {\r\n    if (typeof x === \"object\" && x !== null) {\r\n        if (Array.isArray(x)) {\r\n            return x.map(cloneDeeplyExcludesParent);\r\n        }\r\n\r\n        const retv = {};\r\n\r\n        for (const key in x) {\r\n            if (key !== \"parent\" && hasOwnProperty(x, key)) {\r\n                retv[key] = cloneDeeplyExcludesParent(x[key]);\r\n            }\r\n        }\r\n\r\n        return retv;\r\n    }\r\n\r\n    return x;\r\n}\r\n\r\n/**\r\n * Freezes a given value deeply.\r\n * @param {any} x A value to freeze.\r\n * @returns {void}\r\n */\r\nfunction freezeDeeply(x) {\r\n    if (typeof x === \"object\" && x !== null) {\r\n        if (Array.isArray(x)) {\r\n            x.forEach(freezeDeeply);\r\n        } else {\r\n            for (const key in x) {\r\n                if (key !== \"parent\" && hasOwnProperty(x, key)) {\r\n                    freezeDeeply(x[key]);\r\n                }\r\n            }\r\n        }\r\n        Object.freeze(x);\r\n    }\r\n}\r\n\r\n/**\r\n * Replace control characters by `\\u00xx` form.\r\n * @param {string} text The text to sanitize.\r\n * @returns {string} The sanitized text.\r\n */\r\nfunction sanitize(text) {\r\n    if (typeof text !== \"string\") {\r\n        return \"\";\r\n    }\r\n    return text.replace(\r\n        /[\\u0000-\\u0009\\u000b-\\u001a]/gu, // eslint-disable-line no-control-regex -- Escaping controls\r\n        c => `\\\\u${c.codePointAt(0).toString(16).padStart(4, \"0\")}`\r\n    );\r\n}\r\n\r\n/**\r\n * Define `start`/`end` properties as throwing error.\r\n * @param {string} objName Object name used for error messages.\r\n * @param {ASTNode} node The node to define.\r\n * @returns {void}\r\n */\r\nfunction defineStartEndAsError(objName, node) {\r\n    Object.defineProperties(node, {\r\n        start: {\r\n            get() {\r\n                throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);\r\n            },\r\n            configurable: true,\r\n            enumerable: false\r\n        },\r\n        end: {\r\n            get() {\r\n                throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);\r\n            },\r\n            configurable: true,\r\n            enumerable: false\r\n        }\r\n    });\r\n}\r\n\r\n\r\n/**\r\n * Define `start`/`end` properties of all nodes of the given AST as throwing error.\r\n * @param {ASTNode} ast The root node to errorize `start`/`end` properties.\r\n * @param {Object} [visitorKeys] Visitor keys to be used for traversing the given ast.\r\n * @returns {void}\r\n */\r\nfunction defineStartEndAsErrorInTree(ast, visitorKeys) {\r\n    Traverser.traverse(ast, { visitorKeys, enter: defineStartEndAsError.bind(null, \"node\") });\r\n    ast.tokens.forEach(defineStartEndAsError.bind(null, \"token\"));\r\n    ast.comments.forEach(defineStartEndAsError.bind(null, \"token\"));\r\n}\r\n\r\n/**\r\n * Wraps the given parser in order to intercept and modify return values from the `parse` and `parseForESLint` methods, for test purposes.\r\n * In particular, to modify ast nodes, tokens and comments to throw on access to their `start` and `end` properties.\r\n * @param {Parser} parser Parser object.\r\n * @returns {Parser} Wrapped parser object.\r\n */\r\nfunction wrapParser(parser) {\r\n\r\n    if (typeof parser.parseForESLint === \"function\") {\r\n        return {\r\n            [parserSymbol]: parser,\r\n            parseForESLint(...args) {\r\n                const ret = parser.parseForESLint(...args);\r\n\r\n                defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);\r\n                return ret;\r\n            }\r\n        };\r\n    }\r\n\r\n    return {\r\n        [parserSymbol]: parser,\r\n        parse(...args) {\r\n            const ast = parser.parse(...args);\r\n\r\n            defineStartEndAsErrorInTree(ast);\r\n            return ast;\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Function to replace `SourceCode.prototype.getComments`.\r\n * @returns {void}\r\n * @throws {Error} Deprecation message.\r\n */\r\nfunction getCommentsDeprecation() {\r\n    throw new Error(\r\n        \"`SourceCode#getComments()` is deprecated and will be removed in a future major version. Use `getCommentsBefore()`, `getCommentsAfter()`, and `getCommentsInside()` instead.\"\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n// default separators for testing\r\nconst DESCRIBE = Symbol(\"describe\");\r\nconst IT = Symbol(\"it\");\r\nconst IT_ONLY = Symbol(\"itOnly\");\r\n\r\n/**\r\n * This is `it` default handler if `it` don't exist.\r\n * @this {Mocha}\r\n * @param {string} text The description of the test case.\r\n * @param {Function} method The logic of the test case.\r\n * @throws {Error} Any error upon execution of `method`.\r\n * @returns {any} Returned value of `method`.\r\n */\r\nfunction itDefaultHandler(text, method) {\r\n    try {\r\n        return method.call(this);\r\n    } catch (err) {\r\n        if (err instanceof assert.AssertionError) {\r\n            err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;\r\n        }\r\n        throw err;\r\n    }\r\n}\r\n\r\n/**\r\n * This is `describe` default handler if `describe` don't exist.\r\n * @this {Mocha}\r\n * @param {string} text The description of the test case.\r\n * @param {Function} method The logic of the test case.\r\n * @returns {any} Returned value of `method`.\r\n */\r\nfunction describeDefaultHandler(text, method) {\r\n    return method.call(this);\r\n}\r\n\r\n/**\r\n * Mocha test wrapper.\r\n */\r\nclass RuleTester {\r\n\r\n    /**\r\n     * Creates a new instance of RuleTester.\r\n     * @param {Object} [testerConfig] Optional, extra configuration for the tester\r\n     */\r\n    constructor(testerConfig) {\r\n\r\n        /**\r\n         * The configuration to use for this tester. Combination of the tester\r\n         * configuration and the default configuration.\r\n         * @type {Object}\r\n         */\r\n        this.testerConfig = merge(\r\n            {},\r\n            defaultConfig,\r\n            testerConfig,\r\n            { rules: { \"rule-tester/validate-ast\": \"error\" } }\r\n        );\r\n\r\n        /**\r\n         * Rule definitions to define before tests.\r\n         * @type {Object}\r\n         */\r\n        this.rules = {};\r\n        this.linter = new Linter();\r\n    }\r\n\r\n    /**\r\n     * Set the configuration to use for all future tests\r\n     * @param {Object} config the configuration to use.\r\n     * @throws {TypeError} If non-object config.\r\n     * @returns {void}\r\n     */\r\n    static setDefaultConfig(config) {\r\n        if (typeof config !== \"object\") {\r\n            throw new TypeError(\"RuleTester.setDefaultConfig: config must be an object\");\r\n        }\r\n        defaultConfig = config;\r\n\r\n        // Make sure the rules object exists since it is assumed to exist later\r\n        defaultConfig.rules = defaultConfig.rules || {};\r\n    }\r\n\r\n    /**\r\n     * Get the current configuration used for all tests\r\n     * @returns {Object} the current configuration\r\n     */\r\n    static getDefaultConfig() {\r\n        return defaultConfig;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to the initial configuration of the tester removing\r\n     * any changes made until now.\r\n     * @returns {void}\r\n     */\r\n    static resetDefaultConfig() {\r\n        defaultConfig = merge({}, testerDefaultConfig);\r\n    }\r\n\r\n\r\n    /*\r\n     * If people use `mocha test.js --watch` command, `describe` and `it` function\r\n     * instances are different for each execution. So `describe` and `it` should get fresh instance\r\n     * always.\r\n     */\r\n    static get describe() {\r\n        return (\r\n            this[DESCRIBE] ||\r\n            (typeof describe === \"function\" ? describe : describeDefaultHandler)\r\n        );\r\n    }\r\n\r\n    static set describe(value) {\r\n        this[DESCRIBE] = value;\r\n    }\r\n\r\n    static get it() {\r\n        return (\r\n            this[IT] ||\r\n            (typeof it === \"function\" ? it : itDefaultHandler)\r\n        );\r\n    }\r\n\r\n    static set it(value) {\r\n        this[IT] = value;\r\n    }\r\n\r\n    /**\r\n     * Adds the `only` property to a test to run it in isolation.\r\n     * @param {string | ValidTestCase | InvalidTestCase} item A single test to run by itself.\r\n     * @returns {ValidTestCase | InvalidTestCase} The test with `only` set.\r\n     */\r\n    static only(item) {\r\n        if (typeof item === \"string\") {\r\n            return { code: item, only: true };\r\n        }\r\n\r\n        return { ...item, only: true };\r\n    }\r\n\r\n    static get itOnly() {\r\n        if (typeof this[IT_ONLY] === \"function\") {\r\n            return this[IT_ONLY];\r\n        }\r\n        if (typeof this[IT] === \"function\" && typeof this[IT].only === \"function\") {\r\n            return Function.bind.call(this[IT].only, this[IT]);\r\n        }\r\n        if (typeof it === \"function\" && typeof it.only === \"function\") {\r\n            return Function.bind.call(it.only, it);\r\n        }\r\n\r\n        if (typeof this[DESCRIBE] === \"function\" || typeof this[IT] === \"function\") {\r\n            throw new Error(\r\n                \"Set `RuleTester.itOnly` to use `only` with a custom test framework.\\n\" +\r\n                \"See https://eslint.org/docs/developer-guide/nodejs-api#customizing-ruletester for more.\"\r\n            );\r\n        }\r\n        if (typeof it === \"function\") {\r\n            throw new Error(\"The current test framework does not support exclusive tests with `only`.\");\r\n        }\r\n        throw new Error(\"To use `only`, use RuleTester with a test framework that provides `it.only()` like Mocha.\");\r\n    }\r\n\r\n    static set itOnly(value) {\r\n        this[IT_ONLY] = value;\r\n    }\r\n\r\n    /**\r\n     * Define a rule for one particular run of tests.\r\n     * @param {string} name The name of the rule to define.\r\n     * @param {Function} rule The rule definition.\r\n     * @returns {void}\r\n     */\r\n    defineRule(name, rule) {\r\n        this.rules[name] = rule;\r\n    }\r\n\r\n    /**\r\n     * Adds a new rule test to execute.\r\n     * @param {string} ruleName The name of the rule to run.\r\n     * @param {Function} rule The rule to test.\r\n     * @param {{\r\n     *   valid: (ValidTestCase | string)[],\r\n     *   invalid: InvalidTestCase[]\r\n     * }} test The collection of tests to run.\r\n     * @throws {TypeError|Error} If non-object `test`, or if a required\r\n     * scenario of the given type is missing.\r\n     * @returns {void}\r\n     */\r\n    run(ruleName, rule, test) {\r\n\r\n        const testerConfig = this.testerConfig,\r\n            requiredScenarios = [\"valid\", \"invalid\"],\r\n            scenarioErrors = [],\r\n            linter = this.linter;\r\n\r\n        if (!test || typeof test !== \"object\") {\r\n            throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);\r\n        }\r\n\r\n        requiredScenarios.forEach(scenarioType => {\r\n            if (!test[scenarioType]) {\r\n                scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);\r\n            }\r\n        });\r\n\r\n        if (scenarioErrors.length > 0) {\r\n            throw new Error([\r\n                `Test Scenarios for rule ${ruleName} is invalid:`\r\n            ].concat(scenarioErrors).join(\"\\n\"));\r\n        }\r\n\r\n\r\n        linter.defineRule(ruleName, Object.assign({}, rule, {\r\n\r\n            // Create a wrapper rule that freezes the `context` properties.\r\n            create(context) {\r\n                freezeDeeply(context.options);\r\n                freezeDeeply(context.settings);\r\n                freezeDeeply(context.parserOptions);\r\n\r\n                return (typeof rule === \"function\" ? rule : rule.create)(context);\r\n            }\r\n        }));\r\n\r\n        linter.defineRules(this.rules);\r\n\r\n        /**\r\n         * Run the rule for the given item\r\n         * @param {string|Object} item Item to run the rule against\r\n         * @throws {Error} If an invalid schema.\r\n         * @returns {Object} Eslint run result\r\n         * @private\r\n         */\r\n        function runRuleForItem(item) {\r\n            let config = merge({}, testerConfig),\r\n                code, filename, output, beforeAST, afterAST;\r\n\r\n            if (typeof item === \"string\") {\r\n                code = item;\r\n            } else {\r\n                code = item.code;\r\n\r\n                /*\r\n                 * Assumes everything on the item is a config except for the\r\n                 * parameters used by this tester\r\n                 */\r\n                const itemConfig = { ...item };\r\n\r\n                for (const parameter of RuleTesterParameters) {\r\n                    delete itemConfig[parameter];\r\n                }\r\n\r\n                /*\r\n                 * Create the config object from the tester config and this item\r\n                 * specific configurations.\r\n                 */\r\n                config = merge(\r\n                    config,\r\n                    itemConfig\r\n                );\r\n            }\r\n\r\n            if (item.filename) {\r\n                filename = item.filename;\r\n            }\r\n\r\n            if (hasOwnProperty(item, \"options\")) {\r\n                assert(Array.isArray(item.options), \"options must be an array\");\r\n                config.rules[ruleName] = [1].concat(item.options);\r\n            } else {\r\n                config.rules[ruleName] = 1;\r\n            }\r\n\r\n            const schema = getRuleOptionsSchema(rule);\r\n\r\n            /*\r\n             * Setup AST getters.\r\n             * The goal is to check whether or not AST was modified when\r\n             * running the rule under test.\r\n             */\r\n            linter.defineRule(\"rule-tester/validate-ast\", () => ({\r\n                Program(node) {\r\n                    beforeAST = cloneDeeplyExcludesParent(node);\r\n                },\r\n                \"Program:exit\"(node) {\r\n                    afterAST = node;\r\n                }\r\n            }));\r\n\r\n            if (typeof config.parser === \"string\") {\r\n                assert(path.isAbsolute(config.parser), \"Parsers provided as strings to RuleTester must be absolute paths\");\r\n            } else {\r\n                config.parser = espreePath;\r\n            }\r\n\r\n            linter.defineParser(config.parser, wrapParser(require(config.parser)));\r\n\r\n            if (schema) {\r\n                ajv.validateSchema(schema);\r\n\r\n                if (ajv.errors) {\r\n                    const errors = ajv.errors.map(error => {\r\n                        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\r\n\r\n                        return `\\t${field}: ${error.message}`;\r\n                    }).join(\"\\n\");\r\n\r\n                    throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);\r\n                }\r\n\r\n                /*\r\n                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a \"meta-schema\"),\r\n                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling\r\n                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,\r\n                 * the schema is compiled here separately from checking for `validateSchema` errors.\r\n                 */\r\n                try {\r\n                    ajv.compile(schema);\r\n                } catch (err) {\r\n                    throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);\r\n                }\r\n            }\r\n\r\n            validate(config, \"rule-tester\", id => (id === ruleName ? rule : null));\r\n\r\n            // Verify the code.\r\n            const { getComments } = SourceCode.prototype;\r\n            let messages;\r\n\r\n            try {\r\n                SourceCode.prototype.getComments = getCommentsDeprecation;\r\n                messages = linter.verify(code, config, filename);\r\n            } finally {\r\n                SourceCode.prototype.getComments = getComments;\r\n            }\r\n\r\n            const fatalErrorMessage = messages.find(m => m.fatal);\r\n\r\n            assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);\r\n\r\n            // Verify if autofix makes a syntax error or not.\r\n            if (messages.some(m => m.fix)) {\r\n                output = SourceCodeFixer.applyFixes(code, messages).output;\r\n                const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);\r\n\r\n                assert(!errorMessageInFix, [\r\n                    \"A fatal parsing error occurred in autofix.\",\r\n                    `Error: ${errorMessageInFix && errorMessageInFix.message}`,\r\n                    \"Autofix output:\",\r\n                    output\r\n                ].join(\"\\n\"));\r\n            } else {\r\n                output = code;\r\n            }\r\n\r\n            return {\r\n                messages,\r\n                output,\r\n                beforeAST,\r\n                afterAST: cloneDeeplyExcludesParent(afterAST)\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Check if the AST was changed\r\n         * @param {ASTNode} beforeAST AST node before running\r\n         * @param {ASTNode} afterAST AST node after running\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function assertASTDidntChange(beforeAST, afterAST) {\r\n            if (!equal(beforeAST, afterAST)) {\r\n                assert.fail(\"Rule should not modify AST.\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the template is valid or not\r\n         * all valid cases go through this\r\n         * @param {string|Object} item Item to run the rule against\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function testValidTemplate(item) {\r\n            const code = typeof item === \"object\" ? item.code : item;\r\n\r\n            assert.ok(typeof code === \"string\", \"Test case must specify a string value for 'code'\");\r\n            if (item.name) {\r\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\r\n            }\r\n\r\n            const result = runRuleForItem(item);\r\n            const messages = result.messages;\r\n\r\n            assert.strictEqual(messages.length, 0, util.format(\"Should have no errors but had %d: %s\",\r\n                messages.length,\r\n                util.inspect(messages)));\r\n\r\n            assertASTDidntChange(result.beforeAST, result.afterAST);\r\n        }\r\n\r\n        /**\r\n         * Asserts that the message matches its expected value. If the expected\r\n         * value is a regular expression, it is checked against the actual\r\n         * value.\r\n         * @param {string} actual Actual value\r\n         * @param {string|RegExp} expected Expected value\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function assertMessageMatches(actual, expected) {\r\n            if (expected instanceof RegExp) {\r\n\r\n                // assert.js doesn't have a built-in RegExp match function\r\n                assert.ok(\r\n                    expected.test(actual),\r\n                    `Expected '${actual}' to match ${expected}`\r\n                );\r\n            } else {\r\n                assert.strictEqual(actual, expected);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the template is invalid or not\r\n         * all invalid cases go through this.\r\n         * @param {string|Object} item Item to run the rule against\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function testInvalidTemplate(item) {\r\n            assert.ok(typeof item.code === \"string\", \"Test case must specify a string value for 'code'\");\r\n            if (item.name) {\r\n                assert.ok(typeof item.name === \"string\", \"Optional test case property 'name' must be a string\");\r\n            }\r\n            assert.ok(item.errors || item.errors === 0,\r\n                `Did not specify errors for an invalid test of ${ruleName}`);\r\n\r\n            if (Array.isArray(item.errors) && item.errors.length === 0) {\r\n                assert.fail(\"Invalid cases must have at least one error\");\r\n            }\r\n\r\n            const ruleHasMetaMessages = hasOwnProperty(rule, \"meta\") && hasOwnProperty(rule.meta, \"messages\");\r\n            const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map(key => `'${key}'`).join(\", \")}]` : null;\r\n\r\n            const result = runRuleForItem(item);\r\n            const messages = result.messages;\r\n\r\n            if (typeof item.errors === \"number\") {\r\n\r\n                if (item.errors === 0) {\r\n                    assert.fail(\"Invalid cases must have 'error' value greater than 0\");\r\n                }\r\n\r\n                assert.strictEqual(messages.length, item.errors, util.format(\"Should have %d error%s but had %d: %s\",\r\n                    item.errors,\r\n                    item.errors === 1 ? \"\" : \"s\",\r\n                    messages.length,\r\n                    util.inspect(messages)));\r\n            } else {\r\n                assert.strictEqual(\r\n                    messages.length, item.errors.length, util.format(\r\n                        \"Should have %d error%s but had %d: %s\",\r\n                        item.errors.length,\r\n                        item.errors.length === 1 ? \"\" : \"s\",\r\n                        messages.length,\r\n                        util.inspect(messages)\r\n                    )\r\n                );\r\n\r\n                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);\r\n\r\n                for (let i = 0, l = item.errors.length; i < l; i++) {\r\n                    const error = item.errors[i];\r\n                    const message = messages[i];\r\n\r\n                    assert(hasMessageOfThisRule, \"Error rule name should be the same as the name of the rule being tested\");\r\n\r\n                    if (typeof error === \"string\" || error instanceof RegExp) {\r\n\r\n                        // Just an error message.\r\n                        assertMessageMatches(message.message, error);\r\n                    } else if (typeof error === \"object\" && error !== null) {\r\n\r\n                        /*\r\n                         * Error object.\r\n                         * This may have a message, messageId, data, node type, line, and/or\r\n                         * column.\r\n                         */\r\n\r\n                        Object.keys(error).forEach(propertyName => {\r\n                            assert.ok(\r\n                                errorObjectParameters.has(propertyName),\r\n                                `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`\r\n                            );\r\n                        });\r\n\r\n                        if (hasOwnProperty(error, \"message\")) {\r\n                            assert.ok(!hasOwnProperty(error, \"messageId\"), \"Error should not specify both 'message' and a 'messageId'.\");\r\n                            assert.ok(!hasOwnProperty(error, \"data\"), \"Error should not specify both 'data' and 'message'.\");\r\n                            assertMessageMatches(message.message, error.message);\r\n                        } else if (hasOwnProperty(error, \"messageId\")) {\r\n                            assert.ok(\r\n                                ruleHasMetaMessages,\r\n                                \"Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.\"\r\n                            );\r\n                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) {\r\n                                assert(false, `Invalid messageId '${error.messageId}'. Expected one of ${friendlyIDList}.`);\r\n                            }\r\n                            assert.strictEqual(\r\n                                message.messageId,\r\n                                error.messageId,\r\n                                `messageId '${message.messageId}' does not match expected messageId '${error.messageId}'.`\r\n                            );\r\n                            if (hasOwnProperty(error, \"data\")) {\r\n\r\n                                /*\r\n                                 *  if data was provided, then directly compare the returned message to a synthetic\r\n                                 *  interpolated message using the same message ID and data provided in the test.\r\n                                 *  See https://github.com/eslint/eslint/issues/9890 for context.\r\n                                 */\r\n                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];\r\n                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);\r\n\r\n                                assert.strictEqual(\r\n                                    message.message,\r\n                                    rehydratedMessage,\r\n                                    `Hydrated message \"${rehydratedMessage}\" does not match \"${message.message}\"`\r\n                                );\r\n                            }\r\n                        }\r\n\r\n                        assert.ok(\r\n                            hasOwnProperty(error, \"data\") ? hasOwnProperty(error, \"messageId\") : true,\r\n                            \"Error must specify 'messageId' if 'data' is used.\"\r\n                        );\r\n\r\n                        if (error.type) {\r\n                            assert.strictEqual(message.nodeType, error.type, `Error type should be ${error.type}, found ${message.nodeType}`);\r\n                        }\r\n\r\n                        if (hasOwnProperty(error, \"line\")) {\r\n                            assert.strictEqual(message.line, error.line, `Error line should be ${error.line}`);\r\n                        }\r\n\r\n                        if (hasOwnProperty(error, \"column\")) {\r\n                            assert.strictEqual(message.column, error.column, `Error column should be ${error.column}`);\r\n                        }\r\n\r\n                        if (hasOwnProperty(error, \"endLine\")) {\r\n                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be ${error.endLine}`);\r\n                        }\r\n\r\n                        if (hasOwnProperty(error, \"endColumn\")) {\r\n                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be ${error.endColumn}`);\r\n                        }\r\n\r\n                        if (hasOwnProperty(error, \"suggestions\")) {\r\n\r\n                            // Support asserting there are no suggestions\r\n                            if (!error.suggestions || (Array.isArray(error.suggestions) && error.suggestions.length === 0)) {\r\n                                if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {\r\n                                    assert.fail(`Error should have no suggestions on error with message: \"${message.message}\"`);\r\n                                }\r\n                            } else {\r\n                                assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received \"${message.suggestions}\" on error with message: \"${message.message}\"`);\r\n                                assert.strictEqual(message.suggestions.length, error.suggestions.length, `Error should have ${error.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);\r\n\r\n                                error.suggestions.forEach((expectedSuggestion, index) => {\r\n                                    assert.ok(\r\n                                        typeof expectedSuggestion === \"object\" && expectedSuggestion !== null,\r\n                                        \"Test suggestion in 'suggestions' array must be an object.\"\r\n                                    );\r\n                                    Object.keys(expectedSuggestion).forEach(propertyName => {\r\n                                        assert.ok(\r\n                                            suggestionObjectParameters.has(propertyName),\r\n                                            `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`\r\n                                        );\r\n                                    });\r\n\r\n                                    const actualSuggestion = message.suggestions[index];\r\n                                    const suggestionPrefix = `Error Suggestion at index ${index} :`;\r\n\r\n                                    if (hasOwnProperty(expectedSuggestion, \"desc\")) {\r\n                                        assert.ok(\r\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\r\n                                            `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`\r\n                                        );\r\n                                        assert.strictEqual(\r\n                                            actualSuggestion.desc,\r\n                                            expectedSuggestion.desc,\r\n                                            `${suggestionPrefix} desc should be \"${expectedSuggestion.desc}\" but got \"${actualSuggestion.desc}\" instead.`\r\n                                        );\r\n                                    }\r\n\r\n                                    if (hasOwnProperty(expectedSuggestion, \"messageId\")) {\r\n                                        assert.ok(\r\n                                            ruleHasMetaMessages,\r\n                                            `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`\r\n                                        );\r\n                                        assert.ok(\r\n                                            hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId),\r\n                                            `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`\r\n                                        );\r\n                                        assert.strictEqual(\r\n                                            actualSuggestion.messageId,\r\n                                            expectedSuggestion.messageId,\r\n                                            `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`\r\n                                        );\r\n                                        if (hasOwnProperty(expectedSuggestion, \"data\")) {\r\n                                            const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];\r\n                                            const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);\r\n\r\n                                            assert.strictEqual(\r\n                                                actualSuggestion.desc,\r\n                                                rehydratedDesc,\r\n                                                `${suggestionPrefix} Hydrated test desc \"${rehydratedDesc}\" does not match received desc \"${actualSuggestion.desc}\".`\r\n                                            );\r\n                                        }\r\n                                    } else {\r\n                                        assert.ok(\r\n                                            !hasOwnProperty(expectedSuggestion, \"data\"),\r\n                                            `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`\r\n                                        );\r\n                                    }\r\n\r\n                                    if (hasOwnProperty(expectedSuggestion, \"output\")) {\r\n                                        const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;\r\n\r\n                                        assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: \"${message.message}\"`);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    } else {\r\n\r\n                        // Message was an unexpected type\r\n                        assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (hasOwnProperty(item, \"output\")) {\r\n                if (item.output === null) {\r\n                    assert.strictEqual(\r\n                        result.output,\r\n                        item.code,\r\n                        \"Expected no autofixes to be suggested\"\r\n                    );\r\n                } else {\r\n                    assert.strictEqual(result.output, item.output, \"Output is incorrect.\");\r\n                }\r\n            } else {\r\n                assert.strictEqual(\r\n                    result.output,\r\n                    item.code,\r\n                    \"The rule fixed the code. Please add 'output' property.\"\r\n                );\r\n            }\r\n\r\n            assertASTDidntChange(result.beforeAST, result.afterAST);\r\n        }\r\n\r\n        /*\r\n         * This creates a mocha test suite and pipes all supplied info through\r\n         * one of the templates above.\r\n         */\r\n        this.constructor.describe(ruleName, () => {\r\n            this.constructor.describe(\"valid\", () => {\r\n                test.valid.forEach(valid => {\r\n                    this.constructor[valid.only ? \"itOnly\" : \"it\"](\r\n                        sanitize(typeof valid === \"object\" ? valid.name || valid.code : valid),\r\n                        () => {\r\n                            testValidTemplate(valid);\r\n                        }\r\n                    );\r\n                });\r\n            });\r\n\r\n            this.constructor.describe(\"invalid\", () => {\r\n                test.invalid.forEach(invalid => {\r\n                    this.constructor[invalid.only ? \"itOnly\" : \"it\"](\r\n                        sanitize(invalid.name || invalid.code),\r\n                        () => {\r\n                            testInvalidTemplate(invalid);\r\n                        }\r\n                    );\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nRuleTester[DESCRIBE] = RuleTester[IT] = RuleTester[IT_ONLY] = null;\r\n\r\nmodule.exports = RuleTester;\r\n"]},"metadata":{},"sourceType":"script"}