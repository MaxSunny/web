{"ast":null,"code":"/**\r\n * @fileoverview Enforces or disallows inline comments.\r\n * @author Greg Cochard\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow inline comments after code\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-inline-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignorePattern: {\n          type: \"string\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedInlineComment: \"Unexpected comment inline with code.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0];\n    let customIgnoreRegExp;\n\n    if (options && options.ignorePattern) {\n      customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\n    }\n    /**\r\n     * Will check that comments are not on lines starting with or ending with code\r\n     * @param {ASTNode} node The comment node to check\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    function testCodeAroundComment(node) {\n      const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\n            endLine = String(sourceCode.lines[node.loc.end.line - 1]),\n            preamble = startLine.slice(0, node.loc.start.column).trim(),\n            postamble = endLine.slice(node.loc.end.column).trim(),\n            isPreambleEmpty = !preamble,\n            isPostambleEmpty = !postamble; // Nothing on both sides\n\n      if (isPreambleEmpty && isPostambleEmpty) {\n        return;\n      } // Matches the ignore pattern\n\n\n      if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\n        return;\n      } // JSX Exception\n\n\n      if ((isPreambleEmpty || preamble === \"{\") && (isPostambleEmpty || postamble === \"}\")) {\n        const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\n\n        if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\n          return;\n        }\n      } // Don't report ESLint directive comments\n\n\n      if (astUtils.isDirectiveComment(node)) {\n        return;\n      }\n\n      context.report({\n        node,\n        messageId: \"unexpectedInlineComment\"\n      });\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        sourceCode.getAllComments().filter(token => token.type !== \"Shebang\").forEach(testCodeAroundComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-inline-comments.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","ignorePattern","additionalProperties","messages","unexpectedInlineComment","create","context","sourceCode","getSourceCode","options","customIgnoreRegExp","RegExp","testCodeAroundComment","node","startLine","String","lines","loc","start","line","endLine","end","preamble","slice","column","trim","postamble","isPreambleEmpty","isPostambleEmpty","test","value","enclosingNode","getNodeByRangeIndex","range","isDirectiveComment","report","messageId","Program","getAllComments","filter","token","forEach"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Enforces or disallows inline comments.\r\n * @author Greg Cochard\r\n */\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow inline comments after code\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-inline-comments\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignorePattern: {\r\n                        type: \"string\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedInlineComment: \"Unexpected comment inline with code.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const options = context.options[0];\r\n        let customIgnoreRegExp;\r\n\r\n        if (options && options.ignorePattern) {\r\n            customIgnoreRegExp = new RegExp(options.ignorePattern, \"u\");\r\n        }\r\n\r\n        /**\r\n         * Will check that comments are not on lines starting with or ending with code\r\n         * @param {ASTNode} node The comment node to check\r\n         * @private\r\n         * @returns {void}\r\n         */\r\n        function testCodeAroundComment(node) {\r\n\r\n            const startLine = String(sourceCode.lines[node.loc.start.line - 1]),\r\n                endLine = String(sourceCode.lines[node.loc.end.line - 1]),\r\n                preamble = startLine.slice(0, node.loc.start.column).trim(),\r\n                postamble = endLine.slice(node.loc.end.column).trim(),\r\n                isPreambleEmpty = !preamble,\r\n                isPostambleEmpty = !postamble;\r\n\r\n            // Nothing on both sides\r\n            if (isPreambleEmpty && isPostambleEmpty) {\r\n                return;\r\n            }\r\n\r\n            // Matches the ignore pattern\r\n            if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {\r\n                return;\r\n            }\r\n\r\n            // JSX Exception\r\n            if (\r\n                (isPreambleEmpty || preamble === \"{\") &&\r\n                (isPostambleEmpty || postamble === \"}\")\r\n            ) {\r\n                const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);\r\n\r\n                if (enclosingNode && enclosingNode.type === \"JSXEmptyExpression\") {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            // Don't report ESLint directive comments\r\n            if (astUtils.isDirectiveComment(node)) {\r\n                return;\r\n            }\r\n\r\n            context.report({\r\n                node,\r\n                messageId: \"unexpectedInlineComment\"\r\n            });\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program() {\r\n                sourceCode.getAllComments()\r\n                    .filter(token => token.type !== \"Shebang\")\r\n                    .forEach(testCodeAroundComment);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}