{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow negating the left operand of relational operators\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether the given operator is `in` or `instanceof`\r\n * @param {string} op The operator type to check.\r\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\r\n */\n\n\nfunction isInOrInstanceOfOperator(op) {\n  return op === \"in\" || op === \"instanceof\";\n}\n/**\r\n * Checks whether the given operator is an ordering relational operator or not.\r\n * @param {string} op The operator type to check.\r\n * @returns {boolean} `true` if the operator is an ordering relational operator.\r\n */\n\n\nfunction isOrderingRelationalOperator(op) {\n  return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\n}\n/**\r\n * Checks whether the given node is a logical negation expression or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a logical negation expression.\r\n */\n\n\nfunction isNegation(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"!\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow negating the left operand of relational operators\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unsafe-negation\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForOrderingRelations: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: null,\n    messages: {\n      unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\n      suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\n      suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = context.options[0] || {};\n    const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\n    return {\n      BinaryExpression(node) {\n        const operator = node.operator;\n        const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\n\n        if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {\n          context.report({\n            node,\n            loc: node.left.loc,\n            messageId: \"unexpected\",\n            data: {\n              operator\n            },\n            suggest: [{\n              messageId: \"suggestNegatedExpression\",\n              data: {\n                operator\n              },\n\n              fix(fixer) {\n                const negationToken = sourceCode.getFirstToken(node.left);\n                const fixRange = [negationToken.range[1], node.range[1]];\n                const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\n                return fixer.replaceTextRange(fixRange, `(${text})`);\n              }\n\n            }, {\n              messageId: \"suggestParenthesisedNegation\",\n\n              fix(fixer) {\n                return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\n              }\n\n            }]\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unsafe-negation.js"],"names":["astUtils","require","isInOrInstanceOfOperator","op","isOrderingRelationalOperator","isNegation","node","type","operator","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","properties","enforceForOrderingRelations","default","additionalProperties","fixable","messages","unexpected","suggestNegatedExpression","suggestParenthesisedNegation","create","context","sourceCode","getSourceCode","options","BinaryExpression","orderingRelationRuleApplies","left","isParenthesised","report","loc","messageId","data","suggest","fix","fixer","negationToken","getFirstToken","fixRange","range","text","slice","replaceTextRange","replaceText","getText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow negating the left operand of relational operators\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether the given operator is `in` or `instanceof`\r\n * @param {string} op The operator type to check.\r\n * @returns {boolean} `true` if the operator is `in` or `instanceof`\r\n */\r\nfunction isInOrInstanceOfOperator(op) {\r\n    return op === \"in\" || op === \"instanceof\";\r\n}\r\n\r\n/**\r\n * Checks whether the given operator is an ordering relational operator or not.\r\n * @param {string} op The operator type to check.\r\n * @returns {boolean} `true` if the operator is an ordering relational operator.\r\n */\r\nfunction isOrderingRelationalOperator(op) {\r\n    return op === \"<\" || op === \">\" || op === \">=\" || op === \"<=\";\r\n}\r\n\r\n/**\r\n * Checks whether the given node is a logical negation expression or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a logical negation expression.\r\n */\r\nfunction isNegation(node) {\r\n    return node.type === \"UnaryExpression\" && node.operator === \"!\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow negating the left operand of relational operators\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-unsafe-negation\"\r\n        },\r\n\r\n        hasSuggestions: true,\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    enforceForOrderingRelations: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: null,\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected negating the left operand of '{{operator}}' operator.\",\r\n            suggestNegatedExpression: \"Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.\",\r\n            suggestParenthesisedNegation: \"Wrap negation in '()' to make the intention explicit. This preserves the current behavior.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const options = context.options[0] || {};\r\n        const enforceForOrderingRelations = options.enforceForOrderingRelations === true;\r\n\r\n        return {\r\n            BinaryExpression(node) {\r\n                const operator = node.operator;\r\n                const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);\r\n\r\n                if (\r\n                    (isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) &&\r\n                    isNegation(node.left) &&\r\n                    !astUtils.isParenthesised(sourceCode, node.left)\r\n                ) {\r\n                    context.report({\r\n                        node,\r\n                        loc: node.left.loc,\r\n                        messageId: \"unexpected\",\r\n                        data: { operator },\r\n                        suggest: [\r\n                            {\r\n                                messageId: \"suggestNegatedExpression\",\r\n                                data: { operator },\r\n                                fix(fixer) {\r\n                                    const negationToken = sourceCode.getFirstToken(node.left);\r\n                                    const fixRange = [negationToken.range[1], node.range[1]];\r\n                                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);\r\n\r\n                                    return fixer.replaceTextRange(fixRange, `(${text})`);\r\n                                }\r\n                            },\r\n                            {\r\n                                messageId: \"suggestParenthesisedNegation\",\r\n                                fix(fixer) {\r\n                                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);\r\n                                }\r\n                            }\r\n                        ]\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}