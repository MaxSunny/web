{"ast":null,"code":"/**\r\n * @fileoverview Main CLI object.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\";\n/*\r\n * The CLI object should *not* call process.exit() directly. It should only return\r\n * exit codes. This allows other programs to use the CLI object and still control\r\n * when the program exits.\r\n */\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst defaultOptions = require(\"../../conf/default-cli-options\");\n\nconst pkg = require(\"../../package.json\");\n\nconst {\n  Legacy: {\n    ConfigOps,\n    naming,\n    CascadingConfigArrayFactory,\n    IgnorePattern,\n    getUsedExtractedConfigs,\n    ModuleResolver\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n  FileEnumerator\n} = require(\"./file-enumerator\");\n\nconst {\n  Linter\n} = require(\"../linter\");\n\nconst builtInRules = require(\"../rules\");\n\nconst loadRules = require(\"./load-rules\");\n\nconst hash = require(\"./hash\");\n\nconst LintResultCache = require(\"./lint-result-cache\");\n\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\n\nconst validFixTypes = new Set([\"directive\", \"problem\", \"suggestion\", \"layout\"]); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n// For VSCode IntelliSense\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\n\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\n\n/**\r\n * The options to configure a CLI engine with.\r\n * @typedef {Object} CLIEngineOptions\r\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\r\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\r\n * @property {boolean} [cache] Enable result caching.\r\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\r\n * @property {string} [configFile] The configuration file to use.\r\n * @property {string} [cwd] The value to use for the current working directory.\r\n * @property {string[]} [envs] An array of environments to load.\r\n * @property {string[]|null} [extensions] An array of file extensions to check.\r\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\r\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\r\n * @property {string[]} [globals] An array of global variables to declare.\r\n * @property {boolean} [ignore] False disables use of .eslintignore.\r\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\r\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\r\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\r\n * @property {string} [parser] The name of the parser to use.\r\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\r\n * @property {string[]} [plugins] An array of plugins to load.\r\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\r\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\r\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\r\n */\n\n/**\r\n * A linting result.\r\n * @typedef {Object} LintResult\r\n * @property {string} filePath The path to the file that was linted.\r\n * @property {LintMessage[]} messages All of the messages for the result.\r\n * @property {SuppressedLintMessage[]} suppressedMessages All of the suppressed messages for the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {string} [source] The source code of the file that was linted.\r\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\r\n */\n\n/**\r\n * Linting results.\r\n * @typedef {Object} LintReport\r\n * @property {LintResult[]} results All of the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\r\n */\n\n/**\r\n * Private data for CLIEngine.\r\n * @typedef {Object} CLIEngineInternalSlots\r\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\r\n * @property {string} cacheFilePath The path to the cache of lint results.\r\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\r\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\r\n * @property {FileEnumerator} fileEnumerator The file enumerator.\r\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\r\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\r\n * @property {Linter} linter The linter instance which has loaded rules.\r\n * @property {CLIEngineOptions} options The normalized options of this instance.\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/**\r\n * Determines if each fix type in an array is supported by ESLint and throws\r\n * an error if not.\r\n * @param {string[]} fixTypes An array of fix types to check.\r\n * @returns {void}\r\n * @throws {Error} If an invalid fix type is found.\r\n */\n\nfunction validateFixTypes(fixTypes) {\n  for (const fixType of fixTypes) {\n    if (!validFixTypes.has(fixType)) {\n      throw new Error(`Invalid fix type \"${fixType}\" found.`);\n    }\n  }\n}\n/**\r\n * It will calculate the error and warning count for collection of messages per file\r\n * @param {LintMessage[]} messages Collection of messages\r\n * @returns {Object} Contains the stats\r\n * @private\r\n */\n\n\nfunction calculateStatsPerFile(messages) {\n  return messages.reduce((stat, message) => {\n    if (message.fatal || message.severity === 2) {\n      stat.errorCount++;\n\n      if (message.fatal) {\n        stat.fatalErrorCount++;\n      }\n\n      if (message.fix) {\n        stat.fixableErrorCount++;\n      }\n    } else {\n      stat.warningCount++;\n\n      if (message.fix) {\n        stat.fixableWarningCount++;\n      }\n    }\n\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n/**\r\n * It will calculate the error and warning count for collection of results from all files\r\n * @param {LintResult[]} results Collection of messages from all the files\r\n * @returns {Object} Contains the stats\r\n * @private\r\n */\n\n\nfunction calculateStatsPerRun(results) {\n  return results.reduce((stat, result) => {\n    stat.errorCount += result.errorCount;\n    stat.fatalErrorCount += result.fatalErrorCount;\n    stat.warningCount += result.warningCount;\n    stat.fixableErrorCount += result.fixableErrorCount;\n    stat.fixableWarningCount += result.fixableWarningCount;\n    return stat;\n  }, {\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 0,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  });\n}\n/**\r\n * Processes an source code using ESLint.\r\n * @param {Object} config The config object.\r\n * @param {string} config.text The source code to verify.\r\n * @param {string} config.cwd The path to the current working directory.\r\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\r\n * @param {ConfigArray} config.config The config.\r\n * @param {boolean} config.fix If `true` then it does fix.\r\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\r\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\r\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\r\n * @param {Linter} config.linter The linter instance to verify.\r\n * @returns {LintResult} The result of linting.\r\n * @private\r\n */\n\n\nfunction verifyText(_ref) {\n  let {\n    text,\n    cwd,\n    filePath: providedFilePath,\n    config,\n    fix,\n    allowInlineConfig,\n    reportUnusedDisableDirectives,\n    fileEnumerator,\n    linter\n  } = _ref;\n  const filePath = providedFilePath || \"<text>\";\n  debug(`Lint ${filePath}`);\n  /*\r\n   * Verify.\r\n   * `config.extractConfig(filePath)` requires an absolute path, but `linter`\r\n   * doesn't know CWD, so it gives `linter` an absolute path always.\r\n   */\n\n  const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;\n  const {\n    fixed,\n    messages,\n    output\n  } = linter.verifyAndFix(text, config, {\n    allowInlineConfig,\n    filename: filePathToVerify,\n    fix,\n    reportUnusedDisableDirectives,\n\n    /**\r\n     * Check if the linter should adopt a given code block or not.\r\n     * @param {string} blockFilename The virtual filename of a code block.\r\n     * @returns {boolean} `true` if the linter should adopt the code block.\r\n     */\n    filterCodeBlock(blockFilename) {\n      return fileEnumerator.isTargetPath(blockFilename);\n    }\n\n  }); // Tweak and return.\n\n  const result = {\n    filePath,\n    messages,\n    suppressedMessages: linter.getSuppressedMessages(),\n    ...calculateStatsPerFile(messages)\n  };\n\n  if (fixed) {\n    result.output = output;\n  }\n\n  if (result.errorCount + result.warningCount > 0 && typeof result.output === \"undefined\") {\n    result.source = text;\n  }\n\n  return result;\n}\n/**\r\n * Returns result with warning by ignore settings\r\n * @param {string} filePath File path of checked code\r\n * @param {string} baseDir Absolute path of base directory\r\n * @returns {LintResult} Result with single warning\r\n * @private\r\n */\n\n\nfunction createIgnoreResult(filePath, baseDir) {\n  let message;\n  const isHidden = filePath.split(path.sep).find(segment => /^\\./u.test(segment));\n  const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\n\n  if (isHidden) {\n    message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\n  } else if (isInNodeModules) {\n    message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\n  } else {\n    message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n  }\n\n  return {\n    filePath: path.resolve(filePath),\n    messages: [{\n      fatal: false,\n      severity: 1,\n      message\n    }],\n    suppressedMessages: [],\n    errorCount: 0,\n    fatalErrorCount: 0,\n    warningCount: 1,\n    fixableErrorCount: 0,\n    fixableWarningCount: 0\n  };\n}\n/**\r\n * Get a rule.\r\n * @param {string} ruleId The rule ID to get.\r\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\r\n * @returns {Rule|null} The rule or null.\r\n */\n\n\nfunction getRule(ruleId, configArrays) {\n  for (const configArray of configArrays) {\n    const rule = configArray.pluginRules.get(ruleId);\n\n    if (rule) {\n      return rule;\n    }\n  }\n\n  return builtInRules.get(ruleId) || null;\n}\n/**\r\n * Checks whether a message's rule type should be fixed.\r\n * @param {LintMessage} message The message to check.\r\n * @param {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\r\n * @param {string[]} fixTypes An array of fix types to check.\r\n * @returns {boolean} Whether the message should be fixed.\r\n */\n\n\nfunction shouldMessageBeFixed(message, lastConfigArrays, fixTypes) {\n  if (!message.ruleId) {\n    return fixTypes.has(\"directive\");\n  }\n\n  const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);\n  return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\n}\n/**\r\n * Collect used deprecated rules.\r\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\r\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\r\n */\n\n\nfunction* iterateRuleDeprecationWarnings(usedConfigArrays) {\n  const processedRuleIds = new Set(); // Flatten used configs.\n\n  /** @type {ExtractedConfig[]} */\n\n  const configs = [].concat(...usedConfigArrays.map(getUsedExtractedConfigs)); // Traverse rule configs.\n\n  for (const config of configs) {\n    for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\n      // Skip if it was processed.\n      if (processedRuleIds.has(ruleId)) {\n        continue;\n      }\n\n      processedRuleIds.add(ruleId); // Skip if it's not used.\n\n      if (!ConfigOps.getRuleSeverity(ruleConfig)) {\n        continue;\n      }\n\n      const rule = getRule(ruleId, usedConfigArrays); // Skip if it's not deprecated.\n\n      if (!(rule && rule.meta && rule.meta.deprecated)) {\n        continue;\n      } // This rule was used and deprecated.\n\n\n      yield {\n        ruleId,\n        replacedBy: rule.meta.replacedBy || []\n      };\n    }\n  }\n}\n/**\r\n * Checks if the given message is an error message.\r\n * @param {LintMessage} message The message to check.\r\n * @returns {boolean} Whether or not the message is an error message.\r\n * @private\r\n */\n\n\nfunction isErrorMessage(message) {\n  return message.severity === 2;\n}\n/**\r\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\r\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\r\n * name will be the `cacheFile/.cache_hashOfCWD`\r\n *\r\n * if cacheFile points to a file or looks like a file then it will just use that file\r\n * @param {string} cacheFile The name of file to be used to store the cache\r\n * @param {string} cwd Current working directory\r\n * @returns {string} the resolved path to the cache file\r\n */\n\n\nfunction getCacheFile(cacheFile, cwd) {\n  /*\r\n   * make sure the path separators are normalized for the environment/os\r\n   * keeping the trailing path separator if present\r\n   */\n  const normalizedCacheFile = path.normalize(cacheFile);\n  const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\n  const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\n  /**\r\n   * return the name for the cache file in case the provided parameter is a directory\r\n   * @returns {string} the resolved path to the cacheFile\r\n   */\n\n  function getCacheFileForDirectory() {\n    return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\n  }\n\n  let fileStats;\n\n  try {\n    fileStats = fs.lstatSync(resolvedCacheFile);\n  } catch {\n    fileStats = null;\n  }\n  /*\r\n   * in case the file exists we need to verify if the provided path\r\n   * is a directory or a file. If it is a directory we want to create a file\r\n   * inside that directory\r\n   */\n\n\n  if (fileStats) {\n    /*\r\n     * is a directory or is a file, but the original file the user provided\r\n     * looks like a directory but `path.resolve` removed the `last path.sep`\r\n     * so we need to still treat this like a directory\r\n     */\n    if (fileStats.isDirectory() || looksLikeADirectory) {\n      return getCacheFileForDirectory();\n    } // is file so just use that file\n\n\n    return resolvedCacheFile;\n  }\n  /*\r\n   * here we known the file or directory doesn't exist,\r\n   * so we will try to infer if its a directory if it looks like a directory\r\n   * for the current operating system.\r\n   */\n  // if the last character passed is a path separator we assume is a directory\n\n\n  if (looksLikeADirectory) {\n    return getCacheFileForDirectory();\n  }\n\n  return resolvedCacheFile;\n}\n/**\r\n * Convert a string array to a boolean map.\r\n * @param {string[]|null} keys The keys to assign true.\r\n * @param {boolean} defaultValue The default value for each property.\r\n * @param {string} displayName The property name which is used in error message.\r\n * @throws {Error} Requires array.\r\n * @returns {Record<string,boolean>} The boolean map.\r\n */\n\n\nfunction toBooleanMap(keys, defaultValue, displayName) {\n  if (keys && !Array.isArray(keys)) {\n    throw new Error(`${displayName} must be an array.`);\n  }\n\n  if (keys && keys.length > 0) {\n    return keys.reduce((map, def) => {\n      const [key, value] = def.split(\":\");\n\n      if (key !== \"__proto__\") {\n        map[key] = value === void 0 ? defaultValue : value === \"true\";\n      }\n\n      return map;\n    }, {});\n  }\n\n  return void 0;\n}\n/**\r\n * Create a config data from CLI options.\r\n * @param {CLIEngineOptions} options The options\r\n * @returns {ConfigData|null} The created config data.\r\n */\n\n\nfunction createConfigDataFromOptions(options) {\n  const {\n    ignorePattern,\n    parser,\n    parserOptions,\n    plugins,\n    rules\n  } = options;\n  const env = toBooleanMap(options.envs, true, \"envs\");\n  const globals = toBooleanMap(options.globals, false, \"globals\");\n\n  if (env === void 0 && globals === void 0 && (ignorePattern === void 0 || ignorePattern.length === 0) && parser === void 0 && parserOptions === void 0 && plugins === void 0 && rules === void 0) {\n    return null;\n  }\n\n  return {\n    env,\n    globals,\n    ignorePatterns: ignorePattern,\n    parser,\n    parserOptions,\n    plugins,\n    rules\n  };\n}\n/**\r\n * Checks whether a directory exists at the given location\r\n * @param {string} resolvedPath A path from the CWD\r\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\r\n * @returns {boolean} `true` if a directory exists\r\n */\n\n\nfunction directoryExists(resolvedPath) {\n  try {\n    return fs.statSync(resolvedPath).isDirectory();\n  } catch (error) {\n    if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\n      return false;\n    }\n\n    throw error;\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * Core CLI.\r\n */\n\n\nclass CLIEngine {\n  /**\r\n   * Creates a new instance of the core CLI engine.\r\n   * @param {CLIEngineOptions} providedOptions The options for this instance.\r\n   * @param {Object} [additionalData] Additional settings that are not CLIEngineOptions.\r\n   * @param {Record<string,Plugin>|null} [additionalData.preloadedPlugins] Preloaded plugins.\r\n   */\n  constructor(providedOptions) {\n    let {\n      preloadedPlugins\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const options = Object.assign(Object.create(null), defaultOptions, {\n      cwd: process.cwd()\n    }, providedOptions);\n\n    if (options.fix === void 0) {\n      options.fix = false;\n    }\n\n    const additionalPluginPool = new Map();\n\n    if (preloadedPlugins) {\n      for (const [id, plugin] of Object.entries(preloadedPlugins)) {\n        additionalPluginPool.set(id, plugin);\n      }\n    }\n\n    const cacheFilePath = getCacheFile(options.cacheLocation || options.cacheFile, options.cwd);\n    const configArrayFactory = new CascadingConfigArrayFactory({\n      additionalPluginPool,\n      baseConfig: options.baseConfig || null,\n      cliConfig: createConfigDataFromOptions(options),\n      cwd: options.cwd,\n      ignorePath: options.ignorePath,\n      resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,\n      rulePaths: options.rulePaths,\n      specificConfigPath: options.configFile,\n      useEslintrc: options.useEslintrc,\n      builtInRules,\n      loadRules,\n      getEslintRecommendedConfig: () => require(\"../../conf/eslint-recommended.js\"),\n      getEslintAllConfig: () => require(\"../../conf/eslint-all.js\")\n    });\n    const fileEnumerator = new FileEnumerator({\n      configArrayFactory,\n      cwd: options.cwd,\n      extensions: options.extensions,\n      globInputPaths: options.globInputPaths,\n      errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,\n      ignore: options.ignore\n    });\n    const lintResultCache = options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;\n    const linter = new Linter({\n      cwd: options.cwd\n    });\n    /** @type {ConfigArray[]} */\n\n    const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()]; // Store private data.\n\n    internalSlotsMap.set(this, {\n      additionalPluginPool,\n      cacheFilePath,\n      configArrayFactory,\n      defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),\n      fileEnumerator,\n      lastConfigArrays,\n      lintResultCache,\n      linter,\n      options\n    }); // setup special filter for fixes\n\n    if (options.fix && options.fixTypes && options.fixTypes.length > 0) {\n      debug(`Using fix types ${options.fixTypes}`); // throw an error if any invalid fix types are found\n\n      validateFixTypes(options.fixTypes); // convert to Set for faster lookup\n\n      const fixTypes = new Set(options.fixTypes); // save original value of options.fix in case it's a function\n\n      const originalFix = typeof options.fix === \"function\" ? options.fix : () => true;\n\n      options.fix = message => shouldMessageBeFixed(message, lastConfigArrays, fixTypes) && originalFix(message);\n    }\n  }\n\n  getRules() {\n    const {\n      lastConfigArrays\n    } = internalSlotsMap.get(this);\n    return new Map(function* () {\n      yield* builtInRules;\n\n      for (const configArray of lastConfigArrays) {\n        yield* configArray.pluginRules;\n      }\n    }());\n  }\n  /**\r\n   * Returns results that only contains errors.\r\n   * @param {LintResult[]} results The results to filter.\r\n   * @returns {LintResult[]} The filtered results.\r\n   */\n\n\n  static getErrorResults(results) {\n    const filtered = [];\n    results.forEach(result => {\n      const filteredMessages = result.messages.filter(isErrorMessage);\n      const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\n\n      if (filteredMessages.length > 0) {\n        filtered.push({ ...result,\n          messages: filteredMessages,\n          suppressedMessages: filteredSuppressedMessages,\n          errorCount: filteredMessages.length,\n          warningCount: 0,\n          fixableErrorCount: result.fixableErrorCount,\n          fixableWarningCount: 0\n        });\n      }\n    });\n    return filtered;\n  }\n  /**\r\n   * Outputs fixes from the given results to files.\r\n   * @param {LintReport} report The report object created by CLIEngine.\r\n   * @returns {void}\r\n   */\n\n\n  static outputFixes(report) {\n    report.results.filter(result => Object.prototype.hasOwnProperty.call(result, \"output\")).forEach(result => {\n      fs.writeFileSync(result.filePath, result.output);\n    });\n  }\n  /**\r\n   * Resolves the patterns passed into executeOnFiles() into glob-based patterns\r\n   * for easier handling.\r\n   * @param {string[]} patterns The file patterns passed on the command line.\r\n   * @returns {string[]} The equivalent glob patterns.\r\n   */\n\n\n  resolveFileGlobPatterns(patterns) {\n    const {\n      options\n    } = internalSlotsMap.get(this);\n\n    if (options.globInputPaths === false) {\n      return patterns.filter(Boolean);\n    }\n\n    const extensions = (options.extensions || [\".js\"]).map(ext => ext.replace(/^\\./u, \"\"));\n    const dirSuffix = `/**/*.{${extensions.join(\",\")}}`;\n    return patterns.filter(Boolean).map(pathname => {\n      const resolvedPath = path.resolve(options.cwd, pathname);\n      const newPath = directoryExists(resolvedPath) ? pathname.replace(/[/\\\\]$/u, \"\") + dirSuffix : pathname;\n      return path.normalize(newPath).replace(/\\\\/gu, \"/\");\n    });\n  }\n  /**\r\n   * Executes the current configuration on an array of file and directory names.\r\n   * @param {string[]} patterns An array of file and directory names.\r\n   * @throws {Error} As may be thrown by `fs.unlinkSync`.\r\n   * @returns {LintReport} The results for all files that were linted.\r\n   */\n\n\n  executeOnFiles(patterns) {\n    const {\n      cacheFilePath,\n      fileEnumerator,\n      lastConfigArrays,\n      lintResultCache,\n      linter,\n      options: {\n        allowInlineConfig,\n        cache,\n        cwd,\n        fix,\n        reportUnusedDisableDirectives\n      }\n    } = internalSlotsMap.get(this);\n    const results = [];\n    const startTime = Date.now(); // Clear the last used config arrays.\n\n    lastConfigArrays.length = 0; // Delete cache file; should this do here?\n\n    if (!cache) {\n      try {\n        fs.unlinkSync(cacheFilePath);\n      } catch (error) {\n        const errorCode = error && error.code; // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\n\n        if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !fs.existsSync(cacheFilePath))) {\n          throw error;\n        }\n      }\n    } // Iterate source code files.\n\n\n    for (const {\n      config,\n      filePath,\n      ignored\n    } of fileEnumerator.iterateFiles(patterns)) {\n      if (ignored) {\n        results.push(createIgnoreResult(filePath, cwd));\n        continue;\n      }\n      /*\r\n       * Store used configs for:\r\n       * - this method uses to collect used deprecated rules.\r\n       * - `getRules()` method uses to collect all loaded rules.\r\n       * - `--fix-type` option uses to get the loaded rule's meta data.\r\n       */\n\n\n      if (!lastConfigArrays.includes(config)) {\n        lastConfigArrays.push(config);\n      } // Skip if there is cached result.\n\n\n      if (lintResultCache) {\n        const cachedResult = lintResultCache.getCachedLintResults(filePath, config);\n\n        if (cachedResult) {\n          const hadMessages = cachedResult.messages && cachedResult.messages.length > 0;\n\n          if (hadMessages && fix) {\n            debug(`Reprocessing cached file to allow autofix: ${filePath}`);\n          } else {\n            debug(`Skipping file since it hasn't changed: ${filePath}`);\n            results.push(cachedResult);\n            continue;\n          }\n        }\n      } // Do lint.\n\n\n      const result = verifyText({\n        text: fs.readFileSync(filePath, \"utf8\"),\n        filePath,\n        config,\n        cwd,\n        fix,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        fileEnumerator,\n        linter\n      });\n      results.push(result);\n      /*\r\n       * Store the lint result in the LintResultCache.\r\n       * NOTE: The LintResultCache will remove the file source and any\r\n       * other properties that are difficult to serialize, and will\r\n       * hydrate those properties back in on future lint runs.\r\n       */\n\n      if (lintResultCache) {\n        lintResultCache.setCachedLintResults(filePath, config, result);\n      }\n    } // Persist the cache to disk.\n\n\n    if (lintResultCache) {\n      lintResultCache.reconcile();\n    }\n\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    let usedDeprecatedRules;\n    return {\n      results,\n      ...calculateStatsPerRun(results),\n\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));\n        }\n\n        return usedDeprecatedRules;\n      }\n\n    };\n  }\n  /**\r\n   * Executes the current configuration on text.\r\n   * @param {string} text A string of JavaScript code to lint.\r\n   * @param {string} [filename] An optional string representing the texts filename.\r\n   * @param {boolean} [warnIgnored] Always warn when a file is ignored\r\n   * @returns {LintReport} The results for the linting.\r\n   */\n\n\n  executeOnText(text, filename, warnIgnored) {\n    const {\n      configArrayFactory,\n      fileEnumerator,\n      lastConfigArrays,\n      linter,\n      options: {\n        allowInlineConfig,\n        cwd,\n        fix,\n        reportUnusedDisableDirectives\n      }\n    } = internalSlotsMap.get(this);\n    const results = [];\n    const startTime = Date.now();\n    const resolvedFilename = filename && path.resolve(cwd, filename); // Clear the last used config arrays.\n\n    lastConfigArrays.length = 0;\n\n    if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {\n      if (warnIgnored) {\n        results.push(createIgnoreResult(resolvedFilename, cwd));\n      }\n    } else {\n      const config = configArrayFactory.getConfigArrayForFile(resolvedFilename || \"__placeholder__.js\");\n      /*\r\n       * Store used configs for:\r\n       * - this method uses to collect used deprecated rules.\r\n       * - `getRules()` method uses to collect all loaded rules.\r\n       * - `--fix-type` option uses to get the loaded rule's meta data.\r\n       */\n\n      lastConfigArrays.push(config); // Do lint.\n\n      results.push(verifyText({\n        text,\n        filePath: resolvedFilename,\n        config,\n        cwd,\n        fix,\n        allowInlineConfig,\n        reportUnusedDisableDirectives,\n        fileEnumerator,\n        linter\n      }));\n    }\n\n    debug(`Linting complete in: ${Date.now() - startTime}ms`);\n    let usedDeprecatedRules;\n    return {\n      results,\n      ...calculateStatsPerRun(results),\n\n      // Initialize it lazily because CLI and `ESLint` API don't use it.\n      get usedDeprecatedRules() {\n        if (!usedDeprecatedRules) {\n          usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));\n        }\n\n        return usedDeprecatedRules;\n      }\n\n    };\n  }\n  /**\r\n   * Returns a configuration object for the given file based on the CLI options.\r\n   * This is the same logic used by the ESLint CLI executable to determine\r\n   * configuration for each file it processes.\r\n   * @param {string} filePath The path of the file to retrieve a config object for.\r\n   * @throws {Error} If filepath a directory path.\r\n   * @returns {ConfigData} A configuration object for the file.\r\n   */\n\n\n  getConfigForFile(filePath) {\n    const {\n      configArrayFactory,\n      options\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(options.cwd, filePath);\n\n    if (directoryExists(absolutePath)) {\n      throw Object.assign(new Error(\"'filePath' should not be a directory path.\"), {\n        messageTemplate: \"print-config-with-directory-path\"\n      });\n    }\n\n    return configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath).toCompatibleObjectAsConfigFileContent();\n  }\n  /**\r\n   * Checks if a given path is ignored by ESLint.\r\n   * @param {string} filePath The path of the file to check.\r\n   * @returns {boolean} Whether or not the given path is ignored.\r\n   */\n\n\n  isPathIgnored(filePath) {\n    const {\n      configArrayFactory,\n      defaultIgnores,\n      options: {\n        cwd,\n        ignore\n      }\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, filePath);\n\n    if (ignore) {\n      const config = configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath);\n      const ignores = config.ignores || defaultIgnores;\n      return ignores(absolutePath);\n    }\n\n    return defaultIgnores(absolutePath);\n  }\n  /**\r\n   * Returns the formatter representing the given format or null if the `format` is not a string.\r\n   * @param {string} [format] The name of the format to load or the path to a\r\n   *      custom formatter.\r\n   * @throws {any} As may be thrown by requiring of formatter\r\n   * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\r\n   */\n\n\n  getFormatter(format) {\n    // default is stylish\n    const resolvedFormatName = format || \"stylish\"; // only strings are valid formatters\n\n    if (typeof resolvedFormatName === \"string\") {\n      // replace \\ with / for Windows compatibility\n      const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\n      const slots = internalSlotsMap.get(this);\n      const cwd = slots ? slots.options.cwd : process.cwd();\n      const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\n      let formatterPath; // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\n\n      if (!namespace && normalizedFormatName.indexOf(\"/\") > -1) {\n        formatterPath = path.resolve(cwd, normalizedFormatName);\n      } else {\n        try {\n          const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\n          formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\n        } catch {\n          formatterPath = path.resolve(__dirname, \"formatters\", normalizedFormatName);\n        }\n      }\n\n      try {\n        return require(formatterPath);\n      } catch (ex) {\n        if (format === \"table\" || format === \"codeframe\") {\n          ex.message = `The ${format} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${format}\\``;\n        } else {\n          ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\n        }\n\n        throw ex;\n      }\n    } else {\n      return null;\n    }\n  }\n\n}\n\nCLIEngine.version = pkg.version;\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\nmodule.exports = {\n  CLIEngine,\n\n  /**\r\n   * Get the internal slots of a given CLIEngine instance for tests.\r\n   * @param {CLIEngine} instance The CLIEngine instance to get.\r\n   * @returns {CLIEngineInternalSlots} The internal slots.\r\n   */\n  getCLIEngineInternalSlots(instance) {\n    return internalSlotsMap.get(instance);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/cli-engine/cli-engine.js"],"names":["fs","require","path","defaultOptions","pkg","Legacy","ConfigOps","naming","CascadingConfigArrayFactory","IgnorePattern","getUsedExtractedConfigs","ModuleResolver","FileEnumerator","Linter","builtInRules","loadRules","hash","LintResultCache","debug","validFixTypes","Set","internalSlotsMap","WeakMap","validateFixTypes","fixTypes","fixType","has","Error","calculateStatsPerFile","messages","reduce","stat","message","fatal","severity","errorCount","fatalErrorCount","fix","fixableErrorCount","warningCount","fixableWarningCount","calculateStatsPerRun","results","result","verifyText","text","cwd","filePath","providedFilePath","config","allowInlineConfig","reportUnusedDisableDirectives","fileEnumerator","linter","filePathToVerify","join","fixed","output","verifyAndFix","filename","filterCodeBlock","blockFilename","isTargetPath","suppressedMessages","getSuppressedMessages","source","createIgnoreResult","baseDir","isHidden","split","sep","find","segment","test","isInNodeModules","relative","startsWith","resolve","getRule","ruleId","configArrays","configArray","rule","pluginRules","get","shouldMessageBeFixed","lastConfigArrays","Boolean","meta","type","iterateRuleDeprecationWarnings","usedConfigArrays","processedRuleIds","configs","concat","map","ruleConfig","Object","entries","rules","add","getRuleSeverity","deprecated","replacedBy","isErrorMessage","getCacheFile","cacheFile","normalizedCacheFile","normalize","resolvedCacheFile","looksLikeADirectory","slice","getCacheFileForDirectory","fileStats","lstatSync","isDirectory","toBooleanMap","keys","defaultValue","displayName","Array","isArray","length","def","key","value","createConfigDataFromOptions","options","ignorePattern","parser","parserOptions","plugins","env","envs","globals","ignorePatterns","directoryExists","resolvedPath","statSync","error","code","CLIEngine","constructor","providedOptions","preloadedPlugins","assign","create","process","additionalPluginPool","Map","id","plugin","set","cacheFilePath","cacheLocation","configArrayFactory","baseConfig","cliConfig","ignorePath","resolvePluginsRelativeTo","rulePaths","specificConfigPath","configFile","useEslintrc","getEslintRecommendedConfig","getEslintAllConfig","extensions","globInputPaths","errorOnUnmatchedPattern","ignore","lintResultCache","cache","cacheStrategy","getConfigArrayForFile","defaultIgnores","createDefaultIgnore","originalFix","getRules","getErrorResults","filtered","forEach","filteredMessages","filter","filteredSuppressedMessages","push","outputFixes","report","prototype","hasOwnProperty","call","writeFileSync","resolveFileGlobPatterns","patterns","ext","replace","dirSuffix","pathname","newPath","executeOnFiles","startTime","Date","now","unlinkSync","errorCode","existsSync","ignored","iterateFiles","includes","cachedResult","getCachedLintResults","hadMessages","readFileSync","setCachedLintResults","reconcile","usedDeprecatedRules","from","executeOnText","warnIgnored","resolvedFilename","isPathIgnored","getConfigForFile","absolutePath","messageTemplate","extractConfig","toCompatibleObjectAsConfigFileContent","ignores","getFormatter","format","resolvedFormatName","normalizedFormatName","slots","namespace","getNamespaceFromTerm","formatterPath","indexOf","npmFormat","normalizePackageName","__dirname","ex","version","module","exports","getCLIEngineInternalSlots","instance"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Main CLI object.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n/*\r\n * The CLI object should *not* call process.exit() directly. It should only return\r\n * exit codes. This allows other programs to use the CLI object and still control\r\n * when the program exits.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst defaultOptions = require(\"../../conf/default-cli-options\");\r\nconst pkg = require(\"../../package.json\");\r\n\r\n\r\nconst {\r\n    Legacy: {\r\n        ConfigOps,\r\n        naming,\r\n        CascadingConfigArrayFactory,\r\n        IgnorePattern,\r\n        getUsedExtractedConfigs,\r\n        ModuleResolver\r\n    }\r\n} = require(\"@eslint/eslintrc\");\r\n\r\nconst { FileEnumerator } = require(\"./file-enumerator\");\r\n\r\nconst { Linter } = require(\"../linter\");\r\nconst builtInRules = require(\"../rules\");\r\nconst loadRules = require(\"./load-rules\");\r\nconst hash = require(\"./hash\");\r\nconst LintResultCache = require(\"./lint-result-cache\");\r\n\r\nconst debug = require(\"debug\")(\"eslint:cli-engine\");\r\nconst validFixTypes = new Set([\"directive\", \"problem\", \"suggestion\", \"layout\"]);\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n// For VSCode IntelliSense\r\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\r\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\r\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\r\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\r\n/** @typedef {import(\"../shared/types\").ParserOptions} ParserOptions */\r\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\r\n/** @typedef {import(\"../shared/types\").RuleConf} RuleConf */\r\n/** @typedef {import(\"../shared/types\").Rule} Rule */\r\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\r\n/** @typedef {ReturnType<ConfigArray.extractConfig>} ExtractedConfig */\r\n\r\n/**\r\n * The options to configure a CLI engine with.\r\n * @typedef {Object} CLIEngineOptions\r\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\r\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this CLIEngine instance\r\n * @property {boolean} [cache] Enable result caching.\r\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\r\n * @property {string} [configFile] The configuration file to use.\r\n * @property {string} [cwd] The value to use for the current working directory.\r\n * @property {string[]} [envs] An array of environments to load.\r\n * @property {string[]|null} [extensions] An array of file extensions to check.\r\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\r\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\r\n * @property {string[]} [globals] An array of global variables to declare.\r\n * @property {boolean} [ignore] False disables use of .eslintignore.\r\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\r\n * @property {string|string[]} [ignorePattern] One or more glob patterns to ignore.\r\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc\r\n * @property {string} [parser] The name of the parser to use.\r\n * @property {ParserOptions} [parserOptions] An object of parserOption settings to use.\r\n * @property {string[]} [plugins] An array of plugins to load.\r\n * @property {Record<string,RuleConf>} [rules] An object of rules to use.\r\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\r\n * @property {boolean} [reportUnusedDisableDirectives] `true` adds reports for unused eslint-disable directives\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD\r\n */\r\n\r\n/**\r\n * A linting result.\r\n * @typedef {Object} LintResult\r\n * @property {string} filePath The path to the file that was linted.\r\n * @property {LintMessage[]} messages All of the messages for the result.\r\n * @property {SuppressedLintMessage[]} suppressedMessages All of the suppressed messages for the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {string} [source] The source code of the file that was linted.\r\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\r\n */\r\n\r\n/**\r\n * Linting results.\r\n * @typedef {Object} LintReport\r\n * @property {LintResult[]} results All of the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\r\n */\r\n\r\n/**\r\n * Private data for CLIEngine.\r\n * @typedef {Object} CLIEngineInternalSlots\r\n * @property {Map<string, Plugin>} additionalPluginPool The map for additional plugins.\r\n * @property {string} cacheFilePath The path to the cache of lint results.\r\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory of configs.\r\n * @property {(filePath: string) => boolean} defaultIgnores The default predicate function to check if a file ignored or not.\r\n * @property {FileEnumerator} fileEnumerator The file enumerator.\r\n * @property {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\r\n * @property {LintResultCache|null} lintResultCache The cache of lint results.\r\n * @property {Linter} linter The linter instance which has loaded rules.\r\n * @property {CLIEngineOptions} options The normalized options of this instance.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {WeakMap<CLIEngine, CLIEngineInternalSlots>} */\r\nconst internalSlotsMap = new WeakMap();\r\n\r\n/**\r\n * Determines if each fix type in an array is supported by ESLint and throws\r\n * an error if not.\r\n * @param {string[]} fixTypes An array of fix types to check.\r\n * @returns {void}\r\n * @throws {Error} If an invalid fix type is found.\r\n */\r\nfunction validateFixTypes(fixTypes) {\r\n    for (const fixType of fixTypes) {\r\n        if (!validFixTypes.has(fixType)) {\r\n            throw new Error(`Invalid fix type \"${fixType}\" found.`);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * It will calculate the error and warning count for collection of messages per file\r\n * @param {LintMessage[]} messages Collection of messages\r\n * @returns {Object} Contains the stats\r\n * @private\r\n */\r\nfunction calculateStatsPerFile(messages) {\r\n    return messages.reduce((stat, message) => {\r\n        if (message.fatal || message.severity === 2) {\r\n            stat.errorCount++;\r\n            if (message.fatal) {\r\n                stat.fatalErrorCount++;\r\n            }\r\n            if (message.fix) {\r\n                stat.fixableErrorCount++;\r\n            }\r\n        } else {\r\n            stat.warningCount++;\r\n            if (message.fix) {\r\n                stat.fixableWarningCount++;\r\n            }\r\n        }\r\n        return stat;\r\n    }, {\r\n        errorCount: 0,\r\n        fatalErrorCount: 0,\r\n        warningCount: 0,\r\n        fixableErrorCount: 0,\r\n        fixableWarningCount: 0\r\n    });\r\n}\r\n\r\n/**\r\n * It will calculate the error and warning count for collection of results from all files\r\n * @param {LintResult[]} results Collection of messages from all the files\r\n * @returns {Object} Contains the stats\r\n * @private\r\n */\r\nfunction calculateStatsPerRun(results) {\r\n    return results.reduce((stat, result) => {\r\n        stat.errorCount += result.errorCount;\r\n        stat.fatalErrorCount += result.fatalErrorCount;\r\n        stat.warningCount += result.warningCount;\r\n        stat.fixableErrorCount += result.fixableErrorCount;\r\n        stat.fixableWarningCount += result.fixableWarningCount;\r\n        return stat;\r\n    }, {\r\n        errorCount: 0,\r\n        fatalErrorCount: 0,\r\n        warningCount: 0,\r\n        fixableErrorCount: 0,\r\n        fixableWarningCount: 0\r\n    });\r\n}\r\n\r\n/**\r\n * Processes an source code using ESLint.\r\n * @param {Object} config The config object.\r\n * @param {string} config.text The source code to verify.\r\n * @param {string} config.cwd The path to the current working directory.\r\n * @param {string|undefined} config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.\r\n * @param {ConfigArray} config.config The config.\r\n * @param {boolean} config.fix If `true` then it does fix.\r\n * @param {boolean} config.allowInlineConfig If `true` then it uses directive comments.\r\n * @param {boolean} config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.\r\n * @param {FileEnumerator} config.fileEnumerator The file enumerator to check if a path is a target or not.\r\n * @param {Linter} config.linter The linter instance to verify.\r\n * @returns {LintResult} The result of linting.\r\n * @private\r\n */\r\nfunction verifyText({\r\n    text,\r\n    cwd,\r\n    filePath: providedFilePath,\r\n    config,\r\n    fix,\r\n    allowInlineConfig,\r\n    reportUnusedDisableDirectives,\r\n    fileEnumerator,\r\n    linter\r\n}) {\r\n    const filePath = providedFilePath || \"<text>\";\r\n\r\n    debug(`Lint ${filePath}`);\r\n\r\n    /*\r\n     * Verify.\r\n     * `config.extractConfig(filePath)` requires an absolute path, but `linter`\r\n     * doesn't know CWD, so it gives `linter` an absolute path always.\r\n     */\r\n    const filePathToVerify = filePath === \"<text>\" ? path.join(cwd, filePath) : filePath;\r\n    const { fixed, messages, output } = linter.verifyAndFix(\r\n        text,\r\n        config,\r\n        {\r\n            allowInlineConfig,\r\n            filename: filePathToVerify,\r\n            fix,\r\n            reportUnusedDisableDirectives,\r\n\r\n            /**\r\n             * Check if the linter should adopt a given code block or not.\r\n             * @param {string} blockFilename The virtual filename of a code block.\r\n             * @returns {boolean} `true` if the linter should adopt the code block.\r\n             */\r\n            filterCodeBlock(blockFilename) {\r\n                return fileEnumerator.isTargetPath(blockFilename);\r\n            }\r\n        }\r\n    );\r\n\r\n    // Tweak and return.\r\n    const result = {\r\n        filePath,\r\n        messages,\r\n        suppressedMessages: linter.getSuppressedMessages(),\r\n        ...calculateStatsPerFile(messages)\r\n    };\r\n\r\n    if (fixed) {\r\n        result.output = output;\r\n    }\r\n    if (\r\n        result.errorCount + result.warningCount > 0 &&\r\n        typeof result.output === \"undefined\"\r\n    ) {\r\n        result.source = text;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns result with warning by ignore settings\r\n * @param {string} filePath File path of checked code\r\n * @param {string} baseDir Absolute path of base directory\r\n * @returns {LintResult} Result with single warning\r\n * @private\r\n */\r\nfunction createIgnoreResult(filePath, baseDir) {\r\n    let message;\r\n    const isHidden = filePath.split(path.sep)\r\n        .find(segment => /^\\./u.test(segment));\r\n    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith(\"node_modules\");\r\n\r\n    if (isHidden) {\r\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern '!<relative/path/to/filename>'\\\") to override.\";\r\n    } else if (isInNodeModules) {\r\n        message = \"File ignored by default. Use \\\"--ignore-pattern '!node_modules/*'\\\" to override.\";\r\n    } else {\r\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\r\n    }\r\n\r\n    return {\r\n        filePath: path.resolve(filePath),\r\n        messages: [\r\n            {\r\n                fatal: false,\r\n                severity: 1,\r\n                message\r\n            }\r\n        ],\r\n        suppressedMessages: [],\r\n        errorCount: 0,\r\n        fatalErrorCount: 0,\r\n        warningCount: 1,\r\n        fixableErrorCount: 0,\r\n        fixableWarningCount: 0\r\n    };\r\n}\r\n\r\n/**\r\n * Get a rule.\r\n * @param {string} ruleId The rule ID to get.\r\n * @param {ConfigArray[]} configArrays The config arrays that have plugin rules.\r\n * @returns {Rule|null} The rule or null.\r\n */\r\nfunction getRule(ruleId, configArrays) {\r\n    for (const configArray of configArrays) {\r\n        const rule = configArray.pluginRules.get(ruleId);\r\n\r\n        if (rule) {\r\n            return rule;\r\n        }\r\n    }\r\n    return builtInRules.get(ruleId) || null;\r\n}\r\n\r\n/**\r\n * Checks whether a message's rule type should be fixed.\r\n * @param {LintMessage} message The message to check.\r\n * @param {ConfigArray[]} lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.\r\n * @param {string[]} fixTypes An array of fix types to check.\r\n * @returns {boolean} Whether the message should be fixed.\r\n */\r\nfunction shouldMessageBeFixed(message, lastConfigArrays, fixTypes) {\r\n    if (!message.ruleId) {\r\n        return fixTypes.has(\"directive\");\r\n    }\r\n\r\n    const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);\r\n\r\n    return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));\r\n}\r\n\r\n/**\r\n * Collect used deprecated rules.\r\n * @param {ConfigArray[]} usedConfigArrays The config arrays which were used.\r\n * @returns {IterableIterator<DeprecatedRuleInfo>} Used deprecated rules.\r\n */\r\nfunction *iterateRuleDeprecationWarnings(usedConfigArrays) {\r\n    const processedRuleIds = new Set();\r\n\r\n    // Flatten used configs.\r\n    /** @type {ExtractedConfig[]} */\r\n    const configs = [].concat(\r\n        ...usedConfigArrays.map(getUsedExtractedConfigs)\r\n    );\r\n\r\n    // Traverse rule configs.\r\n    for (const config of configs) {\r\n        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {\r\n\r\n            // Skip if it was processed.\r\n            if (processedRuleIds.has(ruleId)) {\r\n                continue;\r\n            }\r\n            processedRuleIds.add(ruleId);\r\n\r\n            // Skip if it's not used.\r\n            if (!ConfigOps.getRuleSeverity(ruleConfig)) {\r\n                continue;\r\n            }\r\n            const rule = getRule(ruleId, usedConfigArrays);\r\n\r\n            // Skip if it's not deprecated.\r\n            if (!(rule && rule.meta && rule.meta.deprecated)) {\r\n                continue;\r\n            }\r\n\r\n            // This rule was used and deprecated.\r\n            yield {\r\n                ruleId,\r\n                replacedBy: rule.meta.replacedBy || []\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Checks if the given message is an error message.\r\n * @param {LintMessage} message The message to check.\r\n * @returns {boolean} Whether or not the message is an error message.\r\n * @private\r\n */\r\nfunction isErrorMessage(message) {\r\n    return message.severity === 2;\r\n}\r\n\r\n\r\n/**\r\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\r\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\r\n * name will be the `cacheFile/.cache_hashOfCWD`\r\n *\r\n * if cacheFile points to a file or looks like a file then it will just use that file\r\n * @param {string} cacheFile The name of file to be used to store the cache\r\n * @param {string} cwd Current working directory\r\n * @returns {string} the resolved path to the cache file\r\n */\r\nfunction getCacheFile(cacheFile, cwd) {\r\n\r\n    /*\r\n     * make sure the path separators are normalized for the environment/os\r\n     * keeping the trailing path separator if present\r\n     */\r\n    const normalizedCacheFile = path.normalize(cacheFile);\r\n\r\n    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);\r\n    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;\r\n\r\n    /**\r\n     * return the name for the cache file in case the provided parameter is a directory\r\n     * @returns {string} the resolved path to the cacheFile\r\n     */\r\n    function getCacheFileForDirectory() {\r\n        return path.join(resolvedCacheFile, `.cache_${hash(cwd)}`);\r\n    }\r\n\r\n    let fileStats;\r\n\r\n    try {\r\n        fileStats = fs.lstatSync(resolvedCacheFile);\r\n    } catch {\r\n        fileStats = null;\r\n    }\r\n\r\n\r\n    /*\r\n     * in case the file exists we need to verify if the provided path\r\n     * is a directory or a file. If it is a directory we want to create a file\r\n     * inside that directory\r\n     */\r\n    if (fileStats) {\r\n\r\n        /*\r\n         * is a directory or is a file, but the original file the user provided\r\n         * looks like a directory but `path.resolve` removed the `last path.sep`\r\n         * so we need to still treat this like a directory\r\n         */\r\n        if (fileStats.isDirectory() || looksLikeADirectory) {\r\n            return getCacheFileForDirectory();\r\n        }\r\n\r\n        // is file so just use that file\r\n        return resolvedCacheFile;\r\n    }\r\n\r\n    /*\r\n     * here we known the file or directory doesn't exist,\r\n     * so we will try to infer if its a directory if it looks like a directory\r\n     * for the current operating system.\r\n     */\r\n\r\n    // if the last character passed is a path separator we assume is a directory\r\n    if (looksLikeADirectory) {\r\n        return getCacheFileForDirectory();\r\n    }\r\n\r\n    return resolvedCacheFile;\r\n}\r\n\r\n/**\r\n * Convert a string array to a boolean map.\r\n * @param {string[]|null} keys The keys to assign true.\r\n * @param {boolean} defaultValue The default value for each property.\r\n * @param {string} displayName The property name which is used in error message.\r\n * @throws {Error} Requires array.\r\n * @returns {Record<string,boolean>} The boolean map.\r\n */\r\nfunction toBooleanMap(keys, defaultValue, displayName) {\r\n    if (keys && !Array.isArray(keys)) {\r\n        throw new Error(`${displayName} must be an array.`);\r\n    }\r\n    if (keys && keys.length > 0) {\r\n        return keys.reduce((map, def) => {\r\n            const [key, value] = def.split(\":\");\r\n\r\n            if (key !== \"__proto__\") {\r\n                map[key] = value === void 0\r\n                    ? defaultValue\r\n                    : value === \"true\";\r\n            }\r\n\r\n            return map;\r\n        }, {});\r\n    }\r\n    return void 0;\r\n}\r\n\r\n/**\r\n * Create a config data from CLI options.\r\n * @param {CLIEngineOptions} options The options\r\n * @returns {ConfigData|null} The created config data.\r\n */\r\nfunction createConfigDataFromOptions(options) {\r\n    const {\r\n        ignorePattern,\r\n        parser,\r\n        parserOptions,\r\n        plugins,\r\n        rules\r\n    } = options;\r\n    const env = toBooleanMap(options.envs, true, \"envs\");\r\n    const globals = toBooleanMap(options.globals, false, \"globals\");\r\n\r\n    if (\r\n        env === void 0 &&\r\n        globals === void 0 &&\r\n        (ignorePattern === void 0 || ignorePattern.length === 0) &&\r\n        parser === void 0 &&\r\n        parserOptions === void 0 &&\r\n        plugins === void 0 &&\r\n        rules === void 0\r\n    ) {\r\n        return null;\r\n    }\r\n    return {\r\n        env,\r\n        globals,\r\n        ignorePatterns: ignorePattern,\r\n        parser,\r\n        parserOptions,\r\n        plugins,\r\n        rules\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether a directory exists at the given location\r\n * @param {string} resolvedPath A path from the CWD\r\n * @throws {Error} As thrown by `fs.statSync` or `fs.isDirectory`.\r\n * @returns {boolean} `true` if a directory exists\r\n */\r\nfunction directoryExists(resolvedPath) {\r\n    try {\r\n        return fs.statSync(resolvedPath).isDirectory();\r\n    } catch (error) {\r\n        if (error && (error.code === \"ENOENT\" || error.code === \"ENOTDIR\")) {\r\n            return false;\r\n        }\r\n        throw error;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Core CLI.\r\n */\r\nclass CLIEngine {\r\n\r\n    /**\r\n     * Creates a new instance of the core CLI engine.\r\n     * @param {CLIEngineOptions} providedOptions The options for this instance.\r\n     * @param {Object} [additionalData] Additional settings that are not CLIEngineOptions.\r\n     * @param {Record<string,Plugin>|null} [additionalData.preloadedPlugins] Preloaded plugins.\r\n     */\r\n    constructor(providedOptions, { preloadedPlugins } = {}) {\r\n        const options = Object.assign(\r\n            Object.create(null),\r\n            defaultOptions,\r\n            { cwd: process.cwd() },\r\n            providedOptions\r\n        );\r\n\r\n        if (options.fix === void 0) {\r\n            options.fix = false;\r\n        }\r\n\r\n        const additionalPluginPool = new Map();\r\n\r\n        if (preloadedPlugins) {\r\n            for (const [id, plugin] of Object.entries(preloadedPlugins)) {\r\n                additionalPluginPool.set(id, plugin);\r\n            }\r\n        }\r\n\r\n        const cacheFilePath = getCacheFile(\r\n            options.cacheLocation || options.cacheFile,\r\n            options.cwd\r\n        );\r\n        const configArrayFactory = new CascadingConfigArrayFactory({\r\n            additionalPluginPool,\r\n            baseConfig: options.baseConfig || null,\r\n            cliConfig: createConfigDataFromOptions(options),\r\n            cwd: options.cwd,\r\n            ignorePath: options.ignorePath,\r\n            resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,\r\n            rulePaths: options.rulePaths,\r\n            specificConfigPath: options.configFile,\r\n            useEslintrc: options.useEslintrc,\r\n            builtInRules,\r\n            loadRules,\r\n            getEslintRecommendedConfig: () => require(\"../../conf/eslint-recommended.js\"),\r\n            getEslintAllConfig: () => require(\"../../conf/eslint-all.js\")\r\n        });\r\n        const fileEnumerator = new FileEnumerator({\r\n            configArrayFactory,\r\n            cwd: options.cwd,\r\n            extensions: options.extensions,\r\n            globInputPaths: options.globInputPaths,\r\n            errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,\r\n            ignore: options.ignore\r\n        });\r\n        const lintResultCache =\r\n            options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;\r\n        const linter = new Linter({ cwd: options.cwd });\r\n\r\n        /** @type {ConfigArray[]} */\r\n        const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];\r\n\r\n        // Store private data.\r\n        internalSlotsMap.set(this, {\r\n            additionalPluginPool,\r\n            cacheFilePath,\r\n            configArrayFactory,\r\n            defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),\r\n            fileEnumerator,\r\n            lastConfigArrays,\r\n            lintResultCache,\r\n            linter,\r\n            options\r\n        });\r\n\r\n        // setup special filter for fixes\r\n        if (options.fix && options.fixTypes && options.fixTypes.length > 0) {\r\n            debug(`Using fix types ${options.fixTypes}`);\r\n\r\n            // throw an error if any invalid fix types are found\r\n            validateFixTypes(options.fixTypes);\r\n\r\n            // convert to Set for faster lookup\r\n            const fixTypes = new Set(options.fixTypes);\r\n\r\n            // save original value of options.fix in case it's a function\r\n            const originalFix = (typeof options.fix === \"function\")\r\n                ? options.fix : () => true;\r\n\r\n            options.fix = message => shouldMessageBeFixed(message, lastConfigArrays, fixTypes) && originalFix(message);\r\n        }\r\n    }\r\n\r\n    getRules() {\r\n        const { lastConfigArrays } = internalSlotsMap.get(this);\r\n\r\n        return new Map(function *() {\r\n            yield* builtInRules;\r\n\r\n            for (const configArray of lastConfigArrays) {\r\n                yield* configArray.pluginRules;\r\n            }\r\n        }());\r\n    }\r\n\r\n    /**\r\n     * Returns results that only contains errors.\r\n     * @param {LintResult[]} results The results to filter.\r\n     * @returns {LintResult[]} The filtered results.\r\n     */\r\n    static getErrorResults(results) {\r\n        const filtered = [];\r\n\r\n        results.forEach(result => {\r\n            const filteredMessages = result.messages.filter(isErrorMessage);\r\n            const filteredSuppressedMessages = result.suppressedMessages.filter(isErrorMessage);\r\n\r\n            if (filteredMessages.length > 0) {\r\n                filtered.push({\r\n                    ...result,\r\n                    messages: filteredMessages,\r\n                    suppressedMessages: filteredSuppressedMessages,\r\n                    errorCount: filteredMessages.length,\r\n                    warningCount: 0,\r\n                    fixableErrorCount: result.fixableErrorCount,\r\n                    fixableWarningCount: 0\r\n                });\r\n            }\r\n        });\r\n\r\n        return filtered;\r\n    }\r\n\r\n    /**\r\n     * Outputs fixes from the given results to files.\r\n     * @param {LintReport} report The report object created by CLIEngine.\r\n     * @returns {void}\r\n     */\r\n    static outputFixes(report) {\r\n        report.results.filter(result => Object.prototype.hasOwnProperty.call(result, \"output\")).forEach(result => {\r\n            fs.writeFileSync(result.filePath, result.output);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\r\n     * for easier handling.\r\n     * @param {string[]} patterns The file patterns passed on the command line.\r\n     * @returns {string[]} The equivalent glob patterns.\r\n     */\r\n    resolveFileGlobPatterns(patterns) {\r\n        const { options } = internalSlotsMap.get(this);\r\n\r\n        if (options.globInputPaths === false) {\r\n            return patterns.filter(Boolean);\r\n        }\r\n\r\n        const extensions = (options.extensions || [\".js\"]).map(ext => ext.replace(/^\\./u, \"\"));\r\n        const dirSuffix = `/**/*.{${extensions.join(\",\")}}`;\r\n\r\n        return patterns.filter(Boolean).map(pathname => {\r\n            const resolvedPath = path.resolve(options.cwd, pathname);\r\n            const newPath = directoryExists(resolvedPath)\r\n                ? pathname.replace(/[/\\\\]$/u, \"\") + dirSuffix\r\n                : pathname;\r\n\r\n            return path.normalize(newPath).replace(/\\\\/gu, \"/\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes the current configuration on an array of file and directory names.\r\n     * @param {string[]} patterns An array of file and directory names.\r\n     * @throws {Error} As may be thrown by `fs.unlinkSync`.\r\n     * @returns {LintReport} The results for all files that were linted.\r\n     */\r\n    executeOnFiles(patterns) {\r\n        const {\r\n            cacheFilePath,\r\n            fileEnumerator,\r\n            lastConfigArrays,\r\n            lintResultCache,\r\n            linter,\r\n            options: {\r\n                allowInlineConfig,\r\n                cache,\r\n                cwd,\r\n                fix,\r\n                reportUnusedDisableDirectives\r\n            }\r\n        } = internalSlotsMap.get(this);\r\n        const results = [];\r\n        const startTime = Date.now();\r\n\r\n        // Clear the last used config arrays.\r\n        lastConfigArrays.length = 0;\r\n\r\n        // Delete cache file; should this do here?\r\n        if (!cache) {\r\n            try {\r\n                fs.unlinkSync(cacheFilePath);\r\n            } catch (error) {\r\n                const errorCode = error && error.code;\r\n\r\n                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)\r\n                if (errorCode !== \"ENOENT\" && !(errorCode === \"EROFS\" && !fs.existsSync(cacheFilePath))) {\r\n                    throw error;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Iterate source code files.\r\n        for (const { config, filePath, ignored } of fileEnumerator.iterateFiles(patterns)) {\r\n            if (ignored) {\r\n                results.push(createIgnoreResult(filePath, cwd));\r\n                continue;\r\n            }\r\n\r\n            /*\r\n             * Store used configs for:\r\n             * - this method uses to collect used deprecated rules.\r\n             * - `getRules()` method uses to collect all loaded rules.\r\n             * - `--fix-type` option uses to get the loaded rule's meta data.\r\n             */\r\n            if (!lastConfigArrays.includes(config)) {\r\n                lastConfigArrays.push(config);\r\n            }\r\n\r\n            // Skip if there is cached result.\r\n            if (lintResultCache) {\r\n                const cachedResult =\r\n                    lintResultCache.getCachedLintResults(filePath, config);\r\n\r\n                if (cachedResult) {\r\n                    const hadMessages =\r\n                        cachedResult.messages &&\r\n                        cachedResult.messages.length > 0;\r\n\r\n                    if (hadMessages && fix) {\r\n                        debug(`Reprocessing cached file to allow autofix: ${filePath}`);\r\n                    } else {\r\n                        debug(`Skipping file since it hasn't changed: ${filePath}`);\r\n                        results.push(cachedResult);\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Do lint.\r\n            const result = verifyText({\r\n                text: fs.readFileSync(filePath, \"utf8\"),\r\n                filePath,\r\n                config,\r\n                cwd,\r\n                fix,\r\n                allowInlineConfig,\r\n                reportUnusedDisableDirectives,\r\n                fileEnumerator,\r\n                linter\r\n            });\r\n\r\n            results.push(result);\r\n\r\n            /*\r\n             * Store the lint result in the LintResultCache.\r\n             * NOTE: The LintResultCache will remove the file source and any\r\n             * other properties that are difficult to serialize, and will\r\n             * hydrate those properties back in on future lint runs.\r\n             */\r\n            if (lintResultCache) {\r\n                lintResultCache.setCachedLintResults(filePath, config, result);\r\n            }\r\n        }\r\n\r\n        // Persist the cache to disk.\r\n        if (lintResultCache) {\r\n            lintResultCache.reconcile();\r\n        }\r\n\r\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\r\n        let usedDeprecatedRules;\r\n\r\n        return {\r\n            results,\r\n            ...calculateStatsPerRun(results),\r\n\r\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\r\n            get usedDeprecatedRules() {\r\n                if (!usedDeprecatedRules) {\r\n                    usedDeprecatedRules = Array.from(\r\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\r\n                    );\r\n                }\r\n                return usedDeprecatedRules;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Executes the current configuration on text.\r\n     * @param {string} text A string of JavaScript code to lint.\r\n     * @param {string} [filename] An optional string representing the texts filename.\r\n     * @param {boolean} [warnIgnored] Always warn when a file is ignored\r\n     * @returns {LintReport} The results for the linting.\r\n     */\r\n    executeOnText(text, filename, warnIgnored) {\r\n        const {\r\n            configArrayFactory,\r\n            fileEnumerator,\r\n            lastConfigArrays,\r\n            linter,\r\n            options: {\r\n                allowInlineConfig,\r\n                cwd,\r\n                fix,\r\n                reportUnusedDisableDirectives\r\n            }\r\n        } = internalSlotsMap.get(this);\r\n        const results = [];\r\n        const startTime = Date.now();\r\n        const resolvedFilename = filename && path.resolve(cwd, filename);\r\n\r\n\r\n        // Clear the last used config arrays.\r\n        lastConfigArrays.length = 0;\r\n        if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {\r\n            if (warnIgnored) {\r\n                results.push(createIgnoreResult(resolvedFilename, cwd));\r\n            }\r\n        } else {\r\n            const config = configArrayFactory.getConfigArrayForFile(\r\n                resolvedFilename || \"__placeholder__.js\"\r\n            );\r\n\r\n            /*\r\n             * Store used configs for:\r\n             * - this method uses to collect used deprecated rules.\r\n             * - `getRules()` method uses to collect all loaded rules.\r\n             * - `--fix-type` option uses to get the loaded rule's meta data.\r\n             */\r\n            lastConfigArrays.push(config);\r\n\r\n            // Do lint.\r\n            results.push(verifyText({\r\n                text,\r\n                filePath: resolvedFilename,\r\n                config,\r\n                cwd,\r\n                fix,\r\n                allowInlineConfig,\r\n                reportUnusedDisableDirectives,\r\n                fileEnumerator,\r\n                linter\r\n            }));\r\n        }\r\n\r\n        debug(`Linting complete in: ${Date.now() - startTime}ms`);\r\n        let usedDeprecatedRules;\r\n\r\n        return {\r\n            results,\r\n            ...calculateStatsPerRun(results),\r\n\r\n            // Initialize it lazily because CLI and `ESLint` API don't use it.\r\n            get usedDeprecatedRules() {\r\n                if (!usedDeprecatedRules) {\r\n                    usedDeprecatedRules = Array.from(\r\n                        iterateRuleDeprecationWarnings(lastConfigArrays)\r\n                    );\r\n                }\r\n                return usedDeprecatedRules;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a configuration object for the given file based on the CLI options.\r\n     * This is the same logic used by the ESLint CLI executable to determine\r\n     * configuration for each file it processes.\r\n     * @param {string} filePath The path of the file to retrieve a config object for.\r\n     * @throws {Error} If filepath a directory path.\r\n     * @returns {ConfigData} A configuration object for the file.\r\n     */\r\n    getConfigForFile(filePath) {\r\n        const { configArrayFactory, options } = internalSlotsMap.get(this);\r\n        const absolutePath = path.resolve(options.cwd, filePath);\r\n\r\n        if (directoryExists(absolutePath)) {\r\n            throw Object.assign(\r\n                new Error(\"'filePath' should not be a directory path.\"),\r\n                { messageTemplate: \"print-config-with-directory-path\" }\r\n            );\r\n        }\r\n\r\n        return configArrayFactory\r\n            .getConfigArrayForFile(absolutePath)\r\n            .extractConfig(absolutePath)\r\n            .toCompatibleObjectAsConfigFileContent();\r\n    }\r\n\r\n    /**\r\n     * Checks if a given path is ignored by ESLint.\r\n     * @param {string} filePath The path of the file to check.\r\n     * @returns {boolean} Whether or not the given path is ignored.\r\n     */\r\n    isPathIgnored(filePath) {\r\n        const {\r\n            configArrayFactory,\r\n            defaultIgnores,\r\n            options: { cwd, ignore }\r\n        } = internalSlotsMap.get(this);\r\n        const absolutePath = path.resolve(cwd, filePath);\r\n\r\n        if (ignore) {\r\n            const config = configArrayFactory\r\n                .getConfigArrayForFile(absolutePath)\r\n                .extractConfig(absolutePath);\r\n            const ignores = config.ignores || defaultIgnores;\r\n\r\n            return ignores(absolutePath);\r\n        }\r\n\r\n        return defaultIgnores(absolutePath);\r\n    }\r\n\r\n    /**\r\n     * Returns the formatter representing the given format or null if the `format` is not a string.\r\n     * @param {string} [format] The name of the format to load or the path to a\r\n     *      custom formatter.\r\n     * @throws {any} As may be thrown by requiring of formatter\r\n     * @returns {(Function|null)} The formatter function or null if the `format` is not a string.\r\n     */\r\n    getFormatter(format) {\r\n\r\n        // default is stylish\r\n        const resolvedFormatName = format || \"stylish\";\r\n\r\n        // only strings are valid formatters\r\n        if (typeof resolvedFormatName === \"string\") {\r\n\r\n            // replace \\ with / for Windows compatibility\r\n            const normalizedFormatName = resolvedFormatName.replace(/\\\\/gu, \"/\");\r\n\r\n            const slots = internalSlotsMap.get(this);\r\n            const cwd = slots ? slots.options.cwd : process.cwd();\r\n            const namespace = naming.getNamespaceFromTerm(normalizedFormatName);\r\n\r\n            let formatterPath;\r\n\r\n            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)\r\n            if (!namespace && normalizedFormatName.indexOf(\"/\") > -1) {\r\n                formatterPath = path.resolve(cwd, normalizedFormatName);\r\n            } else {\r\n                try {\r\n                    const npmFormat = naming.normalizePackageName(normalizedFormatName, \"eslint-formatter\");\r\n\r\n                    formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, \"__placeholder__.js\"));\r\n                } catch {\r\n                    formatterPath = path.resolve(__dirname, \"formatters\", normalizedFormatName);\r\n                }\r\n            }\r\n\r\n            try {\r\n                return require(formatterPath);\r\n            } catch (ex) {\r\n                if (format === \"table\" || format === \"codeframe\") {\r\n                    ex.message = `The ${format} formatter is no longer part of core ESLint. Install it manually with \\`npm install -D eslint-formatter-${format}\\``;\r\n                } else {\r\n                    ex.message = `There was a problem loading formatter: ${formatterPath}\\nError: ${ex.message}`;\r\n                }\r\n                throw ex;\r\n            }\r\n\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nCLIEngine.version = pkg.version;\r\nCLIEngine.getFormatter = CLIEngine.prototype.getFormatter;\r\n\r\nmodule.exports = {\r\n    CLIEngine,\r\n\r\n    /**\r\n     * Get the internal slots of a given CLIEngine instance for tests.\r\n     * @param {CLIEngine} instance The CLIEngine instance to get.\r\n     * @returns {CLIEngineInternalSlots} The internal slots.\r\n     */\r\n    getCLIEngineInternalSlots(instance) {\r\n        return internalSlotsMap.get(instance);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}