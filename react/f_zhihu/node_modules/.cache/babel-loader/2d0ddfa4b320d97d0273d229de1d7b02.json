{"ast":null,"code":"/**\r\n * @fileoverview disallow unnecessary concatenation of template strings\r\n * @author Henry Zhu\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given node is a concatenation.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a concatenation.\r\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\r\n * Checks if the given token is a `+` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `+` token.\r\n */\n\n\nfunction isConcatOperatorToken(token) {\n  return token.value === \"+\" && token.type === \"Punctuator\";\n}\n/**\r\n * Get's the right most node on the left side of a BinaryExpression with + operator.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {ASTNode} node\r\n */\n\n\nfunction getLeft(node) {\n  let left = node.left;\n\n  while (isConcatenation(left)) {\n    left = left.right;\n  }\n\n  return left;\n}\n/**\r\n * Get's the left most node on the right side of a BinaryExpression with + operator.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {ASTNode} node\r\n */\n\n\nfunction getRight(node) {\n  let right = node.right;\n\n  while (isConcatenation(right)) {\n    right = right.left;\n  }\n\n  return right;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary concatenation of literals or template literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-concat\"\n    },\n    schema: [],\n    messages: {\n      unexpectedConcat: \"Unexpected string concatenation of literals.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      BinaryExpression(node) {\n        // check if not concatenation\n        if (node.operator !== \"+\") {\n          return;\n        } // account for the `foo + \"a\" + \"b\"` case\n\n\n        const left = getLeft(node);\n        const right = getRight(node);\n\n        if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {\n          const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\n          context.report({\n            node,\n            loc: operatorToken.loc,\n            messageId: \"unexpectedConcat\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-concat.js"],"names":["astUtils","require","isConcatenation","node","type","operator","isConcatOperatorToken","token","value","getLeft","left","right","getRight","module","exports","meta","docs","description","recommended","url","schema","messages","unexpectedConcat","create","context","sourceCode","getSourceCode","BinaryExpression","isStringLiteral","isTokenOnSameLine","operatorToken","getFirstTokenBetween","report","loc","messageId"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBC,IAAzB,EAA+B;AAC3B,SAAOA,IAAI,CAACC,IAAL,KAAc,kBAAd,IAAoCD,IAAI,CAACE,QAAL,KAAkB,GAA7D;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,qBAAT,CAA+BC,KAA/B,EAAsC;AAClC,SAAOA,KAAK,CAACC,KAAN,KAAgB,GAAhB,IAAuBD,KAAK,CAACH,IAAN,KAAe,YAA7C;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASK,OAAT,CAAiBN,IAAjB,EAAuB;AACnB,MAAIO,IAAI,GAAGP,IAAI,CAACO,IAAhB;;AAEA,SAAOR,eAAe,CAACQ,IAAD,CAAtB,EAA8B;AAC1BA,IAAAA,IAAI,GAAGA,IAAI,CAACC,KAAZ;AACH;;AACD,SAAOD,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASE,QAAT,CAAkBT,IAAlB,EAAwB;AACpB,MAAIQ,KAAK,GAAGR,IAAI,CAACQ,KAAjB;;AAEA,SAAOT,eAAe,CAACS,KAAD,CAAtB,EAA+B;AAC3BA,IAAAA,KAAK,GAAGA,KAAK,CAACD,IAAd;AACH;;AACD,SAAOC,KAAP;AACH,C,CAED;AACA;AACA;;AAEA;;;AACAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFX,IAAAA,IAAI,EAAE,YADJ;AAGFY,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qEADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,EATN;AAWFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,gBAAgB,EAAE;AADZ;AAXR,GADO;;AAiBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AAEA,WAAO;AACHC,MAAAA,gBAAgB,CAACxB,IAAD,EAAO;AAEnB;AACA,YAAIA,IAAI,CAACE,QAAL,KAAkB,GAAtB,EAA2B;AACvB;AACH,SALkB,CAOnB;;;AACA,cAAMK,IAAI,GAAGD,OAAO,CAACN,IAAD,CAApB;AACA,cAAMQ,KAAK,GAAGC,QAAQ,CAACT,IAAD,CAAtB;;AAEA,YAAIH,QAAQ,CAAC4B,eAAT,CAAyBlB,IAAzB,KACAV,QAAQ,CAAC4B,eAAT,CAAyBjB,KAAzB,CADA,IAEAX,QAAQ,CAAC6B,iBAAT,CAA2BnB,IAA3B,EAAiCC,KAAjC,CAFJ,EAGE;AACE,gBAAMmB,aAAa,GAAGL,UAAU,CAACM,oBAAX,CAAgCrB,IAAhC,EAAsCC,KAAtC,EAA6CL,qBAA7C,CAAtB;AAEAkB,UAAAA,OAAO,CAACQ,MAAR,CAAe;AACX7B,YAAAA,IADW;AAEX8B,YAAAA,GAAG,EAAEH,aAAa,CAACG,GAFR;AAGXC,YAAAA,SAAS,EAAE;AAHA,WAAf;AAKH;AACJ;;AAxBE,KAAP;AA0BH;;AA9CY,CAAjB","sourcesContent":["/**\r\n * @fileoverview disallow unnecessary concatenation of template strings\r\n * @author Henry Zhu\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given node is a concatenation.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a concatenation.\r\n */\r\nfunction isConcatenation(node) {\r\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a `+` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `+` token.\r\n */\r\nfunction isConcatOperatorToken(token) {\r\n    return token.value === \"+\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Get's the right most node on the left side of a BinaryExpression with + operator.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {ASTNode} node\r\n */\r\nfunction getLeft(node) {\r\n    let left = node.left;\r\n\r\n    while (isConcatenation(left)) {\r\n        left = left.right;\r\n    }\r\n    return left;\r\n}\r\n\r\n/**\r\n * Get's the left most node on the right side of a BinaryExpression with + operator.\r\n * @param {ASTNode} node A BinaryExpression node to check.\r\n * @returns {ASTNode} node\r\n */\r\nfunction getRight(node) {\r\n    let right = node.right;\r\n\r\n    while (isConcatenation(right)) {\r\n        right = right.left;\r\n    }\r\n    return right;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary concatenation of literals or template literals\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-useless-concat\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unexpectedConcat: \"Unexpected string concatenation of literals.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        return {\r\n            BinaryExpression(node) {\r\n\r\n                // check if not concatenation\r\n                if (node.operator !== \"+\") {\r\n                    return;\r\n                }\r\n\r\n                // account for the `foo + \"a\" + \"b\"` case\r\n                const left = getLeft(node);\r\n                const right = getRight(node);\r\n\r\n                if (astUtils.isStringLiteral(left) &&\r\n                    astUtils.isStringLiteral(right) &&\r\n                    astUtils.isTokenOnSameLine(left, right)\r\n                ) {\r\n                    const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: operatorToken.loc,\r\n                        messageId: \"unexpectedConcat\"\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}