{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({\n  type: \"BinaryExpression\",\n  operator: \"**\"\n});\n/**\r\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\r\n * @param {ASTNode} base The node to check.\r\n * @returns {boolean} `true` if the node needs to be parenthesised.\r\n */\n\nfunction doesBaseNeedParens(base) {\n  return (// '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\n    astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || // An unary operator cannot be used immediately before an exponentiation expression\n    base.type === \"AwaitExpression\" || base.type === \"UnaryExpression\"\n  );\n}\n/**\r\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\r\n * @param {ASTNode} exponent The node to check.\r\n * @returns {boolean} `true` if the node needs to be parenthesised.\r\n */\n\n\nfunction doesExponentNeedParens(exponent) {\n  // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\n  return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\n}\n/**\r\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\r\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\r\n * @param {SourceCode} sourceCode A SourceCode object.\r\n * @returns {boolean} `true` if the expression needs to be parenthesised.\r\n */\n\n\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\n  const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n  const needsParens = parent.type === \"ClassDeclaration\" || parent.type.endsWith(\"Expression\") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) && !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) && !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) && !(parent.type === \"ArrayExpression\");\n  return needsParens && !astUtils.isParenthesised(sourceCode, node);\n}\n/**\r\n * Optionally parenthesizes given text.\r\n * @param {string} text The text to parenthesize.\r\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\r\n * @returns {string} parenthesised or unchanged text.\r\n */\n\n\nfunction parenthesizeIfShould(text, shouldParenthesize) {\n  return shouldParenthesize ? `(${text})` : text;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports the given node.\r\n     * @param {ASTNode} node 'Math.pow()' node to report.\r\n     * @returns {void}\r\n     */\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"useExponentiation\",\n\n        fix(fixer) {\n          if (node.arguments.length !== 2 || node.arguments.some(arg => arg.type === \"SpreadElement\") || sourceCode.getCommentsInside(node).length > 0) {\n            return null;\n          }\n\n          const base = node.arguments[0],\n                exponent = node.arguments[1],\n                baseText = sourceCode.getText(base),\n                exponentText = sourceCode.getText(exponent),\n                shouldParenthesizeBase = doesBaseNeedParens(base),\n                shouldParenthesizeExponent = doesExponentNeedParens(exponent),\n                shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\n          let prefix = \"\",\n              suffix = \"\";\n\n          if (!shouldParenthesizeAll) {\n            if (!shouldParenthesizeBase) {\n              const firstReplacementToken = sourceCode.getFirstToken(base),\n                    tokenBefore = sourceCode.getTokenBefore(node);\n\n              if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\n              }\n            }\n\n            if (!shouldParenthesizeExponent) {\n              const lastReplacementToken = sourceCode.getLastToken(exponent),\n                    tokenAfter = sourceCode.getTokenAfter(node);\n\n              if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {\n                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\n              }\n            }\n          }\n\n          const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\n                exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\n                replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\n          return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\n        }\n\n      });\n    }\n\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Math: {\n            pow: {\n              [CALL]: true\n            }\n          }\n        };\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-exponentiation-operator.js"],"names":["astUtils","require","CALL","ReferenceTracker","PRECEDENCE_OF_EXPONENTIATION_EXPR","getPrecedence","type","operator","doesBaseNeedParens","base","doesExponentNeedParens","exponent","doesExponentiationExpressionNeedParens","node","sourceCode","parent","needsParens","endsWith","right","arguments","includes","computed","property","isParenthesised","parenthesizeIfShould","text","shouldParenthesize","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","useExponentiation","create","context","getSourceCode","report","messageId","fix","fixer","length","some","arg","getCommentsInside","baseText","getText","exponentText","shouldParenthesizeBase","shouldParenthesizeExponent","shouldParenthesizeAll","prefix","suffix","firstReplacementToken","getFirstToken","tokenBefore","getTokenBefore","range","canTokensBeAdjacent","lastReplacementToken","getLastToken","tokenAfter","getTokenAfter","baseReplacement","exponentReplacement","replacement","replaceText","Program","scope","getScope","tracker","trackMap","Math","pow","iterateGlobalReferences"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow Math.pow in favor of the ** operator\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({ type: \"BinaryExpression\", operator: \"**\" });\r\n\r\n/**\r\n * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.\r\n * @param {ASTNode} base The node to check.\r\n * @returns {boolean} `true` if the node needs to be parenthesised.\r\n */\r\nfunction doesBaseNeedParens(base) {\r\n    return (\r\n\r\n        // '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c\r\n        astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||\r\n\r\n        // An unary operator cannot be used immediately before an exponentiation expression\r\n        base.type === \"AwaitExpression\" ||\r\n        base.type === \"UnaryExpression\"\r\n    );\r\n}\r\n\r\n/**\r\n * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.\r\n * @param {ASTNode} exponent The node to check.\r\n * @returns {boolean} `true` if the node needs to be parenthesised.\r\n */\r\nfunction doesExponentNeedParens(exponent) {\r\n\r\n    // '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c\r\n    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;\r\n}\r\n\r\n/**\r\n * Determines whether an exponentiation binary expression at the place of the given node would need parens.\r\n * @param {ASTNode} node A node that would be replaced by an exponentiation binary expression.\r\n * @param {SourceCode} sourceCode A SourceCode object.\r\n * @returns {boolean} `true` if the expression needs to be parenthesised.\r\n */\r\nfunction doesExponentiationExpressionNeedParens(node, sourceCode) {\r\n    const parent = node.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\r\n\r\n    const needsParens = (\r\n        parent.type === \"ClassDeclaration\" ||\r\n        (\r\n            parent.type.endsWith(\"Expression\") &&\r\n            astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR &&\r\n            !(parent.type === \"BinaryExpression\" && parent.operator === \"**\" && parent.right === node) &&\r\n            !((parent.type === \"CallExpression\" || parent.type === \"NewExpression\") && parent.arguments.includes(node)) &&\r\n            !(parent.type === \"MemberExpression\" && parent.computed && parent.property === node) &&\r\n            !(parent.type === \"ArrayExpression\")\r\n        )\r\n    );\r\n\r\n    return needsParens && !astUtils.isParenthesised(sourceCode, node);\r\n}\r\n\r\n/**\r\n * Optionally parenthesizes given text.\r\n * @param {string} text The text to parenthesize.\r\n * @param {boolean} shouldParenthesize If `true`, the text will be parenthesised.\r\n * @returns {string} parenthesised or unchanged text.\r\n */\r\nfunction parenthesizeIfShould(text, shouldParenthesize) {\r\n    return shouldParenthesize ? `(${text})` : text;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow the use of `Math.pow` in favor of the `**` operator\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-exponentiation-operator\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            useExponentiation: \"Use the '**' operator instead of 'Math.pow'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports the given node.\r\n         * @param {ASTNode} node 'Math.pow()' node to report.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"useExponentiation\",\r\n                fix(fixer) {\r\n                    if (\r\n                        node.arguments.length !== 2 ||\r\n                        node.arguments.some(arg => arg.type === \"SpreadElement\") ||\r\n                        sourceCode.getCommentsInside(node).length > 0\r\n                    ) {\r\n                        return null;\r\n                    }\r\n\r\n                    const base = node.arguments[0],\r\n                        exponent = node.arguments[1],\r\n                        baseText = sourceCode.getText(base),\r\n                        exponentText = sourceCode.getText(exponent),\r\n                        shouldParenthesizeBase = doesBaseNeedParens(base),\r\n                        shouldParenthesizeExponent = doesExponentNeedParens(exponent),\r\n                        shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);\r\n\r\n                    let prefix = \"\",\r\n                        suffix = \"\";\r\n\r\n                    if (!shouldParenthesizeAll) {\r\n                        if (!shouldParenthesizeBase) {\r\n                            const firstReplacementToken = sourceCode.getFirstToken(base),\r\n                                tokenBefore = sourceCode.getTokenBefore(node);\r\n\r\n                            if (\r\n                                tokenBefore &&\r\n                                tokenBefore.range[1] === node.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\r\n                            ) {\r\n                                prefix = \" \"; // a+Math.pow(++b, c) -> a+ ++b**c\r\n                            }\r\n                        }\r\n                        if (!shouldParenthesizeExponent) {\r\n                            const lastReplacementToken = sourceCode.getLastToken(exponent),\r\n                                tokenAfter = sourceCode.getTokenAfter(node);\r\n\r\n                            if (\r\n                                tokenAfter &&\r\n                                node.range[1] === tokenAfter.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)\r\n                            ) {\r\n                                suffix = \" \"; // Math.pow(a, b)in c -> a**b in c\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase),\r\n                        exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent),\r\n                        replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);\r\n\r\n                    return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                const scope = context.getScope();\r\n                const tracker = new ReferenceTracker(scope);\r\n                const trackMap = {\r\n                    Math: {\r\n                        pow: { [CALL]: true }\r\n                    }\r\n                };\r\n\r\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\r\n                    report(node);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}