{"ast":null,"code":"/**\r\n * @fileoverview Rule to warn when a function expression does not have a name.\r\n * @author Kyle T. Nunery\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n/**\r\n * Checks whether or not a given variable is a function name.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is a function name.\r\n */\n\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow named `function` expressions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/func-names\"\n    },\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always\", \"as-needed\", \"never\"]\n        }\n      },\n      items: [{\n        $ref: \"#/definitions/value\"\n      }, {\n        type: \"object\",\n        properties: {\n          generators: {\n            $ref: \"#/definitions/value\"\n          }\n        },\n        additionalProperties: false\n      }]\n    },\n    messages: {\n      unnamed: \"Unexpected unnamed {{name}}.\",\n      named: \"Unexpected named {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Returns the config option for the given node.\r\n     * @param {ASTNode} node A node to get the config for.\r\n     * @returns {string} The config option.\r\n     */\n\n    function getConfigForNode(node) {\n      if (node.generator && context.options.length > 1 && context.options[1].generators) {\n        return context.options[1].generators;\n      }\n\n      return context.options[0] || \"always\";\n    }\n    /**\r\n     * Determines whether the current FunctionExpression node is a get, set, or\r\n     * shorthand method in an object literal or a class.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} True if the node is a get, set, or shorthand method.\r\n     */\n\n\n    function isObjectOrClassMethod(node) {\n      const parent = node.parent;\n      return parent.type === \"MethodDefinition\" || parent.type === \"Property\" && (parent.method || parent.kind === \"get\" || parent.kind === \"set\");\n    }\n    /**\r\n     * Determines whether the current FunctionExpression node has a name that would be\r\n     * inferred from context in a conforming ES6 environment.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} True if the node would have a name assigned automatically.\r\n     */\n\n\n    function hasInferredName(node) {\n      const parent = node.parent;\n      return isObjectOrClassMethod(node) || parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node || parent.type === \"Property\" && parent.value === node || parent.type === \"PropertyDefinition\" && parent.value === node || parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node || parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node;\n    }\n    /**\r\n     * Reports that an unnamed function should be named\r\n     * @param {ASTNode} node The node to report in the event of an error.\r\n     * @returns {void}\r\n     */\n\n\n    function reportUnexpectedUnnamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"unnamed\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n    /**\r\n     * Reports that a named function should be unnamed\r\n     * @param {ASTNode} node The node to report in the event of an error.\r\n     * @returns {void}\r\n     */\n\n\n    function reportUnexpectedNamedFunction(node) {\n      context.report({\n        node,\n        messageId: \"named\",\n        loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n        data: {\n          name: astUtils.getFunctionNameWithKind(node)\n        }\n      });\n    }\n    /**\r\n     * The listener for function nodes.\r\n     * @param {ASTNode} node function node\r\n     * @returns {void}\r\n     */\n\n\n    function handleFunction(node) {\n      // Skip recursive functions.\n      const nameVar = context.getDeclaredVariables(node)[0];\n\n      if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n        return;\n      }\n\n      const hasName = Boolean(node.id && node.id.name);\n      const config = getConfigForNode(node);\n\n      if (config === \"never\") {\n        if (hasName && node.type !== \"FunctionDeclaration\") {\n          reportUnexpectedNamedFunction(node);\n        }\n      } else if (config === \"as-needed\") {\n        if (!hasName && !hasInferredName(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      } else {\n        if (!hasName && !isObjectOrClassMethod(node)) {\n          reportUnexpectedUnnamedFunction(node);\n        }\n      }\n    }\n\n    return {\n      \"FunctionExpression:exit\": handleFunction,\n      \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/func-names.js"],"names":["astUtils","require","isFunctionName","variable","defs","type","module","exports","meta","docs","description","recommended","url","schema","definitions","value","enum","items","$ref","properties","generators","additionalProperties","messages","unnamed","named","create","context","sourceCode","getSourceCode","getConfigForNode","node","generator","options","length","isObjectOrClassMethod","parent","method","kind","hasInferredName","id","init","left","right","reportUnexpectedUnnamedFunction","report","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportUnexpectedNamedFunction","handleFunction","nameVar","getDeclaredVariables","references","hasName","Boolean","config"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to warn when a function expression does not have a name.\r\n * @author Kyle T. Nunery\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n/**\r\n * Checks whether or not a given variable is a function name.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is a function name.\r\n */\r\nfunction isFunctionName(variable) {\r\n    return variable && variable.defs[0].type === \"FunctionName\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require or disallow named `function` expressions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/func-names\"\r\n        },\r\n\r\n        schema: {\r\n            definitions: {\r\n                value: {\r\n                    enum: [\r\n                        \"always\",\r\n                        \"as-needed\",\r\n                        \"never\"\r\n                    ]\r\n                }\r\n            },\r\n            items: [\r\n                {\r\n                    $ref: \"#/definitions/value\"\r\n                },\r\n                {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        generators: {\r\n                            $ref: \"#/definitions/value\"\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            unnamed: \"Unexpected unnamed {{name}}.\",\r\n            named: \"Unexpected named {{name}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Returns the config option for the given node.\r\n         * @param {ASTNode} node A node to get the config for.\r\n         * @returns {string} The config option.\r\n         */\r\n        function getConfigForNode(node) {\r\n            if (\r\n                node.generator &&\r\n                context.options.length > 1 &&\r\n                context.options[1].generators\r\n            ) {\r\n                return context.options[1].generators;\r\n            }\r\n\r\n            return context.options[0] || \"always\";\r\n        }\r\n\r\n        /**\r\n         * Determines whether the current FunctionExpression node is a get, set, or\r\n         * shorthand method in an object literal or a class.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} True if the node is a get, set, or shorthand method.\r\n         */\r\n        function isObjectOrClassMethod(node) {\r\n            const parent = node.parent;\r\n\r\n            return (parent.type === \"MethodDefinition\" || (\r\n                parent.type === \"Property\" && (\r\n                    parent.method ||\r\n                    parent.kind === \"get\" ||\r\n                    parent.kind === \"set\"\r\n                )\r\n            ));\r\n        }\r\n\r\n        /**\r\n         * Determines whether the current FunctionExpression node has a name that would be\r\n         * inferred from context in a conforming ES6 environment.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} True if the node would have a name assigned automatically.\r\n         */\r\n        function hasInferredName(node) {\r\n            const parent = node.parent;\r\n\r\n            return isObjectOrClassMethod(node) ||\r\n                (parent.type === \"VariableDeclarator\" && parent.id.type === \"Identifier\" && parent.init === node) ||\r\n                (parent.type === \"Property\" && parent.value === node) ||\r\n                (parent.type === \"PropertyDefinition\" && parent.value === node) ||\r\n                (parent.type === \"AssignmentExpression\" && parent.left.type === \"Identifier\" && parent.right === node) ||\r\n                (parent.type === \"AssignmentPattern\" && parent.left.type === \"Identifier\" && parent.right === node);\r\n        }\r\n\r\n        /**\r\n         * Reports that an unnamed function should be named\r\n         * @param {ASTNode} node The node to report in the event of an error.\r\n         * @returns {void}\r\n         */\r\n        function reportUnexpectedUnnamedFunction(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"unnamed\",\r\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\r\n                data: { name: astUtils.getFunctionNameWithKind(node) }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports that a named function should be unnamed\r\n         * @param {ASTNode} node The node to report in the event of an error.\r\n         * @returns {void}\r\n         */\r\n        function reportUnexpectedNamedFunction(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"named\",\r\n                loc: astUtils.getFunctionHeadLoc(node, sourceCode),\r\n                data: { name: astUtils.getFunctionNameWithKind(node) }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * The listener for function nodes.\r\n         * @param {ASTNode} node function node\r\n         * @returns {void}\r\n         */\r\n        function handleFunction(node) {\r\n\r\n            // Skip recursive functions.\r\n            const nameVar = context.getDeclaredVariables(node)[0];\r\n\r\n            if (isFunctionName(nameVar) && nameVar.references.length > 0) {\r\n                return;\r\n            }\r\n\r\n            const hasName = Boolean(node.id && node.id.name);\r\n            const config = getConfigForNode(node);\r\n\r\n            if (config === \"never\") {\r\n                if (hasName && node.type !== \"FunctionDeclaration\") {\r\n                    reportUnexpectedNamedFunction(node);\r\n                }\r\n            } else if (config === \"as-needed\") {\r\n                if (!hasName && !hasInferredName(node)) {\r\n                    reportUnexpectedUnnamedFunction(node);\r\n                }\r\n            } else {\r\n                if (!hasName && !isObjectOrClassMethod(node)) {\r\n                    reportUnexpectedUnnamedFunction(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"FunctionExpression:exit\": handleFunction,\r\n            \"ExportDefaultDeclaration > FunctionDeclaration\": handleFunction\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}