{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag missing semicolons.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow semicolons instead of ASI\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"never\"]\n        }, {\n          type: \"object\",\n          properties: {\n            beforeStatementContinuationChars: {\n              enum: [\"always\", \"any\", \"never\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            omitLastInOneLineBlock: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      missingSemi: \"Missing semicolon.\",\n      extraSemi: \"Extra semicolon.\"\n    }\n  },\n\n  create(context) {\n    const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`\n\n    const unsafeClassFieldNames = new Set([\"get\", \"set\", \"static\"]);\n    const unsafeClassFieldFollowers = new Set([\"*\", \"in\", \"instanceof\"]);\n    const options = context.options[1];\n    const never = context.options[0] === \"never\";\n    const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);\n    const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || \"any\";\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Reports a semicolon error with appropriate location and message.\r\n     * @param {ASTNode} node The node with an extra or missing semicolon.\r\n     * @param {boolean} missing True if the semicolon is missing.\r\n     * @returns {void}\r\n     */\n\n    function report(node, missing) {\n      const lastToken = sourceCode.getLastToken(node);\n      let messageId, fix, loc;\n\n      if (!missing) {\n        messageId = \"missingSemi\";\n        loc = {\n          start: lastToken.loc.end,\n          end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)\n        };\n\n        fix = function (fixer) {\n          return fixer.insertTextAfter(lastToken, \";\");\n        };\n      } else {\n        messageId = \"extraSemi\";\n        loc = lastToken.loc;\n\n        fix = function (fixer) {\n          /*\r\n           * Expand the replacement range to include the surrounding\r\n           * tokens to avoid conflicting with no-extra-semi.\r\n           * https://github.com/eslint/eslint/issues/7928\r\n           */\n          return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);\n        };\n      }\n\n      context.report({\n        node,\n        loc,\n        messageId,\n        fix\n      });\n    }\n    /**\r\n     * Check whether a given semicolon token is redundant.\r\n     * @param {Token} semiToken A semicolon token to check.\r\n     * @returns {boolean} `true` if the next token is `;` or `}`.\r\n     */\n\n\n    function isRedundantSemi(semiToken) {\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);\n    }\n    /**\r\n     * Check whether a given token is the closing brace of an arrow function.\r\n     * @param {Token} lastToken A token to check.\r\n     * @returns {boolean} `true` if the token is the closing brace of an arrow function.\r\n     */\n\n\n    function isEndOfArrowBlock(lastToken) {\n      if (!astUtils.isClosingBraceToken(lastToken)) {\n        return false;\n      }\n\n      const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);\n      return node.type === \"BlockStatement\" && node.parent.type === \"ArrowFunctionExpression\";\n    }\n    /**\r\n     * Checks if a given PropertyDefinition node followed by a semicolon\r\n     * can safely remove that semicolon. It is not to safe to remove if\r\n     * the class field name is \"get\", \"set\", or \"static\", or if\r\n     * followed by a generator method.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node cannot have the semicolon\r\n     *      removed.\r\n     */\n\n\n    function maybeClassFieldAsiHazard(node) {\n      if (node.type !== \"PropertyDefinition\") {\n        return false;\n      }\n      /*\r\n       * Computed property names and non-identifiers are always safe\r\n       * as they can be distinguished from keywords easily.\r\n       */\n\n\n      const needsNameCheck = !node.computed && node.key.type === \"Identifier\";\n      /*\r\n       * Certain names are problematic unless they also have a\r\n       * a way to distinguish between keywords and property\r\n       * names.\r\n       */\n\n      if (needsNameCheck && unsafeClassFieldNames.has(node.key.name)) {\n        /*\r\n         * Special case: If the field name is `static`,\r\n         * it is only valid if the field is marked as static,\r\n         * so \"static static\" is okay but \"static\" is not.\r\n         */\n        const isStaticStatic = node.static && node.key.name === \"static\";\n        /*\r\n         * For other unsafe names, we only care if there is no\r\n         * initializer. No initializer = hazard.\r\n         */\n\n        if (!isStaticStatic && !node.value) {\n          return true;\n        }\n      }\n\n      const followingToken = sourceCode.getTokenAfter(node);\n      return unsafeClassFieldFollowers.has(followingToken.value);\n    }\n    /**\r\n     * Check whether a given node is on the same line with the next token.\r\n     * @param {Node} node A statement node to check.\r\n     * @returns {boolean} `true` if the node is on the same line with the next token.\r\n     */\n\n\n    function isOnSameLineWithNextToken(node) {\n      const prevToken = sourceCode.getLastToken(node, 1);\n      const nextToken = sourceCode.getTokenAfter(node);\n      return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);\n    }\n    /**\r\n     * Check whether a given node can connect the next line if the next line is unreliable.\r\n     * @param {Node} node A statement node to check.\r\n     * @returns {boolean} `true` if the node can connect the next line.\r\n     */\n\n\n    function maybeAsiHazardAfter(node) {\n      const t = node.type;\n\n      if (t === \"DoWhileStatement\" || t === \"BreakStatement\" || t === \"ContinueStatement\" || t === \"DebuggerStatement\" || t === \"ImportDeclaration\" || t === \"ExportAllDeclaration\") {\n        return false;\n      }\n\n      if (t === \"ReturnStatement\") {\n        return Boolean(node.argument);\n      }\n\n      if (t === \"ExportNamedDeclaration\") {\n        return Boolean(node.declaration);\n      }\n\n      if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Check whether a given token can connect the previous statement.\r\n     * @param {Token} token A token to check.\r\n     * @returns {boolean} `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.\r\n     */\n\n\n    function maybeAsiHazardBefore(token) {\n      return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== \"++\" && token.value !== \"--\";\n    }\n    /**\r\n     * Check if the semicolon of a given node is unnecessary, only true if:\r\n     *   - next token is a valid statement divider (`;` or `}`).\r\n     *   - next token is on a new line and the node is not connectable to the new line.\r\n     * @param {Node} node A statement node to check.\r\n     * @returns {boolean} whether the semicolon is unnecessary.\r\n     */\n\n\n    function canRemoveSemicolon(node) {\n      if (isRedundantSemi(sourceCode.getLastToken(node))) {\n        return true; // `;;` or `;}`\n      }\n\n      if (maybeClassFieldAsiHazard(node)) {\n        return false;\n      }\n\n      if (isOnSameLineWithNextToken(node)) {\n        return false; // One liner.\n      } // continuation characters should not apply to class fields\n\n\n      if (node.type !== \"PropertyDefinition\" && beforeStatementContinuationChars === \"never\" && !maybeAsiHazardAfter(node)) {\n        return true; // ASI works. This statement doesn't connect to the next.\n      }\n\n      if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n        return true; // ASI works. The next token doesn't connect to this statement.\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks a node to see if it's the last item in a one-liner block.\r\n     * Block is any `BlockStatement` or `StaticBlock` node. Block is a one-liner if its\r\n     * braces (and consequently everything between them) are on the same line.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} whether the node is the last item in a one-liner block.\r\n     */\n\n\n    function isLastInOneLinerBlock(node) {\n      const parent = node.parent;\n      const nextToken = sourceCode.getTokenAfter(node);\n\n      if (!nextToken || nextToken.value !== \"}\") {\n        return false;\n      }\n\n      if (parent.type === \"BlockStatement\") {\n        return parent.loc.start.line === parent.loc.end.line;\n      }\n\n      if (parent.type === \"StaticBlock\") {\n        const openingBrace = sourceCode.getFirstToken(parent, {\n          skip: 1\n        }); // skip the `static` token\n\n        return openingBrace.loc.start.line === parent.loc.end.line;\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks a node to see if it's followed by a semicolon.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForSemicolon(node) {\n      const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));\n\n      if (never) {\n        if (isSemi && canRemoveSemicolon(node)) {\n          report(node, true);\n        } else if (!isSemi && beforeStatementContinuationChars === \"always\" && node.type !== \"PropertyDefinition\" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\n          report(node);\n        }\n      } else {\n        const oneLinerBlock = exceptOneLine && isLastInOneLinerBlock(node);\n\n        if (isSemi && oneLinerBlock) {\n          report(node, true);\n        } else if (!isSemi && !oneLinerBlock) {\n          report(node);\n        }\n      }\n    }\n    /**\r\n     * Checks to see if there's a semicolon after a variable declaration.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForSemicolonForVariableDeclaration(node) {\n      const parent = node.parent;\n\n      if ((parent.type !== \"ForStatement\" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {\n        checkForSemicolon(node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclaration: checkForSemicolonForVariableDeclaration,\n      ExpressionStatement: checkForSemicolon,\n      ReturnStatement: checkForSemicolon,\n      ThrowStatement: checkForSemicolon,\n      DoWhileStatement: checkForSemicolon,\n      DebuggerStatement: checkForSemicolon,\n      BreakStatement: checkForSemicolon,\n      ContinueStatement: checkForSemicolon,\n      ImportDeclaration: checkForSemicolon,\n      ExportAllDeclaration: checkForSemicolon,\n\n      ExportNamedDeclaration(node) {\n        if (!node.declaration) {\n          checkForSemicolon(node);\n        }\n      },\n\n      ExportDefaultDeclaration(node) {\n        if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {\n          checkForSemicolon(node);\n        }\n      },\n\n      PropertyDefinition: checkForSemicolon\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/semi.js"],"names":["FixTracker","require","astUtils","module","exports","meta","type","docs","description","recommended","url","fixable","schema","anyOf","items","enum","properties","beforeStatementContinuationChars","additionalProperties","minItems","maxItems","omitLastInOneLineBlock","messages","missingSemi","extraSemi","create","context","OPT_OUT_PATTERN","unsafeClassFieldNames","Set","unsafeClassFieldFollowers","options","never","exceptOneLine","Boolean","sourceCode","getSourceCode","report","node","missing","lastToken","getLastToken","messageId","fix","loc","start","end","getNextLocation","fixer","insertTextAfter","retainSurroundingTokens","remove","isRedundantSemi","semiToken","nextToken","getTokenAfter","isClosingBraceToken","isSemicolonToken","isEndOfArrowBlock","getNodeByRangeIndex","range","parent","maybeClassFieldAsiHazard","needsNameCheck","computed","key","has","name","isStaticStatic","static","value","followingToken","isOnSameLineWithNextToken","prevToken","isTokenOnSameLine","maybeAsiHazardAfter","t","argument","declaration","maybeAsiHazardBefore","token","test","canRemoveSemicolon","isLastInOneLinerBlock","line","openingBrace","getFirstToken","skip","checkForSemicolon","isSemi","oneLinerBlock","checkForSemicolonForVariableDeclaration","init","left","VariableDeclaration","ExpressionStatement","ReturnStatement","ThrowStatement","DoWhileStatement","DebuggerStatement","BreakStatement","ContinueStatement","ImportDeclaration","ExportAllDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","PropertyDefinition"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag missing semicolons.\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst FixTracker = require(\"./utils/fix-tracker\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow semicolons instead of ASI\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/semi\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"never\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                beforeStatementContinuationChars: {\r\n                                    enum: [\"always\", \"any\", \"never\"]\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                omitLastInOneLineBlock: { type: \"boolean\" }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            missingSemi: \"Missing semicolon.\",\r\n            extraSemi: \"Extra semicolon.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`\r\n        const unsafeClassFieldNames = new Set([\"get\", \"set\", \"static\"]);\r\n        const unsafeClassFieldFollowers = new Set([\"*\", \"in\", \"instanceof\"]);\r\n        const options = context.options[1];\r\n        const never = context.options[0] === \"never\";\r\n        const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);\r\n        const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || \"any\";\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Reports a semicolon error with appropriate location and message.\r\n         * @param {ASTNode} node The node with an extra or missing semicolon.\r\n         * @param {boolean} missing True if the semicolon is missing.\r\n         * @returns {void}\r\n         */\r\n        function report(node, missing) {\r\n            const lastToken = sourceCode.getLastToken(node);\r\n            let messageId,\r\n                fix,\r\n                loc;\r\n\r\n            if (!missing) {\r\n                messageId = \"missingSemi\";\r\n                loc = {\r\n                    start: lastToken.loc.end,\r\n                    end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)\r\n                };\r\n                fix = function(fixer) {\r\n                    return fixer.insertTextAfter(lastToken, \";\");\r\n                };\r\n            } else {\r\n                messageId = \"extraSemi\";\r\n                loc = lastToken.loc;\r\n                fix = function(fixer) {\r\n\r\n                    /*\r\n                     * Expand the replacement range to include the surrounding\r\n                     * tokens to avoid conflicting with no-extra-semi.\r\n                     * https://github.com/eslint/eslint/issues/7928\r\n                     */\r\n                    return new FixTracker(fixer, sourceCode)\r\n                        .retainSurroundingTokens(lastToken)\r\n                        .remove(lastToken);\r\n                };\r\n            }\r\n\r\n            context.report({\r\n                node,\r\n                loc,\r\n                messageId,\r\n                fix\r\n            });\r\n\r\n        }\r\n\r\n        /**\r\n         * Check whether a given semicolon token is redundant.\r\n         * @param {Token} semiToken A semicolon token to check.\r\n         * @returns {boolean} `true` if the next token is `;` or `}`.\r\n         */\r\n        function isRedundantSemi(semiToken) {\r\n            const nextToken = sourceCode.getTokenAfter(semiToken);\r\n\r\n            return (\r\n                !nextToken ||\r\n                astUtils.isClosingBraceToken(nextToken) ||\r\n                astUtils.isSemicolonToken(nextToken)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check whether a given token is the closing brace of an arrow function.\r\n         * @param {Token} lastToken A token to check.\r\n         * @returns {boolean} `true` if the token is the closing brace of an arrow function.\r\n         */\r\n        function isEndOfArrowBlock(lastToken) {\r\n            if (!astUtils.isClosingBraceToken(lastToken)) {\r\n                return false;\r\n            }\r\n            const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);\r\n\r\n            return (\r\n                node.type === \"BlockStatement\" &&\r\n                node.parent.type === \"ArrowFunctionExpression\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks if a given PropertyDefinition node followed by a semicolon\r\n         * can safely remove that semicolon. It is not to safe to remove if\r\n         * the class field name is \"get\", \"set\", or \"static\", or if\r\n         * followed by a generator method.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} `true` if the node cannot have the semicolon\r\n         *      removed.\r\n         */\r\n        function maybeClassFieldAsiHazard(node) {\r\n\r\n            if (node.type !== \"PropertyDefinition\") {\r\n                return false;\r\n            }\r\n\r\n            /*\r\n             * Computed property names and non-identifiers are always safe\r\n             * as they can be distinguished from keywords easily.\r\n             */\r\n            const needsNameCheck = !node.computed && node.key.type === \"Identifier\";\r\n\r\n            /*\r\n             * Certain names are problematic unless they also have a\r\n             * a way to distinguish between keywords and property\r\n             * names.\r\n             */\r\n            if (needsNameCheck && unsafeClassFieldNames.has(node.key.name)) {\r\n\r\n                /*\r\n                 * Special case: If the field name is `static`,\r\n                 * it is only valid if the field is marked as static,\r\n                 * so \"static static\" is okay but \"static\" is not.\r\n                 */\r\n                const isStaticStatic = node.static && node.key.name === \"static\";\r\n\r\n                /*\r\n                 * For other unsafe names, we only care if there is no\r\n                 * initializer. No initializer = hazard.\r\n                 */\r\n                if (!isStaticStatic && !node.value) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            const followingToken = sourceCode.getTokenAfter(node);\r\n\r\n            return unsafeClassFieldFollowers.has(followingToken.value);\r\n        }\r\n\r\n        /**\r\n         * Check whether a given node is on the same line with the next token.\r\n         * @param {Node} node A statement node to check.\r\n         * @returns {boolean} `true` if the node is on the same line with the next token.\r\n         */\r\n        function isOnSameLineWithNextToken(node) {\r\n            const prevToken = sourceCode.getLastToken(node, 1);\r\n            const nextToken = sourceCode.getTokenAfter(node);\r\n\r\n            return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);\r\n        }\r\n\r\n        /**\r\n         * Check whether a given node can connect the next line if the next line is unreliable.\r\n         * @param {Node} node A statement node to check.\r\n         * @returns {boolean} `true` if the node can connect the next line.\r\n         */\r\n        function maybeAsiHazardAfter(node) {\r\n            const t = node.type;\r\n\r\n            if (t === \"DoWhileStatement\" ||\r\n                t === \"BreakStatement\" ||\r\n                t === \"ContinueStatement\" ||\r\n                t === \"DebuggerStatement\" ||\r\n                t === \"ImportDeclaration\" ||\r\n                t === \"ExportAllDeclaration\"\r\n            ) {\r\n                return false;\r\n            }\r\n            if (t === \"ReturnStatement\") {\r\n                return Boolean(node.argument);\r\n            }\r\n            if (t === \"ExportNamedDeclaration\") {\r\n                return Boolean(node.declaration);\r\n            }\r\n            if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Check whether a given token can connect the previous statement.\r\n         * @param {Token} token A token to check.\r\n         * @returns {boolean} `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.\r\n         */\r\n        function maybeAsiHazardBefore(token) {\r\n            return (\r\n                Boolean(token) &&\r\n                OPT_OUT_PATTERN.test(token.value) &&\r\n                token.value !== \"++\" &&\r\n                token.value !== \"--\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check if the semicolon of a given node is unnecessary, only true if:\r\n         *   - next token is a valid statement divider (`;` or `}`).\r\n         *   - next token is on a new line and the node is not connectable to the new line.\r\n         * @param {Node} node A statement node to check.\r\n         * @returns {boolean} whether the semicolon is unnecessary.\r\n         */\r\n        function canRemoveSemicolon(node) {\r\n            if (isRedundantSemi(sourceCode.getLastToken(node))) {\r\n                return true; // `;;` or `;}`\r\n            }\r\n            if (maybeClassFieldAsiHazard(node)) {\r\n                return false;\r\n            }\r\n            if (isOnSameLineWithNextToken(node)) {\r\n                return false; // One liner.\r\n            }\r\n\r\n            // continuation characters should not apply to class fields\r\n            if (\r\n                node.type !== \"PropertyDefinition\" &&\r\n                beforeStatementContinuationChars === \"never\" &&\r\n                !maybeAsiHazardAfter(node)\r\n            ) {\r\n                return true; // ASI works. This statement doesn't connect to the next.\r\n            }\r\n            if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {\r\n                return true; // ASI works. The next token doesn't connect to this statement.\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks a node to see if it's the last item in a one-liner block.\r\n         * Block is any `BlockStatement` or `StaticBlock` node. Block is a one-liner if its\r\n         * braces (and consequently everything between them) are on the same line.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} whether the node is the last item in a one-liner block.\r\n         */\r\n        function isLastInOneLinerBlock(node) {\r\n            const parent = node.parent;\r\n            const nextToken = sourceCode.getTokenAfter(node);\r\n\r\n            if (!nextToken || nextToken.value !== \"}\") {\r\n                return false;\r\n            }\r\n\r\n            if (parent.type === \"BlockStatement\") {\r\n                return parent.loc.start.line === parent.loc.end.line;\r\n            }\r\n\r\n            if (parent.type === \"StaticBlock\") {\r\n                const openingBrace = sourceCode.getFirstToken(parent, { skip: 1 }); // skip the `static` token\r\n\r\n                return openingBrace.loc.start.line === parent.loc.end.line;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks a node to see if it's followed by a semicolon.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkForSemicolon(node) {\r\n            const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));\r\n\r\n            if (never) {\r\n                if (isSemi && canRemoveSemicolon(node)) {\r\n                    report(node, true);\r\n                } else if (\r\n                    !isSemi && beforeStatementContinuationChars === \"always\" &&\r\n                    node.type !== \"PropertyDefinition\" &&\r\n                    maybeAsiHazardBefore(sourceCode.getTokenAfter(node))\r\n                ) {\r\n                    report(node);\r\n                }\r\n            } else {\r\n                const oneLinerBlock = (exceptOneLine && isLastInOneLinerBlock(node));\r\n\r\n                if (isSemi && oneLinerBlock) {\r\n                    report(node, true);\r\n                } else if (!isSemi && !oneLinerBlock) {\r\n                    report(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks to see if there's a semicolon after a variable declaration.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkForSemicolonForVariableDeclaration(node) {\r\n            const parent = node.parent;\r\n\r\n            if ((parent.type !== \"ForStatement\" || parent.init !== node) &&\r\n                (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)\r\n            ) {\r\n                checkForSemicolon(node);\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            VariableDeclaration: checkForSemicolonForVariableDeclaration,\r\n            ExpressionStatement: checkForSemicolon,\r\n            ReturnStatement: checkForSemicolon,\r\n            ThrowStatement: checkForSemicolon,\r\n            DoWhileStatement: checkForSemicolon,\r\n            DebuggerStatement: checkForSemicolon,\r\n            BreakStatement: checkForSemicolon,\r\n            ContinueStatement: checkForSemicolon,\r\n            ImportDeclaration: checkForSemicolon,\r\n            ExportAllDeclaration: checkForSemicolon,\r\n            ExportNamedDeclaration(node) {\r\n                if (!node.declaration) {\r\n                    checkForSemicolon(node);\r\n                }\r\n            },\r\n            ExportDefaultDeclaration(node) {\r\n                if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {\r\n                    checkForSemicolon(node);\r\n                }\r\n            },\r\n            PropertyDefinition: checkForSemicolon\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}