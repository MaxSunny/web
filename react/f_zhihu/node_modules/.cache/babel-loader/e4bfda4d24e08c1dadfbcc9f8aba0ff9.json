{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\n/**\r\n * Checks a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\r\n * Checks a given node is a member access which has the specified name's\r\n * property.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a member access which has\r\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\r\n */\n\n\nfunction isTargetMethod(node) {\n  return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\n}\n/**\r\n * Returns a human-legible description of an array method\r\n * @param {string} arrayMethodName A method name to fully qualify\r\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\r\n *      or else `Array.prototype.` if it is an instance method.\r\n */\n\n\nfunction fullMethodName(arrayMethodName) {\n  if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\n    return \"Array.\".concat(arrayMethodName);\n  }\n\n  return \"Array.prototype.\".concat(arrayMethodName);\n}\n/**\r\n * Checks whether or not a given node is a function expression which is the\r\n * callback of an array method, returning the method name.\r\n * @param {ASTNode} node A node to check. This is one of\r\n *      FunctionExpression or ArrowFunctionExpression.\r\n * @returns {string} The method name if the node is a callback method,\r\n *      null otherwise.\r\n */\n\n\nfunction getArrayMethodName(node) {\n  let currentNode = node;\n\n  while (currentNode) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      /*\r\n       * Looks up the destination. e.g.,\r\n       * foo.every(nativeFoo || function foo() { ... });\r\n       */\n      case \"LogicalExpression\":\n      case \"ConditionalExpression\":\n      case \"ChainExpression\":\n        currentNode = parent;\n        break;\n\n      /*\r\n       * If the upper function is IIFE, checks the destination of the return value.\r\n       * e.g.\r\n       *   foo.every((function() {\r\n       *     // setup...\r\n       *     return function callback() { ... };\r\n       *   })());\r\n       */\n\n      case \"ReturnStatement\":\n        {\n          const func = astUtils.getUpperFunction(parent);\n\n          if (func === null || !astUtils.isCallee(func)) {\n            return null;\n          }\n\n          currentNode = func.parent;\n          break;\n        }\n\n      /*\r\n       * e.g.\r\n       *   Array.from([], function() {});\r\n       *   list.every(function() {});\r\n       */\n\n      case \"CallExpression\":\n        if (astUtils.isArrayFromMethod(parent.callee)) {\n          if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {\n            return \"from\";\n          }\n        }\n\n        if (isTargetMethod(parent.callee)) {\n          if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {\n            return astUtils.getStaticPropertyName(parent.callee);\n          }\n        }\n\n        return null;\n      // Otherwise this node is not target.\n\n      default:\n        return null;\n    }\n  }\n  /* istanbul ignore next: unreachable */\n\n\n  return null;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in callbacks of array methods\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-callback-return\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        },\n        checkForEach: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\n      expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\n      expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false,\n      checkForEach: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      arrayMethodName: null,\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\r\n     * Checks whether or not the last code path segment is reachable.\r\n     * Then reports this function if the segment is reachable.\r\n     *\r\n     * If the last code path segment is reachable, there are paths which are not\r\n     * returned or thrown.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {void}\r\n     */\n\n    function checkLastSegment(node) {\n      if (!funcInfo.shouldCheck) {\n        return;\n      }\n\n      let messageId = null;\n\n      if (funcInfo.arrayMethodName === \"forEach\") {\n        if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\n          messageId = \"expectedNoReturnValue\";\n        }\n      } else {\n        if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\n          messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\n        }\n      }\n\n      if (messageId) {\n        const name = astUtils.getFunctionNameWithKind(node);\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId,\n          data: {\n            name,\n            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n          }\n        });\n      }\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        let methodName = null;\n\n        if (TARGET_NODE_TYPE.test(node.type)) {\n          methodName = getArrayMethodName(node);\n        }\n\n        funcInfo = {\n          arrayMethodName: methodName,\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: methodName && !node.async && !node.generator,\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (!funcInfo.shouldCheck) {\n          return;\n        }\n\n        funcInfo.hasReturn = true;\n        let messageId = null;\n\n        if (funcInfo.arrayMethodName === \"forEach\") {\n          // if checkForEach: true, returning a value at any path inside a forEach is not allowed\n          if (options.checkForEach && node.argument) {\n            messageId = \"expectedNoReturnValue\";\n          }\n        } else {\n          // if allowImplicit: false, should also check node.argument\n          if (!options.allowImplicit && !node.argument) {\n            messageId = \"expectedReturnValue\";\n          }\n        }\n\n        if (messageId) {\n          context.report({\n            node,\n            messageId,\n            data: {\n              name: astUtils.getFunctionNameWithKind(funcInfo.node),\n              arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\n            }\n          });\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/array-callback-return.js"],"names":["astUtils","require","TARGET_NODE_TYPE","TARGET_METHODS","isReachable","segment","reachable","isTargetMethod","node","isSpecificMemberAccess","fullMethodName","arrayMethodName","includes","concat","getArrayMethodName","currentNode","parent","type","func","getUpperFunction","isCallee","isArrayFromMethod","callee","arguments","length","getStaticPropertyName","module","exports","meta","docs","description","recommended","url","schema","properties","allowImplicit","default","checkForEach","additionalProperties","messages","expectedAtEnd","expectedInside","expectedReturnValue","expectedNoReturnValue","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","checkLastSegment","messageId","expression","body","currentSegments","some","name","getFunctionNameWithKind","report","loc","getFunctionHeadLoc","data","onCodePathStart","methodName","test","async","generator","onCodePathEnd","ReturnStatement","argument"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\r\nconst TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;\r\n\r\n/**\r\n * Checks a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n/**\r\n * Checks a given node is a member access which has the specified name's\r\n * property.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a member access which has\r\n *      the specified name's property. The node may be a `(Chain|Member)Expression` node.\r\n */\r\nfunction isTargetMethod(node) {\r\n    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);\r\n}\r\n\r\n/**\r\n * Returns a human-legible description of an array method\r\n * @param {string} arrayMethodName A method name to fully qualify\r\n * @returns {string} the method name prefixed with `Array.` if it is a class method,\r\n *      or else `Array.prototype.` if it is an instance method.\r\n */\r\nfunction fullMethodName(arrayMethodName) {\r\n    if ([\"from\", \"of\", \"isArray\"].includes(arrayMethodName)) {\r\n        return \"Array.\".concat(arrayMethodName);\r\n    }\r\n    return \"Array.prototype.\".concat(arrayMethodName);\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is a function expression which is the\r\n * callback of an array method, returning the method name.\r\n * @param {ASTNode} node A node to check. This is one of\r\n *      FunctionExpression or ArrowFunctionExpression.\r\n * @returns {string} The method name if the node is a callback method,\r\n *      null otherwise.\r\n */\r\nfunction getArrayMethodName(node) {\r\n    let currentNode = node;\r\n\r\n    while (currentNode) {\r\n        const parent = currentNode.parent;\r\n\r\n        switch (parent.type) {\r\n\r\n            /*\r\n             * Looks up the destination. e.g.,\r\n             * foo.every(nativeFoo || function foo() { ... });\r\n             */\r\n            case \"LogicalExpression\":\r\n            case \"ConditionalExpression\":\r\n            case \"ChainExpression\":\r\n                currentNode = parent;\r\n                break;\r\n\r\n            /*\r\n             * If the upper function is IIFE, checks the destination of the return value.\r\n             * e.g.\r\n             *   foo.every((function() {\r\n             *     // setup...\r\n             *     return function callback() { ... };\r\n             *   })());\r\n             */\r\n            case \"ReturnStatement\": {\r\n                const func = astUtils.getUpperFunction(parent);\r\n\r\n                if (func === null || !astUtils.isCallee(func)) {\r\n                    return null;\r\n                }\r\n                currentNode = func.parent;\r\n                break;\r\n            }\r\n\r\n            /*\r\n             * e.g.\r\n             *   Array.from([], function() {});\r\n             *   list.every(function() {});\r\n             */\r\n            case \"CallExpression\":\r\n                if (astUtils.isArrayFromMethod(parent.callee)) {\r\n                    if (\r\n                        parent.arguments.length >= 2 &&\r\n                        parent.arguments[1] === currentNode\r\n                    ) {\r\n                        return \"from\";\r\n                    }\r\n                }\r\n                if (isTargetMethod(parent.callee)) {\r\n                    if (\r\n                        parent.arguments.length >= 1 &&\r\n                        parent.arguments[0] === currentNode\r\n                    ) {\r\n                        return astUtils.getStaticPropertyName(parent.callee);\r\n                    }\r\n                }\r\n                return null;\r\n\r\n            // Otherwise this node is not target.\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /* istanbul ignore next: unreachable */\r\n    return null;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"enforce `return` statements in callbacks of array methods\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/array-callback-return\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowImplicit: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    checkForEach: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            expectedAtEnd: \"{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.\",\r\n            expectedInside: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\r\n            expectedReturnValue: \"{{arrayMethodName}}() expects a return value from {{name}}.\",\r\n            expectedNoReturnValue: \"{{arrayMethodName}}() expects no useless return value from {{name}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0] || { allowImplicit: false, checkForEach: false };\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        let funcInfo = {\r\n            arrayMethodName: null,\r\n            upper: null,\r\n            codePath: null,\r\n            hasReturn: false,\r\n            shouldCheck: false,\r\n            node: null\r\n        };\r\n\r\n        /**\r\n         * Checks whether or not the last code path segment is reachable.\r\n         * Then reports this function if the segment is reachable.\r\n         *\r\n         * If the last code path segment is reachable, there are paths which are not\r\n         * returned or thrown.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkLastSegment(node) {\r\n\r\n            if (!funcInfo.shouldCheck) {\r\n                return;\r\n            }\r\n\r\n            let messageId = null;\r\n\r\n            if (funcInfo.arrayMethodName === \"forEach\") {\r\n                if (options.checkForEach && node.type === \"ArrowFunctionExpression\" && node.expression) {\r\n                    messageId = \"expectedNoReturnValue\";\r\n                }\r\n            } else {\r\n                if (node.body.type === \"BlockStatement\" && funcInfo.codePath.currentSegments.some(isReachable)) {\r\n                    messageId = funcInfo.hasReturn ? \"expectedAtEnd\" : \"expectedInside\";\r\n                }\r\n            }\r\n\r\n            if (messageId) {\r\n                const name = astUtils.getFunctionNameWithKind(node);\r\n\r\n                context.report({\r\n                    node,\r\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\r\n                    messageId,\r\n                    data: { name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName) }\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n\r\n            // Stacks this function's information.\r\n            onCodePathStart(codePath, node) {\r\n\r\n                let methodName = null;\r\n\r\n                if (TARGET_NODE_TYPE.test(node.type)) {\r\n                    methodName = getArrayMethodName(node);\r\n                }\r\n\r\n                funcInfo = {\r\n                    arrayMethodName: methodName,\r\n                    upper: funcInfo,\r\n                    codePath,\r\n                    hasReturn: false,\r\n                    shouldCheck:\r\n                        methodName &&\r\n                        !node.async &&\r\n                        !node.generator,\r\n                    node\r\n                };\r\n            },\r\n\r\n            // Pops this function's information.\r\n            onCodePathEnd() {\r\n                funcInfo = funcInfo.upper;\r\n            },\r\n\r\n            // Checks the return statement is valid.\r\n            ReturnStatement(node) {\r\n\r\n                if (!funcInfo.shouldCheck) {\r\n                    return;\r\n                }\r\n\r\n                funcInfo.hasReturn = true;\r\n\r\n                let messageId = null;\r\n\r\n                if (funcInfo.arrayMethodName === \"forEach\") {\r\n\r\n                    // if checkForEach: true, returning a value at any path inside a forEach is not allowed\r\n                    if (options.checkForEach && node.argument) {\r\n                        messageId = \"expectedNoReturnValue\";\r\n                    }\r\n                } else {\r\n\r\n                    // if allowImplicit: false, should also check node.argument\r\n                    if (!options.allowImplicit && !node.argument) {\r\n                        messageId = \"expectedReturnValue\";\r\n                    }\r\n                }\r\n\r\n                if (messageId) {\r\n                    context.report({\r\n                        node,\r\n                        messageId,\r\n                        data: {\r\n                            name: astUtils.getFunctionNameWithKind(funcInfo.node),\r\n                            arrayMethodName: fullMethodName(funcInfo.arrayMethodName)\r\n                        }\r\n                    });\r\n                }\r\n            },\r\n\r\n            // Reports a given function if the last path is reachable.\r\n            \"FunctionExpression:exit\": checkLastSegment,\r\n            \"ArrowFunctionExpression:exit\": checkLastSegment\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}