{"ast":null,"code":"/**\r\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\r\n * @author Michael Ficarra\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst {\n  isParenthesized: isParenthesizedRaw\n} = require(\"eslint-utils\");\n\nconst astUtils = require(\"./utils/ast-utils.js\");\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"disallow unnecessary parentheses\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-parens\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"functions\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"all\"]\n        }, {\n          type: \"object\",\n          properties: {\n            conditionalAssign: {\n              type: \"boolean\"\n            },\n            nestedBinaryExpressions: {\n              type: \"boolean\"\n            },\n            returnAssign: {\n              type: \"boolean\"\n            },\n            ignoreJSX: {\n              enum: [\"none\", \"all\", \"single-line\", \"multi-line\"]\n            },\n            enforceForArrowConditionals: {\n              type: \"boolean\"\n            },\n            enforceForSequenceExpressions: {\n              type: \"boolean\"\n            },\n            enforceForNewInMemberExpressions: {\n              type: \"boolean\"\n            },\n            enforceForFunctionPrototypeMethods: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      unexpected: \"Unnecessary parentheses around expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const tokensToIgnore = new WeakSet();\n    const precedence = astUtils.getPrecedence;\n    const ALL_NODES = context.options[0] !== \"functions\";\n    const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n    const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n    const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n    const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\n    const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] && context.options[1].enforceForArrowConditionals === false;\n    const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] && context.options[1].enforceForSequenceExpressions === false;\n    const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] && context.options[1].enforceForNewInMemberExpressions === false;\n    const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] && context.options[1].enforceForFunctionPrototypeMethods === false;\n    const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({\n      type: \"AssignmentExpression\"\n    });\n    const PRECEDENCE_OF_UPDATE_EXPR = precedence({\n      type: \"UpdateExpression\"\n    });\n    let reportsBuffer;\n    /**\r\n     * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\r\n     * Example: function(){}.call()\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\r\n     * @private\r\n     */\n\n    function isImmediateFunctionPrototypeMethodCall(node) {\n      const callNode = astUtils.skipChainExpression(node);\n\n      if (callNode.type !== \"CallExpression\") {\n        return false;\n      }\n\n      const callee = astUtils.skipChainExpression(callNode.callee);\n      return callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee));\n    }\n    /**\r\n     * Determines if this rule should be enforced for a node given the current configuration.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the rule should be enforced for this node.\r\n     * @private\r\n     */\n\n\n    function ruleApplies(node) {\n      if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\n        const isSingleLine = node.loc.start.line === node.loc.end.line;\n\n        switch (IGNORE_JSX) {\n          // Exclude this JSX element from linting\n          case \"all\":\n            return false;\n          // Exclude this JSX element if it is multi-line element\n\n          case \"multi-line\":\n            return isSingleLine;\n          // Exclude this JSX element if it is single-line element\n\n          case \"single-line\":\n            return !isSingleLine;\n          // Nothing special to be done for JSX elements\n\n          case \"none\":\n            break;\n          // no default\n        }\n      }\n\n      if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\n        return false;\n      }\n\n      if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\n        return false;\n      }\n\n      return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n    }\n    /**\r\n     * Determines if a node is surrounded by parentheses.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is parenthesised.\r\n     * @private\r\n     */\n\n\n    function isParenthesised(node) {\n      return isParenthesizedRaw(1, node, sourceCode);\n    }\n    /**\r\n     * Determines if a node is surrounded by parentheses twice.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is doubly parenthesised.\r\n     * @private\r\n     */\n\n\n    function isParenthesisedTwice(node) {\n      return isParenthesizedRaw(2, node, sourceCode);\n    }\n    /**\r\n     * Determines if a node is surrounded by (potentially) invalid parentheses.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is incorrectly parenthesised.\r\n     * @private\r\n     */\n\n\n    function hasExcessParens(node) {\n      return ruleApplies(node) && isParenthesised(node);\n    }\n    /**\r\n     * Determines if a node that is expected to be parenthesised is surrounded by\r\n     * (potentially) invalid extra parentheses.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\r\n     * @private\r\n     */\n\n\n    function hasDoubleExcessParens(node) {\n      return ruleApplies(node) && isParenthesisedTwice(node);\n    }\n    /**\r\n     * Determines if a node that is expected to be parenthesised is surrounded by\r\n     * (potentially) invalid extra parentheses with considering precedence level of the node.\r\n     * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\r\n     * whether the node is surrounded by parentheses twice or not.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @param {number} precedenceLowerLimit The lower limit of precedence.\r\n     * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\r\n     * @private\r\n     */\n\n\n    function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\n      if (ruleApplies(node) && isParenthesised(node)) {\n        if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines if a node test expression is allowed to have a parenthesised assignment\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the assignment can be parenthesised.\r\n     * @private\r\n     */\n\n\n    function isCondAssignException(node) {\n      return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n    }\n    /**\r\n     * Determines if a node is in a return statement\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is in a return statement.\r\n     * @private\r\n     */\n\n\n    function isInReturnStatement(node) {\n      for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n        if (currentNode.type === \"ReturnStatement\" || currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\") {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines if a constructor function is newed-up with parens\r\n     * @param {ASTNode} newExpression The NewExpression node to be checked.\r\n     * @returns {boolean} True if the constructor is called with parens.\r\n     * @private\r\n     */\n\n\n    function isNewExpressionWithParens(newExpression) {\n      const lastToken = sourceCode.getLastToken(newExpression);\n      const penultimateToken = sourceCode.getTokenBefore(lastToken);\n      return newExpression.arguments.length > 0 || // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\n      astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];\n    }\n    /**\r\n     * Determines if a node is or contains an assignment expression\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is or contains an assignment expression.\r\n     * @private\r\n     */\n\n\n    function containsAssignment(node) {\n      if (node.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      if (node.type === \"ConditionalExpression\" && (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n        return true;\n      }\n\n      if (node.left && node.left.type === \"AssignmentExpression\" || node.right && node.right.type === \"AssignmentExpression\") {\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the assignment can be parenthesised.\r\n     * @private\r\n     */\n\n\n    function isReturnAssignException(node) {\n      if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n        return false;\n      }\n\n      if (node.type === \"ReturnStatement\") {\n        return node.argument && containsAssignment(node.argument);\n      }\n\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        return containsAssignment(node.body);\n      }\n\n      return containsAssignment(node);\n    }\n    /**\r\n     * Determines if a node following a [no LineTerminator here] restriction is\r\n     * surrounded by (potentially) invalid extra parentheses.\r\n     * @param {Token} token The token preceding the [no LineTerminator here] restriction.\r\n     * @param {ASTNode} node The node to be checked.\r\n     * @returns {boolean} True if the node is incorrectly parenthesised.\r\n     * @private\r\n     */\n\n\n    function hasExcessParensNoLineTerminator(token, node) {\n      if (token.loc.end.line === node.loc.start.line) {\n        return hasExcessParens(node);\n      }\n\n      return hasDoubleExcessParens(node);\n    }\n    /**\r\n     * Determines whether a node should be preceded by an additional space when removing parens\r\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\r\n     * @returns {boolean} `true` if a space should be inserted before the node\r\n     * @private\r\n     */\n\n\n    function requiresLeadingSpace(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, {\n        includeComments: true\n      });\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, {\n        includeComments: true\n      });\n      return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\n    }\n    /**\r\n     * Determines whether a node should be followed by an additional space when removing parens\r\n     * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\r\n     * @returns {boolean} `true` if a space should be inserted after the node\r\n     * @private\r\n     */\n\n\n    function requiresTrailingSpace(node) {\n      const nextTwoTokens = sourceCode.getTokensAfter(node, {\n        count: 2\n      });\n      const rightParenToken = nextTwoTokens[0];\n      const tokenAfterRightParen = nextTwoTokens[1];\n      const tokenBeforeRightParen = sourceCode.getLastToken(node);\n      return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\n    }\n    /**\r\n     * Determines if a given expression node is an IIFE\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} `true` if the given node is an IIFE\r\n     */\n\n\n    function isIIFE(node) {\n      const maybeCallNode = astUtils.skipChainExpression(node);\n      return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\n    }\n    /**\r\n     * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\r\n     * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\r\n     * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\r\n     * @param {ASTNode} [node] The node to check\r\n     * @returns {boolean} `true` if the given node can be a valid assignment target\r\n     */\n\n\n    function canBeAssignmentTarget(node) {\n      return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\n    }\n    /**\r\n     * Report the node\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(node) {\n      const leftParenToken = sourceCode.getTokenBefore(node);\n      const rightParenToken = sourceCode.getTokenAfter(node);\n\n      if (!isParenthesisedTwice(node)) {\n        if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\n          return;\n        }\n\n        if (isIIFE(node) && !isParenthesised(node.callee)) {\n          return;\n        }\n      }\n      /**\r\n       * Finishes reporting\r\n       * @returns {void}\r\n       * @private\r\n       */\n\n\n      function finishReport() {\n        context.report({\n          node,\n          loc: leftParenToken.loc,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\n            return fixer.replaceTextRange([leftParenToken.range[0], rightParenToken.range[1]], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\n          }\n\n        });\n      }\n\n      if (reportsBuffer) {\n        reportsBuffer.reports.push({\n          node,\n          finishReport\n        });\n        return;\n      }\n\n      finishReport();\n    }\n    /**\r\n     * Evaluate a argument of the node.\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkArgumentWithPrecedence(node) {\n      if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\n        report(node.argument);\n      }\n    }\n    /**\r\n     * Check if a member expression contains a call expression\r\n     * @param {ASTNode} node MemberExpression node to evaluate\r\n     * @returns {boolean} true if found, false if not\r\n     */\n\n\n    function doesMemberExpressionContainCallExpression(node) {\n      let currentNode = node.object;\n      let currentNodeType = node.object.type;\n\n      while (currentNodeType === \"MemberExpression\") {\n        currentNode = currentNode.object;\n        currentNodeType = currentNode.type;\n      }\n\n      return currentNodeType === \"CallExpression\";\n    }\n    /**\r\n     * Evaluate a new call\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkCallNew(node) {\n      const callee = node.callee;\n\n      if (hasExcessParensWithPrecedence(callee, precedence(node))) {\n        if (hasDoubleExcessParens(callee) || !(isIIFE(node) || // (new A)(); new (new A)();\n        callee.type === \"NewExpression\" && !isNewExpressionWithParens(callee) && !(node.type === \"NewExpression\" && !isNewExpressionWithParens(node)) || // new (a().b)(); new (a.b().c);\n        node.type === \"NewExpression\" && callee.type === \"MemberExpression\" && doesMemberExpressionContainCallExpression(callee) || // (a?.b)(); (a?.())();\n        !node.optional && callee.type === \"ChainExpression\")) {\n          report(node.callee);\n        }\n      }\n\n      node.arguments.filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n    }\n    /**\r\n     * Evaluate binary logicals\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkBinaryLogical(node) {\n      const prec = precedence(node);\n      const leftPrecedence = precedence(node.left);\n      const rightPrecedence = precedence(node.right);\n      const isExponentiation = node.operator === \"**\";\n      const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\n      const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\n\n      if (!shouldSkipLeft && hasExcessParens(node.left)) {\n        if (!([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {\n          report(node.left);\n        }\n      }\n\n      if (!shouldSkipRight && hasExcessParens(node.right)) {\n        if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {\n          report(node.right);\n        }\n      }\n    }\n    /**\r\n     * Check the parentheses around the super class of the given class definition.\r\n     * @param {ASTNode} node The node of class declarations to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkClass(node) {\n      if (!node.superClass) {\n        return;\n      }\n      /*\r\n       * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\r\n       * Otherwise, parentheses are needed.\r\n       */\n\n\n      const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);\n\n      if (hasExtraParens) {\n        report(node.superClass);\n      }\n    }\n    /**\r\n     * Check the parentheses around the argument of the given spread operator.\r\n     * @param {ASTNode} node The node of spread elements/properties to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpreadOperator(node) {\n      if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n        report(node.argument);\n      }\n    }\n    /**\r\n     * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\r\n     * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\r\n     * @returns {void}\r\n     */\n\n\n    function checkExpressionOrExportStatement(node) {\n      const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\n      const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\n      const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\n      const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\n\n      if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === \"Keyword\" && (secondToken.value === \"function\" || secondToken.value === \"class\" || secondToken.value === \"let\" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === \"Identifier\")) || secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\")) {\n        tokensToIgnore.add(secondToken);\n      }\n\n      const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);\n\n      if (hasExtraParens) {\n        report(node);\n      }\n    }\n    /**\r\n     * Finds the path from the given node to the specified ancestor.\r\n     * @param {ASTNode} node First node in the path.\r\n     * @param {ASTNode} ancestor Last node in the path.\r\n     * @returns {ASTNode[]} Path, including both nodes.\r\n     * @throws {Error} If the given node does not have the specified ancestor.\r\n     */\n\n\n    function pathToAncestor(node, ancestor) {\n      const path = [node];\n      let currentNode = node;\n\n      while (currentNode !== ancestor) {\n        currentNode = currentNode.parent;\n        /* istanbul ignore if */\n\n        if (currentNode === null) {\n          throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\n        }\n\n        path.push(currentNode);\n      }\n\n      return path;\n    }\n    /**\r\n     * Finds the path from the given node to the specified descendant.\r\n     * @param {ASTNode} node First node in the path.\r\n     * @param {ASTNode} descendant Last node in the path.\r\n     * @returns {ASTNode[]} Path, including both nodes.\r\n     * @throws {Error} If the given node does not have the specified descendant.\r\n     */\n\n\n    function pathToDescendant(node, descendant) {\n      return pathToAncestor(descendant, node).reverse();\n    }\n    /**\r\n     * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\r\n     * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\r\n     * @param {ASTNode} node Ancestor of an 'in' expression.\r\n     * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\r\n     * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\r\n     */\n\n\n    function isSafelyEnclosingInExpression(node, child) {\n      switch (node.type) {\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n        case \"BlockStatement\":\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n        case \"TemplateLiteral\":\n          return true;\n\n        case \"ArrowFunctionExpression\":\n        case \"FunctionExpression\":\n          return node.params.includes(child);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.arguments.includes(child);\n\n        case \"MemberExpression\":\n          return node.computed && node.property === child;\n\n        case \"ConditionalExpression\":\n          return node.consequent === child;\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\r\n     * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\r\n     * @returns {void}\r\n     */\n\n\n    function startNewReportsBuffering() {\n      reportsBuffer = {\n        upper: reportsBuffer,\n        inExpressionNodes: [],\n        reports: []\n      };\n    }\n    /**\r\n     * Ends the current reports buffering.\r\n     * @returns {void}\r\n     */\n\n\n    function endCurrentReportsBuffering() {\n      const {\n        upper,\n        inExpressionNodes,\n        reports\n      } = reportsBuffer;\n\n      if (upper) {\n        upper.inExpressionNodes.push(...inExpressionNodes);\n        upper.reports.push(...reports);\n      } else {\n        // flush remaining reports\n        reports.forEach(_ref => {\n          let {\n            finishReport\n          } = _ref;\n          return finishReport();\n        });\n      }\n\n      reportsBuffer = upper;\n    }\n    /**\r\n     * Checks whether the given node is in the current reports buffer.\r\n     * @param {ASTNode} node Node to check.\r\n     * @returns {boolean} True if the node is in the current buffer, false otherwise.\r\n     */\n\n\n    function isInCurrentReportsBuffer(node) {\n      return reportsBuffer.reports.some(r => r.node === node);\n    }\n    /**\r\n     * Removes the given node from the current reports buffer.\r\n     * @param {ASTNode} node Node to remove.\r\n     * @returns {void}\r\n     */\n\n\n    function removeFromCurrentReportsBuffer(node) {\n      reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\n    }\n    /**\r\n     * Checks whether a node is a MemberExpression at NewExpression's callee.\r\n     * @param {ASTNode} node node to check.\r\n     * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\r\n     */\n\n\n    function isMemberExpInNewCallee(node) {\n      if (node.type === \"MemberExpression\") {\n        return node.parent.type === \"NewExpression\" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);\n      }\n\n      return false;\n    }\n\n    return {\n      ArrayExpression(node) {\n        node.elements.filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);\n      },\n\n      ArrayPattern(node) {\n        node.elements.filter(e => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);\n      },\n\n      ArrowFunctionExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.body.type === \"ConditionalExpression\" && IGNORE_ARROW_CONDITIONALS) {\n          return;\n        }\n\n        if (node.body.type !== \"BlockStatement\") {\n          const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\n          const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\n\n          if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\n            tokensToIgnore.add(firstBodyToken);\n          }\n\n          if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(node.body);\n          }\n        }\n      },\n\n      AssignmentExpression(node) {\n        if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\n          report(node.right);\n        }\n      },\n\n      BinaryExpression(node) {\n        if (reportsBuffer && node.operator === \"in\") {\n          reportsBuffer.inExpressionNodes.push(node);\n        }\n\n        checkBinaryLogical(node);\n      },\n\n      CallExpression: checkCallNew,\n\n      ConditionalExpression(node) {\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (!isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({\n          type: \"LogicalExpression\",\n          operator: \"||\"\n        }))) {\n          report(node.test);\n        }\n\n        if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.consequent);\n        }\n\n        if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.alternate);\n        }\n      },\n\n      DoWhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\n      ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\n\n      ForInStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n          if (firstLeftToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken))) {\n            // ForInStatement#left expression cannot start with `let[`.\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (hasExcessParens(node.right)) {\n          report(node.right);\n        }\n      },\n\n      ForOfStatement(node) {\n        if (node.left.type !== \"VariableDeclaration\") {\n          const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\n\n          if (firstLeftToken.value === \"let\") {\n            // ForOfStatement#left expression cannot start with `let`.\n            tokensToIgnore.add(firstLeftToken);\n          }\n        }\n\n        if (hasExcessParens(node.left)) {\n          report(node.left);\n        }\n\n        if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.right);\n        }\n      },\n\n      ForStatement(node) {\n        if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n\n        if (node.update && hasExcessParens(node.update)) {\n          report(node.update);\n        }\n\n        if (node.init) {\n          if (node.init.type !== \"VariableDeclaration\") {\n            const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\n\n            if (firstToken.value === \"let\" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken))) {\n              // ForStatement#init expression cannot start with `let[`.\n              tokensToIgnore.add(firstToken);\n            }\n          }\n\n          startNewReportsBuffering();\n\n          if (hasExcessParens(node.init)) {\n            report(node.init);\n          }\n        }\n      },\n\n      \"ForStatement > *.init:exit\"(node) {\n        /*\r\n         * Removing parentheses around `in` expressions might change semantics and cause errors.\r\n         *\r\n         * For example, this valid for loop:\r\n         *      for (let a = (b in c); ;);\r\n         * after removing parentheses would be treated as an invalid for-in loop:\r\n         *      for (let a = b in c; ;);\r\n         */\n        if (reportsBuffer.reports.length) {\n          reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\n            const path = pathToDescendant(node, inExpressionNode);\n            let nodeToExclude;\n\n            for (let i = 0; i < path.length; i++) {\n              const pathNode = path[i];\n\n              if (i < path.length - 1) {\n                const nextPathNode = path[i + 1];\n\n                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\n                  // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\n                  return;\n                }\n              }\n\n              if (isParenthesised(pathNode)) {\n                if (isInCurrentReportsBuffer(pathNode)) {\n                  // This node was supposed to be reported, but parentheses might be necessary.\n                  if (isParenthesisedTwice(pathNode)) {\n                    /*\r\n                     * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\r\n                     * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\r\n                     * The remaining pair is safely enclosing the 'in' expression.\r\n                     */\n                    return;\n                  } // Exclude the outermost node only.\n\n\n                  if (!nodeToExclude) {\n                    nodeToExclude = pathNode;\n                  } // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\n\n                } else {\n                  // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\n                  return;\n                }\n              }\n            } // Exclude the node from the list (i.e. treat parentheses as necessary)\n\n\n            removeFromCurrentReportsBuffer(nodeToExclude);\n          });\n        }\n\n        endCurrentReportsBuffering();\n      },\n\n      IfStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      ImportExpression(node) {\n        const {\n          source\n        } = node;\n\n        if (source.type === \"SequenceExpression\") {\n          if (hasDoubleExcessParens(source)) {\n            report(source);\n          }\n        } else if (hasExcessParens(source)) {\n          report(source);\n        }\n      },\n\n      LogicalExpression: checkBinaryLogical,\n\n      MemberExpression(node) {\n        const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);\n        const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);\n\n        if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || // RegExp literal is allowed to have parens (#1589)\n        node.object.type === \"Literal\" && node.object.regex))) {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && node.object.type === \"CallExpression\") {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === \"NewExpression\" && isNewExpressionWithParens(node.object)) {\n          report(node.object);\n        }\n\n        if (nodeObjHasExcessParens && node.optional && node.object.type === \"ChainExpression\") {\n          report(node.object);\n        }\n\n        if (node.computed && hasExcessParens(node.property)) {\n          report(node.property);\n        }\n      },\n\n      \"MethodDefinition[computed=true]\"(node) {\n        if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.key);\n        }\n      },\n\n      NewExpression: checkCallNew,\n\n      ObjectExpression(node) {\n        node.properties.filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(property => report(property.value));\n      },\n\n      ObjectPattern(node) {\n        node.properties.filter(property => {\n          const value = property.value;\n          return canBeAssignmentTarget(value) && hasExcessParens(value);\n        }).forEach(property => report(property.value));\n      },\n\n      Property(node) {\n        if (node.computed) {\n          const {\n            key\n          } = node;\n\n          if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n            report(key);\n          }\n        }\n      },\n\n      PropertyDefinition(node) {\n        if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.key);\n        }\n\n        if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(node.value);\n        }\n      },\n\n      RestElement(node) {\n        const argument = node.argument;\n\n        if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\n          report(argument);\n        }\n      },\n\n      ReturnStatement(node) {\n        const returnToken = sourceCode.getFirstToken(node);\n\n        if (isReturnAssignException(node)) {\n          return;\n        }\n\n        if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && // RegExp literal is allowed to have parens (#1589)\n        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n          report(node.argument);\n        }\n      },\n\n      SequenceExpression(node) {\n        const precedenceOfNode = precedence(node);\n        node.expressions.filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);\n      },\n\n      SwitchCase(node) {\n        if (node.test && hasExcessParens(node.test)) {\n          report(node.test);\n        }\n      },\n\n      SwitchStatement(node) {\n        if (hasExcessParens(node.discriminant)) {\n          report(node.discriminant);\n        }\n      },\n\n      ThrowStatement(node) {\n        const throwToken = sourceCode.getFirstToken(node);\n\n        if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n          report(node.argument);\n        }\n      },\n\n      UnaryExpression: checkArgumentWithPrecedence,\n\n      UpdateExpression(node) {\n        if (node.prefix) {\n          checkArgumentWithPrecedence(node);\n        } else {\n          const {\n            argument\n          } = node;\n          const operatorToken = sourceCode.getLastToken(node);\n\n          if (argument.loc.end.line === operatorToken.loc.start.line) {\n            checkArgumentWithPrecedence(node);\n          } else {\n            if (hasDoubleExcessParens(argument)) {\n              report(argument);\n            }\n          }\n        }\n      },\n\n      AwaitExpression: checkArgumentWithPrecedence,\n\n      VariableDeclarator(node) {\n        if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && // RegExp literal is allowed to have parens (#1589)\n        !(node.init.type === \"Literal\" && node.init.regex)) {\n          report(node.init);\n        }\n      },\n\n      WhileStatement(node) {\n        if (hasExcessParens(node.test) && !isCondAssignException(node)) {\n          report(node.test);\n        }\n      },\n\n      WithStatement(node) {\n        if (hasExcessParens(node.object)) {\n          report(node.object);\n        }\n      },\n\n      YieldExpression(node) {\n        if (node.argument) {\n          const yieldToken = sourceCode.getFirstToken(node);\n\n          if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {\n            report(node.argument);\n          }\n        }\n      },\n\n      ClassDeclaration: checkClass,\n      ClassExpression: checkClass,\n      SpreadElement: checkSpreadOperator,\n      SpreadProperty: checkSpreadOperator,\n      ExperimentalSpreadProperty: checkSpreadOperator,\n\n      TemplateLiteral(node) {\n        node.expressions.filter(e => e && hasExcessParens(e)).forEach(report);\n      },\n\n      AssignmentPattern(node) {\n        const {\n          left,\n          right\n        } = node;\n\n        if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\n          report(left);\n        }\n\n        if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\n          report(right);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-extra-parens.js"],"names":["isParenthesized","isParenthesizedRaw","require","astUtils","module","exports","meta","type","docs","description","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","properties","conditionalAssign","nestedBinaryExpressions","returnAssign","ignoreJSX","enforceForArrowConditionals","enforceForSequenceExpressions","enforceForNewInMemberExpressions","enforceForFunctionPrototypeMethods","additionalProperties","messages","unexpected","create","context","sourceCode","getSourceCode","tokensToIgnore","WeakSet","precedence","getPrecedence","ALL_NODES","options","EXCEPT_COND_ASSIGN","NESTED_BINARY","EXCEPT_RETURN_ASSIGN","IGNORE_JSX","IGNORE_ARROW_CONDITIONALS","IGNORE_SEQUENCE_EXPRESSIONS","IGNORE_NEW_IN_MEMBER_EXPR","IGNORE_FUNCTION_PROTOTYPE_METHODS","PRECEDENCE_OF_ASSIGNMENT_EXPR","PRECEDENCE_OF_UPDATE_EXPR","reportsBuffer","isImmediateFunctionPrototypeMethodCall","node","callNode","skipChainExpression","callee","object","includes","getStaticPropertyName","ruleApplies","isSingleLine","loc","start","line","end","isParenthesised","isParenthesisedTwice","hasExcessParens","hasDoubleExcessParens","hasExcessParensWithPrecedence","precedenceLowerLimit","isCondAssignException","test","isInReturnStatement","currentNode","parent","body","isNewExpressionWithParens","newExpression","lastToken","getLastToken","penultimateToken","getTokenBefore","arguments","length","isOpeningParenToken","isClosingParenToken","range","containsAssignment","consequent","alternate","left","right","isReturnAssignException","argument","hasExcessParensNoLineTerminator","token","requiresLeadingSpace","leftParenToken","tokenBeforeLeftParen","includeComments","tokenAfterLeftParen","getTokenAfter","canTokensBeAdjacent","requiresTrailingSpace","nextTwoTokens","getTokensAfter","count","rightParenToken","tokenAfterRightParen","tokenBeforeRightParen","isSpaceBetweenTokens","isIIFE","maybeCallNode","canBeAssignmentTarget","report","has","getFirstToken","finishReport","messageId","fix","fixer","parenthesizedSource","text","slice","replaceTextRange","reports","push","checkArgumentWithPrecedence","doesMemberExpressionContainCallExpression","currentNodeType","checkCallNew","optional","filter","arg","forEach","checkBinaryLogical","prec","leftPrecedence","rightPrecedence","isExponentiation","operator","shouldSkipLeft","shouldSkipRight","isMixedLogicalAndCoalesceExpressions","checkClass","superClass","hasExtraParens","checkSpreadOperator","checkExpressionOrExportStatement","firstToken","secondToken","isNotOpeningParenToken","thirdToken","tokenAfterClosingParens","isNotClosingParenToken","isOpeningBraceToken","value","isOpeningBracketToken","add","pathToAncestor","ancestor","path","Error","pathToDescendant","descendant","reverse","isSafelyEnclosingInExpression","child","params","computed","property","startNewReportsBuffering","upper","inExpressionNodes","endCurrentReportsBuffering","isInCurrentReportsBuffer","some","r","removeFromCurrentReportsBuffer","isMemberExpInNewCallee","ArrayExpression","elements","e","ArrayPattern","ArrowFunctionExpression","firstBodyToken","tokenBeforeFirst","AssignmentExpression","BinaryExpression","CallExpression","ConditionalExpression","DoWhileStatement","ExportDefaultDeclaration","declaration","ExpressionStatement","expression","ForInStatement","firstLeftToken","ForOfStatement","ForStatement","update","init","inExpressionNode","nodeToExclude","i","pathNode","nextPathNode","IfStatement","ImportExpression","source","LogicalExpression","MemberExpression","shouldAllowWrapOnce","nodeObjHasExcessParens","isDecimalInteger","regex","key","NewExpression","ObjectExpression","ObjectPattern","Property","PropertyDefinition","RestElement","ReturnStatement","returnToken","SequenceExpression","precedenceOfNode","expressions","SwitchCase","SwitchStatement","discriminant","ThrowStatement","throwToken","UnaryExpression","UpdateExpression","prefix","operatorToken","AwaitExpression","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","yieldToken","ClassDeclaration","ClassExpression","SpreadElement","SpreadProperty","ExperimentalSpreadProperty","TemplateLiteral","AssignmentPattern"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\r\n * @author Michael Ficarra\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst { isParenthesized: isParenthesizedRaw } = require(\"eslint-utils\");\r\nconst astUtils = require(\"./utils/ast-utils.js\");\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary parentheses\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-extra-parens\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"functions\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 1\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"all\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                conditionalAssign: { type: \"boolean\" },\r\n                                nestedBinaryExpressions: { type: \"boolean\" },\r\n                                returnAssign: { type: \"boolean\" },\r\n                                ignoreJSX: { enum: [\"none\", \"all\", \"single-line\", \"multi-line\"] },\r\n                                enforceForArrowConditionals: { type: \"boolean\" },\r\n                                enforceForSequenceExpressions: { type: \"boolean\" },\r\n                                enforceForNewInMemberExpressions: { type: \"boolean\" },\r\n                                enforceForFunctionPrototypeMethods: { type: \"boolean\" }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            unexpected: \"Unnecessary parentheses around expression.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const tokensToIgnore = new WeakSet();\r\n        const precedence = astUtils.getPrecedence;\r\n        const ALL_NODES = context.options[0] !== \"functions\";\r\n        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\r\n        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\r\n        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\r\n        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;\r\n        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&\r\n            context.options[1].enforceForArrowConditionals === false;\r\n        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&\r\n            context.options[1].enforceForSequenceExpressions === false;\r\n        const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context.options[1] &&\r\n            context.options[1].enforceForNewInMemberExpressions === false;\r\n        const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context.options[1] &&\r\n            context.options[1].enforceForFunctionPrototypeMethods === false;\r\n\r\n        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({ type: \"AssignmentExpression\" });\r\n        const PRECEDENCE_OF_UPDATE_EXPR = precedence({ type: \"UpdateExpression\" });\r\n\r\n        let reportsBuffer;\r\n\r\n        /**\r\n         * Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.\r\n         * Example: function(){}.call()\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is an immediate `call` or `apply` method call.\r\n         * @private\r\n         */\r\n        function isImmediateFunctionPrototypeMethodCall(node) {\r\n            const callNode = astUtils.skipChainExpression(node);\r\n\r\n            if (callNode.type !== \"CallExpression\") {\r\n                return false;\r\n            }\r\n            const callee = astUtils.skipChainExpression(callNode.callee);\r\n\r\n            return (\r\n                callee.type === \"MemberExpression\" &&\r\n                callee.object.type === \"FunctionExpression\" &&\r\n                [\"call\", \"apply\"].includes(astUtils.getStaticPropertyName(callee))\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Determines if this rule should be enforced for a node given the current configuration.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the rule should be enforced for this node.\r\n         * @private\r\n         */\r\n        function ruleApplies(node) {\r\n            if (node.type === \"JSXElement\" || node.type === \"JSXFragment\") {\r\n                const isSingleLine = node.loc.start.line === node.loc.end.line;\r\n\r\n                switch (IGNORE_JSX) {\r\n\r\n                    // Exclude this JSX element from linting\r\n                    case \"all\":\r\n                        return false;\r\n\r\n                    // Exclude this JSX element if it is multi-line element\r\n                    case \"multi-line\":\r\n                        return isSingleLine;\r\n\r\n                    // Exclude this JSX element if it is single-line element\r\n                    case \"single-line\":\r\n                        return !isSingleLine;\r\n\r\n                    // Nothing special to be done for JSX elements\r\n                    case \"none\":\r\n                        break;\r\n\r\n                    // no default\r\n                }\r\n            }\r\n\r\n            if (node.type === \"SequenceExpression\" && IGNORE_SEQUENCE_EXPRESSIONS) {\r\n                return false;\r\n            }\r\n\r\n            if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {\r\n                return false;\r\n            }\r\n\r\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is surrounded by parentheses.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is parenthesised.\r\n         * @private\r\n         */\r\n        function isParenthesised(node) {\r\n            return isParenthesizedRaw(1, node, sourceCode);\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is surrounded by parentheses twice.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is doubly parenthesised.\r\n         * @private\r\n         */\r\n        function isParenthesisedTwice(node) {\r\n            return isParenthesizedRaw(2, node, sourceCode);\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is incorrectly parenthesised.\r\n         * @private\r\n         */\r\n        function hasExcessParens(node) {\r\n            return ruleApplies(node) && isParenthesised(node);\r\n        }\r\n\r\n        /**\r\n         * Determines if a node that is expected to be parenthesised is surrounded by\r\n         * (potentially) invalid extra parentheses.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\r\n         * @private\r\n         */\r\n        function hasDoubleExcessParens(node) {\r\n            return ruleApplies(node) && isParenthesisedTwice(node);\r\n        }\r\n\r\n        /**\r\n         * Determines if a node that is expected to be parenthesised is surrounded by\r\n         * (potentially) invalid extra parentheses with considering precedence level of the node.\r\n         * If the preference level of the node is not higher or equal to precedence lower limit, it also checks\r\n         * whether the node is surrounded by parentheses twice or not.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @param {number} precedenceLowerLimit The lower limit of precedence.\r\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\r\n         * @private\r\n         */\r\n        function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {\r\n            if (ruleApplies(node) && isParenthesised(node)) {\r\n                if (\r\n                    precedence(node) >= precedenceLowerLimit ||\r\n                    isParenthesisedTwice(node)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if a node test expression is allowed to have a parenthesised assignment\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the assignment can be parenthesised.\r\n         * @private\r\n         */\r\n        function isCondAssignException(node) {\r\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is in a return statement\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is in a return statement.\r\n         * @private\r\n         */\r\n        function isInReturnStatement(node) {\r\n            for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\r\n                if (\r\n                    currentNode.type === \"ReturnStatement\" ||\r\n                    (currentNode.type === \"ArrowFunctionExpression\" && currentNode.body.type !== \"BlockStatement\")\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if a constructor function is newed-up with parens\r\n         * @param {ASTNode} newExpression The NewExpression node to be checked.\r\n         * @returns {boolean} True if the constructor is called with parens.\r\n         * @private\r\n         */\r\n        function isNewExpressionWithParens(newExpression) {\r\n            const lastToken = sourceCode.getLastToken(newExpression);\r\n            const penultimateToken = sourceCode.getTokenBefore(lastToken);\r\n\r\n            return newExpression.arguments.length > 0 ||\r\n                (\r\n\r\n                    // The expression should end with its own parens, e.g., new new foo() is not a new expression with parens\r\n                    astUtils.isOpeningParenToken(penultimateToken) &&\r\n                    astUtils.isClosingParenToken(lastToken) &&\r\n                    newExpression.callee.range[1] < newExpression.range[1]\r\n                );\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is or contains an assignment expression\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is or contains an assignment expression.\r\n         * @private\r\n         */\r\n        function containsAssignment(node) {\r\n            if (node.type === \"AssignmentExpression\") {\r\n                return true;\r\n            }\r\n            if (node.type === \"ConditionalExpression\" &&\r\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\r\n                return true;\r\n            }\r\n            if ((node.left && node.left.type === \"AssignmentExpression\") ||\r\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the assignment can be parenthesised.\r\n         * @private\r\n         */\r\n        function isReturnAssignException(node) {\r\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\r\n                return false;\r\n            }\r\n\r\n            if (node.type === \"ReturnStatement\") {\r\n                return node.argument && containsAssignment(node.argument);\r\n            }\r\n            if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\r\n                return containsAssignment(node.body);\r\n            }\r\n            return containsAssignment(node);\r\n\r\n        }\r\n\r\n        /**\r\n         * Determines if a node following a [no LineTerminator here] restriction is\r\n         * surrounded by (potentially) invalid extra parentheses.\r\n         * @param {Token} token The token preceding the [no LineTerminator here] restriction.\r\n         * @param {ASTNode} node The node to be checked.\r\n         * @returns {boolean} True if the node is incorrectly parenthesised.\r\n         * @private\r\n         */\r\n        function hasExcessParensNoLineTerminator(token, node) {\r\n            if (token.loc.end.line === node.loc.start.line) {\r\n                return hasExcessParens(node);\r\n            }\r\n\r\n            return hasDoubleExcessParens(node);\r\n        }\r\n\r\n        /**\r\n         * Determines whether a node should be preceded by an additional space when removing parens\r\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\r\n         * @returns {boolean} `true` if a space should be inserted before the node\r\n         * @private\r\n         */\r\n        function requiresLeadingSpace(node) {\r\n            const leftParenToken = sourceCode.getTokenBefore(node);\r\n            const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, { includeComments: true });\r\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, { includeComments: true });\r\n\r\n            return tokenBeforeLeftParen &&\r\n                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&\r\n                leftParenToken.range[1] === tokenAfterLeftParen.range[0] &&\r\n                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);\r\n        }\r\n\r\n        /**\r\n         * Determines whether a node should be followed by an additional space when removing parens\r\n         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses\r\n         * @returns {boolean} `true` if a space should be inserted after the node\r\n         * @private\r\n         */\r\n        function requiresTrailingSpace(node) {\r\n            const nextTwoTokens = sourceCode.getTokensAfter(node, { count: 2 });\r\n            const rightParenToken = nextTwoTokens[0];\r\n            const tokenAfterRightParen = nextTwoTokens[1];\r\n            const tokenBeforeRightParen = sourceCode.getLastToken(node);\r\n\r\n            return rightParenToken && tokenAfterRightParen &&\r\n                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&\r\n                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);\r\n        }\r\n\r\n        /**\r\n         * Determines if a given expression node is an IIFE\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} `true` if the given node is an IIFE\r\n         */\r\n        function isIIFE(node) {\r\n            const maybeCallNode = astUtils.skipChainExpression(node);\r\n\r\n            return maybeCallNode.type === \"CallExpression\" && maybeCallNode.callee.type === \"FunctionExpression\";\r\n        }\r\n\r\n        /**\r\n         * Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.\r\n         * This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,\r\n         * such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.\r\n         * @param {ASTNode} [node] The node to check\r\n         * @returns {boolean} `true` if the given node can be a valid assignment target\r\n         */\r\n        function canBeAssignmentTarget(node) {\r\n            return node && (node.type === \"Identifier\" || node.type === \"MemberExpression\");\r\n        }\r\n\r\n        /**\r\n         * Report the node\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node) {\r\n            const leftParenToken = sourceCode.getTokenBefore(node);\r\n            const rightParenToken = sourceCode.getTokenAfter(node);\r\n\r\n            if (!isParenthesisedTwice(node)) {\r\n                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {\r\n                    return;\r\n                }\r\n\r\n                if (isIIFE(node) && !isParenthesised(node.callee)) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            /**\r\n             * Finishes reporting\r\n             * @returns {void}\r\n             * @private\r\n             */\r\n            function finishReport() {\r\n                context.report({\r\n                    node,\r\n                    loc: leftParenToken.loc,\r\n                    messageId: \"unexpected\",\r\n                    fix(fixer) {\r\n                        const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);\r\n\r\n                        return fixer.replaceTextRange([\r\n                            leftParenToken.range[0],\r\n                            rightParenToken.range[1]\r\n                        ], (requiresLeadingSpace(node) ? \" \" : \"\") + parenthesizedSource + (requiresTrailingSpace(node) ? \" \" : \"\"));\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (reportsBuffer) {\r\n                reportsBuffer.reports.push({ node, finishReport });\r\n                return;\r\n            }\r\n\r\n            finishReport();\r\n        }\r\n\r\n        /**\r\n         * Evaluate a argument of the node.\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkArgumentWithPrecedence(node) {\r\n            if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {\r\n                report(node.argument);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if a member expression contains a call expression\r\n         * @param {ASTNode} node MemberExpression node to evaluate\r\n         * @returns {boolean} true if found, false if not\r\n         */\r\n        function doesMemberExpressionContainCallExpression(node) {\r\n            let currentNode = node.object;\r\n            let currentNodeType = node.object.type;\r\n\r\n            while (currentNodeType === \"MemberExpression\") {\r\n                currentNode = currentNode.object;\r\n                currentNodeType = currentNode.type;\r\n            }\r\n\r\n            return currentNodeType === \"CallExpression\";\r\n        }\r\n\r\n        /**\r\n         * Evaluate a new call\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkCallNew(node) {\r\n            const callee = node.callee;\r\n\r\n            if (hasExcessParensWithPrecedence(callee, precedence(node))) {\r\n                if (\r\n                    hasDoubleExcessParens(callee) ||\r\n                    !(\r\n                        isIIFE(node) ||\r\n\r\n                        // (new A)(); new (new A)();\r\n                        (\r\n                            callee.type === \"NewExpression\" &&\r\n                            !isNewExpressionWithParens(callee) &&\r\n                            !(\r\n                                node.type === \"NewExpression\" &&\r\n                                !isNewExpressionWithParens(node)\r\n                            )\r\n                        ) ||\r\n\r\n                        // new (a().b)(); new (a.b().c);\r\n                        (\r\n                            node.type === \"NewExpression\" &&\r\n                            callee.type === \"MemberExpression\" &&\r\n                            doesMemberExpressionContainCallExpression(callee)\r\n                        ) ||\r\n\r\n                        // (a?.b)(); (a?.())();\r\n                        (\r\n                            !node.optional &&\r\n                            callee.type === \"ChainExpression\"\r\n                        )\r\n                    )\r\n                ) {\r\n                    report(node.callee);\r\n                }\r\n            }\r\n            node.arguments\r\n                .filter(arg => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR))\r\n                .forEach(report);\r\n        }\r\n\r\n        /**\r\n         * Evaluate binary logicals\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkBinaryLogical(node) {\r\n            const prec = precedence(node);\r\n            const leftPrecedence = precedence(node.left);\r\n            const rightPrecedence = precedence(node.right);\r\n            const isExponentiation = node.operator === \"**\";\r\n            const shouldSkipLeft = NESTED_BINARY && (node.left.type === \"BinaryExpression\" || node.left.type === \"LogicalExpression\");\r\n            const shouldSkipRight = NESTED_BINARY && (node.right.type === \"BinaryExpression\" || node.right.type === \"LogicalExpression\");\r\n\r\n            if (!shouldSkipLeft && hasExcessParens(node.left)) {\r\n                if (\r\n                    !([\"AwaitExpression\", \"UnaryExpression\"].includes(node.left.type) && isExponentiation) &&\r\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) &&\r\n                    (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation)) ||\r\n                    isParenthesisedTwice(node.left)\r\n                ) {\r\n                    report(node.left);\r\n                }\r\n            }\r\n\r\n            if (!shouldSkipRight && hasExcessParens(node.right)) {\r\n                if (\r\n                    !astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) &&\r\n                    (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation)) ||\r\n                    isParenthesisedTwice(node.right)\r\n                ) {\r\n                    report(node.right);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check the parentheses around the super class of the given class definition.\r\n         * @param {ASTNode} node The node of class declarations to check.\r\n         * @returns {void}\r\n         */\r\n        function checkClass(node) {\r\n            if (!node.superClass) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.\r\n             * Otherwise, parentheses are needed.\r\n             */\r\n            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR\r\n                ? hasExcessParens(node.superClass)\r\n                : hasDoubleExcessParens(node.superClass);\r\n\r\n            if (hasExtraParens) {\r\n                report(node.superClass);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check the parentheses around the argument of the given spread operator.\r\n         * @param {ASTNode} node The node of spread elements/properties to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSpreadOperator(node) {\r\n            if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                report(node.argument);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration\r\n         * @param {ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node\r\n         * @returns {void}\r\n         */\r\n        function checkExpressionOrExportStatement(node) {\r\n            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);\r\n            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);\r\n            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;\r\n            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;\r\n\r\n            if (\r\n                astUtils.isOpeningParenToken(firstToken) &&\r\n                (\r\n                    astUtils.isOpeningBraceToken(secondToken) ||\r\n                    secondToken.type === \"Keyword\" && (\r\n                        secondToken.value === \"function\" ||\r\n                        secondToken.value === \"class\" ||\r\n                        secondToken.value === \"let\" &&\r\n                            tokenAfterClosingParens &&\r\n                            (\r\n                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||\r\n                                tokenAfterClosingParens.type === \"Identifier\"\r\n                            )\r\n                    ) ||\r\n                    secondToken && secondToken.type === \"Identifier\" && secondToken.value === \"async\" && thirdToken && thirdToken.type === \"Keyword\" && thirdToken.value === \"function\"\r\n                )\r\n            ) {\r\n                tokensToIgnore.add(secondToken);\r\n            }\r\n\r\n            const hasExtraParens = node.parent.type === \"ExportDefaultDeclaration\"\r\n                ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR)\r\n                : hasExcessParens(node);\r\n\r\n            if (hasExtraParens) {\r\n                report(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Finds the path from the given node to the specified ancestor.\r\n         * @param {ASTNode} node First node in the path.\r\n         * @param {ASTNode} ancestor Last node in the path.\r\n         * @returns {ASTNode[]} Path, including both nodes.\r\n         * @throws {Error} If the given node does not have the specified ancestor.\r\n         */\r\n        function pathToAncestor(node, ancestor) {\r\n            const path = [node];\r\n            let currentNode = node;\r\n\r\n            while (currentNode !== ancestor) {\r\n\r\n                currentNode = currentNode.parent;\r\n\r\n                /* istanbul ignore if */\r\n                if (currentNode === null) {\r\n                    throw new Error(\"Nodes are not in the ancestor-descendant relationship.\");\r\n                }\r\n\r\n                path.push(currentNode);\r\n            }\r\n\r\n            return path;\r\n        }\r\n\r\n        /**\r\n         * Finds the path from the given node to the specified descendant.\r\n         * @param {ASTNode} node First node in the path.\r\n         * @param {ASTNode} descendant Last node in the path.\r\n         * @returns {ASTNode[]} Path, including both nodes.\r\n         * @throws {Error} If the given node does not have the specified descendant.\r\n         */\r\n        function pathToDescendant(node, descendant) {\r\n            return pathToAncestor(descendant, node).reverse();\r\n        }\r\n\r\n        /**\r\n         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer\r\n         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.\r\n         * @param {ASTNode} node Ancestor of an 'in' expression.\r\n         * @param {ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.\r\n         * @returns {boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.\r\n         */\r\n        function isSafelyEnclosingInExpression(node, child) {\r\n            switch (node.type) {\r\n                case \"ArrayExpression\":\r\n                case \"ArrayPattern\":\r\n                case \"BlockStatement\":\r\n                case \"ObjectExpression\":\r\n                case \"ObjectPattern\":\r\n                case \"TemplateLiteral\":\r\n                    return true;\r\n                case \"ArrowFunctionExpression\":\r\n                case \"FunctionExpression\":\r\n                    return node.params.includes(child);\r\n                case \"CallExpression\":\r\n                case \"NewExpression\":\r\n                    return node.arguments.includes(child);\r\n                case \"MemberExpression\":\r\n                    return node.computed && node.property === child;\r\n                case \"ConditionalExpression\":\r\n                    return node.consequent === child;\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.\r\n         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.\r\n         * @returns {void}\r\n         */\r\n        function startNewReportsBuffering() {\r\n            reportsBuffer = {\r\n                upper: reportsBuffer,\r\n                inExpressionNodes: [],\r\n                reports: []\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Ends the current reports buffering.\r\n         * @returns {void}\r\n         */\r\n        function endCurrentReportsBuffering() {\r\n            const { upper, inExpressionNodes, reports } = reportsBuffer;\r\n\r\n            if (upper) {\r\n                upper.inExpressionNodes.push(...inExpressionNodes);\r\n                upper.reports.push(...reports);\r\n            } else {\r\n\r\n                // flush remaining reports\r\n                reports.forEach(({ finishReport }) => finishReport());\r\n            }\r\n\r\n            reportsBuffer = upper;\r\n        }\r\n\r\n        /**\r\n         * Checks whether the given node is in the current reports buffer.\r\n         * @param {ASTNode} node Node to check.\r\n         * @returns {boolean} True if the node is in the current buffer, false otherwise.\r\n         */\r\n        function isInCurrentReportsBuffer(node) {\r\n            return reportsBuffer.reports.some(r => r.node === node);\r\n        }\r\n\r\n        /**\r\n         * Removes the given node from the current reports buffer.\r\n         * @param {ASTNode} node Node to remove.\r\n         * @returns {void}\r\n         */\r\n        function removeFromCurrentReportsBuffer(node) {\r\n            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);\r\n        }\r\n\r\n        /**\r\n         * Checks whether a node is a MemberExpression at NewExpression's callee.\r\n         * @param {ASTNode} node node to check.\r\n         * @returns {boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.\r\n         */\r\n        function isMemberExpInNewCallee(node) {\r\n            if (node.type === \"MemberExpression\") {\r\n                return node.parent.type === \"NewExpression\" && node.parent.callee === node\r\n                    ? true\r\n                    : node.parent.object === node && isMemberExpInNewCallee(node.parent);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        return {\r\n            ArrayExpression(node) {\r\n                node.elements\r\n                    .filter(e => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR))\r\n                    .forEach(report);\r\n            },\r\n\r\n            ArrayPattern(node) {\r\n                node.elements\r\n                    .filter(e => canBeAssignmentTarget(e) && hasExcessParens(e))\r\n                    .forEach(report);\r\n            },\r\n\r\n            ArrowFunctionExpression(node) {\r\n                if (isReturnAssignException(node)) {\r\n                    return;\r\n                }\r\n\r\n                if (node.body.type === \"ConditionalExpression\" &&\r\n                    IGNORE_ARROW_CONDITIONALS\r\n                ) {\r\n                    return;\r\n                }\r\n\r\n                if (node.body.type !== \"BlockStatement\") {\r\n                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);\r\n                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);\r\n\r\n                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {\r\n                        tokensToIgnore.add(firstBodyToken);\r\n                    }\r\n                    if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                        report(node.body);\r\n                    }\r\n                }\r\n            },\r\n\r\n            AssignmentExpression(node) {\r\n                if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {\r\n                    report(node.left);\r\n                }\r\n\r\n                if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {\r\n                    report(node.right);\r\n                }\r\n            },\r\n\r\n            BinaryExpression(node) {\r\n                if (reportsBuffer && node.operator === \"in\") {\r\n                    reportsBuffer.inExpressionNodes.push(node);\r\n                }\r\n\r\n                checkBinaryLogical(node);\r\n            },\r\n\r\n            CallExpression: checkCallNew,\r\n\r\n            ConditionalExpression(node) {\r\n                if (isReturnAssignException(node)) {\r\n                    return;\r\n                }\r\n                if (\r\n                    !isCondAssignException(node) &&\r\n                    hasExcessParensWithPrecedence(node.test, precedence({ type: \"LogicalExpression\", operator: \"||\" }))\r\n                ) {\r\n                    report(node.test);\r\n                }\r\n\r\n                if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.consequent);\r\n                }\r\n\r\n                if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.alternate);\r\n                }\r\n            },\r\n\r\n            DoWhileStatement(node) {\r\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\r\n                    report(node.test);\r\n                }\r\n            },\r\n\r\n            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),\r\n            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),\r\n\r\n            ForInStatement(node) {\r\n                if (node.left.type !== \"VariableDeclaration\") {\r\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\r\n\r\n                    if (\r\n                        firstLeftToken.value === \"let\" &&\r\n                        astUtils.isOpeningBracketToken(\r\n                            sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)\r\n                        )\r\n                    ) {\r\n\r\n                        // ForInStatement#left expression cannot start with `let[`.\r\n                        tokensToIgnore.add(firstLeftToken);\r\n                    }\r\n                }\r\n\r\n                if (hasExcessParens(node.left)) {\r\n                    report(node.left);\r\n                }\r\n\r\n                if (hasExcessParens(node.right)) {\r\n                    report(node.right);\r\n                }\r\n            },\r\n\r\n            ForOfStatement(node) {\r\n                if (node.left.type !== \"VariableDeclaration\") {\r\n                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);\r\n\r\n                    if (firstLeftToken.value === \"let\") {\r\n\r\n                        // ForOfStatement#left expression cannot start with `let`.\r\n                        tokensToIgnore.add(firstLeftToken);\r\n                    }\r\n                }\r\n\r\n                if (hasExcessParens(node.left)) {\r\n                    report(node.left);\r\n                }\r\n\r\n                if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.right);\r\n                }\r\n            },\r\n\r\n            ForStatement(node) {\r\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\r\n                    report(node.test);\r\n                }\r\n\r\n                if (node.update && hasExcessParens(node.update)) {\r\n                    report(node.update);\r\n                }\r\n\r\n                if (node.init) {\r\n\r\n                    if (node.init.type !== \"VariableDeclaration\") {\r\n                        const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);\r\n\r\n                        if (\r\n                            firstToken.value === \"let\" &&\r\n                            astUtils.isOpeningBracketToken(\r\n                                sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken)\r\n                            )\r\n                        ) {\r\n\r\n                            // ForStatement#init expression cannot start with `let[`.\r\n                            tokensToIgnore.add(firstToken);\r\n                        }\r\n                    }\r\n\r\n                    startNewReportsBuffering();\r\n\r\n                    if (hasExcessParens(node.init)) {\r\n                        report(node.init);\r\n                    }\r\n                }\r\n            },\r\n\r\n            \"ForStatement > *.init:exit\"(node) {\r\n\r\n                /*\r\n                 * Removing parentheses around `in` expressions might change semantics and cause errors.\r\n                 *\r\n                 * For example, this valid for loop:\r\n                 *      for (let a = (b in c); ;);\r\n                 * after removing parentheses would be treated as an invalid for-in loop:\r\n                 *      for (let a = b in c; ;);\r\n                 */\r\n\r\n                if (reportsBuffer.reports.length) {\r\n                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => {\r\n                        const path = pathToDescendant(node, inExpressionNode);\r\n                        let nodeToExclude;\r\n\r\n                        for (let i = 0; i < path.length; i++) {\r\n                            const pathNode = path[i];\r\n\r\n                            if (i < path.length - 1) {\r\n                                const nextPathNode = path[i + 1];\r\n\r\n                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {\r\n\r\n                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            if (isParenthesised(pathNode)) {\r\n                                if (isInCurrentReportsBuffer(pathNode)) {\r\n\r\n                                    // This node was supposed to be reported, but parentheses might be necessary.\r\n\r\n                                    if (isParenthesisedTwice(pathNode)) {\r\n\r\n                                        /*\r\n                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.\r\n                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.\r\n                                         * The remaining pair is safely enclosing the 'in' expression.\r\n                                         */\r\n                                        return;\r\n                                    }\r\n\r\n                                    // Exclude the outermost node only.\r\n                                    if (!nodeToExclude) {\r\n                                        nodeToExclude = pathNode;\r\n                                    }\r\n\r\n                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.\r\n\r\n                                } else {\r\n\r\n                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.\r\n                                    return;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // Exclude the node from the list (i.e. treat parentheses as necessary)\r\n                        removeFromCurrentReportsBuffer(nodeToExclude);\r\n                    });\r\n                }\r\n\r\n                endCurrentReportsBuffering();\r\n            },\r\n\r\n            IfStatement(node) {\r\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\r\n                    report(node.test);\r\n                }\r\n            },\r\n\r\n            ImportExpression(node) {\r\n                const { source } = node;\r\n\r\n                if (source.type === \"SequenceExpression\") {\r\n                    if (hasDoubleExcessParens(source)) {\r\n                        report(source);\r\n                    }\r\n                } else if (hasExcessParens(source)) {\r\n                    report(source);\r\n                }\r\n            },\r\n\r\n            LogicalExpression: checkBinaryLogical,\r\n\r\n            MemberExpression(node) {\r\n                const shouldAllowWrapOnce = isMemberExpInNewCallee(node) &&\r\n                  doesMemberExpressionContainCallExpression(node);\r\n                const nodeObjHasExcessParens = shouldAllowWrapOnce\r\n                    ? hasDoubleExcessParens(node.object)\r\n                    : hasExcessParens(node.object) &&\r\n                    !(\r\n                        isImmediateFunctionPrototypeMethodCall(node.parent) &&\r\n                        node.parent.callee === node &&\r\n                        IGNORE_FUNCTION_PROTOTYPE_METHODS\r\n                    );\r\n\r\n                if (\r\n                    nodeObjHasExcessParens &&\r\n                    precedence(node.object) >= precedence(node) &&\r\n                    (\r\n                        node.computed ||\r\n                        !(\r\n                            astUtils.isDecimalInteger(node.object) ||\r\n\r\n                            // RegExp literal is allowed to have parens (#1589)\r\n                            (node.object.type === \"Literal\" && node.object.regex)\r\n                        )\r\n                    )\r\n                ) {\r\n                    report(node.object);\r\n                }\r\n\r\n                if (nodeObjHasExcessParens &&\r\n                  node.object.type === \"CallExpression\"\r\n                ) {\r\n                    report(node.object);\r\n                }\r\n\r\n                if (nodeObjHasExcessParens &&\r\n                  !IGNORE_NEW_IN_MEMBER_EXPR &&\r\n                  node.object.type === \"NewExpression\" &&\r\n                  isNewExpressionWithParens(node.object)) {\r\n                    report(node.object);\r\n                }\r\n\r\n                if (nodeObjHasExcessParens &&\r\n                    node.optional &&\r\n                    node.object.type === \"ChainExpression\"\r\n                ) {\r\n                    report(node.object);\r\n                }\r\n\r\n                if (node.computed && hasExcessParens(node.property)) {\r\n                    report(node.property);\r\n                }\r\n            },\r\n\r\n            \"MethodDefinition[computed=true]\"(node) {\r\n                if (hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.key);\r\n                }\r\n            },\r\n\r\n            NewExpression: checkCallNew,\r\n\r\n            ObjectExpression(node) {\r\n                node.properties\r\n                    .filter(property => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR))\r\n                    .forEach(property => report(property.value));\r\n            },\r\n\r\n            ObjectPattern(node) {\r\n                node.properties\r\n                    .filter(property => {\r\n                        const value = property.value;\r\n\r\n                        return canBeAssignmentTarget(value) && hasExcessParens(value);\r\n                    }).forEach(property => report(property.value));\r\n            },\r\n\r\n            Property(node) {\r\n                if (node.computed) {\r\n                    const { key } = node;\r\n\r\n                    if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                        report(key);\r\n                    }\r\n                }\r\n            },\r\n\r\n            PropertyDefinition(node) {\r\n                if (node.computed && hasExcessParensWithPrecedence(node.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.key);\r\n                }\r\n\r\n                if (node.value && hasExcessParensWithPrecedence(node.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(node.value);\r\n                }\r\n            },\r\n\r\n            RestElement(node) {\r\n                const argument = node.argument;\r\n\r\n                if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {\r\n                    report(argument);\r\n                }\r\n            },\r\n\r\n            ReturnStatement(node) {\r\n                const returnToken = sourceCode.getFirstToken(node);\r\n\r\n                if (isReturnAssignException(node)) {\r\n                    return;\r\n                }\r\n\r\n                if (node.argument &&\r\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\r\n\r\n                        // RegExp literal is allowed to have parens (#1589)\r\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\r\n                    report(node.argument);\r\n                }\r\n            },\r\n\r\n            SequenceExpression(node) {\r\n                const precedenceOfNode = precedence(node);\r\n\r\n                node.expressions\r\n                    .filter(e => hasExcessParensWithPrecedence(e, precedenceOfNode))\r\n                    .forEach(report);\r\n            },\r\n\r\n            SwitchCase(node) {\r\n                if (node.test && hasExcessParens(node.test)) {\r\n                    report(node.test);\r\n                }\r\n            },\r\n\r\n            SwitchStatement(node) {\r\n                if (hasExcessParens(node.discriminant)) {\r\n                    report(node.discriminant);\r\n                }\r\n            },\r\n\r\n            ThrowStatement(node) {\r\n                const throwToken = sourceCode.getFirstToken(node);\r\n\r\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\r\n                    report(node.argument);\r\n                }\r\n            },\r\n\r\n            UnaryExpression: checkArgumentWithPrecedence,\r\n            UpdateExpression(node) {\r\n                if (node.prefix) {\r\n                    checkArgumentWithPrecedence(node);\r\n                } else {\r\n                    const { argument } = node;\r\n                    const operatorToken = sourceCode.getLastToken(node);\r\n\r\n                    if (argument.loc.end.line === operatorToken.loc.start.line) {\r\n                        checkArgumentWithPrecedence(node);\r\n                    } else {\r\n                        if (hasDoubleExcessParens(argument)) {\r\n                            report(argument);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            AwaitExpression: checkArgumentWithPrecedence,\r\n\r\n            VariableDeclarator(node) {\r\n                if (\r\n                    node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) &&\r\n\r\n                    // RegExp literal is allowed to have parens (#1589)\r\n                    !(node.init.type === \"Literal\" && node.init.regex)\r\n                ) {\r\n                    report(node.init);\r\n                }\r\n            },\r\n\r\n            WhileStatement(node) {\r\n                if (hasExcessParens(node.test) && !isCondAssignException(node)) {\r\n                    report(node.test);\r\n                }\r\n            },\r\n\r\n            WithStatement(node) {\r\n                if (hasExcessParens(node.object)) {\r\n                    report(node.object);\r\n                }\r\n            },\r\n\r\n            YieldExpression(node) {\r\n                if (node.argument) {\r\n                    const yieldToken = sourceCode.getFirstToken(node);\r\n\r\n                    if ((precedence(node.argument) >= precedence(node) &&\r\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\r\n                            hasDoubleExcessParens(node.argument)) {\r\n                        report(node.argument);\r\n                    }\r\n                }\r\n            },\r\n\r\n            ClassDeclaration: checkClass,\r\n            ClassExpression: checkClass,\r\n\r\n            SpreadElement: checkSpreadOperator,\r\n            SpreadProperty: checkSpreadOperator,\r\n            ExperimentalSpreadProperty: checkSpreadOperator,\r\n\r\n            TemplateLiteral(node) {\r\n                node.expressions\r\n                    .filter(e => e && hasExcessParens(e))\r\n                    .forEach(report);\r\n            },\r\n\r\n            AssignmentPattern(node) {\r\n                const { left, right } = node;\r\n\r\n                if (canBeAssignmentTarget(left) && hasExcessParens(left)) {\r\n                    report(left);\r\n                }\r\n\r\n                if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {\r\n                    report(right);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}