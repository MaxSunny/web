{"ast":null,"code":"/**\r\n * @fileoverview Validates newlines before and after dots\r\n * @author Greg Cochard\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent newlines before and after dots\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-location\"\n    },\n    schema: [{\n      enum: [\"object\", \"property\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      expectedDotAfterObject: \"Expected dot to be on same line as object.\",\n      expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0]; // default to onObject if no preference is passed\n\n    const onObject = config === \"object\" || !config;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports if the dot between object and property is on the correct location.\r\n     * @param {ASTNode} node The `MemberExpression` node.\r\n     * @returns {void}\r\n     */\n\n    function checkDotLocation(node) {\n      const property = node.property;\n      const dotToken = sourceCode.getTokenBefore(property);\n\n      if (onObject) {\n        // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.\n        const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);\n\n        if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {\n          context.report({\n            node,\n            loc: dotToken.loc,\n            messageId: \"expectedDotAfterObject\",\n\n            *fix(fixer) {\n              if (dotToken.value.startsWith(\".\") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {\n                yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);\n              } else {\n                yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);\n              }\n\n              yield fixer.remove(dotToken);\n            }\n\n          });\n        }\n      } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {\n        context.report({\n          node,\n          loc: dotToken.loc,\n          messageId: \"expectedDotBeforeProperty\",\n\n          *fix(fixer) {\n            yield fixer.remove(dotToken);\n            yield fixer.insertTextBefore(property, dotToken.value);\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Checks the spacing of the dot within a member expression.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkNode(node) {\n      if (!node.computed) {\n        checkDotLocation(node);\n      }\n    }\n\n    return {\n      MemberExpression: checkNode\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/dot-location.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","fixable","messages","expectedDotAfterObject","expectedDotBeforeProperty","create","context","config","options","onObject","sourceCode","getSourceCode","checkDotLocation","node","property","dotToken","getTokenBefore","tokenBeforeDot","isTokenOnSameLine","report","loc","messageId","fix","fixer","value","startsWith","isDecimalIntegerNumericToken","insertTextAfter","remove","insertTextBefore","checkNode","computed","MemberExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Validates newlines before and after dots\r\n * @author Greg Cochard\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent newlines before and after dots\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/dot-location\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"object\", \"property\"]\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            expectedDotAfterObject: \"Expected dot to be on same line as object.\",\r\n            expectedDotBeforeProperty: \"Expected dot to be on same line as property.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const config = context.options[0];\r\n\r\n        // default to onObject if no preference is passed\r\n        const onObject = config === \"object\" || !config;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports if the dot between object and property is on the correct location.\r\n         * @param {ASTNode} node The `MemberExpression` node.\r\n         * @returns {void}\r\n         */\r\n        function checkDotLocation(node) {\r\n            const property = node.property;\r\n            const dotToken = sourceCode.getTokenBefore(property);\r\n\r\n            if (onObject) {\r\n\r\n                // `obj` expression can be parenthesized, but those paren tokens are not a part of the `obj` node.\r\n                const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);\r\n\r\n                if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {\r\n                    context.report({\r\n                        node,\r\n                        loc: dotToken.loc,\r\n                        messageId: \"expectedDotAfterObject\",\r\n                        *fix(fixer) {\r\n                            if (dotToken.value.startsWith(\".\") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {\r\n                                yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);\r\n                            } else {\r\n                                yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);\r\n                            }\r\n                            yield fixer.remove(dotToken);\r\n                        }\r\n                    });\r\n                }\r\n            } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {\r\n                context.report({\r\n                    node,\r\n                    loc: dotToken.loc,\r\n                    messageId: \"expectedDotBeforeProperty\",\r\n                    *fix(fixer) {\r\n                        yield fixer.remove(dotToken);\r\n                        yield fixer.insertTextBefore(property, dotToken.value);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the spacing of the dot within a member expression.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkNode(node) {\r\n            if (!node.computed) {\r\n                checkDotLocation(node);\r\n            }\r\n        }\r\n\r\n        return {\r\n            MemberExpression: checkNode\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}