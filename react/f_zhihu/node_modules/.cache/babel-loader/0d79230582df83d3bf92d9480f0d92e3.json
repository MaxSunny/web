{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst SPACES = /\\s+/gu;\n/**\r\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\r\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\r\n *      a Property.\r\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\r\n *      a Property.\r\n * @param {boolean} props The flag to check member expressions as well.\r\n * @param {Function} report A callback function to report.\r\n * @returns {void}\r\n */\n\nfunction eachSelfAssignment(left, right, props, report) {\n  if (!left || !right) {// do nothing\n  } else if (left.type === \"Identifier\" && right.type === \"Identifier\" && left.name === right.name) {\n    report(right);\n  } else if (left.type === \"ArrayPattern\" && right.type === \"ArrayExpression\") {\n    const end = Math.min(left.elements.length, right.elements.length);\n\n    for (let i = 0; i < end; ++i) {\n      const leftElement = left.elements[i];\n      const rightElement = right.elements[i]; // Avoid cases such as [...a] = [...a, 1]\n\n      if (leftElement && leftElement.type === \"RestElement\" && i < right.elements.length - 1) {\n        break;\n      }\n\n      eachSelfAssignment(leftElement, rightElement, props, report); // After a spread element, those indices are unknown.\n\n      if (rightElement && rightElement.type === \"SpreadElement\") {\n        break;\n      }\n    }\n  } else if (left.type === \"RestElement\" && right.type === \"SpreadElement\") {\n    eachSelfAssignment(left.argument, right.argument, props, report);\n  } else if (left.type === \"ObjectPattern\" && right.type === \"ObjectExpression\" && right.properties.length >= 1) {\n    /*\r\n     * Gets the index of the last spread property.\r\n     * It's possible to overwrite properties followed by it.\r\n     */\n    let startJ = 0;\n\n    for (let i = right.properties.length - 1; i >= 0; --i) {\n      const propType = right.properties[i].type;\n\n      if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\n        startJ = i + 1;\n        break;\n      }\n    }\n\n    for (let i = 0; i < left.properties.length; ++i) {\n      for (let j = startJ; j < right.properties.length; ++j) {\n        eachSelfAssignment(left.properties[i], right.properties[j], props, report);\n      }\n    }\n  } else if (left.type === \"Property\" && right.type === \"Property\" && right.kind === \"init\" && !right.method) {\n    const leftName = astUtils.getStaticPropertyName(left);\n\n    if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\n      eachSelfAssignment(left.value, right.value, props, report);\n    }\n  } else if (props && astUtils.skipChainExpression(left).type === \"MemberExpression\" && astUtils.skipChainExpression(right).type === \"MemberExpression\" && astUtils.isSameReference(left, right)) {\n    report(right);\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments where both sides are exactly the same\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-self-assign\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        props: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      selfAssignment: \"'{{name}}' is assigned to itself.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const [{\n      props = true\n    } = {}] = context.options;\n    /**\r\n     * Reports a given node as self assignments.\r\n     * @param {ASTNode} node A node to report. This is an Identifier node.\r\n     * @returns {void}\r\n     */\n\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"selfAssignment\",\n        data: {\n          name: sourceCode.getText(node).replace(SPACES, \"\")\n        }\n      });\n    }\n\n    return {\n      AssignmentExpression(node) {\n        if ([\"=\", \"&&=\", \"||=\", \"??=\"].includes(node.operator)) {\n          eachSelfAssignment(node.left, node.right, props, report);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-self-assign.js"],"names":["astUtils","require","SPACES","eachSelfAssignment","left","right","props","report","type","name","end","Math","min","elements","length","i","leftElement","rightElement","argument","properties","startJ","propType","j","kind","method","leftName","getStaticPropertyName","value","skipChainExpression","isSameReference","module","exports","meta","docs","description","recommended","url","schema","default","additionalProperties","messages","selfAssignment","create","context","sourceCode","getSourceCode","options","node","messageId","data","getText","replace","AssignmentExpression","includes","operator"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow assignments where both sides are exactly the same\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst SPACES = /\\s+/gu;\r\n\r\n/**\r\n * Traverses 2 Pattern nodes in parallel, then reports self-assignments.\r\n * @param {ASTNode|null} left A left node to traverse. This is a Pattern or\r\n *      a Property.\r\n * @param {ASTNode|null} right A right node to traverse. This is a Pattern or\r\n *      a Property.\r\n * @param {boolean} props The flag to check member expressions as well.\r\n * @param {Function} report A callback function to report.\r\n * @returns {void}\r\n */\r\nfunction eachSelfAssignment(left, right, props, report) {\r\n    if (!left || !right) {\r\n\r\n        // do nothing\r\n    } else if (\r\n        left.type === \"Identifier\" &&\r\n        right.type === \"Identifier\" &&\r\n        left.name === right.name\r\n    ) {\r\n        report(right);\r\n    } else if (\r\n        left.type === \"ArrayPattern\" &&\r\n        right.type === \"ArrayExpression\"\r\n    ) {\r\n        const end = Math.min(left.elements.length, right.elements.length);\r\n\r\n        for (let i = 0; i < end; ++i) {\r\n            const leftElement = left.elements[i];\r\n            const rightElement = right.elements[i];\r\n\r\n            // Avoid cases such as [...a] = [...a, 1]\r\n            if (\r\n                leftElement &&\r\n                leftElement.type === \"RestElement\" &&\r\n                i < right.elements.length - 1\r\n            ) {\r\n                break;\r\n            }\r\n\r\n            eachSelfAssignment(leftElement, rightElement, props, report);\r\n\r\n            // After a spread element, those indices are unknown.\r\n            if (rightElement && rightElement.type === \"SpreadElement\") {\r\n                break;\r\n            }\r\n        }\r\n    } else if (\r\n        left.type === \"RestElement\" &&\r\n        right.type === \"SpreadElement\"\r\n    ) {\r\n        eachSelfAssignment(left.argument, right.argument, props, report);\r\n    } else if (\r\n        left.type === \"ObjectPattern\" &&\r\n        right.type === \"ObjectExpression\" &&\r\n        right.properties.length >= 1\r\n    ) {\r\n\r\n        /*\r\n         * Gets the index of the last spread property.\r\n         * It's possible to overwrite properties followed by it.\r\n         */\r\n        let startJ = 0;\r\n\r\n        for (let i = right.properties.length - 1; i >= 0; --i) {\r\n            const propType = right.properties[i].type;\r\n\r\n            if (propType === \"SpreadElement\" || propType === \"ExperimentalSpreadProperty\") {\r\n                startJ = i + 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < left.properties.length; ++i) {\r\n            for (let j = startJ; j < right.properties.length; ++j) {\r\n                eachSelfAssignment(\r\n                    left.properties[i],\r\n                    right.properties[j],\r\n                    props,\r\n                    report\r\n                );\r\n            }\r\n        }\r\n    } else if (\r\n        left.type === \"Property\" &&\r\n        right.type === \"Property\" &&\r\n        right.kind === \"init\" &&\r\n        !right.method\r\n    ) {\r\n        const leftName = astUtils.getStaticPropertyName(left);\r\n\r\n        if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {\r\n            eachSelfAssignment(left.value, right.value, props, report);\r\n        }\r\n    } else if (\r\n        props &&\r\n        astUtils.skipChainExpression(left).type === \"MemberExpression\" &&\r\n        astUtils.skipChainExpression(right).type === \"MemberExpression\" &&\r\n        astUtils.isSameReference(left, right)\r\n    ) {\r\n        report(right);\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow assignments where both sides are exactly the same\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-self-assign\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    props: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            selfAssignment: \"'{{name}}' is assigned to itself.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const [{ props = true } = {}] = context.options;\r\n\r\n        /**\r\n         * Reports a given node as self assignments.\r\n         * @param {ASTNode} node A node to report. This is an Identifier node.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"selfAssignment\",\r\n                data: {\r\n                    name: sourceCode.getText(node).replace(SPACES, \"\")\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            AssignmentExpression(node) {\r\n                if ([\"=\", \"&&=\", \"||=\", \"??=\"].includes(node.operator)) {\r\n                    eachSelfAssignment(node.left, node.right, props, report);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}