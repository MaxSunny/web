{"ast":null,"code":"/**\r\n * @fileoverview Rule to forbid or enforce dangling commas.\r\n * @author Ian Christian Myers\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_OPTIONS = Object.freeze({\n  arrays: \"never\",\n  objects: \"never\",\n  imports: \"never\",\n  exports: \"never\",\n  functions: \"never\"\n});\n/**\r\n * Checks whether or not a trailing comma is allowed in a given node.\r\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\r\n * @param {ASTNode} lastItem The node of the last element in the given node.\r\n * @returns {boolean} `true` if a trailing comma is allowed.\r\n */\n\nfunction isTrailingCommaAllowed(lastItem) {\n  return !(lastItem.type === \"RestElement\" || lastItem.type === \"RestProperty\" || lastItem.type === \"ExperimentalRestProperty\");\n}\n/**\r\n * Normalize option value.\r\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\r\n * @param {number} ecmaVersion The normalized ECMAScript version.\r\n * @returns {Object} The normalized option value.\r\n */\n\n\nfunction normalizeOptions(optionValue, ecmaVersion) {\n  if (typeof optionValue === \"string\") {\n    return {\n      arrays: optionValue,\n      objects: optionValue,\n      imports: optionValue,\n      exports: optionValue,\n      functions: !ecmaVersion || ecmaVersion < 8 ? \"ignore\" : optionValue\n    };\n  }\n\n  if (typeof optionValue === \"object\" && optionValue !== null) {\n    return {\n      arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\n      objects: optionValue.objects || DEFAULT_OPTIONS.objects,\n      imports: optionValue.imports || DEFAULT_OPTIONS.imports,\n      exports: optionValue.exports || DEFAULT_OPTIONS.exports,\n      functions: optionValue.functions || DEFAULT_OPTIONS.functions\n    };\n  }\n\n  return DEFAULT_OPTIONS;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow trailing commas\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-dangle\"\n    },\n    fixable: \"code\",\n    schema: {\n      definitions: {\n        value: {\n          enum: [\"always-multiline\", \"always\", \"never\", \"only-multiline\"]\n        },\n        valueWithIgnore: {\n          enum: [\"always-multiline\", \"always\", \"ignore\", \"never\", \"only-multiline\"]\n        }\n      },\n      type: \"array\",\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/value\"\n        }, {\n          type: \"object\",\n          properties: {\n            arrays: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            objects: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            imports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            exports: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            },\n            functions: {\n              $ref: \"#/definitions/valueWithIgnore\"\n            }\n          },\n          additionalProperties: false\n        }]\n      }],\n      additionalItems: false\n    },\n    messages: {\n      unexpected: \"Unexpected trailing comma.\",\n      missing: \"Missing trailing comma.\"\n    }\n  },\n\n  create(context) {\n    const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Gets the last item of the given node.\r\n     * @param {ASTNode} node The node to get.\r\n     * @returns {ASTNode|null} The last node or null.\r\n     */\n\n    function getLastItem(node) {\n      /**\r\n       * Returns the last element of an array\r\n       * @param {any[]} array The input array\r\n       * @returns {any} The last element\r\n       */\n      function last(array) {\n        return array[array.length - 1];\n      }\n\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ObjectPattern\":\n          return last(node.properties);\n\n        case \"ArrayExpression\":\n        case \"ArrayPattern\":\n          return last(node.elements);\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return last(node.specifiers);\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n          return last(node.params);\n\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return last(node.arguments);\n\n        default:\n          return null;\n      }\n    }\n    /**\r\n     * Gets the trailing comma token of the given node.\r\n     * If the trailing comma does not exist, this returns the token which is\r\n     * the insertion point of the trailing comma token.\r\n     * @param {ASTNode} node The node to get.\r\n     * @param {ASTNode} lastItem The last item of the node.\r\n     * @returns {Token} The trailing comma token or the insertion point.\r\n     */\n\n\n    function getTrailingToken(node, lastItem) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n        case \"ArrayExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return sourceCode.getLastToken(node, 1);\n\n        default:\n          {\n            const nextToken = sourceCode.getTokenAfter(lastItem);\n\n            if (astUtils.isCommaToken(nextToken)) {\n              return nextToken;\n            }\n\n            return sourceCode.getLastToken(lastItem);\n          }\n      }\n    }\n    /**\r\n     * Checks whether or not a given node is multiline.\r\n     * This rule handles a given node as multiline when the closing parenthesis\r\n     * and the last element are not on the same line.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} `true` if the node is multiline.\r\n     */\n\n\n    function isMultiline(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem) {\n        return false;\n      }\n\n      const penultimateToken = getTrailingToken(node, lastItem);\n      const lastToken = sourceCode.getTokenAfter(penultimateToken);\n      return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n    }\n    /**\r\n     * Reports a trailing comma if it exists.\r\n     * @param {ASTNode} node A node to check. Its type is one of\r\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n     *   ImportDeclaration, and ExportNamedDeclaration.\r\n     * @returns {void}\r\n     */\n\n\n    function forbidTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (astUtils.isCommaToken(trailingToken)) {\n        context.report({\n          node: lastItem,\n          loc: trailingToken.loc,\n          messageId: \"unexpected\",\n\n          *fix(fixer) {\n            yield fixer.remove(trailingToken);\n            /*\r\n             * Extend the range of the fix to include surrounding tokens to ensure\r\n             * that the element after which the comma is removed stays _last_.\r\n             * This intentionally makes conflicts in fix ranges with rules that may be\r\n             * adding or removing elements in the same autofix pass.\r\n             * https://github.com/eslint/eslint/issues/15660\r\n             */\n\n            yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), \"\");\n            yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Reports the last element of a given node if it does not have a trailing\r\n     * comma.\r\n     *\r\n     * If a given node is `ArrayPattern` which has `RestElement`, the trailing\r\n     * comma is disallowed, so report if it exists.\r\n     * @param {ASTNode} node A node to check. Its type is one of\r\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n     *   ImportDeclaration, and ExportNamedDeclaration.\r\n     * @returns {void}\r\n     */\n\n\n    function forceTrailingComma(node) {\n      const lastItem = getLastItem(node);\n\n      if (!lastItem || node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\") {\n        return;\n      }\n\n      if (!isTrailingCommaAllowed(lastItem)) {\n        forbidTrailingComma(node);\n        return;\n      }\n\n      const trailingToken = getTrailingToken(node, lastItem);\n\n      if (trailingToken.value !== \",\") {\n        context.report({\n          node: lastItem,\n          loc: {\n            start: trailingToken.loc.end,\n            end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\n          },\n          messageId: \"missing\",\n\n          *fix(fixer) {\n            yield fixer.insertTextAfter(trailingToken, \",\");\n            /*\r\n             * Extend the range of the fix to include surrounding tokens to ensure\r\n             * that the element after which the comma is inserted stays _last_.\r\n             * This intentionally makes conflicts in fix ranges with rules that may be\r\n             * adding or removing elements in the same autofix pass.\r\n             * https://github.com/eslint/eslint/issues/15660\r\n             */\n\n            yield fixer.insertTextBefore(trailingToken, \"\");\n            yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\n          }\n\n        });\n      }\n    }\n    /**\r\n     * If a given node is multiline, reports the last element of a given node\r\n     * when it does not have a trailing comma.\r\n     * Otherwise, reports a trailing comma if it exists.\r\n     * @param {ASTNode} node A node to check. Its type is one of\r\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n     *   ImportDeclaration, and ExportNamedDeclaration.\r\n     * @returns {void}\r\n     */\n\n\n    function forceTrailingCommaIfMultiline(node) {\n      if (isMultiline(node)) {\n        forceTrailingComma(node);\n      } else {\n        forbidTrailingComma(node);\n      }\n    }\n    /**\r\n     * Only if a given node is not multiline, reports the last element of a given node\r\n     * when it does not have a trailing comma.\r\n     * Otherwise, reports a trailing comma if it exists.\r\n     * @param {ASTNode} node A node to check. Its type is one of\r\n     *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n     *   ImportDeclaration, and ExportNamedDeclaration.\r\n     * @returns {void}\r\n     */\n\n\n    function allowTrailingCommaIfMultiline(node) {\n      if (!isMultiline(node)) {\n        forbidTrailingComma(node);\n      }\n    }\n\n    const predicate = {\n      always: forceTrailingComma,\n      \"always-multiline\": forceTrailingCommaIfMultiline,\n      \"only-multiline\": allowTrailingCommaIfMultiline,\n      never: forbidTrailingComma,\n      ignore: () => {}\n    };\n    return {\n      ObjectExpression: predicate[options.objects],\n      ObjectPattern: predicate[options.objects],\n      ArrayExpression: predicate[options.arrays],\n      ArrayPattern: predicate[options.arrays],\n      ImportDeclaration: predicate[options.imports],\n      ExportNamedDeclaration: predicate[options.exports],\n      FunctionDeclaration: predicate[options.functions],\n      FunctionExpression: predicate[options.functions],\n      ArrowFunctionExpression: predicate[options.functions],\n      CallExpression: predicate[options.functions],\n      NewExpression: predicate[options.functions]\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/comma-dangle.js"],"names":["astUtils","require","DEFAULT_OPTIONS","Object","freeze","arrays","objects","imports","exports","functions","isTrailingCommaAllowed","lastItem","type","normalizeOptions","optionValue","ecmaVersion","module","meta","docs","description","recommended","url","fixable","schema","definitions","value","enum","valueWithIgnore","items","oneOf","$ref","properties","additionalProperties","additionalItems","messages","unexpected","missing","create","context","options","parserOptions","sourceCode","getSourceCode","getLastItem","node","last","array","length","elements","specifiers","params","arguments","getTrailingToken","getLastToken","nextToken","getTokenAfter","isCommaToken","isMultiline","penultimateToken","lastToken","loc","end","line","forbidTrailingComma","trailingToken","report","messageId","fix","fixer","remove","insertTextBefore","getTokenBefore","insertTextAfter","forceTrailingComma","start","getNextLocation","forceTrailingCommaIfMultiline","allowTrailingCommaIfMultiline","predicate","always","never","ignore","ObjectExpression","ObjectPattern","ArrayExpression","ArrayPattern","ImportDeclaration","ExportNamedDeclaration","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","CallExpression","NewExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to forbid or enforce dangling commas.\r\n * @author Ian Christian Myers\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst DEFAULT_OPTIONS = Object.freeze({\r\n    arrays: \"never\",\r\n    objects: \"never\",\r\n    imports: \"never\",\r\n    exports: \"never\",\r\n    functions: \"never\"\r\n});\r\n\r\n/**\r\n * Checks whether or not a trailing comma is allowed in a given node.\r\n * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.\r\n * @param {ASTNode} lastItem The node of the last element in the given node.\r\n * @returns {boolean} `true` if a trailing comma is allowed.\r\n */\r\nfunction isTrailingCommaAllowed(lastItem) {\r\n    return !(\r\n        lastItem.type === \"RestElement\" ||\r\n        lastItem.type === \"RestProperty\" ||\r\n        lastItem.type === \"ExperimentalRestProperty\"\r\n    );\r\n}\r\n\r\n/**\r\n * Normalize option value.\r\n * @param {string|Object|undefined} optionValue The 1st option value to normalize.\r\n * @param {number} ecmaVersion The normalized ECMAScript version.\r\n * @returns {Object} The normalized option value.\r\n */\r\nfunction normalizeOptions(optionValue, ecmaVersion) {\r\n    if (typeof optionValue === \"string\") {\r\n        return {\r\n            arrays: optionValue,\r\n            objects: optionValue,\r\n            imports: optionValue,\r\n            exports: optionValue,\r\n            functions: (!ecmaVersion || ecmaVersion < 8) ? \"ignore\" : optionValue\r\n        };\r\n    }\r\n    if (typeof optionValue === \"object\" && optionValue !== null) {\r\n        return {\r\n            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,\r\n            objects: optionValue.objects || DEFAULT_OPTIONS.objects,\r\n            imports: optionValue.imports || DEFAULT_OPTIONS.imports,\r\n            exports: optionValue.exports || DEFAULT_OPTIONS.exports,\r\n            functions: optionValue.functions || DEFAULT_OPTIONS.functions\r\n        };\r\n    }\r\n\r\n    return DEFAULT_OPTIONS;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow trailing commas\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/comma-dangle\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: {\r\n            definitions: {\r\n                value: {\r\n                    enum: [\r\n                        \"always-multiline\",\r\n                        \"always\",\r\n                        \"never\",\r\n                        \"only-multiline\"\r\n                    ]\r\n                },\r\n                valueWithIgnore: {\r\n                    enum: [\r\n                        \"always-multiline\",\r\n                        \"always\",\r\n                        \"ignore\",\r\n                        \"never\",\r\n                        \"only-multiline\"\r\n                    ]\r\n                }\r\n            },\r\n            type: \"array\",\r\n            items: [\r\n                {\r\n                    oneOf: [\r\n                        {\r\n                            $ref: \"#/definitions/value\"\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                arrays: { $ref: \"#/definitions/valueWithIgnore\" },\r\n                                objects: { $ref: \"#/definitions/valueWithIgnore\" },\r\n                                imports: { $ref: \"#/definitions/valueWithIgnore\" },\r\n                                exports: { $ref: \"#/definitions/valueWithIgnore\" },\r\n                                functions: { $ref: \"#/definitions/valueWithIgnore\" }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ]\r\n                }\r\n            ],\r\n            additionalItems: false\r\n        },\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected trailing comma.\",\r\n            missing: \"Missing trailing comma.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = normalizeOptions(context.options[0], context.parserOptions.ecmaVersion);\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Gets the last item of the given node.\r\n         * @param {ASTNode} node The node to get.\r\n         * @returns {ASTNode|null} The last node or null.\r\n         */\r\n        function getLastItem(node) {\r\n\r\n            /**\r\n             * Returns the last element of an array\r\n             * @param {any[]} array The input array\r\n             * @returns {any} The last element\r\n             */\r\n            function last(array) {\r\n                return array[array.length - 1];\r\n            }\r\n\r\n            switch (node.type) {\r\n                case \"ObjectExpression\":\r\n                case \"ObjectPattern\":\r\n                    return last(node.properties);\r\n                case \"ArrayExpression\":\r\n                case \"ArrayPattern\":\r\n                    return last(node.elements);\r\n                case \"ImportDeclaration\":\r\n                case \"ExportNamedDeclaration\":\r\n                    return last(node.specifiers);\r\n                case \"FunctionDeclaration\":\r\n                case \"FunctionExpression\":\r\n                case \"ArrowFunctionExpression\":\r\n                    return last(node.params);\r\n                case \"CallExpression\":\r\n                case \"NewExpression\":\r\n                    return last(node.arguments);\r\n                default:\r\n                    return null;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the trailing comma token of the given node.\r\n         * If the trailing comma does not exist, this returns the token which is\r\n         * the insertion point of the trailing comma token.\r\n         * @param {ASTNode} node The node to get.\r\n         * @param {ASTNode} lastItem The last item of the node.\r\n         * @returns {Token} The trailing comma token or the insertion point.\r\n         */\r\n        function getTrailingToken(node, lastItem) {\r\n            switch (node.type) {\r\n                case \"ObjectExpression\":\r\n                case \"ArrayExpression\":\r\n                case \"CallExpression\":\r\n                case \"NewExpression\":\r\n                    return sourceCode.getLastToken(node, 1);\r\n                default: {\r\n                    const nextToken = sourceCode.getTokenAfter(lastItem);\r\n\r\n                    if (astUtils.isCommaToken(nextToken)) {\r\n                        return nextToken;\r\n                    }\r\n                    return sourceCode.getLastToken(lastItem);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given node is multiline.\r\n         * This rule handles a given node as multiline when the closing parenthesis\r\n         * and the last element are not on the same line.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} `true` if the node is multiline.\r\n         */\r\n        function isMultiline(node) {\r\n            const lastItem = getLastItem(node);\r\n\r\n            if (!lastItem) {\r\n                return false;\r\n            }\r\n\r\n            const penultimateToken = getTrailingToken(node, lastItem);\r\n            const lastToken = sourceCode.getTokenAfter(penultimateToken);\r\n\r\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\r\n        }\r\n\r\n        /**\r\n         * Reports a trailing comma if it exists.\r\n         * @param {ASTNode} node A node to check. Its type is one of\r\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n         *   ImportDeclaration, and ExportNamedDeclaration.\r\n         * @returns {void}\r\n         */\r\n        function forbidTrailingComma(node) {\r\n            const lastItem = getLastItem(node);\r\n\r\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\r\n                return;\r\n            }\r\n\r\n            const trailingToken = getTrailingToken(node, lastItem);\r\n\r\n            if (astUtils.isCommaToken(trailingToken)) {\r\n                context.report({\r\n                    node: lastItem,\r\n                    loc: trailingToken.loc,\r\n                    messageId: \"unexpected\",\r\n                    *fix(fixer) {\r\n                        yield fixer.remove(trailingToken);\r\n\r\n                        /*\r\n                         * Extend the range of the fix to include surrounding tokens to ensure\r\n                         * that the element after which the comma is removed stays _last_.\r\n                         * This intentionally makes conflicts in fix ranges with rules that may be\r\n                         * adding or removing elements in the same autofix pass.\r\n                         * https://github.com/eslint/eslint/issues/15660\r\n                         */\r\n                        yield fixer.insertTextBefore(sourceCode.getTokenBefore(trailingToken), \"\");\r\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports the last element of a given node if it does not have a trailing\r\n         * comma.\r\n         *\r\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\r\n         * comma is disallowed, so report if it exists.\r\n         * @param {ASTNode} node A node to check. Its type is one of\r\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n         *   ImportDeclaration, and ExportNamedDeclaration.\r\n         * @returns {void}\r\n         */\r\n        function forceTrailingComma(node) {\r\n            const lastItem = getLastItem(node);\r\n\r\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\r\n                return;\r\n            }\r\n            if (!isTrailingCommaAllowed(lastItem)) {\r\n                forbidTrailingComma(node);\r\n                return;\r\n            }\r\n\r\n            const trailingToken = getTrailingToken(node, lastItem);\r\n\r\n            if (trailingToken.value !== \",\") {\r\n                context.report({\r\n                    node: lastItem,\r\n                    loc: {\r\n                        start: trailingToken.loc.end,\r\n                        end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)\r\n                    },\r\n                    messageId: \"missing\",\r\n                    *fix(fixer) {\r\n                        yield fixer.insertTextAfter(trailingToken, \",\");\r\n\r\n                        /*\r\n                         * Extend the range of the fix to include surrounding tokens to ensure\r\n                         * that the element after which the comma is inserted stays _last_.\r\n                         * This intentionally makes conflicts in fix ranges with rules that may be\r\n                         * adding or removing elements in the same autofix pass.\r\n                         * https://github.com/eslint/eslint/issues/15660\r\n                         */\r\n                        yield fixer.insertTextBefore(trailingToken, \"\");\r\n                        yield fixer.insertTextAfter(sourceCode.getTokenAfter(trailingToken), \"\");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * If a given node is multiline, reports the last element of a given node\r\n         * when it does not have a trailing comma.\r\n         * Otherwise, reports a trailing comma if it exists.\r\n         * @param {ASTNode} node A node to check. Its type is one of\r\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n         *   ImportDeclaration, and ExportNamedDeclaration.\r\n         * @returns {void}\r\n         */\r\n        function forceTrailingCommaIfMultiline(node) {\r\n            if (isMultiline(node)) {\r\n                forceTrailingComma(node);\r\n            } else {\r\n                forbidTrailingComma(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Only if a given node is not multiline, reports the last element of a given node\r\n         * when it does not have a trailing comma.\r\n         * Otherwise, reports a trailing comma if it exists.\r\n         * @param {ASTNode} node A node to check. Its type is one of\r\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\r\n         *   ImportDeclaration, and ExportNamedDeclaration.\r\n         * @returns {void}\r\n         */\r\n        function allowTrailingCommaIfMultiline(node) {\r\n            if (!isMultiline(node)) {\r\n                forbidTrailingComma(node);\r\n            }\r\n        }\r\n\r\n        const predicate = {\r\n            always: forceTrailingComma,\r\n            \"always-multiline\": forceTrailingCommaIfMultiline,\r\n            \"only-multiline\": allowTrailingCommaIfMultiline,\r\n            never: forbidTrailingComma,\r\n            ignore: () => {}\r\n        };\r\n\r\n        return {\r\n            ObjectExpression: predicate[options.objects],\r\n            ObjectPattern: predicate[options.objects],\r\n\r\n            ArrayExpression: predicate[options.arrays],\r\n            ArrayPattern: predicate[options.arrays],\r\n\r\n            ImportDeclaration: predicate[options.imports],\r\n\r\n            ExportNamedDeclaration: predicate[options.exports],\r\n\r\n            FunctionDeclaration: predicate[options.functions],\r\n            FunctionExpression: predicate[options.functions],\r\n            ArrowFunctionExpression: predicate[options.functions],\r\n            CallExpression: predicate[options.functions],\r\n            NewExpression: predicate[options.functions]\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}