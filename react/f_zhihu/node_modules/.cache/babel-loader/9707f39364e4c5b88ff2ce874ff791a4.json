{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\r\n * @author Burak Yigit Kaya\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines whether the computed key syntax is unnecessarily used for the given node.\r\n * In particular, it determines whether removing the square brackets and using the content between them\r\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\r\n * Valid non-computed keys are only: identifiers, number literals and string literals.\r\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\r\n * Property\r\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\r\n *     { \"__proto__\": foo } defines object's prototype\r\n * PropertyDefinition\r\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\r\n *     class C { \"constructor\"; } produces a parsing error\r\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\r\n *     class C { static \"constructor\"; } produces a parsing error\r\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\r\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\r\n * MethodDefinition\r\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\r\n *     class C { \"constructor\"() {} } defines the constructor\r\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\r\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\r\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\r\n * @throws {Error} (Unreachable.)\r\n * @returns {void} `true` if the node has useless computed key.\r\n */\n\n\nfunction hasUselessComputedKey(node) {\n  if (!node.computed) {\n    return false;\n  }\n\n  const {\n    key\n  } = node;\n\n  if (key.type !== \"Literal\") {\n    return false;\n  }\n\n  const {\n    value\n  } = key;\n\n  if (typeof value !== \"number\" && typeof value !== \"string\") {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"Property\":\n      return value !== \"__proto__\";\n\n    case \"PropertyDefinition\":\n      if (node.static) {\n        return value !== \"constructor\" && value !== \"prototype\";\n      }\n\n      return value !== \"constructor\";\n\n    case \"MethodDefinition\":\n      if (node.static) {\n        return value !== \"prototype\";\n      }\n\n      return value !== \"constructor\";\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error(`Unexpected node type: ${node.type}`);\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary computed property keys in objects and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\n    /**\r\n     * Reports a given node if it violated this rule.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n    function check(node) {\n      if (hasUselessComputedKey(node)) {\n        const {\n          key\n        } = node;\n        context.report({\n          node,\n          messageId: \"unnecessarilyComputedProperty\",\n          data: {\n            property: sourceCode.getText(key)\n          },\n\n          fix(fixer) {\n            const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\n            const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken); // If there are comments between the brackets and the property name, don't do a fix.\n\n            if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\n              return null;\n            }\n\n            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket); // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\n\n            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\n            const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\n            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\n          }\n\n        });\n      }\n    }\n    /**\r\n     * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function noop() {}\n\n    return {\n      Property: check,\n      MethodDefinition: enforceForClassMembers ? check : noop,\n      PropertyDefinition: enforceForClassMembers ? check : noop\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-computed-key.js"],"names":["astUtils","require","hasUselessComputedKey","node","computed","key","type","value","static","Error","module","exports","meta","docs","description","recommended","url","schema","properties","enforceForClassMembers","default","additionalProperties","fixable","messages","unnecessarilyComputedProperty","create","context","sourceCode","getSourceCode","options","check","report","messageId","data","property","getText","fix","fixer","leftSquareBracket","getTokenBefore","isOpeningBracketToken","rightSquareBracket","getTokenAfter","isClosingBracketToken","commentsExistBetween","tokenBeforeLeftBracket","needsSpaceBeforeKey","range","canTokensBeAdjacent","getFirstToken","replacementKey","raw","replaceTextRange","noop","Property","MethodDefinition","PropertyDefinition"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow unnecessary computed property keys in object literals\r\n * @author Burak Yigit Kaya\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines whether the computed key syntax is unnecessarily used for the given node.\r\n * In particular, it determines whether removing the square brackets and using the content between them\r\n * directly as the key (e.g. ['foo'] -> 'foo') would produce valid syntax and preserve the same behavior.\r\n * Valid non-computed keys are only: identifiers, number literals and string literals.\r\n * Only literals can preserve the same behavior, with a few exceptions for specific node types:\r\n * Property\r\n *   - { [\"__proto__\"]: foo } defines a property named \"__proto__\"\r\n *     { \"__proto__\": foo } defines object's prototype\r\n * PropertyDefinition\r\n *   - class C { [\"constructor\"]; } defines an instance field named \"constructor\"\r\n *     class C { \"constructor\"; } produces a parsing error\r\n *   - class C { static [\"constructor\"]; } defines a static field named \"constructor\"\r\n *     class C { static \"constructor\"; } produces a parsing error\r\n *   - class C { static [\"prototype\"]; } produces a runtime error (doesn't break the whole script)\r\n *     class C { static \"prototype\"; } produces a parsing error (breaks the whole script)\r\n * MethodDefinition\r\n *   - class C { [\"constructor\"]() {} } defines a prototype method named \"constructor\"\r\n *     class C { \"constructor\"() {} } defines the constructor\r\n *   - class C { static [\"prototype\"]() {} } produces a runtime error (doesn't break the whole script)\r\n *     class C { static \"prototype\"() {} } produces a parsing error (breaks the whole script)\r\n * @param {ASTNode} node The node to check. It can be `Property`, `PropertyDefinition` or `MethodDefinition`.\r\n * @throws {Error} (Unreachable.)\r\n * @returns {void} `true` if the node has useless computed key.\r\n */\r\nfunction hasUselessComputedKey(node) {\r\n    if (!node.computed) {\r\n        return false;\r\n    }\r\n\r\n    const { key } = node;\r\n\r\n    if (key.type !== \"Literal\") {\r\n        return false;\r\n    }\r\n\r\n    const { value } = key;\r\n\r\n    if (typeof value !== \"number\" && typeof value !== \"string\") {\r\n        return false;\r\n    }\r\n\r\n    switch (node.type) {\r\n        case \"Property\":\r\n            return value !== \"__proto__\";\r\n\r\n        case \"PropertyDefinition\":\r\n            if (node.static) {\r\n                return value !== \"constructor\" && value !== \"prototype\";\r\n            }\r\n\r\n            return value !== \"constructor\";\r\n\r\n        case \"MethodDefinition\":\r\n            if (node.static) {\r\n                return value !== \"prototype\";\r\n            }\r\n\r\n            return value !== \"constructor\";\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n            throw new Error(`Unexpected node type: ${node.type}`);\r\n    }\r\n\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary computed property keys in objects and classes\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-useless-computed-key\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                enforceForClassMembers: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unnecessarilyComputedProperty: \"Unnecessarily computed property [{{property}}] found.\"\r\n        }\r\n    },\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const enforceForClassMembers = context.options[0] && context.options[0].enforceForClassMembers;\r\n\r\n        /**\r\n         * Reports a given node if it violated this rule.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function check(node) {\r\n            if (hasUselessComputedKey(node)) {\r\n                const { key } = node;\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unnecessarilyComputedProperty\",\r\n                    data: { property: sourceCode.getText(key) },\r\n                    fix(fixer) {\r\n                        const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);\r\n                        const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);\r\n\r\n                        // If there are comments between the brackets and the property name, don't do a fix.\r\n                        if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {\r\n                            return null;\r\n                        }\r\n\r\n                        const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);\r\n\r\n                        // Insert a space before the key to avoid changing identifiers, e.g. ({ get[2]() {} }) to ({ get2() {} })\r\n                        const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&\r\n                            !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));\r\n\r\n                        const replacementKey = (needsSpaceBeforeKey ? \" \" : \"\") + key.raw;\r\n\r\n                        return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * A no-op function to act as placeholder for checking a node when the `enforceForClassMembers` option is `false`.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function noop() {}\r\n\r\n        return {\r\n            Property: check,\r\n            MethodDefinition: enforceForClassMembers ? check : noop,\r\n            PropertyDefinition: enforceForClassMembers ? check : noop\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}