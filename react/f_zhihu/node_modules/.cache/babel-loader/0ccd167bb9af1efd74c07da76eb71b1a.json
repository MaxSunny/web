{"ast":null,"code":"/**\r\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst FixTracker = require(\"./utils/fix-tracker\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\n/**\r\n * Checks whether a given node is located at `ForStatement.init` or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\r\n */\n\nfunction isInitOfForStatement(node) {\n  return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n/**\r\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\r\n * @param {ASTNode} identifier An Identifier node to check.\r\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\r\n */\n\n\nfunction canBecomeVariableDeclaration(identifier) {\n  let node = identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  return node.type === \"VariableDeclarator\" || node.type === \"AssignmentExpression\" && node.parent.type === \"ExpressionStatement\" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);\n}\n/**\r\n * Checks if an property or element is from outer scope or function parameters\r\n * in destructing pattern.\r\n * @param {string} name A variable name to be checked.\r\n * @param {eslint-scope.Scope} initScope A scope to start find.\r\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\r\n */\n\n\nfunction isOuterVariableInDestructing(name, initScope) {\n  if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\n    return true;\n  }\n\n  const variable = astUtils.getVariableByName(initScope, name);\n\n  if (variable !== null) {\n    return variable.defs.some(def => def.type === \"Parameter\");\n  }\n\n  return false;\n}\n/**\r\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\r\n * belongs to.\r\n * This is used to detect a mix of reassigned and never reassigned in a\r\n * destructuring.\r\n * @param {eslint-scope.Reference} reference A reference to get.\r\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\r\n *      null.\r\n */\n\n\nfunction getDestructuringHost(reference) {\n  if (!reference.isWrite()) {\n    return null;\n  }\n\n  let node = reference.identifier.parent;\n\n  while (PATTERN_TYPE.test(node.type)) {\n    node = node.parent;\n  }\n\n  if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n    return null;\n  }\n\n  return node;\n}\n/**\r\n * Determines if a destructuring assignment node contains\r\n * any MemberExpression nodes. This is used to determine if a\r\n * variable that is only written once using destructuring can be\r\n * safely converted into a const declaration.\r\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\r\n * @returns {boolean} True if the destructuring pattern contains\r\n *      a MemberExpression, false if not.\r\n */\n\n\nfunction hasMemberExpressionAssignment(node) {\n  switch (node.type) {\n    case \"ObjectPattern\":\n      return node.properties.some(prop => {\n        if (prop) {\n          /*\r\n           * Spread elements have an argument property while\r\n           * others have a value property. Because different\r\n           * parsers use different node types for spread elements,\r\n           * we just check if there is an argument property.\r\n           */\n          return hasMemberExpressionAssignment(prop.argument || prop.value);\n        }\n\n        return false;\n      });\n\n    case \"ArrayPattern\":\n      return node.elements.some(element => {\n        if (element) {\n          return hasMemberExpressionAssignment(element);\n        }\n\n        return false;\n      });\n\n    case \"AssignmentPattern\":\n      return hasMemberExpressionAssignment(node.left);\n\n    case \"MemberExpression\":\n      return true;\n    // no default\n  }\n\n  return false;\n}\n/**\r\n * Gets an identifier node of a given variable.\r\n *\r\n * If the initialization exists or one or more reading references exist before\r\n * the first assignment, the identifier node is the node of the declaration.\r\n * Otherwise, the identifier node is the node of the first assignment.\r\n *\r\n * If the variable should not change to const, this function returns null.\r\n * - If the variable is reassigned.\r\n * - If the variable is never initialized nor assigned.\r\n * - If the variable is initialized in a different scope from the declaration.\r\n * - If the unique assignment of the variable cannot change to a declaration.\r\n *   e.g. `if (a) b = 1` / `return (b = 1)`\r\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\r\n *   `/*exported foo` directive comment makes such variables. This rule does not\r\n *   warn such variables because this rule cannot distinguish whether the\r\n *   exported variables are reassigned or not.\r\n * @param {eslint-scope.Variable} variable A variable to get.\r\n * @param {boolean} ignoreReadBeforeAssign\r\n *      The value of `ignoreReadBeforeAssign` option.\r\n * @returns {ASTNode|null}\r\n *      An Identifier node if the variable should change to const.\r\n *      Otherwise, null.\r\n */\n\n\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n  if (variable.eslintUsed && variable.scope.type === \"global\") {\n    return null;\n  } // Finds the unique WriteReference.\n\n\n  let writer = null;\n  let isReadBeforeInit = false;\n  const references = variable.references;\n\n  for (let i = 0; i < references.length; ++i) {\n    const reference = references[i];\n\n    if (reference.isWrite()) {\n      const isReassigned = writer !== null && writer.identifier !== reference.identifier;\n\n      if (isReassigned) {\n        return null;\n      }\n\n      const destructuringHost = getDestructuringHost(reference);\n\n      if (destructuringHost !== null && destructuringHost.left !== void 0) {\n        const leftNode = destructuringHost.left;\n        let hasOuterVariables = false,\n            hasNonIdentifiers = false;\n\n        if (leftNode.type === \"ObjectPattern\") {\n          const properties = leftNode.properties;\n          hasOuterVariables = properties.filter(prop => prop.value).map(prop => prop.value.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        } else if (leftNode.type === \"ArrayPattern\") {\n          const elements = leftNode.elements;\n          hasOuterVariables = elements.map(element => element && element.name).some(name => isOuterVariableInDestructing(name, variable.scope));\n          hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\n        }\n\n        if (hasOuterVariables || hasNonIdentifiers) {\n          return null;\n        }\n      }\n\n      writer = reference;\n    } else if (reference.isRead() && writer === null) {\n      if (ignoreReadBeforeAssign) {\n        return null;\n      }\n\n      isReadBeforeInit = true;\n    }\n  }\n  /*\r\n   * If the assignment is from a different scope, ignore it.\r\n   * If the assignment cannot change to a declaration, ignore it.\r\n   */\n\n\n  const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);\n\n  if (!shouldBeConst) {\n    return null;\n  }\n\n  if (isReadBeforeInit) {\n    return variable.defs[0].name;\n  }\n\n  return writer.identifier;\n}\n/**\r\n * Groups by the VariableDeclarator/AssignmentExpression node that each\r\n * reference of given variables belongs to.\r\n * This is used to detect a mix of reassigned and never reassigned in a\r\n * destructuring.\r\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\r\n * @param {boolean} ignoreReadBeforeAssign\r\n *      The value of `ignoreReadBeforeAssign` option.\r\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\r\n */\n\n\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n  const identifierMap = new Map();\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n    const references = variable.references;\n    const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n    let prevId = null;\n\n    for (let j = 0; j < references.length; ++j) {\n      const reference = references[j];\n      const id = reference.identifier;\n      /*\r\n       * Avoid counting a reference twice or more for default values of\r\n       * destructuring.\r\n       */\n\n      if (id === prevId) {\n        continue;\n      }\n\n      prevId = id; // Add the identifier node into the destructuring group.\n\n      const group = getDestructuringHost(reference);\n\n      if (group) {\n        if (identifierMap.has(group)) {\n          identifierMap.get(group).push(identifier);\n        } else {\n          identifierMap.set(group, [identifier]);\n        }\n      }\n    }\n  }\n\n  return identifierMap;\n}\n/**\r\n * Finds the nearest parent of node with a given type.\r\n * @param {ASTNode} node The node to search from.\r\n * @param {string} type The type field of the parent node.\r\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\r\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\r\n */\n\n\nfunction findUp(node, type, shouldStop) {\n  if (!node || shouldStop(node)) {\n    return null;\n  }\n\n  if (node.type === type) {\n    return node;\n  }\n\n  return findUp(node.parent, type, shouldStop);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require `const` declarations for variables that are never reassigned after declared\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-const\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        destructuring: {\n          enum: [\"any\", \"all\"],\n          default: \"any\"\n        },\n        ignoreReadBeforeAssign: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const sourceCode = context.getSourceCode();\n    const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\n    const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n    const variables = [];\n    let reportCount = 0;\n    let checkedId = null;\n    let checkedName = \"\";\n    /**\r\n     * Reports given identifier nodes if all of the nodes should be declared\r\n     * as const.\r\n     *\r\n     * The argument 'nodes' is an array of Identifier nodes.\r\n     * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\r\n     * nullable. In simple declaration or assignment cases, the length of\r\n     * the array is 1. In destructuring cases, the length of the array can\r\n     * be 2 or more.\r\n     * @param {(eslint-scope.Reference|null)[]} nodes\r\n     *      References which are grouped by destructuring to report.\r\n     * @returns {void}\r\n     */\n\n    function checkGroup(nodes) {\n      const nodesToReport = nodes.filter(Boolean);\n\n      if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\n        const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\n        const isVarDecParentNull = varDeclParent === null;\n\n        if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\n          const firstDeclaration = varDeclParent.declarations[0];\n\n          if (firstDeclaration.init) {\n            const firstDecParent = firstDeclaration.init.parent;\n            /*\r\n             * First we check the declaration type and then depending on\r\n             * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\r\n             * we compare the name and id from the first identifier, if the names are different\r\n             * we assign the new name, id and reset the count of reportCount and nodeCount in\r\n             * order to check each block for the number of reported errors and base our fix\r\n             * based on comparing nodes.length and nodesToReport.length.\r\n             */\n\n            if (firstDecParent.type === \"VariableDeclarator\") {\n              if (firstDecParent.id.name !== checkedName) {\n                checkedName = firstDecParent.id.name;\n                reportCount = 0;\n              }\n\n              if (firstDecParent.id.type === \"ObjectPattern\") {\n                if (firstDecParent.init.name !== checkedName) {\n                  checkedName = firstDecParent.init.name;\n                  reportCount = 0;\n                }\n              }\n\n              if (firstDecParent.id !== checkedId) {\n                checkedId = firstDecParent.id;\n                reportCount = 0;\n              }\n            }\n          }\n        }\n\n        let shouldFix = varDeclParent && ( // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\n        varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" || varDeclParent.declarations.every(declaration => declaration.init)) &&\n        /*\r\n         * If options.destructuring is \"all\", then this warning will not occur unless\r\n         * every assignment in the destructuring should be const. In that case, it's safe\r\n         * to apply the fix.\r\n         */\n        nodesToReport.length === nodes.length;\n\n        if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\n          if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\n            /*\r\n             * Add nodesToReport.length to a count, then comparing the count to the length\r\n             * of the declarations in the current block.\r\n             */\n            reportCount += nodesToReport.length;\n            shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;\n          }\n        }\n\n        nodesToReport.forEach(node => {\n          context.report({\n            node,\n            messageId: \"useConst\",\n            data: node,\n            fix: shouldFix ? fixer => {\n              const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\n              /**\r\n               * Extend the replacement range to the whole declaration,\r\n               * in order to prevent other fixes in the same pass\r\n               * https://github.com/eslint/eslint/issues/13899\r\n               */\n\n              return new FixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, \"const\");\n            } : null\n          });\n        });\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\n      },\n\n      VariableDeclaration(node) {\n        if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n          variables.push(...context.getDeclaredVariables(node));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-const.js"],"names":["FixTracker","require","astUtils","PATTERN_TYPE","DECLARATION_HOST_TYPE","DESTRUCTURING_HOST_TYPE","isInitOfForStatement","node","parent","type","init","canBecomeVariableDeclaration","identifier","test","isOuterVariableInDestructing","name","initScope","through","find","ref","resolved","variable","getVariableByName","defs","some","def","getDestructuringHost","reference","isWrite","hasMemberExpressionAssignment","properties","prop","argument","value","elements","element","left","getIdentifierIfShouldBeConst","ignoreReadBeforeAssign","eslintUsed","scope","writer","isReadBeforeInit","references","i","length","isReassigned","destructuringHost","leftNode","hasOuterVariables","hasNonIdentifiers","filter","map","isRead","shouldBeConst","from","groupByDestructuring","variables","identifierMap","Map","prevId","j","id","group","has","get","push","set","findUp","shouldStop","module","exports","meta","docs","description","recommended","url","fixable","schema","destructuring","enum","default","additionalProperties","messages","useConst","create","context","options","sourceCode","getSourceCode","shouldMatchAnyDestructuredVariable","reportCount","checkedId","checkedName","checkGroup","nodes","nodesToReport","Boolean","varDeclParent","parentNode","endsWith","isVarDecParentNull","declarations","firstDeclaration","firstDecParent","shouldFix","every","declaration","forEach","report","messageId","data","fix","fixer","letKeywordToken","getFirstToken","t","kind","retainRange","range","replaceTextRange","VariableDeclaration","getDeclaredVariables"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst FixTracker = require(\"./utils/fix-tracker\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;\r\nconst DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|StaticBlock|SwitchCase)$/u;\r\nconst DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;\r\n\r\n/**\r\n * Checks whether a given node is located at `ForStatement.init` or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\r\n */\r\nfunction isInitOfForStatement(node) {\r\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\r\n}\r\n\r\n/**\r\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\r\n * @param {ASTNode} identifier An Identifier node to check.\r\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\r\n */\r\nfunction canBecomeVariableDeclaration(identifier) {\r\n    let node = identifier.parent;\r\n\r\n    while (PATTERN_TYPE.test(node.type)) {\r\n        node = node.parent;\r\n    }\r\n\r\n    return (\r\n        node.type === \"VariableDeclarator\" ||\r\n        (\r\n            node.type === \"AssignmentExpression\" &&\r\n            node.parent.type === \"ExpressionStatement\" &&\r\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Checks if an property or element is from outer scope or function parameters\r\n * in destructing pattern.\r\n * @param {string} name A variable name to be checked.\r\n * @param {eslint-scope.Scope} initScope A scope to start find.\r\n * @returns {boolean} Indicates if the variable is from outer scope or function parameters.\r\n */\r\nfunction isOuterVariableInDestructing(name, initScope) {\r\n\r\n    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) {\r\n        return true;\r\n    }\r\n\r\n    const variable = astUtils.getVariableByName(initScope, name);\r\n\r\n    if (variable !== null) {\r\n        return variable.defs.some(def => def.type === \"Parameter\");\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\r\n * belongs to.\r\n * This is used to detect a mix of reassigned and never reassigned in a\r\n * destructuring.\r\n * @param {eslint-scope.Reference} reference A reference to get.\r\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\r\n *      null.\r\n */\r\nfunction getDestructuringHost(reference) {\r\n    if (!reference.isWrite()) {\r\n        return null;\r\n    }\r\n    let node = reference.identifier.parent;\r\n\r\n    while (PATTERN_TYPE.test(node.type)) {\r\n        node = node.parent;\r\n    }\r\n\r\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\r\n        return null;\r\n    }\r\n    return node;\r\n}\r\n\r\n/**\r\n * Determines if a destructuring assignment node contains\r\n * any MemberExpression nodes. This is used to determine if a\r\n * variable that is only written once using destructuring can be\r\n * safely converted into a const declaration.\r\n * @param {ASTNode} node The ObjectPattern or ArrayPattern node to check.\r\n * @returns {boolean} True if the destructuring pattern contains\r\n *      a MemberExpression, false if not.\r\n */\r\nfunction hasMemberExpressionAssignment(node) {\r\n    switch (node.type) {\r\n        case \"ObjectPattern\":\r\n            return node.properties.some(prop => {\r\n                if (prop) {\r\n\r\n                    /*\r\n                     * Spread elements have an argument property while\r\n                     * others have a value property. Because different\r\n                     * parsers use different node types for spread elements,\r\n                     * we just check if there is an argument property.\r\n                     */\r\n                    return hasMemberExpressionAssignment(prop.argument || prop.value);\r\n                }\r\n\r\n                return false;\r\n            });\r\n\r\n        case \"ArrayPattern\":\r\n            return node.elements.some(element => {\r\n                if (element) {\r\n                    return hasMemberExpressionAssignment(element);\r\n                }\r\n\r\n                return false;\r\n            });\r\n\r\n        case \"AssignmentPattern\":\r\n            return hasMemberExpressionAssignment(node.left);\r\n\r\n        case \"MemberExpression\":\r\n            return true;\r\n\r\n        // no default\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Gets an identifier node of a given variable.\r\n *\r\n * If the initialization exists or one or more reading references exist before\r\n * the first assignment, the identifier node is the node of the declaration.\r\n * Otherwise, the identifier node is the node of the first assignment.\r\n *\r\n * If the variable should not change to const, this function returns null.\r\n * - If the variable is reassigned.\r\n * - If the variable is never initialized nor assigned.\r\n * - If the variable is initialized in a different scope from the declaration.\r\n * - If the unique assignment of the variable cannot change to a declaration.\r\n *   e.g. `if (a) b = 1` / `return (b = 1)`\r\n * - If the variable is declared in the global scope and `eslintUsed` is `true`.\r\n *   `/*exported foo` directive comment makes such variables. This rule does not\r\n *   warn such variables because this rule cannot distinguish whether the\r\n *   exported variables are reassigned or not.\r\n * @param {eslint-scope.Variable} variable A variable to get.\r\n * @param {boolean} ignoreReadBeforeAssign\r\n *      The value of `ignoreReadBeforeAssign` option.\r\n * @returns {ASTNode|null}\r\n *      An Identifier node if the variable should change to const.\r\n *      Otherwise, null.\r\n */\r\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\r\n    if (variable.eslintUsed && variable.scope.type === \"global\") {\r\n        return null;\r\n    }\r\n\r\n    // Finds the unique WriteReference.\r\n    let writer = null;\r\n    let isReadBeforeInit = false;\r\n    const references = variable.references;\r\n\r\n    for (let i = 0; i < references.length; ++i) {\r\n        const reference = references[i];\r\n\r\n        if (reference.isWrite()) {\r\n            const isReassigned = (\r\n                writer !== null &&\r\n                writer.identifier !== reference.identifier\r\n            );\r\n\r\n            if (isReassigned) {\r\n                return null;\r\n            }\r\n\r\n            const destructuringHost = getDestructuringHost(reference);\r\n\r\n            if (destructuringHost !== null && destructuringHost.left !== void 0) {\r\n                const leftNode = destructuringHost.left;\r\n                let hasOuterVariables = false,\r\n                    hasNonIdentifiers = false;\r\n\r\n                if (leftNode.type === \"ObjectPattern\") {\r\n                    const properties = leftNode.properties;\r\n\r\n                    hasOuterVariables = properties\r\n                        .filter(prop => prop.value)\r\n                        .map(prop => prop.value.name)\r\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\r\n\r\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\r\n\r\n                } else if (leftNode.type === \"ArrayPattern\") {\r\n                    const elements = leftNode.elements;\r\n\r\n                    hasOuterVariables = elements\r\n                        .map(element => element && element.name)\r\n                        .some(name => isOuterVariableInDestructing(name, variable.scope));\r\n\r\n                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);\r\n                }\r\n\r\n                if (hasOuterVariables || hasNonIdentifiers) {\r\n                    return null;\r\n                }\r\n\r\n            }\r\n\r\n            writer = reference;\r\n\r\n        } else if (reference.isRead() && writer === null) {\r\n            if (ignoreReadBeforeAssign) {\r\n                return null;\r\n            }\r\n            isReadBeforeInit = true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * If the assignment is from a different scope, ignore it.\r\n     * If the assignment cannot change to a declaration, ignore it.\r\n     */\r\n    const shouldBeConst = (\r\n        writer !== null &&\r\n        writer.from === variable.scope &&\r\n        canBecomeVariableDeclaration(writer.identifier)\r\n    );\r\n\r\n    if (!shouldBeConst) {\r\n        return null;\r\n    }\r\n\r\n    if (isReadBeforeInit) {\r\n        return variable.defs[0].name;\r\n    }\r\n\r\n    return writer.identifier;\r\n}\r\n\r\n/**\r\n * Groups by the VariableDeclarator/AssignmentExpression node that each\r\n * reference of given variables belongs to.\r\n * This is used to detect a mix of reassigned and never reassigned in a\r\n * destructuring.\r\n * @param {eslint-scope.Variable[]} variables Variables to group by destructuring.\r\n * @param {boolean} ignoreReadBeforeAssign\r\n *      The value of `ignoreReadBeforeAssign` option.\r\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\r\n */\r\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\r\n    const identifierMap = new Map();\r\n\r\n    for (let i = 0; i < variables.length; ++i) {\r\n        const variable = variables[i];\r\n        const references = variable.references;\r\n        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\r\n        let prevId = null;\r\n\r\n        for (let j = 0; j < references.length; ++j) {\r\n            const reference = references[j];\r\n            const id = reference.identifier;\r\n\r\n            /*\r\n             * Avoid counting a reference twice or more for default values of\r\n             * destructuring.\r\n             */\r\n            if (id === prevId) {\r\n                continue;\r\n            }\r\n            prevId = id;\r\n\r\n            // Add the identifier node into the destructuring group.\r\n            const group = getDestructuringHost(reference);\r\n\r\n            if (group) {\r\n                if (identifierMap.has(group)) {\r\n                    identifierMap.get(group).push(identifier);\r\n                } else {\r\n                    identifierMap.set(group, [identifier]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return identifierMap;\r\n}\r\n\r\n/**\r\n * Finds the nearest parent of node with a given type.\r\n * @param {ASTNode} node The node to search from.\r\n * @param {string} type The type field of the parent node.\r\n * @param {Function} shouldStop A predicate that returns true if the traversal should stop, and false otherwise.\r\n * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.\r\n */\r\nfunction findUp(node, type, shouldStop) {\r\n    if (!node || shouldStop(node)) {\r\n        return null;\r\n    }\r\n    if (node.type === type) {\r\n        return node;\r\n    }\r\n    return findUp(node.parent, type, shouldStop);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-const\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    destructuring: { enum: [\"any\", \"all\"], default: \"any\" },\r\n                    ignoreReadBeforeAssign: { type: \"boolean\", default: false }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            useConst: \"'{{name}}' is never reassigned. Use 'const' instead.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const sourceCode = context.getSourceCode();\r\n        const shouldMatchAnyDestructuredVariable = options.destructuring !== \"all\";\r\n        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\r\n        const variables = [];\r\n        let reportCount = 0;\r\n        let checkedId = null;\r\n        let checkedName = \"\";\r\n\r\n\r\n        /**\r\n         * Reports given identifier nodes if all of the nodes should be declared\r\n         * as const.\r\n         *\r\n         * The argument 'nodes' is an array of Identifier nodes.\r\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\r\n         * nullable. In simple declaration or assignment cases, the length of\r\n         * the array is 1. In destructuring cases, the length of the array can\r\n         * be 2 or more.\r\n         * @param {(eslint-scope.Reference|null)[]} nodes\r\n         *      References which are grouped by destructuring to report.\r\n         * @returns {void}\r\n         */\r\n        function checkGroup(nodes) {\r\n            const nodesToReport = nodes.filter(Boolean);\r\n\r\n            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {\r\n                const varDeclParent = findUp(nodes[0], \"VariableDeclaration\", parentNode => parentNode.type.endsWith(\"Statement\"));\r\n                const isVarDecParentNull = varDeclParent === null;\r\n\r\n                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {\r\n                    const firstDeclaration = varDeclParent.declarations[0];\r\n\r\n                    if (firstDeclaration.init) {\r\n                        const firstDecParent = firstDeclaration.init.parent;\r\n\r\n                        /*\r\n                         * First we check the declaration type and then depending on\r\n                         * if the type is a \"VariableDeclarator\" or its an \"ObjectPattern\"\r\n                         * we compare the name and id from the first identifier, if the names are different\r\n                         * we assign the new name, id and reset the count of reportCount and nodeCount in\r\n                         * order to check each block for the number of reported errors and base our fix\r\n                         * based on comparing nodes.length and nodesToReport.length.\r\n                         */\r\n\r\n                        if (firstDecParent.type === \"VariableDeclarator\") {\r\n\r\n                            if (firstDecParent.id.name !== checkedName) {\r\n                                checkedName = firstDecParent.id.name;\r\n                                reportCount = 0;\r\n                            }\r\n\r\n                            if (firstDecParent.id.type === \"ObjectPattern\") {\r\n                                if (firstDecParent.init.name !== checkedName) {\r\n                                    checkedName = firstDecParent.init.name;\r\n                                    reportCount = 0;\r\n                                }\r\n                            }\r\n\r\n                            if (firstDecParent.id !== checkedId) {\r\n                                checkedId = firstDecParent.id;\r\n                                reportCount = 0;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let shouldFix = varDeclParent &&\r\n\r\n                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)\r\n                    (varDeclParent.parent.type === \"ForInStatement\" || varDeclParent.parent.type === \"ForOfStatement\" ||\r\n                        varDeclParent.declarations.every(declaration => declaration.init)) &&\r\n\r\n                    /*\r\n                     * If options.destructuring is \"all\", then this warning will not occur unless\r\n                     * every assignment in the destructuring should be const. In that case, it's safe\r\n                     * to apply the fix.\r\n                     */\r\n                    nodesToReport.length === nodes.length;\r\n\r\n                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {\r\n\r\n                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {\r\n\r\n                        /*\r\n                         * Add nodesToReport.length to a count, then comparing the count to the length\r\n                         * of the declarations in the current block.\r\n                         */\r\n\r\n                        reportCount += nodesToReport.length;\r\n\r\n                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);\r\n                    }\r\n                }\r\n\r\n                nodesToReport.forEach(node => {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"useConst\",\r\n                        data: node,\r\n                        fix: shouldFix\r\n                            ? fixer => {\r\n                                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind);\r\n\r\n                                /**\r\n                                 * Extend the replacement range to the whole declaration,\r\n                                 * in order to prevent other fixes in the same pass\r\n                                 * https://github.com/eslint/eslint/issues/13899\r\n                                 */\r\n                                return new FixTracker(fixer, sourceCode)\r\n                                    .retainRange(varDeclParent.range)\r\n                                    .replaceTextRange(letKeywordToken.range, \"const\");\r\n                            }\r\n                            : null\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\"() {\r\n                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);\r\n            },\r\n\r\n            VariableDeclaration(node) {\r\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\r\n                    variables.push(...context.getDeclaredVariables(node));\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}