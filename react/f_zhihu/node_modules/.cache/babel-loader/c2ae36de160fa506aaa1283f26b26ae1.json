{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of comma operator\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst DEFAULT_OPTIONS = {\n  allowInParentheses: true\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow comma operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-sequences\"\n    },\n    schema: [{\n      properties: {\n        allowInParentheses: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedCommaExpression: \"Unexpected use of comma operator.\"\n    }\n  },\n\n  create(context) {\n    const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Parts of the grammar that are required to have parens.\r\n     */\n\n    const parenthesized = {\n      DoWhileStatement: \"test\",\n      IfStatement: \"test\",\n      SwitchStatement: \"discriminant\",\n      WhileStatement: \"test\",\n      WithStatement: \"object\",\n      ArrowFunctionExpression: \"body\"\n      /*\r\n       * Omitting CallExpression - commas are parsed as argument separators\r\n       * Omitting NewExpression - commas are parsed as argument separators\r\n       * Omitting ForInStatement - parts aren't individually parenthesised\r\n       * Omitting ForStatement - parts aren't individually parenthesised\r\n       */\n\n    };\n    /**\r\n     * Determines whether a node is required by the grammar to be wrapped in\r\n     * parens, e.g. the test of an if statement.\r\n     * @param {ASTNode} node The AST node\r\n     * @returns {boolean} True if parens around node belong to parent node.\r\n     */\n\n    function requiresExtraParens(node) {\n      return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];\n    }\n    /**\r\n     * Check if a node is wrapped in parens.\r\n     * @param {ASTNode} node The AST node\r\n     * @returns {boolean} True if the node has a paren on each side.\r\n     */\n\n\n    function isParenthesised(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\r\n     * Check if a node is wrapped in two levels of parens.\r\n     * @param {ASTNode} node The AST node\r\n     * @returns {boolean} True if two parens surround the node on each side.\r\n     */\n\n\n    function isParenthesisedTwice(node) {\n      const previousToken = sourceCode.getTokenBefore(node, 1),\n            nextToken = sourceCode.getTokenAfter(node, 1);\n      return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\n    }\n\n    return {\n      SequenceExpression(node) {\n        // Always allow sequences in for statement update\n        if (node.parent.type === \"ForStatement\" && (node === node.parent.init || node === node.parent.update)) {\n          return;\n        } // Wrapping a sequence in extra parens indicates intent\n\n\n        if (options.allowInParentheses) {\n          if (requiresExtraParens(node)) {\n            if (isParenthesisedTwice(node)) {\n              return;\n            }\n          } else {\n            if (isParenthesised(node)) {\n              return;\n            }\n          }\n        }\n\n        const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\n        context.report({\n          node,\n          loc: firstCommaToken.loc,\n          messageId: \"unexpectedCommaExpression\"\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-sequences.js"],"names":["astUtils","require","DEFAULT_OPTIONS","allowInParentheses","module","exports","meta","type","docs","description","recommended","url","schema","properties","default","additionalProperties","messages","unexpectedCommaExpression","create","context","options","Object","assign","sourceCode","getSourceCode","parenthesized","DoWhileStatement","IfStatement","SwitchStatement","WhileStatement","WithStatement","ArrowFunctionExpression","requiresExtraParens","node","parent","isParenthesised","isParenthesisedTwice","previousToken","getTokenBefore","nextToken","getTokenAfter","isOpeningParenToken","range","isClosingParenToken","SequenceExpression","init","update","firstCommaToken","expressions","isCommaToken","report","loc","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of comma operator\r\n * @author Brandon Mills\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst DEFAULT_OPTIONS = {\r\n    allowInParentheses: true\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow comma operators\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-sequences\"\r\n        },\r\n\r\n        schema: [{\r\n            properties: {\r\n                allowInParentheses: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            unexpectedCommaExpression: \"Unexpected use of comma operator.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = Object.assign({}, DEFAULT_OPTIONS, context.options[0]);\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Parts of the grammar that are required to have parens.\r\n         */\r\n        const parenthesized = {\r\n            DoWhileStatement: \"test\",\r\n            IfStatement: \"test\",\r\n            SwitchStatement: \"discriminant\",\r\n            WhileStatement: \"test\",\r\n            WithStatement: \"object\",\r\n            ArrowFunctionExpression: \"body\"\r\n\r\n            /*\r\n             * Omitting CallExpression - commas are parsed as argument separators\r\n             * Omitting NewExpression - commas are parsed as argument separators\r\n             * Omitting ForInStatement - parts aren't individually parenthesised\r\n             * Omitting ForStatement - parts aren't individually parenthesised\r\n             */\r\n        };\r\n\r\n        /**\r\n         * Determines whether a node is required by the grammar to be wrapped in\r\n         * parens, e.g. the test of an if statement.\r\n         * @param {ASTNode} node The AST node\r\n         * @returns {boolean} True if parens around node belong to parent node.\r\n         */\r\n        function requiresExtraParens(node) {\r\n            return node.parent && parenthesized[node.parent.type] &&\r\n                    node === node.parent[parenthesized[node.parent.type]];\r\n        }\r\n\r\n        /**\r\n         * Check if a node is wrapped in parens.\r\n         * @param {ASTNode} node The AST node\r\n         * @returns {boolean} True if the node has a paren on each side.\r\n         */\r\n        function isParenthesised(node) {\r\n            return astUtils.isParenthesised(sourceCode, node);\r\n        }\r\n\r\n        /**\r\n         * Check if a node is wrapped in two levels of parens.\r\n         * @param {ASTNode} node The AST node\r\n         * @returns {boolean} True if two parens surround the node on each side.\r\n         */\r\n        function isParenthesisedTwice(node) {\r\n            const previousToken = sourceCode.getTokenBefore(node, 1),\r\n                nextToken = sourceCode.getTokenAfter(node, 1);\r\n\r\n            return isParenthesised(node) && previousToken && nextToken &&\r\n                astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&\r\n                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];\r\n        }\r\n\r\n        return {\r\n            SequenceExpression(node) {\r\n\r\n                // Always allow sequences in for statement update\r\n                if (node.parent.type === \"ForStatement\" &&\r\n                        (node === node.parent.init || node === node.parent.update)) {\r\n                    return;\r\n                }\r\n\r\n                // Wrapping a sequence in extra parens indicates intent\r\n                if (options.allowInParentheses) {\r\n                    if (requiresExtraParens(node)) {\r\n                        if (isParenthesisedTwice(node)) {\r\n                            return;\r\n                        }\r\n                    } else {\r\n                        if (isParenthesised(node)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);\r\n\r\n                context.report({ node, loc: firstCommaToken.loc, messageId: \"unexpectedCommaExpression\" });\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}