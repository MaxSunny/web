{"ast":null,"code":"/**\r\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\r\n * @author Joel Feenstra\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * @typedef {Object} ConstructorInfo\r\n * @property {ConstructorInfo | null} upper Info about the constructor that encloses this constructor.\r\n * @property {boolean} hasSuperCall The flag about having `super()` expressions.\r\n */\n\n/**\r\n * Checks whether or not a given variable declarator has the initializer.\r\n * @param {ASTNode} node A VariableDeclarator node to check.\r\n * @returns {boolean} `true` if the node has the initializer.\r\n */\n\nfunction isInitialized(node) {\n  return Boolean(node.init);\n}\n/**\r\n * Checks whether or not a given code path segment is unreachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is unreachable.\r\n */\n\n\nfunction isUnreachable(segment) {\n  return !segment.reachable;\n}\n/**\r\n * The class to distinguish consecutive unreachable statements.\r\n */\n\n\nclass ConsecutiveRange {\n  constructor(sourceCode) {\n    this.sourceCode = sourceCode;\n    this.startNode = null;\n    this.endNode = null;\n  }\n  /**\r\n   * The location object of this range.\r\n   * @type {Object}\r\n   */\n\n\n  get location() {\n    return {\n      start: this.startNode.loc.start,\n      end: this.endNode.loc.end\n    };\n  }\n  /**\r\n   * `true` if this range is empty.\r\n   * @type {boolean}\r\n   */\n\n\n  get isEmpty() {\n    return !(this.startNode && this.endNode);\n  }\n  /**\r\n   * Checks whether the given node is inside of this range.\r\n   * @param {ASTNode|Token} node The node to check.\r\n   * @returns {boolean} `true` if the node is inside of this range.\r\n   */\n\n\n  contains(node) {\n    return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];\n  }\n  /**\r\n   * Checks whether the given node is consecutive to this range.\r\n   * @param {ASTNode} node The node to check.\r\n   * @returns {boolean} `true` if the node is consecutive to this range.\r\n   */\n\n\n  isConsecutive(node) {\n    return this.contains(this.sourceCode.getTokenBefore(node));\n  }\n  /**\r\n   * Merges the given node to this range.\r\n   * @param {ASTNode} node The node to merge.\r\n   * @returns {void}\r\n   */\n\n\n  merge(node) {\n    this.endNode = node;\n  }\n  /**\r\n   * Resets this range by the given node or null.\r\n   * @param {ASTNode|null} node The node to reset, or null.\r\n   * @returns {void}\r\n   */\n\n\n  reset(node) {\n    this.startNode = this.endNode = node;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unreachable\"\n    },\n    schema: [],\n    messages: {\n      unreachableCode: \"Unreachable code.\"\n    }\n  },\n\n  create(context) {\n    let currentCodePath = null;\n    /** @type {ConstructorInfo | null} */\n\n    let constructorInfo = null;\n    /** @type {ConsecutiveRange} */\n\n    const range = new ConsecutiveRange(context.getSourceCode());\n    /**\r\n     * Reports a given node if it's unreachable.\r\n     * @param {ASTNode} node A statement node to report.\r\n     * @returns {void}\r\n     */\n\n    function reportIfUnreachable(node) {\n      let nextNode = null;\n\n      if (node && (node.type === \"PropertyDefinition\" || currentCodePath.currentSegments.every(isUnreachable))) {\n        // Store this statement to distinguish consecutive statements.\n        if (range.isEmpty) {\n          range.reset(node);\n          return;\n        } // Skip if this statement is inside of the current range.\n\n\n        if (range.contains(node)) {\n          return;\n        } // Merge if this statement is consecutive to the current range.\n\n\n        if (range.isConsecutive(node)) {\n          range.merge(node);\n          return;\n        }\n\n        nextNode = node;\n      }\n      /*\r\n       * Report the current range since this statement is reachable or is\r\n       * not consecutive to the current range.\r\n       */\n\n\n      if (!range.isEmpty) {\n        context.report({\n          messageId: \"unreachableCode\",\n          loc: range.location,\n          node: range.startNode\n        });\n      } // Update the current range.\n\n\n      range.reset(nextNode);\n    }\n\n    return {\n      // Manages the current code path.\n      onCodePathStart(codePath) {\n        currentCodePath = codePath;\n      },\n\n      onCodePathEnd() {\n        currentCodePath = currentCodePath.upper;\n      },\n\n      // Registers for all statement nodes (excludes FunctionDeclaration).\n      BlockStatement: reportIfUnreachable,\n      BreakStatement: reportIfUnreachable,\n      ClassDeclaration: reportIfUnreachable,\n      ContinueStatement: reportIfUnreachable,\n      DebuggerStatement: reportIfUnreachable,\n      DoWhileStatement: reportIfUnreachable,\n      ExpressionStatement: reportIfUnreachable,\n      ForInStatement: reportIfUnreachable,\n      ForOfStatement: reportIfUnreachable,\n      ForStatement: reportIfUnreachable,\n      IfStatement: reportIfUnreachable,\n      ImportDeclaration: reportIfUnreachable,\n      LabeledStatement: reportIfUnreachable,\n      ReturnStatement: reportIfUnreachable,\n      SwitchStatement: reportIfUnreachable,\n      ThrowStatement: reportIfUnreachable,\n      TryStatement: reportIfUnreachable,\n\n      VariableDeclaration(node) {\n        if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\n          reportIfUnreachable(node);\n        }\n      },\n\n      WhileStatement: reportIfUnreachable,\n      WithStatement: reportIfUnreachable,\n      ExportNamedDeclaration: reportIfUnreachable,\n      ExportDefaultDeclaration: reportIfUnreachable,\n      ExportAllDeclaration: reportIfUnreachable,\n\n      \"Program:exit\"() {\n        reportIfUnreachable();\n      },\n\n      /*\r\n       * Instance fields defined in a subclass are never created if the constructor of the subclass\r\n       * doesn't call `super()`, so their definitions are unreachable code.\r\n       */\n      \"MethodDefinition[kind='constructor']\"() {\n        constructorInfo = {\n          upper: constructorInfo,\n          hasSuperCall: false\n        };\n      },\n\n      \"MethodDefinition[kind='constructor']:exit\"(node) {\n        const {\n          hasSuperCall\n        } = constructorInfo;\n        constructorInfo = constructorInfo.upper; // skip typescript constructors without the body\n\n        if (!node.value.body) {\n          return;\n        }\n\n        const classDefinition = node.parent.parent;\n\n        if (classDefinition.superClass && !hasSuperCall) {\n          for (const element of classDefinition.body.body) {\n            if (element.type === \"PropertyDefinition\" && !element.static) {\n              reportIfUnreachable(element);\n            }\n          }\n        }\n      },\n\n      \"CallExpression > Super.callee\"() {\n        if (constructorInfo) {\n          constructorInfo.hasSuperCall = true;\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unreachable.js"],"names":["isInitialized","node","Boolean","init","isUnreachable","segment","reachable","ConsecutiveRange","constructor","sourceCode","startNode","endNode","location","start","loc","end","isEmpty","contains","range","isConsecutive","getTokenBefore","merge","reset","module","exports","meta","type","docs","description","recommended","url","schema","messages","unreachableCode","create","context","currentCodePath","constructorInfo","getSourceCode","reportIfUnreachable","nextNode","currentSegments","every","report","messageId","onCodePathStart","codePath","onCodePathEnd","upper","BlockStatement","BreakStatement","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","ReturnStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","kind","declarations","some","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","hasSuperCall","value","body","classDefinition","parent","superClass","element","static"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Checks for unreachable code due to return, throws, break, and continue.\r\n * @author Joel Feenstra\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * @typedef {Object} ConstructorInfo\r\n * @property {ConstructorInfo | null} upper Info about the constructor that encloses this constructor.\r\n * @property {boolean} hasSuperCall The flag about having `super()` expressions.\r\n */\r\n\r\n/**\r\n * Checks whether or not a given variable declarator has the initializer.\r\n * @param {ASTNode} node A VariableDeclarator node to check.\r\n * @returns {boolean} `true` if the node has the initializer.\r\n */\r\nfunction isInitialized(node) {\r\n    return Boolean(node.init);\r\n}\r\n\r\n/**\r\n * Checks whether or not a given code path segment is unreachable.\r\n * @param {CodePathSegment} segment A CodePathSegment to check.\r\n * @returns {boolean} `true` if the segment is unreachable.\r\n */\r\nfunction isUnreachable(segment) {\r\n    return !segment.reachable;\r\n}\r\n\r\n/**\r\n * The class to distinguish consecutive unreachable statements.\r\n */\r\nclass ConsecutiveRange {\r\n    constructor(sourceCode) {\r\n        this.sourceCode = sourceCode;\r\n        this.startNode = null;\r\n        this.endNode = null;\r\n    }\r\n\r\n    /**\r\n     * The location object of this range.\r\n     * @type {Object}\r\n     */\r\n    get location() {\r\n        return {\r\n            start: this.startNode.loc.start,\r\n            end: this.endNode.loc.end\r\n        };\r\n    }\r\n\r\n    /**\r\n     * `true` if this range is empty.\r\n     * @type {boolean}\r\n     */\r\n    get isEmpty() {\r\n        return !(this.startNode && this.endNode);\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given node is inside of this range.\r\n     * @param {ASTNode|Token} node The node to check.\r\n     * @returns {boolean} `true` if the node is inside of this range.\r\n     */\r\n    contains(node) {\r\n        return (\r\n            node.range[0] >= this.startNode.range[0] &&\r\n            node.range[1] <= this.endNode.range[1]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Checks whether the given node is consecutive to this range.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node is consecutive to this range.\r\n     */\r\n    isConsecutive(node) {\r\n        return this.contains(this.sourceCode.getTokenBefore(node));\r\n    }\r\n\r\n    /**\r\n     * Merges the given node to this range.\r\n     * @param {ASTNode} node The node to merge.\r\n     * @returns {void}\r\n     */\r\n    merge(node) {\r\n        this.endNode = node;\r\n    }\r\n\r\n    /**\r\n     * Resets this range by the given node or null.\r\n     * @param {ASTNode|null} node The node to reset, or null.\r\n     * @returns {void}\r\n     */\r\n    reset(node) {\r\n        this.startNode = this.endNode = node;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow unreachable code after `return`, `throw`, `continue`, and `break` statements\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-unreachable\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unreachableCode: \"Unreachable code.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        let currentCodePath = null;\r\n\r\n        /** @type {ConstructorInfo | null} */\r\n        let constructorInfo = null;\r\n\r\n        /** @type {ConsecutiveRange} */\r\n        const range = new ConsecutiveRange(context.getSourceCode());\r\n\r\n        /**\r\n         * Reports a given node if it's unreachable.\r\n         * @param {ASTNode} node A statement node to report.\r\n         * @returns {void}\r\n         */\r\n        function reportIfUnreachable(node) {\r\n            let nextNode = null;\r\n\r\n            if (node && (node.type === \"PropertyDefinition\" || currentCodePath.currentSegments.every(isUnreachable))) {\r\n\r\n                // Store this statement to distinguish consecutive statements.\r\n                if (range.isEmpty) {\r\n                    range.reset(node);\r\n                    return;\r\n                }\r\n\r\n                // Skip if this statement is inside of the current range.\r\n                if (range.contains(node)) {\r\n                    return;\r\n                }\r\n\r\n                // Merge if this statement is consecutive to the current range.\r\n                if (range.isConsecutive(node)) {\r\n                    range.merge(node);\r\n                    return;\r\n                }\r\n\r\n                nextNode = node;\r\n            }\r\n\r\n            /*\r\n             * Report the current range since this statement is reachable or is\r\n             * not consecutive to the current range.\r\n             */\r\n            if (!range.isEmpty) {\r\n                context.report({\r\n                    messageId: \"unreachableCode\",\r\n                    loc: range.location,\r\n                    node: range.startNode\r\n                });\r\n            }\r\n\r\n            // Update the current range.\r\n            range.reset(nextNode);\r\n        }\r\n\r\n        return {\r\n\r\n            // Manages the current code path.\r\n            onCodePathStart(codePath) {\r\n                currentCodePath = codePath;\r\n            },\r\n\r\n            onCodePathEnd() {\r\n                currentCodePath = currentCodePath.upper;\r\n            },\r\n\r\n            // Registers for all statement nodes (excludes FunctionDeclaration).\r\n            BlockStatement: reportIfUnreachable,\r\n            BreakStatement: reportIfUnreachable,\r\n            ClassDeclaration: reportIfUnreachable,\r\n            ContinueStatement: reportIfUnreachable,\r\n            DebuggerStatement: reportIfUnreachable,\r\n            DoWhileStatement: reportIfUnreachable,\r\n            ExpressionStatement: reportIfUnreachable,\r\n            ForInStatement: reportIfUnreachable,\r\n            ForOfStatement: reportIfUnreachable,\r\n            ForStatement: reportIfUnreachable,\r\n            IfStatement: reportIfUnreachable,\r\n            ImportDeclaration: reportIfUnreachable,\r\n            LabeledStatement: reportIfUnreachable,\r\n            ReturnStatement: reportIfUnreachable,\r\n            SwitchStatement: reportIfUnreachable,\r\n            ThrowStatement: reportIfUnreachable,\r\n            TryStatement: reportIfUnreachable,\r\n\r\n            VariableDeclaration(node) {\r\n                if (node.kind !== \"var\" || node.declarations.some(isInitialized)) {\r\n                    reportIfUnreachable(node);\r\n                }\r\n            },\r\n\r\n            WhileStatement: reportIfUnreachable,\r\n            WithStatement: reportIfUnreachable,\r\n            ExportNamedDeclaration: reportIfUnreachable,\r\n            ExportDefaultDeclaration: reportIfUnreachable,\r\n            ExportAllDeclaration: reportIfUnreachable,\r\n\r\n            \"Program:exit\"() {\r\n                reportIfUnreachable();\r\n            },\r\n\r\n            /*\r\n             * Instance fields defined in a subclass are never created if the constructor of the subclass\r\n             * doesn't call `super()`, so their definitions are unreachable code.\r\n             */\r\n            \"MethodDefinition[kind='constructor']\"() {\r\n                constructorInfo = {\r\n                    upper: constructorInfo,\r\n                    hasSuperCall: false\r\n                };\r\n            },\r\n            \"MethodDefinition[kind='constructor']:exit\"(node) {\r\n                const { hasSuperCall } = constructorInfo;\r\n\r\n                constructorInfo = constructorInfo.upper;\r\n\r\n                // skip typescript constructors without the body\r\n                if (!node.value.body) {\r\n                    return;\r\n                }\r\n\r\n                const classDefinition = node.parent.parent;\r\n\r\n                if (classDefinition.superClass && !hasSuperCall) {\r\n                    for (const element of classDefinition.body.body) {\r\n                        if (element.type === \"PropertyDefinition\" && !element.static) {\r\n                            reportIfUnreachable(element);\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            \"CallExpression > Super.callee\"() {\r\n                if (constructorInfo) {\r\n                    constructorInfo.hasSuperCall = true;\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}