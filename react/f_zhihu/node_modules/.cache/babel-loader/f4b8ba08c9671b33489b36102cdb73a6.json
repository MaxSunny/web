{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst eslintUtils = require(\"eslint-utils\"); //----------------------------------------------------------------------\n// Helpers\n//----------------------------------------------------------------------\n\n/**\r\n * Check if the given node is callee of a `NewExpression` node\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} True if the node is callee of a `NewExpression` node\r\n * @private\r\n */\n\n\nfunction isCalleeOfNewExpression(node) {\n  const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  return maybeCallee.parent.type === \"NewExpression\" && maybeCallee.parent.callee === maybeCallee;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require parentheses around immediate `function` invocations\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/wrap-iife\"\n    },\n    schema: [{\n      enum: [\"outside\", \"inside\", \"any\"]\n    }, {\n      type: \"object\",\n      properties: {\n        functionPrototypeMethods: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\n      wrapExpression: \"Wrap only the function expression in parens.\",\n      moveInvocation: \"Move the invocation into the parens that contain the function.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"outside\";\n    const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {boolean} True if it is wrapped in any parens\r\n     * @private\r\n     */\n\n    function isWrappedInAnyParens(node) {\n      return astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\r\n     * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {boolean} True if it is wrapped in grouping parens\r\n     * @private\r\n     */\n\n\n    function isWrappedInGroupingParens(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n    /**\r\n     * Get the function node from an IIFE\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\r\n     */\n\n\n    function getFunctionNodeFromIIFE(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"FunctionExpression\") {\n        return callee;\n      }\n\n      if (includeFunctionPrototypeMethods && callee.type === \"MemberExpression\" && callee.object.type === \"FunctionExpression\" && (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")) {\n        return callee.object;\n      }\n\n      return null;\n    }\n\n    return {\n      CallExpression(node) {\n        const innerNode = getFunctionNodeFromIIFE(node);\n\n        if (!innerNode) {\n          return;\n        }\n\n        const isCallExpressionWrapped = isWrappedInAnyParens(node),\n              isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\n\n        if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapInvocation\",\n\n            fix(fixer) {\n              const nodeToSurround = style === \"inside\" ? innerNode : node;\n              return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\n            }\n\n          });\n        } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"wrapExpression\",\n\n            fix(fixer) {\n              // The outer call expression will always be wrapped at this point.\n              if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\n                /*\r\n                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\r\n                 * Replace the range between the end of the function expression and the end of the call expression.\r\n                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\r\n                 */\n                const parenAfter = sourceCode.getTokenAfter(node);\n                return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);\n              }\n              /*\r\n               * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\r\n               * These parens cannot be removed, so just parenthesize the function expression.\r\n               */\n\n\n              return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\n            }\n\n          });\n        } else if (style === \"outside\" && !isCallExpressionWrapped) {\n          context.report({\n            node,\n            messageId: \"moveInvocation\",\n\n            fix(fixer) {\n              /*\r\n               * The inner function expression will always be wrapped at this point.\r\n               * It's only necessary to replace the range between the end of the function expression\r\n               * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\r\n               * should get replaced with `(bar))`.\r\n               */\n              const parenAfter = sourceCode.getTokenAfter(innerNode);\n              return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/wrap-iife.js"],"names":["astUtils","require","eslintUtils","isCalleeOfNewExpression","node","maybeCallee","parent","type","callee","module","exports","meta","docs","description","recommended","url","schema","enum","properties","functionPrototypeMethods","default","additionalProperties","fixable","messages","wrapInvocation","wrapExpression","moveInvocation","create","context","style","options","includeFunctionPrototypeMethods","sourceCode","getSourceCode","isWrappedInAnyParens","isParenthesised","isWrappedInGroupingParens","isParenthesized","getFunctionNodeFromIIFE","skipChainExpression","object","getStaticPropertyName","CallExpression","innerNode","isCallExpressionWrapped","isFunctionExpressionWrapped","report","messageId","fix","fixer","nodeToSurround","replaceText","getText","parenAfter","getTokenAfter","replaceTextRange","range","slice"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst eslintUtils = require(\"eslint-utils\");\r\n\r\n//----------------------------------------------------------------------\r\n// Helpers\r\n//----------------------------------------------------------------------\r\n\r\n/**\r\n * Check if the given node is callee of a `NewExpression` node\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} True if the node is callee of a `NewExpression` node\r\n * @private\r\n */\r\nfunction isCalleeOfNewExpression(node) {\r\n    const maybeCallee = node.parent.type === \"ChainExpression\"\r\n        ? node.parent\r\n        : node;\r\n\r\n    return (\r\n        maybeCallee.parent.type === \"NewExpression\" &&\r\n        maybeCallee.parent.callee === maybeCallee\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require parentheses around immediate `function` invocations\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/wrap-iife\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"outside\", \"inside\", \"any\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    functionPrototypeMethods: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            wrapInvocation: \"Wrap an immediate function invocation in parentheses.\",\r\n            wrapExpression: \"Wrap only the function expression in parens.\",\r\n            moveInvocation: \"Move the invocation into the parens that contain the function.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const style = context.options[0] || \"outside\";\r\n        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Check if the node is wrapped in any (). All parens count: grouping parens and parens for constructs such as if()\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {boolean} True if it is wrapped in any parens\r\n         * @private\r\n         */\r\n        function isWrappedInAnyParens(node) {\r\n            return astUtils.isParenthesised(sourceCode, node);\r\n        }\r\n\r\n        /**\r\n         * Check if the node is wrapped in grouping (). Parens for constructs such as if() don't count\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {boolean} True if it is wrapped in grouping parens\r\n         * @private\r\n         */\r\n        function isWrappedInGroupingParens(node) {\r\n            return eslintUtils.isParenthesized(1, node, sourceCode);\r\n        }\r\n\r\n        /**\r\n         * Get the function node from an IIFE\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist\r\n         */\r\n        function getFunctionNodeFromIIFE(node) {\r\n            const callee = astUtils.skipChainExpression(node.callee);\r\n\r\n            if (callee.type === \"FunctionExpression\") {\r\n                return callee;\r\n            }\r\n\r\n            if (includeFunctionPrototypeMethods &&\r\n                callee.type === \"MemberExpression\" &&\r\n                callee.object.type === \"FunctionExpression\" &&\r\n                (astUtils.getStaticPropertyName(callee) === \"call\" || astUtils.getStaticPropertyName(callee) === \"apply\")\r\n            ) {\r\n                return callee.object;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n\r\n        return {\r\n            CallExpression(node) {\r\n                const innerNode = getFunctionNodeFromIIFE(node);\r\n\r\n                if (!innerNode) {\r\n                    return;\r\n                }\r\n\r\n                const isCallExpressionWrapped = isWrappedInAnyParens(node),\r\n                    isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);\r\n\r\n                if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"wrapInvocation\",\r\n                        fix(fixer) {\r\n                            const nodeToSurround = style === \"inside\" ? innerNode : node;\r\n\r\n                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);\r\n                        }\r\n                    });\r\n                } else if (style === \"inside\" && !isFunctionExpressionWrapped) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"wrapExpression\",\r\n                        fix(fixer) {\r\n\r\n                            // The outer call expression will always be wrapped at this point.\r\n\r\n                            if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {\r\n\r\n                                /*\r\n                                 * Parenthesize the function expression and remove unnecessary grouping parens around the call expression.\r\n                                 * Replace the range between the end of the function expression and the end of the call expression.\r\n                                 * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.\r\n                                 */\r\n\r\n                                const parenAfter = sourceCode.getTokenAfter(node);\r\n\r\n                                return fixer.replaceTextRange(\r\n                                    [innerNode.range[1], parenAfter.range[1]],\r\n                                    `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`\r\n                                );\r\n                            }\r\n\r\n                            /*\r\n                             * Call expression is wrapped in mandatory parens such as if(), or in necessary grouping parens.\r\n                             * These parens cannot be removed, so just parenthesize the function expression.\r\n                             */\r\n\r\n                            return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);\r\n                        }\r\n                    });\r\n                } else if (style === \"outside\" && !isCallExpressionWrapped) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"moveInvocation\",\r\n                        fix(fixer) {\r\n\r\n                            /*\r\n                             * The inner function expression will always be wrapped at this point.\r\n                             * It's only necessary to replace the range between the end of the function expression\r\n                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`\r\n                             * should get replaced with `(bar))`.\r\n                             */\r\n                            const parenAfter = sourceCode.getTokenAfter(innerNode);\r\n\r\n                            return fixer.replaceTextRange(\r\n                                [parenAfter.range[0], node.range[1]],\r\n                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`\r\n                            );\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}