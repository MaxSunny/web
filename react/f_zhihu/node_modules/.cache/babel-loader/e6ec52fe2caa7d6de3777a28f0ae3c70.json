{"ast":null,"code":"/**\r\n * @fileoverview Validates spacing before and after semicolon\r\n * @author Mathias Schreck\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after semicolons\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: false\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\n      unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\n      missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\n      missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let requireSpaceBefore = false,\n        requireSpaceAfter = true;\n\n    if (typeof config === \"object\") {\n      requireSpaceBefore = config.before;\n      requireSpaceAfter = config.after;\n    }\n    /**\r\n     * Checks if a given token has leading whitespace.\r\n     * @param {Object} token The token to check.\r\n     * @returns {boolean} True if the given token has leading space, false if not.\r\n     */\n\n\n    function hasLeadingSpace(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n    }\n    /**\r\n     * Checks if a given token has trailing whitespace.\r\n     * @param {Object} token The token to check.\r\n     * @returns {boolean} True if the given token has trailing space, false if not.\r\n     */\n\n\n    function hasTrailingSpace(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n    }\n    /**\r\n     * Checks if the given token is the last token in its line.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} Whether or not the token is the last in its line.\r\n     */\n\n\n    function isLastTokenInCurrentLine(token) {\n      const tokenAfter = sourceCode.getTokenAfter(token);\n      return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n    }\n    /**\r\n     * Checks if the given token is the first token in its line\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} Whether or not the token is the first in its line.\r\n     */\n\n\n    function isFirstTokenInCurrentLine(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token);\n      return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n    }\n    /**\r\n     * Checks if the next token of a given token is a closing parenthesis.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\r\n     */\n\n\n    function isBeforeClosingParen(token) {\n      const nextToken = sourceCode.getTokenAfter(token);\n      return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);\n    }\n    /**\r\n     * Report location example :\r\n     *\r\n     * for unexpected space `before`\r\n     *\r\n     * var a = 'b'   ;\r\n     *            ^^^\r\n     *\r\n     * for unexpected space `after`\r\n     *\r\n     * var a = 'b';  c = 10;\r\n     *             ^^\r\n     *\r\n     * Reports if the given token has invalid spacing.\r\n     * @param {Token} token The semicolon token to check.\r\n     * @param {ASTNode} node The corresponding node of the token.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSemicolonSpacing(token, node) {\n      if (astUtils.isSemicolonToken(token)) {\n        if (hasLeadingSpace(token)) {\n          if (!requireSpaceBefore) {\n            const tokenBefore = sourceCode.getTokenBefore(token);\n            const loc = {\n              start: tokenBefore.loc.end,\n              end: token.loc.start\n            };\n            context.report({\n              node,\n              loc,\n              messageId: \"unexpectedWhitespaceBefore\",\n\n              fix(fixer) {\n                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n              }\n\n            });\n          }\n        } else {\n          if (requireSpaceBefore) {\n            const loc = token.loc;\n            context.report({\n              node,\n              loc,\n              messageId: \"missingWhitespaceBefore\",\n\n              fix(fixer) {\n                return fixer.insertTextBefore(token, \" \");\n              }\n\n            });\n          }\n        }\n\n        if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n          if (hasTrailingSpace(token)) {\n            if (!requireSpaceAfter) {\n              const tokenAfter = sourceCode.getTokenAfter(token);\n              const loc = {\n                start: token.loc.end,\n                end: tokenAfter.loc.start\n              };\n              context.report({\n                node,\n                loc,\n                messageId: \"unexpectedWhitespaceAfter\",\n\n                fix(fixer) {\n                  return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                }\n\n              });\n            }\n          } else {\n            if (requireSpaceAfter) {\n              const loc = token.loc;\n              context.report({\n                node,\n                loc,\n                messageId: \"missingWhitespaceAfter\",\n\n                fix(fixer) {\n                  return fixer.insertTextAfter(token, \" \");\n                }\n\n              });\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkNode(node) {\n      const token = sourceCode.getLastToken(node);\n      checkSemicolonSpacing(token, node);\n    }\n\n    return {\n      VariableDeclaration: checkNode,\n      ExpressionStatement: checkNode,\n      BreakStatement: checkNode,\n      ContinueStatement: checkNode,\n      DebuggerStatement: checkNode,\n      DoWhileStatement: checkNode,\n      ReturnStatement: checkNode,\n      ThrowStatement: checkNode,\n      ImportDeclaration: checkNode,\n      ExportNamedDeclaration: checkNode,\n      ExportAllDeclaration: checkNode,\n      ExportDefaultDeclaration: checkNode,\n\n      ForStatement(node) {\n        if (node.init) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n        }\n\n        if (node.test) {\n          checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n        }\n      },\n\n      PropertyDefinition: checkNode\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/semi-spacing.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","before","default","after","additionalProperties","messages","unexpectedWhitespaceBefore","unexpectedWhitespaceAfter","missingWhitespaceBefore","missingWhitespaceAfter","create","context","config","options","sourceCode","getSourceCode","requireSpaceBefore","requireSpaceAfter","hasLeadingSpace","token","tokenBefore","getTokenBefore","isTokenOnSameLine","isSpaceBetweenTokens","hasTrailingSpace","tokenAfter","getTokenAfter","isLastTokenInCurrentLine","isFirstTokenInCurrentLine","isBeforeClosingParen","nextToken","isClosingBraceToken","isClosingParenToken","checkSemicolonSpacing","node","isSemicolonToken","loc","start","end","report","messageId","fix","fixer","removeRange","range","insertTextBefore","insertTextAfter","checkNode","getLastToken","VariableDeclaration","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","DoWhileStatement","ReturnStatement","ThrowStatement","ImportDeclaration","ExportNamedDeclaration","ExportAllDeclaration","ExportDefaultDeclaration","ForStatement","init","test","PropertyDefinition"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Validates spacing before and after semicolon\r\n * @author Mathias Schreck\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing before and after semicolons\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/semi-spacing\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    before: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    after: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedWhitespaceBefore: \"Unexpected whitespace before semicolon.\",\r\n            unexpectedWhitespaceAfter: \"Unexpected whitespace after semicolon.\",\r\n            missingWhitespaceBefore: \"Missing whitespace before semicolon.\",\r\n            missingWhitespaceAfter: \"Missing whitespace after semicolon.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const config = context.options[0],\r\n            sourceCode = context.getSourceCode();\r\n        let requireSpaceBefore = false,\r\n            requireSpaceAfter = true;\r\n\r\n        if (typeof config === \"object\") {\r\n            requireSpaceBefore = config.before;\r\n            requireSpaceAfter = config.after;\r\n        }\r\n\r\n        /**\r\n         * Checks if a given token has leading whitespace.\r\n         * @param {Object} token The token to check.\r\n         * @returns {boolean} True if the given token has leading space, false if not.\r\n         */\r\n        function hasLeadingSpace(token) {\r\n            const tokenBefore = sourceCode.getTokenBefore(token);\r\n\r\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\r\n        }\r\n\r\n        /**\r\n         * Checks if a given token has trailing whitespace.\r\n         * @param {Object} token The token to check.\r\n         * @returns {boolean} True if the given token has trailing space, false if not.\r\n         */\r\n        function hasTrailingSpace(token) {\r\n            const tokenAfter = sourceCode.getTokenAfter(token);\r\n\r\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\r\n        }\r\n\r\n        /**\r\n         * Checks if the given token is the last token in its line.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} Whether or not the token is the last in its line.\r\n         */\r\n        function isLastTokenInCurrentLine(token) {\r\n            const tokenAfter = sourceCode.getTokenAfter(token);\r\n\r\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\r\n        }\r\n\r\n        /**\r\n         * Checks if the given token is the first token in its line\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} Whether or not the token is the first in its line.\r\n         */\r\n        function isFirstTokenInCurrentLine(token) {\r\n            const tokenBefore = sourceCode.getTokenBefore(token);\r\n\r\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\r\n        }\r\n\r\n        /**\r\n         * Checks if the next token of a given token is a closing parenthesis.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\r\n         */\r\n        function isBeforeClosingParen(token) {\r\n            const nextToken = sourceCode.getTokenAfter(token);\r\n\r\n            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));\r\n        }\r\n\r\n        /**\r\n         * Report location example :\r\n         *\r\n         * for unexpected space `before`\r\n         *\r\n         * var a = 'b'   ;\r\n         *            ^^^\r\n         *\r\n         * for unexpected space `after`\r\n         *\r\n         * var a = 'b';  c = 10;\r\n         *             ^^\r\n         *\r\n         * Reports if the given token has invalid spacing.\r\n         * @param {Token} token The semicolon token to check.\r\n         * @param {ASTNode} node The corresponding node of the token.\r\n         * @returns {void}\r\n         */\r\n        function checkSemicolonSpacing(token, node) {\r\n            if (astUtils.isSemicolonToken(token)) {\r\n                if (hasLeadingSpace(token)) {\r\n                    if (!requireSpaceBefore) {\r\n                        const tokenBefore = sourceCode.getTokenBefore(token);\r\n                        const loc = {\r\n                            start: tokenBefore.loc.end,\r\n                            end: token.loc.start\r\n                        };\r\n\r\n                        context.report({\r\n                            node,\r\n                            loc,\r\n                            messageId: \"unexpectedWhitespaceBefore\",\r\n                            fix(fixer) {\r\n\r\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\r\n                            }\r\n                        });\r\n                    }\r\n                } else {\r\n                    if (requireSpaceBefore) {\r\n                        const loc = token.loc;\r\n\r\n                        context.report({\r\n                            node,\r\n                            loc,\r\n                            messageId: \"missingWhitespaceBefore\",\r\n                            fix(fixer) {\r\n                                return fixer.insertTextBefore(token, \" \");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\r\n                    if (hasTrailingSpace(token)) {\r\n                        if (!requireSpaceAfter) {\r\n                            const tokenAfter = sourceCode.getTokenAfter(token);\r\n                            const loc = {\r\n                                start: token.loc.end,\r\n                                end: tokenAfter.loc.start\r\n                            };\r\n\r\n                            context.report({\r\n                                node,\r\n                                loc,\r\n                                messageId: \"unexpectedWhitespaceAfter\",\r\n                                fix(fixer) {\r\n\r\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\r\n                                }\r\n                            });\r\n                        }\r\n                    } else {\r\n                        if (requireSpaceAfter) {\r\n                            const loc = token.loc;\r\n\r\n                            context.report({\r\n                                node,\r\n                                loc,\r\n                                messageId: \"missingWhitespaceAfter\",\r\n                                fix(fixer) {\r\n                                    return fixer.insertTextAfter(token, \" \");\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkNode(node) {\r\n            const token = sourceCode.getLastToken(node);\r\n\r\n            checkSemicolonSpacing(token, node);\r\n        }\r\n\r\n        return {\r\n            VariableDeclaration: checkNode,\r\n            ExpressionStatement: checkNode,\r\n            BreakStatement: checkNode,\r\n            ContinueStatement: checkNode,\r\n            DebuggerStatement: checkNode,\r\n            DoWhileStatement: checkNode,\r\n            ReturnStatement: checkNode,\r\n            ThrowStatement: checkNode,\r\n            ImportDeclaration: checkNode,\r\n            ExportNamedDeclaration: checkNode,\r\n            ExportAllDeclaration: checkNode,\r\n            ExportDefaultDeclaration: checkNode,\r\n            ForStatement(node) {\r\n                if (node.init) {\r\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\r\n                }\r\n\r\n                if (node.test) {\r\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\r\n                }\r\n            },\r\n            PropertyDefinition: checkNode\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}