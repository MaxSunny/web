{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce grouped require statements for Node.JS\r\n * @author Raphael Pigulla\r\n * @deprecated in ESLint v7.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `require` calls to be mixed with regular variable declarations\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-requires\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"boolean\"\n      }, {\n        type: \"object\",\n        properties: {\n          grouping: {\n            type: \"boolean\"\n          },\n          allowCall: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      noMixRequire: \"Do not mix 'require' and other declarations.\",\n      noMixCoreModuleFileComputed: \"Do not mix core, module, file and computed requires.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let grouping = false,\n        allowCall = false;\n\n    if (typeof options === \"object\") {\n      grouping = options.grouping;\n      allowCall = options.allowCall;\n    } else {\n      grouping = !!options;\n    }\n    /**\r\n     * Returns the list of built-in modules.\r\n     * @returns {string[]} An array of built-in Node.js modules.\r\n     */\n\n\n    function getBuiltinModules() {\n      /*\r\n       * This list is generated using:\r\n       * `require(\"repl\")._builtinLibs.concat('repl').sort()`\r\n       * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\r\n       */\n      return [\"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\", \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\", \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\", \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\", \"url\", \"util\", \"v8\", \"vm\", \"zlib\"];\n    }\n\n    const BUILTIN_MODULES = getBuiltinModules();\n    const DECL_REQUIRE = \"require\",\n          DECL_UNINITIALIZED = \"uninitialized\",\n          DECL_OTHER = \"other\";\n    const REQ_CORE = \"core\",\n          REQ_FILE = \"file\",\n          REQ_MODULE = \"module\",\n          REQ_COMPUTED = \"computed\";\n    /**\r\n     * Determines the type of a declaration statement.\r\n     * @param {ASTNode} initExpression The init node of the VariableDeclarator.\r\n     * @returns {string} The type of declaration represented by the expression.\r\n     */\n\n    function getDeclarationType(initExpression) {\n      if (!initExpression) {\n        // \"var x;\"\n        return DECL_UNINITIALIZED;\n      }\n\n      if (initExpression.type === \"CallExpression\" && initExpression.callee.type === \"Identifier\" && initExpression.callee.name === \"require\") {\n        // \"var x = require('util');\"\n        return DECL_REQUIRE;\n      }\n\n      if (allowCall && initExpression.type === \"CallExpression\" && initExpression.callee.type === \"CallExpression\") {\n        // \"var x = require('diagnose')('sub-module');\"\n        return getDeclarationType(initExpression.callee);\n      }\n\n      if (initExpression.type === \"MemberExpression\") {\n        // \"var x = require('glob').Glob;\"\n        return getDeclarationType(initExpression.object);\n      } // \"var x = 42;\"\n\n\n      return DECL_OTHER;\n    }\n    /**\r\n     * Determines the type of module that is loaded via require.\r\n     * @param {ASTNode} initExpression The init node of the VariableDeclarator.\r\n     * @returns {string} The module type.\r\n     */\n\n\n    function inferModuleType(initExpression) {\n      if (initExpression.type === \"MemberExpression\") {\n        // \"var x = require('glob').Glob;\"\n        return inferModuleType(initExpression.object);\n      }\n\n      if (initExpression.arguments.length === 0) {\n        // \"var x = require();\"\n        return REQ_COMPUTED;\n      }\n\n      const arg = initExpression.arguments[0];\n\n      if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\n        // \"var x = require(42);\"\n        return REQ_COMPUTED;\n      }\n\n      if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\n        // \"var fs = require('fs');\"\n        return REQ_CORE;\n      }\n\n      if (/^\\.{0,2}\\//u.test(arg.value)) {\n        // \"var utils = require('./utils');\"\n        return REQ_FILE;\n      } // \"var async = require('async');\"\n\n\n      return REQ_MODULE;\n    }\n    /**\r\n     * Check if the list of variable declarations is mixed, i.e. whether it\r\n     * contains both require and other declarations.\r\n     * @param {ASTNode} declarations The list of VariableDeclarators.\r\n     * @returns {boolean} True if the declarations are mixed, false if not.\r\n     */\n\n\n    function isMixed(declarations) {\n      const contains = {};\n      declarations.forEach(declaration => {\n        const type = getDeclarationType(declaration.init);\n        contains[type] = true;\n      });\n      return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));\n    }\n    /**\r\n     * Check if all require declarations in the given list are of the same\r\n     * type.\r\n     * @param {ASTNode} declarations The list of VariableDeclarators.\r\n     * @returns {boolean} True if the declarations are grouped, false if not.\r\n     */\n\n\n    function isGrouped(declarations) {\n      const found = {};\n      declarations.forEach(declaration => {\n        if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\n          found[inferModuleType(declaration.init)] = true;\n        }\n      });\n      return Object.keys(found).length <= 1;\n    }\n\n    return {\n      VariableDeclaration(node) {\n        if (isMixed(node.declarations)) {\n          context.report({\n            node,\n            messageId: \"noMixRequire\"\n          });\n        } else if (grouping && !isGrouped(node.declarations)) {\n          context.report({\n            node,\n            messageId: \"noMixCoreModuleFileComputed\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-mixed-requires.js"],"names":["module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","schema","oneOf","properties","grouping","allowCall","additionalProperties","messages","noMixRequire","noMixCoreModuleFileComputed","create","context","options","getBuiltinModules","BUILTIN_MODULES","DECL_REQUIRE","DECL_UNINITIALIZED","DECL_OTHER","REQ_CORE","REQ_FILE","REQ_MODULE","REQ_COMPUTED","getDeclarationType","initExpression","callee","name","object","inferModuleType","arguments","length","arg","value","indexOf","test","isMixed","declarations","contains","forEach","declaration","init","isGrouped","found","Object","keys","VariableDeclaration","node","report","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce grouped require statements for Node.JS\r\n * @author Raphael Pigulla\r\n * @deprecated in ESLint v7.0.0\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        deprecated: true,\r\n\r\n        replacedBy: [],\r\n\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow `require` calls to be mixed with regular variable declarations\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-mixed-requires\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        type: \"boolean\"\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            grouping: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            allowCall: {\r\n                                type: \"boolean\"\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            noMixRequire: \"Do not mix 'require' and other declarations.\",\r\n            noMixCoreModuleFileComputed: \"Do not mix core, module, file and computed requires.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0];\r\n        let grouping = false,\r\n            allowCall = false;\r\n\r\n        if (typeof options === \"object\") {\r\n            grouping = options.grouping;\r\n            allowCall = options.allowCall;\r\n        } else {\r\n            grouping = !!options;\r\n        }\r\n\r\n        /**\r\n         * Returns the list of built-in modules.\r\n         * @returns {string[]} An array of built-in Node.js modules.\r\n         */\r\n        function getBuiltinModules() {\r\n\r\n            /*\r\n             * This list is generated using:\r\n             * `require(\"repl\")._builtinLibs.concat('repl').sort()`\r\n             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1\r\n             */\r\n            return [\r\n                \"assert\", \"buffer\", \"child_process\", \"cluster\", \"crypto\",\r\n                \"dgram\", \"dns\", \"domain\", \"events\", \"fs\", \"http\", \"https\",\r\n                \"net\", \"os\", \"path\", \"punycode\", \"querystring\", \"readline\",\r\n                \"repl\", \"smalloc\", \"stream\", \"string_decoder\", \"tls\", \"tty\",\r\n                \"url\", \"util\", \"v8\", \"vm\", \"zlib\"\r\n            ];\r\n        }\r\n\r\n        const BUILTIN_MODULES = getBuiltinModules();\r\n\r\n        const DECL_REQUIRE = \"require\",\r\n            DECL_UNINITIALIZED = \"uninitialized\",\r\n            DECL_OTHER = \"other\";\r\n\r\n        const REQ_CORE = \"core\",\r\n            REQ_FILE = \"file\",\r\n            REQ_MODULE = \"module\",\r\n            REQ_COMPUTED = \"computed\";\r\n\r\n        /**\r\n         * Determines the type of a declaration statement.\r\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\r\n         * @returns {string} The type of declaration represented by the expression.\r\n         */\r\n        function getDeclarationType(initExpression) {\r\n            if (!initExpression) {\r\n\r\n                // \"var x;\"\r\n                return DECL_UNINITIALIZED;\r\n            }\r\n\r\n            if (initExpression.type === \"CallExpression\" &&\r\n                initExpression.callee.type === \"Identifier\" &&\r\n                initExpression.callee.name === \"require\"\r\n            ) {\r\n\r\n                // \"var x = require('util');\"\r\n                return DECL_REQUIRE;\r\n            }\r\n            if (allowCall &&\r\n                initExpression.type === \"CallExpression\" &&\r\n                initExpression.callee.type === \"CallExpression\"\r\n            ) {\r\n\r\n                // \"var x = require('diagnose')('sub-module');\"\r\n                return getDeclarationType(initExpression.callee);\r\n            }\r\n            if (initExpression.type === \"MemberExpression\") {\r\n\r\n                // \"var x = require('glob').Glob;\"\r\n                return getDeclarationType(initExpression.object);\r\n            }\r\n\r\n            // \"var x = 42;\"\r\n            return DECL_OTHER;\r\n        }\r\n\r\n        /**\r\n         * Determines the type of module that is loaded via require.\r\n         * @param {ASTNode} initExpression The init node of the VariableDeclarator.\r\n         * @returns {string} The module type.\r\n         */\r\n        function inferModuleType(initExpression) {\r\n            if (initExpression.type === \"MemberExpression\") {\r\n\r\n                // \"var x = require('glob').Glob;\"\r\n                return inferModuleType(initExpression.object);\r\n            }\r\n            if (initExpression.arguments.length === 0) {\r\n\r\n                // \"var x = require();\"\r\n                return REQ_COMPUTED;\r\n            }\r\n\r\n            const arg = initExpression.arguments[0];\r\n\r\n            if (arg.type !== \"Literal\" || typeof arg.value !== \"string\") {\r\n\r\n                // \"var x = require(42);\"\r\n                return REQ_COMPUTED;\r\n            }\r\n\r\n            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {\r\n\r\n                // \"var fs = require('fs');\"\r\n                return REQ_CORE;\r\n            }\r\n            if (/^\\.{0,2}\\//u.test(arg.value)) {\r\n\r\n                // \"var utils = require('./utils');\"\r\n                return REQ_FILE;\r\n            }\r\n\r\n            // \"var async = require('async');\"\r\n            return REQ_MODULE;\r\n\r\n        }\r\n\r\n        /**\r\n         * Check if the list of variable declarations is mixed, i.e. whether it\r\n         * contains both require and other declarations.\r\n         * @param {ASTNode} declarations The list of VariableDeclarators.\r\n         * @returns {boolean} True if the declarations are mixed, false if not.\r\n         */\r\n        function isMixed(declarations) {\r\n            const contains = {};\r\n\r\n            declarations.forEach(declaration => {\r\n                const type = getDeclarationType(declaration.init);\r\n\r\n                contains[type] = true;\r\n            });\r\n\r\n            return !!(\r\n                contains[DECL_REQUIRE] &&\r\n                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check if all require declarations in the given list are of the same\r\n         * type.\r\n         * @param {ASTNode} declarations The list of VariableDeclarators.\r\n         * @returns {boolean} True if the declarations are grouped, false if not.\r\n         */\r\n        function isGrouped(declarations) {\r\n            const found = {};\r\n\r\n            declarations.forEach(declaration => {\r\n                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {\r\n                    found[inferModuleType(declaration.init)] = true;\r\n                }\r\n            });\r\n\r\n            return Object.keys(found).length <= 1;\r\n        }\r\n\r\n\r\n        return {\r\n\r\n            VariableDeclaration(node) {\r\n\r\n                if (isMixed(node.declarations)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"noMixRequire\"\r\n                    });\r\n                } else if (grouping && !isGrouped(node.declarations)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"noMixCoreModuleFileComputed\"\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}