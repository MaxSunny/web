{"ast":null,"code":"/**\r\n * @fileoverview Helpers to debug for code path analysis.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:code-path\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets id of a given segment.\r\n * @param {CodePathSegment} segment A segment to get.\r\n * @returns {string} Id of the segment.\r\n */\n\n/* istanbul ignore next */\n\n\nfunction getId(segment) {\n  // eslint-disable-line jsdoc/require-jsdoc -- Ignoring\n  return segment.id + (segment.reachable ? \"\" : \"!\");\n}\n/**\r\n * Get string for the given node and operation.\r\n * @param {ASTNode} node The node to convert.\r\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\r\n * @returns {string} The string representation.\r\n */\n\n\nfunction nodeToString(node, label) {\n  const suffix = label ? `:${label}` : \"\";\n\n  switch (node.type) {\n    case \"Identifier\":\n      return `${node.type}${suffix} (${node.name})`;\n\n    case \"Literal\":\n      return `${node.type}${suffix} (${node.value})`;\n\n    default:\n      return `${node.type}${suffix}`;\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  /**\r\n   * A flag that debug dumping is enabled or not.\r\n   * @type {boolean}\r\n   */\n  enabled: debug.enabled,\n\n  /**\r\n   * Dumps given objects.\r\n   * @param {...any} args objects to dump.\r\n   * @returns {void}\r\n   */\n  dump: debug,\n\n  /**\r\n   * Dumps the current analyzing state.\r\n   * @param {ASTNode} node A node to dump.\r\n   * @param {CodePathState} state A state to dump.\r\n   * @param {boolean} leaving A flag whether or not it's leaving\r\n   * @returns {void}\r\n   */\n  dumpState: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (node, state, leaving) {\n    for (let i = 0; i < state.currentSegments.length; ++i) {\n      const segInternal = state.currentSegments[i].internal;\n\n      if (leaving) {\n        const last = segInternal.nodes.length - 1;\n\n        if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\n          segInternal.nodes[last] = nodeToString(node, void 0);\n        } else {\n          segInternal.nodes.push(nodeToString(node, \"exit\"));\n        }\n      } else {\n        segInternal.nodes.push(nodeToString(node, \"enter\"));\n      }\n    }\n\n    debug([`${state.currentSegments.map(getId).join(\",\")})`, `${node.type}${leaving ? \":exit\" : \"\"}`].join(\" \"));\n  },\n\n  /**\r\n   * Dumps a DOT code of a given code path.\r\n   * The DOT code can be visualized with Graphvis.\r\n   * @param {CodePath} codePath A code path to dump.\r\n   * @returns {void}\r\n   * @see http://www.graphviz.org\r\n   * @see http://www.webgraphviz.com\r\n   */\n  dumpDot: !debug.enabled ? debug :\n  /* istanbul ignore next */\n  function (codePath) {\n    let text = \"\\n\" + \"digraph {\\n\" + \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" + \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n\n    if (codePath.returnedSegments.length > 0) {\n      text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\n    }\n\n    if (codePath.thrownSegments.length > 0) {\n      text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\n    }\n\n    const traceMap = Object.create(null);\n    const arrows = this.makeDotArrows(codePath, traceMap);\n\n    for (const id in traceMap) {\n      // eslint-disable-line guard-for-in -- Want ability to traverse prototype\n      const segment = traceMap[id];\n      text += `${id}[`;\n\n      if (segment.reachable) {\n        text += \"label=\\\"\";\n      } else {\n        text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\n      }\n\n      if (segment.internal.nodes.length > 0) {\n        text += segment.internal.nodes.join(\"\\\\n\");\n      } else {\n        text += \"????\";\n      }\n\n      text += \"\\\"];\\n\";\n    }\n\n    text += `${arrows}\\n`;\n    text += \"}\";\n    debug(\"DOT\", text);\n  },\n\n  /**\r\n   * Makes a DOT code of a given code path.\r\n   * The DOT code can be visualized with Graphvis.\r\n   * @param {CodePath} codePath A code path to make DOT.\r\n   * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\r\n   * @returns {string} A DOT code of the code path.\r\n   */\n  makeDotArrows(codePath, traceMap) {\n    const stack = [[codePath.initialSegment, 0]];\n    const done = traceMap || Object.create(null);\n    let lastId = codePath.initialSegment.id;\n    let text = `initial->${codePath.initialSegment.id}`;\n\n    while (stack.length > 0) {\n      const item = stack.pop();\n      const segment = item[0];\n      const index = item[1];\n\n      if (done[segment.id] && index === 0) {\n        continue;\n      }\n\n      done[segment.id] = segment;\n      const nextSegment = segment.allNextSegments[index];\n\n      if (!nextSegment) {\n        continue;\n      }\n\n      if (lastId === segment.id) {\n        text += `->${nextSegment.id}`;\n      } else {\n        text += `;\\n${segment.id}->${nextSegment.id}`;\n      }\n\n      lastId = nextSegment.id;\n      stack.unshift([segment, 1 + index]);\n      stack.push([nextSegment, 0]);\n    }\n\n    codePath.returnedSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->final\";\n      } else {\n        text += `;\\n${finalSegment.id}->final`;\n      }\n\n      lastId = null;\n    });\n    codePath.thrownSegments.forEach(finalSegment => {\n      if (lastId === finalSegment.id) {\n        text += \"->thrown\";\n      } else {\n        text += `;\\n${finalSegment.id}->thrown`;\n      }\n\n      lastId = null;\n    });\n    return `${text};`;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js"],"names":["debug","require","getId","segment","id","reachable","nodeToString","node","label","suffix","type","name","value","module","exports","enabled","dump","dumpState","state","leaving","i","currentSegments","length","segInternal","internal","last","nodes","push","map","join","dumpDot","codePath","text","returnedSegments","thrownSegments","traceMap","Object","create","arrows","makeDotArrows","stack","initialSegment","done","lastId","item","pop","index","nextSegment","allNextSegments","unshift","forEach","finalSegment"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Helpers to debug for code path analysis.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst debug = require(\"debug\")(\"eslint:code-path\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets id of a given segment.\r\n * @param {CodePathSegment} segment A segment to get.\r\n * @returns {string} Id of the segment.\r\n */\r\n/* istanbul ignore next */\r\nfunction getId(segment) { // eslint-disable-line jsdoc/require-jsdoc -- Ignoring\r\n    return segment.id + (segment.reachable ? \"\" : \"!\");\r\n}\r\n\r\n/**\r\n * Get string for the given node and operation.\r\n * @param {ASTNode} node The node to convert.\r\n * @param {\"enter\" | \"exit\" | undefined} label The operation label.\r\n * @returns {string} The string representation.\r\n */\r\nfunction nodeToString(node, label) {\r\n    const suffix = label ? `:${label}` : \"\";\r\n\r\n    switch (node.type) {\r\n        case \"Identifier\": return `${node.type}${suffix} (${node.name})`;\r\n        case \"Literal\": return `${node.type}${suffix} (${node.value})`;\r\n        default: return `${node.type}${suffix}`;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nmodule.exports = {\r\n\r\n    /**\r\n     * A flag that debug dumping is enabled or not.\r\n     * @type {boolean}\r\n     */\r\n    enabled: debug.enabled,\r\n\r\n    /**\r\n     * Dumps given objects.\r\n     * @param {...any} args objects to dump.\r\n     * @returns {void}\r\n     */\r\n    dump: debug,\r\n\r\n    /**\r\n     * Dumps the current analyzing state.\r\n     * @param {ASTNode} node A node to dump.\r\n     * @param {CodePathState} state A state to dump.\r\n     * @param {boolean} leaving A flag whether or not it's leaving\r\n     * @returns {void}\r\n     */\r\n    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {\r\n        for (let i = 0; i < state.currentSegments.length; ++i) {\r\n            const segInternal = state.currentSegments[i].internal;\r\n\r\n            if (leaving) {\r\n                const last = segInternal.nodes.length - 1;\r\n\r\n                if (last >= 0 && segInternal.nodes[last] === nodeToString(node, \"enter\")) {\r\n                    segInternal.nodes[last] = nodeToString(node, void 0);\r\n                } else {\r\n                    segInternal.nodes.push(nodeToString(node, \"exit\"));\r\n                }\r\n            } else {\r\n                segInternal.nodes.push(nodeToString(node, \"enter\"));\r\n            }\r\n        }\r\n\r\n        debug([\r\n            `${state.currentSegments.map(getId).join(\",\")})`,\r\n            `${node.type}${leaving ? \":exit\" : \"\"}`\r\n        ].join(\" \"));\r\n    },\r\n\r\n    /**\r\n     * Dumps a DOT code of a given code path.\r\n     * The DOT code can be visualized with Graphvis.\r\n     * @param {CodePath} codePath A code path to dump.\r\n     * @returns {void}\r\n     * @see http://www.graphviz.org\r\n     * @see http://www.webgraphviz.com\r\n     */\r\n    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {\r\n        let text =\r\n            \"\\n\" +\r\n            \"digraph {\\n\" +\r\n            \"node[shape=box,style=\\\"rounded,filled\\\",fillcolor=white];\\n\" +\r\n            \"initial[label=\\\"\\\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\r\n\r\n        if (codePath.returnedSegments.length > 0) {\r\n            text += \"final[label=\\\"\\\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\\n\";\r\n        }\r\n        if (codePath.thrownSegments.length > 0) {\r\n            text += \"thrown[label=\\\"✘\\\",shape=circle,width=0.3,height=0.3,fixedsize];\\n\";\r\n        }\r\n\r\n        const traceMap = Object.create(null);\r\n        const arrows = this.makeDotArrows(codePath, traceMap);\r\n\r\n        for (const id in traceMap) { // eslint-disable-line guard-for-in -- Want ability to traverse prototype\r\n            const segment = traceMap[id];\r\n\r\n            text += `${id}[`;\r\n\r\n            if (segment.reachable) {\r\n                text += \"label=\\\"\";\r\n            } else {\r\n                text += \"style=\\\"rounded,dashed,filled\\\",fillcolor=\\\"#FF9800\\\",label=\\\"<<unreachable>>\\\\n\";\r\n            }\r\n\r\n            if (segment.internal.nodes.length > 0) {\r\n                text += segment.internal.nodes.join(\"\\\\n\");\r\n            } else {\r\n                text += \"????\";\r\n            }\r\n\r\n            text += \"\\\"];\\n\";\r\n        }\r\n\r\n        text += `${arrows}\\n`;\r\n        text += \"}\";\r\n        debug(\"DOT\", text);\r\n    },\r\n\r\n    /**\r\n     * Makes a DOT code of a given code path.\r\n     * The DOT code can be visualized with Graphvis.\r\n     * @param {CodePath} codePath A code path to make DOT.\r\n     * @param {Object} traceMap Optional. A map to check whether or not segments had been done.\r\n     * @returns {string} A DOT code of the code path.\r\n     */\r\n    makeDotArrows(codePath, traceMap) {\r\n        const stack = [[codePath.initialSegment, 0]];\r\n        const done = traceMap || Object.create(null);\r\n        let lastId = codePath.initialSegment.id;\r\n        let text = `initial->${codePath.initialSegment.id}`;\r\n\r\n        while (stack.length > 0) {\r\n            const item = stack.pop();\r\n            const segment = item[0];\r\n            const index = item[1];\r\n\r\n            if (done[segment.id] && index === 0) {\r\n                continue;\r\n            }\r\n            done[segment.id] = segment;\r\n\r\n            const nextSegment = segment.allNextSegments[index];\r\n\r\n            if (!nextSegment) {\r\n                continue;\r\n            }\r\n\r\n            if (lastId === segment.id) {\r\n                text += `->${nextSegment.id}`;\r\n            } else {\r\n                text += `;\\n${segment.id}->${nextSegment.id}`;\r\n            }\r\n            lastId = nextSegment.id;\r\n\r\n            stack.unshift([segment, 1 + index]);\r\n            stack.push([nextSegment, 0]);\r\n        }\r\n\r\n        codePath.returnedSegments.forEach(finalSegment => {\r\n            if (lastId === finalSegment.id) {\r\n                text += \"->final\";\r\n            } else {\r\n                text += `;\\n${finalSegment.id}->final`;\r\n            }\r\n            lastId = null;\r\n        });\r\n\r\n        codePath.thrownSegments.forEach(finalSegment => {\r\n            if (lastId === finalSegment.id) {\r\n                text += \"->thrown\";\r\n            } else {\r\n                text += `;\\n${finalSegment.id}->thrown`;\r\n            }\r\n            lastId = null;\r\n        });\r\n\r\n        return `${text};`;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}