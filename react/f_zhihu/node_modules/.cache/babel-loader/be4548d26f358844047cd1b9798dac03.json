{"ast":null,"code":"/**\r\n * @fileoverview A rule to set the maximum number of line of code in a function.\r\n * @author Pete Ward <peteward44@gmail.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  upperCaseFirst\n} = require(\"../shared/string-utils\"); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst OPTIONS_SCHEMA = {\n  type: \"object\",\n  properties: {\n    max: {\n      type: \"integer\",\n      minimum: 0\n    },\n    skipComments: {\n      type: \"boolean\"\n    },\n    skipBlankLines: {\n      type: \"boolean\"\n    },\n    IIFEs: {\n      type: \"boolean\"\n    }\n  },\n  additionalProperties: false\n};\nconst OPTIONS_OR_INTEGER_SCHEMA = {\n  oneOf: [OPTIONS_SCHEMA, {\n    type: \"integer\",\n    minimum: 1\n  }]\n};\n/**\r\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\r\n * @param {Array} comments An array of comment nodes.\r\n * @returns {Map<string, Node>} A map with numeric keys (source code line numbers) and comment token values.\r\n */\n\nfunction getCommentLineNumbers(comments) {\n  const map = new Map();\n  comments.forEach(comment => {\n    for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\n      map.set(i, comment);\n    }\n  });\n  return map;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines of code in a function\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines-per-function\"\n    },\n    schema: [OPTIONS_OR_INTEGER_SCHEMA],\n    messages: {\n      exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const lines = sourceCode.lines;\n    const option = context.options[0];\n    let maxLines = 50;\n    let skipComments = false;\n    let skipBlankLines = false;\n    let IIFEs = false;\n\n    if (typeof option === \"object\") {\n      maxLines = typeof option.max === \"number\" ? option.max : 50;\n      skipComments = !!option.skipComments;\n      skipBlankLines = !!option.skipBlankLines;\n      IIFEs = !!option.IIFEs;\n    } else if (typeof option === \"number\") {\n      maxLines = option;\n    }\n\n    const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments()); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Tells if a comment encompasses the entire line.\r\n     * @param {string} line The source line with a trailing comment\r\n     * @param {number} lineNumber The one-indexed line number this is on\r\n     * @param {ASTNode} comment The comment to remove\r\n     * @returns {boolean} If the comment covers the entire line\r\n     */\n\n    function isFullLineComment(line, lineNumber, comment) {\n      const start = comment.loc.start,\n            end = comment.loc.end,\n            isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\n            isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\n      return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);\n    }\n    /**\r\n     * Identifies is a node is a FunctionExpression which is part of an IIFE\r\n     * @param {ASTNode} node Node to test\r\n     * @returns {boolean} True if it's an IIFE\r\n     */\n\n\n    function isIIFE(node) {\n      return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\n    }\n    /**\r\n     * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\r\n     * @param {ASTNode} node Node to test\r\n     * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\r\n     */\n\n\n    function isEmbedded(node) {\n      if (!node.parent) {\n        return false;\n      }\n\n      if (node !== node.parent.value) {\n        return false;\n      }\n\n      if (node.parent.type === \"MethodDefinition\") {\n        return true;\n      }\n\n      if (node.parent.type === \"Property\") {\n        return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\n      }\n\n      return false;\n    }\n    /**\r\n     * Count the lines in the function\r\n     * @param {ASTNode} funcNode Function AST node\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function processFunction(funcNode) {\n      const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\n\n      if (!IIFEs && isIIFE(node)) {\n        return;\n      }\n\n      let lineCount = 0;\n\n      for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\n        const line = lines[i];\n\n        if (skipComments) {\n          if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\n            continue;\n          }\n        }\n\n        if (skipBlankLines) {\n          if (line.match(/^\\s*$/u)) {\n            continue;\n          }\n        }\n\n        lineCount++;\n      }\n\n      if (lineCount > maxLines) {\n        const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: {\n            name,\n            lineCount,\n            maxLines\n          }\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      FunctionDeclaration: processFunction,\n      FunctionExpression: processFunction,\n      ArrowFunctionExpression: processFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/max-lines-per-function.js"],"names":["astUtils","require","upperCaseFirst","OPTIONS_SCHEMA","type","properties","max","minimum","skipComments","skipBlankLines","IIFEs","additionalProperties","OPTIONS_OR_INTEGER_SCHEMA","oneOf","getCommentLineNumbers","comments","map","Map","forEach","comment","i","loc","start","line","end","set","module","exports","meta","docs","description","recommended","url","schema","messages","exceed","create","context","sourceCode","getSourceCode","lines","option","options","maxLines","commentLineNumbers","getAllComments","isFullLineComment","lineNumber","isFirstTokenOnLine","slice","column","trim","isLastTokenOnLine","isIIFE","node","parent","callee","isEmbedded","value","method","kind","processFunction","funcNode","lineCount","has","get","match","name","getFunctionNameWithKind","report","messageId","data","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to set the maximum number of line of code in a function.\r\n * @author Pete Ward <peteward44@gmail.com>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst OPTIONS_SCHEMA = {\r\n    type: \"object\",\r\n    properties: {\r\n        max: {\r\n            type: \"integer\",\r\n            minimum: 0\r\n        },\r\n        skipComments: {\r\n            type: \"boolean\"\r\n        },\r\n        skipBlankLines: {\r\n            type: \"boolean\"\r\n        },\r\n        IIFEs: {\r\n            type: \"boolean\"\r\n        }\r\n    },\r\n    additionalProperties: false\r\n};\r\n\r\nconst OPTIONS_OR_INTEGER_SCHEMA = {\r\n    oneOf: [\r\n        OPTIONS_SCHEMA,\r\n        {\r\n            type: \"integer\",\r\n            minimum: 1\r\n        }\r\n    ]\r\n};\r\n\r\n/**\r\n * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.\r\n * @param {Array} comments An array of comment nodes.\r\n * @returns {Map<string, Node>} A map with numeric keys (source code line numbers) and comment token values.\r\n */\r\nfunction getCommentLineNumbers(comments) {\r\n    const map = new Map();\r\n\r\n    comments.forEach(comment => {\r\n        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {\r\n            map.set(i, comment);\r\n        }\r\n    });\r\n    return map;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce a maximum number of lines of code in a function\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/max-lines-per-function\"\r\n        },\r\n\r\n        schema: [\r\n            OPTIONS_OR_INTEGER_SCHEMA\r\n        ],\r\n        messages: {\r\n            exceed: \"{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const lines = sourceCode.lines;\r\n\r\n        const option = context.options[0];\r\n        let maxLines = 50;\r\n        let skipComments = false;\r\n        let skipBlankLines = false;\r\n        let IIFEs = false;\r\n\r\n        if (typeof option === \"object\") {\r\n            maxLines = typeof option.max === \"number\" ? option.max : 50;\r\n            skipComments = !!option.skipComments;\r\n            skipBlankLines = !!option.skipBlankLines;\r\n            IIFEs = !!option.IIFEs;\r\n        } else if (typeof option === \"number\") {\r\n            maxLines = option;\r\n        }\r\n\r\n        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Tells if a comment encompasses the entire line.\r\n         * @param {string} line The source line with a trailing comment\r\n         * @param {number} lineNumber The one-indexed line number this is on\r\n         * @param {ASTNode} comment The comment to remove\r\n         * @returns {boolean} If the comment covers the entire line\r\n         */\r\n        function isFullLineComment(line, lineNumber, comment) {\r\n            const start = comment.loc.start,\r\n                end = comment.loc.end,\r\n                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),\r\n                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();\r\n\r\n            return comment &&\r\n                (start.line < lineNumber || isFirstTokenOnLine) &&\r\n                (end.line > lineNumber || isLastTokenOnLine);\r\n        }\r\n\r\n        /**\r\n         * Identifies is a node is a FunctionExpression which is part of an IIFE\r\n         * @param {ASTNode} node Node to test\r\n         * @returns {boolean} True if it's an IIFE\r\n         */\r\n        function isIIFE(node) {\r\n            return (node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\") && node.parent && node.parent.type === \"CallExpression\" && node.parent.callee === node;\r\n        }\r\n\r\n        /**\r\n         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property\r\n         * @param {ASTNode} node Node to test\r\n         * @returns {boolean} True if it's a FunctionExpression embedded within a MethodDefinition or Property\r\n         */\r\n        function isEmbedded(node) {\r\n            if (!node.parent) {\r\n                return false;\r\n            }\r\n            if (node !== node.parent.value) {\r\n                return false;\r\n            }\r\n            if (node.parent.type === \"MethodDefinition\") {\r\n                return true;\r\n            }\r\n            if (node.parent.type === \"Property\") {\r\n                return node.parent.method === true || node.parent.kind === \"get\" || node.parent.kind === \"set\";\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Count the lines in the function\r\n         * @param {ASTNode} funcNode Function AST node\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function processFunction(funcNode) {\r\n            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;\r\n\r\n            if (!IIFEs && isIIFE(node)) {\r\n                return;\r\n            }\r\n            let lineCount = 0;\r\n\r\n            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {\r\n                const line = lines[i];\r\n\r\n                if (skipComments) {\r\n                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (skipBlankLines) {\r\n                    if (line.match(/^\\s*$/u)) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                lineCount++;\r\n            }\r\n\r\n            if (lineCount > maxLines) {\r\n                const name = upperCaseFirst(astUtils.getFunctionNameWithKind(funcNode));\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: \"exceed\",\r\n                    data: { name, lineCount, maxLines }\r\n                });\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            FunctionDeclaration: processFunction,\r\n            FunctionExpression: processFunction,\r\n            ArrowFunctionExpression: processFunction\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}