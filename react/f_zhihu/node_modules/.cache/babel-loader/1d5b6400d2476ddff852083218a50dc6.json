{"ast":null,"code":"var path = require('path');\n\nvar crypto = require('crypto');\n\nmodule.exports = {\n  createFromFile: function (filePath, useChecksum) {\n    var fname = path.basename(filePath);\n    var dir = path.dirname(filePath);\n    return this.create(fname, dir, useChecksum);\n  },\n  create: function (cacheId, _path, useChecksum) {\n    var fs = require('fs');\n\n    var flatCache = require('flat-cache');\n\n    var cache = flatCache.load(cacheId, _path);\n    var normalizedEntries = {};\n\n    var removeNotFoundFiles = function removeNotFoundFiles() {\n      const cachedEntries = cache.keys(); // remove not found entries\n\n      cachedEntries.forEach(function remover(fPath) {\n        try {\n          fs.statSync(fPath);\n        } catch (err) {\n          if (err.code === 'ENOENT') {\n            cache.removeKey(fPath);\n          }\n        }\n      });\n    };\n\n    removeNotFoundFiles();\n    return {\n      /**\r\n       * the flat cache storage used to persist the metadata of the `files\r\n       * @type {Object}\r\n       */\n      cache: cache,\n\n      /**\r\n       * Given a buffer, calculate md5 hash of its content.\r\n       * @method getHash\r\n       * @param  {Buffer} buffer   buffer to calculate hash on\r\n       * @return {String}          content hash digest\r\n       */\n      getHash: function (buffer) {\n        return crypto.createHash('md5').update(buffer).digest('hex');\n      },\n\n      /**\r\n       * Return whether or not a file has changed since last time reconcile was called.\r\n       * @method hasFileChanged\r\n       * @param  {String}  file  the filepath to check\r\n       * @return {Boolean}       wheter or not the file has changed\r\n       */\n      hasFileChanged: function (file) {\n        return this.getFileDescriptor(file).changed;\n      },\n\n      /**\r\n       * given an array of file paths it return and object with three arrays:\r\n       *  - changedFiles: Files that changed since previous run\r\n       *  - notChangedFiles: Files that haven't change\r\n       *  - notFoundFiles: Files that were not found, probably deleted\r\n       *\r\n       * @param  {Array} files the files to analyze and compare to the previous seen files\r\n       * @return {[type]}       [description]\r\n       */\n      analyzeFiles: function (files) {\n        var me = this;\n        files = files || [];\n        var res = {\n          changedFiles: [],\n          notFoundFiles: [],\n          notChangedFiles: []\n        };\n        me.normalizeEntries(files).forEach(function (entry) {\n          if (entry.changed) {\n            res.changedFiles.push(entry.key);\n            return;\n          }\n\n          if (entry.notFound) {\n            res.notFoundFiles.push(entry.key);\n            return;\n          }\n\n          res.notChangedFiles.push(entry.key);\n        });\n        return res;\n      },\n      getFileDescriptor: function (file) {\n        var fstat;\n\n        try {\n          fstat = fs.statSync(file);\n        } catch (ex) {\n          this.removeEntry(file);\n          return {\n            key: file,\n            notFound: true,\n            err: ex\n          };\n        }\n\n        if (useChecksum) {\n          return this._getFileDescriptorUsingChecksum(file);\n        }\n\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\n      },\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var cSize = fstat.size;\n        var cTime = fstat.mtime.getTime();\n        var isDifferentDate;\n        var isDifferentSize;\n\n        if (!meta) {\n          meta = {\n            size: cSize,\n            mtime: cTime\n          };\n        } else {\n          isDifferentDate = cTime !== meta.mtime;\n          isDifferentSize = cSize !== meta.size;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\n          meta: meta\n        };\n        return nEntry;\n      },\n      _getFileDescriptorUsingChecksum: function (file) {\n        var meta = cache.getKey(file);\n        var cacheExists = !!meta;\n        var contentBuffer;\n\n        try {\n          contentBuffer = fs.readFileSync(file);\n        } catch (ex) {\n          contentBuffer = '';\n        }\n\n        var isDifferent = true;\n        var hash = this.getHash(contentBuffer);\n\n        if (!meta) {\n          meta = {\n            hash: hash\n          };\n        } else {\n          isDifferent = hash !== meta.hash;\n        }\n\n        var nEntry = normalizedEntries[file] = {\n          key: file,\n          changed: !cacheExists || isDifferent,\n          meta: meta\n        };\n        return nEntry;\n      },\n\n      /**\r\n       * Return the list o the files that changed compared\r\n       * against the ones stored in the cache\r\n       *\r\n       * @method getUpdated\r\n       * @param files {Array} the array of files to compare against the ones in the cache\r\n       * @returns {Array}\r\n       */\n      getUpdatedFiles: function (files) {\n        var me = this;\n        files = files || [];\n        return me.normalizeEntries(files).filter(function (entry) {\n          return entry.changed;\n        }).map(function (entry) {\n          return entry.key;\n        });\n      },\n\n      /**\r\n       * return the list of files\r\n       * @method normalizeEntries\r\n       * @param files\r\n       * @returns {*}\r\n       */\n      normalizeEntries: function (files) {\n        files = files || [];\n        var me = this;\n        var nEntries = files.map(function (file) {\n          return me.getFileDescriptor(file);\n        }); //normalizeEntries = nEntries;\n\n        return nEntries;\n      },\n\n      /**\r\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\r\n       * modified the next time the process is run\r\n       *\r\n       * @method removeEntry\r\n       * @param entryName\r\n       */\n      removeEntry: function (entryName) {\n        delete normalizedEntries[entryName];\n        cache.removeKey(entryName);\n      },\n\n      /**\r\n       * Delete the cache file from the disk\r\n       * @method deleteCacheFile\r\n       */\n      deleteCacheFile: function () {\n        cache.removeCacheFile();\n      },\n\n      /**\r\n       * remove the cache from the file and clear the memory cache\r\n       */\n      destroy: function () {\n        normalizedEntries = {};\n        cache.destroy();\n      },\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\n        var hash = this.getHash(contentBuffer);\n        var meta = Object.assign(cacheEntry.meta, {\n          hash: hash\n        });\n        delete meta.size;\n        delete meta.mtime;\n        return meta;\n      },\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\n        var stat = fs.statSync(cacheEntry.key);\n        var meta = Object.assign(cacheEntry.meta, {\n          size: stat.size,\n          mtime: stat.mtime.getTime()\n        });\n        delete meta.hash;\n        return meta;\n      },\n\n      /**\r\n       * Sync the files and persist them to the cache\r\n       * @method reconcile\r\n       */\n      reconcile: function (noPrune) {\n        removeNotFoundFiles();\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\n        var entries = normalizedEntries;\n        var keys = Object.keys(entries);\n\n        if (keys.length === 0) {\n          return;\n        }\n\n        var me = this;\n        keys.forEach(function (entryName) {\n          var cacheEntry = entries[entryName];\n\n          try {\n            var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\n            cache.setKey(entryName, meta);\n          } catch (err) {\n            // if the file does not exists we don't save it\n            // other errors are just thrown\n            if (err.code !== 'ENOENT') {\n              throw err;\n            }\n          }\n        });\n        cache.save(noPrune);\n      }\n    };\n  }\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/file-entry-cache/cache.js"],"names":["path","require","crypto","module","exports","createFromFile","filePath","useChecksum","fname","basename","dir","dirname","create","cacheId","_path","fs","flatCache","cache","load","normalizedEntries","removeNotFoundFiles","cachedEntries","keys","forEach","remover","fPath","statSync","err","code","removeKey","getHash","buffer","createHash","update","digest","hasFileChanged","file","getFileDescriptor","changed","analyzeFiles","files","me","res","changedFiles","notFoundFiles","notChangedFiles","normalizeEntries","entry","push","key","notFound","fstat","ex","removeEntry","_getFileDescriptorUsingChecksum","_getFileDescriptorUsingMtimeAndSize","meta","getKey","cacheExists","cSize","size","cTime","mtime","getTime","isDifferentDate","isDifferentSize","nEntry","contentBuffer","readFileSync","isDifferent","hash","getUpdatedFiles","filter","map","nEntries","entryName","deleteCacheFile","removeCacheFile","destroy","_getMetaForFileUsingCheckSum","cacheEntry","Object","assign","_getMetaForFileUsingMtimeAndSize","stat","reconcile","noPrune","entries","length","setKey","save"],"mappings":"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","sourcesContent":["var path = require('path');\r\nvar crypto = require('crypto');\r\n\r\nmodule.exports = {\r\n  createFromFile: function (filePath, useChecksum) {\r\n    var fname = path.basename(filePath);\r\n    var dir = path.dirname(filePath);\r\n    return this.create(fname, dir, useChecksum);\r\n  },\r\n\r\n  create: function (cacheId, _path, useChecksum) {\r\n    var fs = require('fs');\r\n    var flatCache = require('flat-cache');\r\n    var cache = flatCache.load(cacheId, _path);\r\n    var normalizedEntries = {};\r\n\r\n    var removeNotFoundFiles = function removeNotFoundFiles() {\r\n      const cachedEntries = cache.keys();\r\n      // remove not found entries\r\n      cachedEntries.forEach(function remover(fPath) {\r\n        try {\r\n          fs.statSync(fPath);\r\n        } catch (err) {\r\n          if (err.code === 'ENOENT') {\r\n            cache.removeKey(fPath);\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    removeNotFoundFiles();\r\n\r\n    return {\r\n      /**\r\n       * the flat cache storage used to persist the metadata of the `files\r\n       * @type {Object}\r\n       */\r\n      cache: cache,\r\n\r\n      /**\r\n       * Given a buffer, calculate md5 hash of its content.\r\n       * @method getHash\r\n       * @param  {Buffer} buffer   buffer to calculate hash on\r\n       * @return {String}          content hash digest\r\n       */\r\n      getHash: function (buffer) {\r\n        return crypto.createHash('md5').update(buffer).digest('hex');\r\n      },\r\n\r\n      /**\r\n       * Return whether or not a file has changed since last time reconcile was called.\r\n       * @method hasFileChanged\r\n       * @param  {String}  file  the filepath to check\r\n       * @return {Boolean}       wheter or not the file has changed\r\n       */\r\n      hasFileChanged: function (file) {\r\n        return this.getFileDescriptor(file).changed;\r\n      },\r\n\r\n      /**\r\n       * given an array of file paths it return and object with three arrays:\r\n       *  - changedFiles: Files that changed since previous run\r\n       *  - notChangedFiles: Files that haven't change\r\n       *  - notFoundFiles: Files that were not found, probably deleted\r\n       *\r\n       * @param  {Array} files the files to analyze and compare to the previous seen files\r\n       * @return {[type]}       [description]\r\n       */\r\n      analyzeFiles: function (files) {\r\n        var me = this;\r\n        files = files || [];\r\n\r\n        var res = {\r\n          changedFiles: [],\r\n          notFoundFiles: [],\r\n          notChangedFiles: [],\r\n        };\r\n\r\n        me.normalizeEntries(files).forEach(function (entry) {\r\n          if (entry.changed) {\r\n            res.changedFiles.push(entry.key);\r\n            return;\r\n          }\r\n          if (entry.notFound) {\r\n            res.notFoundFiles.push(entry.key);\r\n            return;\r\n          }\r\n          res.notChangedFiles.push(entry.key);\r\n        });\r\n        return res;\r\n      },\r\n\r\n      getFileDescriptor: function (file) {\r\n        var fstat;\r\n\r\n        try {\r\n          fstat = fs.statSync(file);\r\n        } catch (ex) {\r\n          this.removeEntry(file);\r\n          return { key: file, notFound: true, err: ex };\r\n        }\r\n\r\n        if (useChecksum) {\r\n          return this._getFileDescriptorUsingChecksum(file);\r\n        }\r\n\r\n        return this._getFileDescriptorUsingMtimeAndSize(file, fstat);\r\n      },\r\n\r\n      _getFileDescriptorUsingMtimeAndSize: function (file, fstat) {\r\n        var meta = cache.getKey(file);\r\n        var cacheExists = !!meta;\r\n\r\n        var cSize = fstat.size;\r\n        var cTime = fstat.mtime.getTime();\r\n\r\n        var isDifferentDate;\r\n        var isDifferentSize;\r\n\r\n        if (!meta) {\r\n          meta = { size: cSize, mtime: cTime };\r\n        } else {\r\n          isDifferentDate = cTime !== meta.mtime;\r\n          isDifferentSize = cSize !== meta.size;\r\n        }\r\n\r\n        var nEntry = (normalizedEntries[file] = {\r\n          key: file,\r\n          changed: !cacheExists || isDifferentDate || isDifferentSize,\r\n          meta: meta,\r\n        });\r\n\r\n        return nEntry;\r\n      },\r\n\r\n      _getFileDescriptorUsingChecksum: function (file) {\r\n        var meta = cache.getKey(file);\r\n        var cacheExists = !!meta;\r\n\r\n        var contentBuffer;\r\n        try {\r\n          contentBuffer = fs.readFileSync(file);\r\n        } catch (ex) {\r\n          contentBuffer = '';\r\n        }\r\n\r\n        var isDifferent = true;\r\n        var hash = this.getHash(contentBuffer);\r\n\r\n        if (!meta) {\r\n          meta = { hash: hash };\r\n        } else {\r\n          isDifferent = hash !== meta.hash;\r\n        }\r\n\r\n        var nEntry = (normalizedEntries[file] = {\r\n          key: file,\r\n          changed: !cacheExists || isDifferent,\r\n          meta: meta,\r\n        });\r\n\r\n        return nEntry;\r\n      },\r\n\r\n      /**\r\n       * Return the list o the files that changed compared\r\n       * against the ones stored in the cache\r\n       *\r\n       * @method getUpdated\r\n       * @param files {Array} the array of files to compare against the ones in the cache\r\n       * @returns {Array}\r\n       */\r\n      getUpdatedFiles: function (files) {\r\n        var me = this;\r\n        files = files || [];\r\n\r\n        return me\r\n          .normalizeEntries(files)\r\n          .filter(function (entry) {\r\n            return entry.changed;\r\n          })\r\n          .map(function (entry) {\r\n            return entry.key;\r\n          });\r\n      },\r\n\r\n      /**\r\n       * return the list of files\r\n       * @method normalizeEntries\r\n       * @param files\r\n       * @returns {*}\r\n       */\r\n      normalizeEntries: function (files) {\r\n        files = files || [];\r\n\r\n        var me = this;\r\n        var nEntries = files.map(function (file) {\r\n          return me.getFileDescriptor(file);\r\n        });\r\n\r\n        //normalizeEntries = nEntries;\r\n        return nEntries;\r\n      },\r\n\r\n      /**\r\n       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered\r\n       * modified the next time the process is run\r\n       *\r\n       * @method removeEntry\r\n       * @param entryName\r\n       */\r\n      removeEntry: function (entryName) {\r\n        delete normalizedEntries[entryName];\r\n        cache.removeKey(entryName);\r\n      },\r\n\r\n      /**\r\n       * Delete the cache file from the disk\r\n       * @method deleteCacheFile\r\n       */\r\n      deleteCacheFile: function () {\r\n        cache.removeCacheFile();\r\n      },\r\n\r\n      /**\r\n       * remove the cache from the file and clear the memory cache\r\n       */\r\n      destroy: function () {\r\n        normalizedEntries = {};\r\n        cache.destroy();\r\n      },\r\n\r\n      _getMetaForFileUsingCheckSum: function (cacheEntry) {\r\n        var contentBuffer = fs.readFileSync(cacheEntry.key);\r\n        var hash = this.getHash(contentBuffer);\r\n        var meta = Object.assign(cacheEntry.meta, { hash: hash });\r\n        delete meta.size;\r\n        delete meta.mtime;\r\n        return meta;\r\n      },\r\n\r\n      _getMetaForFileUsingMtimeAndSize: function (cacheEntry) {\r\n        var stat = fs.statSync(cacheEntry.key);\r\n        var meta = Object.assign(cacheEntry.meta, {\r\n          size: stat.size,\r\n          mtime: stat.mtime.getTime(),\r\n        });\r\n        delete meta.hash;\r\n        return meta;\r\n      },\r\n\r\n      /**\r\n       * Sync the files and persist them to the cache\r\n       * @method reconcile\r\n       */\r\n      reconcile: function (noPrune) {\r\n        removeNotFoundFiles();\r\n\r\n        noPrune = typeof noPrune === 'undefined' ? true : noPrune;\r\n\r\n        var entries = normalizedEntries;\r\n        var keys = Object.keys(entries);\r\n\r\n        if (keys.length === 0) {\r\n          return;\r\n        }\r\n\r\n        var me = this;\r\n\r\n        keys.forEach(function (entryName) {\r\n          var cacheEntry = entries[entryName];\r\n\r\n          try {\r\n            var meta = useChecksum\r\n              ? me._getMetaForFileUsingCheckSum(cacheEntry)\r\n              : me._getMetaForFileUsingMtimeAndSize(cacheEntry);\r\n            cache.setKey(entryName, meta);\r\n          } catch (err) {\r\n            // if the file does not exists we don't save it\r\n            // other errors are just thrown\r\n            if (err.code !== 'ENOENT') {\r\n              throw err;\r\n            }\r\n          }\r\n        });\r\n\r\n        cache.save(noPrune);\r\n      },\r\n    };\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"script"}