{"ast":null,"code":"/**\r\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\r\n * @author Teddy Katz\r\n * @author Toru Nagashima\r\n */\n\"use strict\";\n/**\r\n * Make the map from identifiers to each reference.\r\n * @param {escope.Scope} scope The scope to get references.\r\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\r\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\r\n */\n\nfunction createReferenceMap(scope) {\n  let outReferenceMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n\n  for (const reference of scope.references) {\n    if (reference.resolved === null) {\n      continue;\n    }\n\n    outReferenceMap.set(reference.identifier, reference);\n  }\n\n  for (const childScope of scope.childScopes) {\n    if (childScope.type !== \"function\") {\n      createReferenceMap(childScope, outReferenceMap);\n    }\n  }\n\n  return outReferenceMap;\n}\n/**\r\n * Get `reference.writeExpr` of a given reference.\r\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\r\n * @param {escope.Reference} reference The reference to get.\r\n * @returns {Expression|null} The `reference.writeExpr`.\r\n */\n\n\nfunction getWriteExpr(reference) {\n  if (reference.writeExpr) {\n    return reference.writeExpr;\n  }\n\n  let node = reference.identifier;\n\n  while (node) {\n    const t = node.parent.type;\n\n    if (t === \"AssignmentExpression\" && node.parent.left === node) {\n      return node.parent.right;\n    }\n\n    if (t === \"MemberExpression\" && node.parent.object === node) {\n      node = node.parent;\n      continue;\n    }\n\n    break;\n  }\n\n  return null;\n}\n/**\r\n * Checks if an expression is a variable that can only be observed within the given function.\r\n * @param {Variable|null} variable The variable to check\r\n * @param {boolean} isMemberAccess If `true` then this is a member access.\r\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\r\n */\n\n\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\n  if (!variable) {\n    return false; // A global variable which was not defined.\n  } // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\n\n\n  if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\n    return false;\n  }\n\n  const functionScope = variable.scope.variableScope;\n  return variable.references.every(reference => reference.from.variableScope === functionScope);\n}\n/**\r\n * Represents segment information.\r\n */\n\n\nclass SegmentInfo {\n  constructor() {\n    this.info = new WeakMap();\n  }\n  /**\r\n   * Initialize the segment information.\r\n   * @param {PathSegment} segment The segment to initialize.\r\n   * @returns {void}\r\n   */\n\n\n  initialize(segment) {\n    const outdatedReadVariables = new Set();\n    const freshReadVariables = new Set();\n\n    for (const prevSegment of segment.prevSegments) {\n      const info = this.info.get(prevSegment);\n\n      if (info) {\n        info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\n        info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\n      }\n    }\n\n    this.info.set(segment, {\n      outdatedReadVariables,\n      freshReadVariables\n    });\n  }\n  /**\r\n   * Mark a given variable as read on given segments.\r\n   * @param {PathSegment[]} segments The segments that it read the variable on.\r\n   * @param {Variable} variable The variable to be read.\r\n   * @returns {void}\r\n   */\n\n\n  markAsRead(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.add(variable); // If a variable is freshly read again, then it's no more out-dated.\n\n        info.outdatedReadVariables.delete(variable);\n      }\n    }\n  }\n  /**\r\n   * Move `freshReadVariables` to `outdatedReadVariables`.\r\n   * @param {PathSegment[]} segments The segments to process.\r\n   * @returns {void}\r\n   */\n\n\n  makeOutdated(segments) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info) {\n        info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\n        info.freshReadVariables.clear();\n      }\n    }\n  }\n  /**\r\n   * Check if a given variable is outdated on the current segments.\r\n   * @param {PathSegment[]} segments The current segments.\r\n   * @param {Variable} variable The variable to check.\r\n   * @returns {boolean} `true` if the variable is outdated on the segments.\r\n   */\n\n\n  isOutdated(segments, variable) {\n    for (const segment of segments) {\n      const info = this.info.get(segment);\n\n      if (info && info.outdatedReadVariables.has(variable)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/require-atomic-updates\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowProperties: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\",\n      nonAtomicObjectUpdate: \"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.\"\n    }\n  },\n\n  create(context) {\n    const allowProperties = !!context.options[0] && context.options[0].allowProperties;\n    const sourceCode = context.getSourceCode();\n    const assignmentReferences = new Map();\n    const segmentInfo = new SegmentInfo();\n    let stack = null;\n    return {\n      onCodePathStart(codePath) {\n        const scope = context.getScope();\n        const shouldVerify = scope.type === \"function\" && (scope.block.async || scope.block.generator);\n        stack = {\n          upper: stack,\n          codePath,\n          referenceMap: shouldVerify ? createReferenceMap(scope) : null\n        };\n      },\n\n      onCodePathEnd() {\n        stack = stack.upper;\n      },\n\n      // Initialize the segment information.\n      onCodePathSegmentStart(segment) {\n        segmentInfo.initialize(segment);\n      },\n\n      // Handle references to prepare verification.\n      Identifier(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack;\n        const reference = referenceMap && referenceMap.get(node); // Ignore if this is not a valid variable reference.\n\n        if (!reference) {\n          return;\n        }\n\n        const variable = reference.resolved;\n        const writeExpr = getWriteExpr(reference);\n        const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\"; // Add a fresh read variable.\n\n        if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\n          segmentInfo.markAsRead(codePath.currentSegments, variable);\n        }\n        /*\r\n         * Register the variable to verify after ESLint traversed the `writeExpr` node\r\n         * if this reference is an assignment to a variable which is referred from other closure.\r\n         */\n\n\n        if (writeExpr && writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\n        !isLocalVariableWithoutEscape(variable, isMemberAccess)) {\n          let refs = assignmentReferences.get(writeExpr);\n\n          if (!refs) {\n            refs = [];\n            assignmentReferences.set(writeExpr, refs);\n          }\n\n          refs.push(reference);\n        }\n      },\n\n      /*\r\n       * Verify assignments.\r\n       * If the reference exists in `outdatedReadVariables` list, report it.\r\n       */\n      \":expression:exit\"(node) {\n        const {\n          codePath,\n          referenceMap\n        } = stack; // referenceMap exists if this is in a resumable function scope.\n\n        if (!referenceMap) {\n          return;\n        } // Mark the read variables on this code path as outdated.\n\n\n        if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\n          segmentInfo.makeOutdated(codePath.currentSegments);\n        } // Verify.\n\n\n        const references = assignmentReferences.get(node);\n\n        if (references) {\n          assignmentReferences.delete(node);\n\n          for (const reference of references) {\n            const variable = reference.resolved;\n\n            if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\n              if (node.parent.left === reference.identifier) {\n                context.report({\n                  node: node.parent,\n                  messageId: \"nonAtomicUpdate\",\n                  data: {\n                    value: variable.name\n                  }\n                });\n              } else if (!allowProperties) {\n                context.report({\n                  node: node.parent,\n                  messageId: \"nonAtomicObjectUpdate\",\n                  data: {\n                    value: sourceCode.getText(node.parent.left),\n                    object: variable.name\n                  }\n                });\n              }\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/require-atomic-updates.js"],"names":["createReferenceMap","scope","outReferenceMap","Map","reference","references","resolved","set","identifier","childScope","childScopes","type","getWriteExpr","writeExpr","node","t","parent","left","right","object","isLocalVariableWithoutEscape","variable","isMemberAccess","defs","some","d","functionScope","variableScope","every","from","SegmentInfo","constructor","info","WeakMap","initialize","segment","outdatedReadVariables","Set","freshReadVariables","prevSegment","prevSegments","get","forEach","prototype","add","markAsRead","segments","delete","makeOutdated","clear","isOutdated","has","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","allowProperties","default","additionalProperties","messages","nonAtomicUpdate","nonAtomicObjectUpdate","create","context","options","sourceCode","getSourceCode","assignmentReferences","segmentInfo","stack","onCodePathStart","codePath","getScope","shouldVerify","block","async","generator","upper","referenceMap","onCodePathEnd","onCodePathSegmentStart","Identifier","isRead","operator","currentSegments","refs","push","report","messageId","data","value","name","getText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`\r\n * @author Teddy Katz\r\n * @author Toru Nagashima\r\n */\r\n\"use strict\";\r\n\r\n/**\r\n * Make the map from identifiers to each reference.\r\n * @param {escope.Scope} scope The scope to get references.\r\n * @param {Map<Identifier, escope.Reference>} [outReferenceMap] The map from identifier nodes to each reference object.\r\n * @returns {Map<Identifier, escope.Reference>} `referenceMap`.\r\n */\r\nfunction createReferenceMap(scope, outReferenceMap = new Map()) {\r\n    for (const reference of scope.references) {\r\n        if (reference.resolved === null) {\r\n            continue;\r\n        }\r\n\r\n        outReferenceMap.set(reference.identifier, reference);\r\n    }\r\n    for (const childScope of scope.childScopes) {\r\n        if (childScope.type !== \"function\") {\r\n            createReferenceMap(childScope, outReferenceMap);\r\n        }\r\n    }\r\n\r\n    return outReferenceMap;\r\n}\r\n\r\n/**\r\n * Get `reference.writeExpr` of a given reference.\r\n * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`\r\n * @param {escope.Reference} reference The reference to get.\r\n * @returns {Expression|null} The `reference.writeExpr`.\r\n */\r\nfunction getWriteExpr(reference) {\r\n    if (reference.writeExpr) {\r\n        return reference.writeExpr;\r\n    }\r\n    let node = reference.identifier;\r\n\r\n    while (node) {\r\n        const t = node.parent.type;\r\n\r\n        if (t === \"AssignmentExpression\" && node.parent.left === node) {\r\n            return node.parent.right;\r\n        }\r\n        if (t === \"MemberExpression\" && node.parent.object === node) {\r\n            node = node.parent;\r\n            continue;\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks if an expression is a variable that can only be observed within the given function.\r\n * @param {Variable|null} variable The variable to check\r\n * @param {boolean} isMemberAccess If `true` then this is a member access.\r\n * @returns {boolean} `true` if the variable is local to the given function, and is never referenced in a closure.\r\n */\r\nfunction isLocalVariableWithoutEscape(variable, isMemberAccess) {\r\n    if (!variable) {\r\n        return false; // A global variable which was not defined.\r\n    }\r\n\r\n    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.\r\n    if (isMemberAccess && variable.defs.some(d => d.type === \"Parameter\")) {\r\n        return false;\r\n    }\r\n\r\n    const functionScope = variable.scope.variableScope;\r\n\r\n    return variable.references.every(reference =>\r\n        reference.from.variableScope === functionScope);\r\n}\r\n\r\n/**\r\n * Represents segment information.\r\n */\r\nclass SegmentInfo {\r\n    constructor() {\r\n        this.info = new WeakMap();\r\n    }\r\n\r\n    /**\r\n     * Initialize the segment information.\r\n     * @param {PathSegment} segment The segment to initialize.\r\n     * @returns {void}\r\n     */\r\n    initialize(segment) {\r\n        const outdatedReadVariables = new Set();\r\n        const freshReadVariables = new Set();\r\n\r\n        for (const prevSegment of segment.prevSegments) {\r\n            const info = this.info.get(prevSegment);\r\n\r\n            if (info) {\r\n                info.outdatedReadVariables.forEach(Set.prototype.add, outdatedReadVariables);\r\n                info.freshReadVariables.forEach(Set.prototype.add, freshReadVariables);\r\n            }\r\n        }\r\n\r\n        this.info.set(segment, { outdatedReadVariables, freshReadVariables });\r\n    }\r\n\r\n    /**\r\n     * Mark a given variable as read on given segments.\r\n     * @param {PathSegment[]} segments The segments that it read the variable on.\r\n     * @param {Variable} variable The variable to be read.\r\n     * @returns {void}\r\n     */\r\n    markAsRead(segments, variable) {\r\n        for (const segment of segments) {\r\n            const info = this.info.get(segment);\r\n\r\n            if (info) {\r\n                info.freshReadVariables.add(variable);\r\n\r\n                // If a variable is freshly read again, then it's no more out-dated.\r\n                info.outdatedReadVariables.delete(variable);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move `freshReadVariables` to `outdatedReadVariables`.\r\n     * @param {PathSegment[]} segments The segments to process.\r\n     * @returns {void}\r\n     */\r\n    makeOutdated(segments) {\r\n        for (const segment of segments) {\r\n            const info = this.info.get(segment);\r\n\r\n            if (info) {\r\n                info.freshReadVariables.forEach(Set.prototype.add, info.outdatedReadVariables);\r\n                info.freshReadVariables.clear();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a given variable is outdated on the current segments.\r\n     * @param {PathSegment[]} segments The current segments.\r\n     * @param {Variable} variable The variable to check.\r\n     * @returns {boolean} `true` if the variable is outdated on the segments.\r\n     */\r\n    isOutdated(segments, variable) {\r\n        for (const segment of segments) {\r\n            const info = this.info.get(segment);\r\n\r\n            if (info && info.outdatedReadVariables.has(variable)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow assignments that can lead to race conditions due to usage of `await` or `yield`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/require-atomic-updates\"\r\n        },\r\n\r\n        fixable: null,\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                allowProperties: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            nonAtomicUpdate: \"Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`.\",\r\n            nonAtomicObjectUpdate: \"Possible race condition: `{{value}}` might be assigned based on an outdated state of `{{object}}`.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const allowProperties = !!context.options[0] && context.options[0].allowProperties;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n        const assignmentReferences = new Map();\r\n        const segmentInfo = new SegmentInfo();\r\n        let stack = null;\r\n\r\n        return {\r\n            onCodePathStart(codePath) {\r\n                const scope = context.getScope();\r\n                const shouldVerify =\r\n                    scope.type === \"function\" &&\r\n                    (scope.block.async || scope.block.generator);\r\n\r\n                stack = {\r\n                    upper: stack,\r\n                    codePath,\r\n                    referenceMap: shouldVerify ? createReferenceMap(scope) : null\r\n                };\r\n            },\r\n            onCodePathEnd() {\r\n                stack = stack.upper;\r\n            },\r\n\r\n            // Initialize the segment information.\r\n            onCodePathSegmentStart(segment) {\r\n                segmentInfo.initialize(segment);\r\n            },\r\n\r\n            // Handle references to prepare verification.\r\n            Identifier(node) {\r\n                const { codePath, referenceMap } = stack;\r\n                const reference = referenceMap && referenceMap.get(node);\r\n\r\n                // Ignore if this is not a valid variable reference.\r\n                if (!reference) {\r\n                    return;\r\n                }\r\n                const variable = reference.resolved;\r\n                const writeExpr = getWriteExpr(reference);\r\n                const isMemberAccess = reference.identifier.parent.type === \"MemberExpression\";\r\n\r\n                // Add a fresh read variable.\r\n                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === \"=\")) {\r\n                    segmentInfo.markAsRead(codePath.currentSegments, variable);\r\n                }\r\n\r\n                /*\r\n                 * Register the variable to verify after ESLint traversed the `writeExpr` node\r\n                 * if this reference is an assignment to a variable which is referred from other closure.\r\n                 */\r\n                if (writeExpr &&\r\n                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.\r\n                    !isLocalVariableWithoutEscape(variable, isMemberAccess)\r\n                ) {\r\n                    let refs = assignmentReferences.get(writeExpr);\r\n\r\n                    if (!refs) {\r\n                        refs = [];\r\n                        assignmentReferences.set(writeExpr, refs);\r\n                    }\r\n\r\n                    refs.push(reference);\r\n                }\r\n            },\r\n\r\n            /*\r\n             * Verify assignments.\r\n             * If the reference exists in `outdatedReadVariables` list, report it.\r\n             */\r\n            \":expression:exit\"(node) {\r\n                const { codePath, referenceMap } = stack;\r\n\r\n                // referenceMap exists if this is in a resumable function scope.\r\n                if (!referenceMap) {\r\n                    return;\r\n                }\r\n\r\n                // Mark the read variables on this code path as outdated.\r\n                if (node.type === \"AwaitExpression\" || node.type === \"YieldExpression\") {\r\n                    segmentInfo.makeOutdated(codePath.currentSegments);\r\n                }\r\n\r\n                // Verify.\r\n                const references = assignmentReferences.get(node);\r\n\r\n                if (references) {\r\n                    assignmentReferences.delete(node);\r\n\r\n                    for (const reference of references) {\r\n                        const variable = reference.resolved;\r\n\r\n                        if (segmentInfo.isOutdated(codePath.currentSegments, variable)) {\r\n                            if (node.parent.left === reference.identifier) {\r\n                                context.report({\r\n                                    node: node.parent,\r\n                                    messageId: \"nonAtomicUpdate\",\r\n                                    data: {\r\n                                        value: variable.name\r\n                                    }\r\n                                });\r\n                            } else if (!allowProperties) {\r\n                                context.report({\r\n                                    node: node.parent,\r\n                                    messageId: \"nonAtomicObjectUpdate\",\r\n                                    data: {\r\n                                        value: sourceCode.getText(node.parent.left),\r\n                                        object: variable.name\r\n                                    }\r\n                                });\r\n                            }\r\n\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}