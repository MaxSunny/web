{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag non-camelcased identifiers\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce camelcase naming convention\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/camelcase\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImports: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        },\n        allow: {\n          type: \"array\",\n          items: [{\n            type: \"string\"\n          }],\n          minItems: 0,\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\n      notCamelCasePrivate: \"#{{name}} is not in camel case.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const properties = options.properties === \"never\" ? \"never\" : \"always\";\n    const ignoreDestructuring = options.ignoreDestructuring;\n    const ignoreImports = options.ignoreImports;\n    const ignoreGlobals = options.ignoreGlobals;\n    const allow = options.allow || []; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n\n    const reported = new Set();\n    /**\r\n     * Checks if a string contains an underscore and isn't all upper-case\r\n     * @param {string} name The string to check.\r\n     * @returns {boolean} if the string is underscored\r\n     * @private\r\n     */\n\n    function isUnderscored(name) {\n      const nameBody = name.replace(/^_+|_+$/gu, \"\"); // if there's an underscore, it might be A_CONSTANT, which is okay\n\n      return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\n    }\n    /**\r\n     * Checks if a string match the ignore list\r\n     * @param {string} name The string to check.\r\n     * @returns {boolean} if the string is ignored\r\n     * @private\r\n     */\n\n\n    function isAllowed(name) {\n      return allow.some(entry => name === entry || name.match(new RegExp(entry, \"u\")));\n    }\n    /**\r\n     * Checks if a given name is good or not.\r\n     * @param {string} name The name to check.\r\n     * @returns {boolean} `true` if the name is good.\r\n     * @private\r\n     */\n\n\n    function isGoodName(name) {\n      return !isUnderscored(name) || isAllowed(name);\n    }\n    /**\r\n     * Checks if a given identifier reference or member expression is an assignment\r\n     * target.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node is an assignment target.\r\n     */\n\n\n    function isAssignmentTarget(node) {\n      const parent = node.parent;\n\n      switch (parent.type) {\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          return parent.left === node;\n\n        case \"Property\":\n          return parent.parent.type === \"ObjectPattern\" && parent.value === node;\n\n        case \"ArrayPattern\":\n        case \"RestElement\":\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * Checks if a given binding identifier uses the original name as-is.\r\n     * - If it's in object destructuring or object expression, the original name is its property name.\r\n     * - If it's in import declaration, the original name is its exported name.\r\n     * @param {ASTNode} node The `Identifier` node to check.\r\n     * @returns {boolean} `true` if the identifier uses the original name as-is.\r\n     */\n\n\n    function equalsToOriginalName(node) {\n      const localName = node.name;\n      const valueNode = node.parent.type === \"AssignmentPattern\" ? node.parent : node;\n      const parent = valueNode.parent;\n\n      switch (parent.type) {\n        case \"Property\":\n          return (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") && parent.value === valueNode && !parent.computed && parent.key.type === \"Identifier\" && parent.key.name === localName;\n\n        case \"ImportSpecifier\":\n          return parent.local === node && astUtils.getModuleExportName(parent.imported) === localName;\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * Reports an AST node as a rule violation.\r\n     * @param {ASTNode} node The node to report.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(node) {\n      if (reported.has(node.range[0])) {\n        return;\n      }\n\n      reported.add(node.range[0]); // Report it.\n\n      context.report({\n        node,\n        messageId: node.type === \"PrivateIdentifier\" ? \"notCamelCasePrivate\" : \"notCamelCase\",\n        data: {\n          name: node.name\n        }\n      });\n    }\n    /**\r\n     * Reports an identifier reference or a binding identifier.\r\n     * @param {ASTNode} node The `Identifier` node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function reportReferenceId(node) {\n      /*\r\n       * For backward compatibility, if it's in callings then ignore it.\r\n       * Not sure why it is.\r\n       */\n      if (node.parent.type === \"CallExpression\" || node.parent.type === \"NewExpression\") {\n        return;\n      }\n      /*\r\n       * For backward compatibility, if it's a default value of\r\n       * destructuring/parameters then ignore it.\r\n       * Not sure why it is.\r\n       */\n\n\n      if (node.parent.type === \"AssignmentPattern\" && node.parent.right === node) {\n        return;\n      }\n      /*\r\n       * The `ignoreDestructuring` flag skips the identifiers that uses\r\n       * the property name as-is.\r\n       */\n\n\n      if (ignoreDestructuring && equalsToOriginalName(node)) {\n        return;\n      }\n\n      report(node);\n    }\n\n    return {\n      // Report camelcase of global variable references ------------------\n      Program() {\n        const scope = context.getScope();\n\n        if (!ignoreGlobals) {\n          // Defined globals in config files or directive comments.\n          for (const variable of scope.variables) {\n            if (variable.identifiers.length > 0 || isGoodName(variable.name)) {\n              continue;\n            }\n\n            for (const reference of variable.references) {\n              /*\r\n               * For backward compatibility, this rule reports read-only\r\n               * references as well.\r\n               */\n              reportReferenceId(reference.identifier);\n            }\n          }\n        } // Undefined globals.\n\n\n        for (const reference of scope.through) {\n          const id = reference.identifier;\n\n          if (isGoodName(id.name)) {\n            continue;\n          }\n          /*\r\n           * For backward compatibility, this rule reports read-only\r\n           * references as well.\r\n           */\n\n\n          reportReferenceId(id);\n        }\n      },\n\n      // Report camelcase of declared variables --------------------------\n      [[\"VariableDeclaration\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\", \"ClassDeclaration\", \"ClassExpression\", \"CatchClause\"]](node) {\n        for (const variable of context.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n\n          const id = variable.identifiers[0]; // Report declaration.\n\n          if (!(ignoreDestructuring && equalsToOriginalName(id))) {\n            report(id);\n          }\n          /*\r\n           * For backward compatibility, report references as well.\r\n           * It looks unnecessary because declarations are reported.\r\n           */\n\n\n          for (const reference of variable.references) {\n            if (reference.init) {\n              continue; // Skip the write references of initializers.\n            }\n\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n\n      // Report camelcase in properties ----------------------------------\n      [[\"ObjectExpression > Property[computed!=true] > Identifier.key\", \"MethodDefinition[computed!=true] > Identifier.key\", \"PropertyDefinition[computed!=true] > Identifier.key\", \"MethodDefinition > PrivateIdentifier.key\", \"PropertyDefinition > PrivateIdentifier.key\"]](node) {\n        if (properties === \"never\" || isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      \"MemberExpression[computed!=true] > Identifier.property\"(node) {\n        if (properties === \"never\" || !isAssignmentTarget(node.parent) || // ← ignore read-only references.\n        isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      // Report camelcase in import --------------------------------------\n      ImportDeclaration(node) {\n        for (const variable of context.getDeclaredVariables(node)) {\n          if (isGoodName(variable.name)) {\n            continue;\n          }\n\n          const id = variable.identifiers[0]; // Report declaration.\n\n          if (!(ignoreImports && equalsToOriginalName(id))) {\n            report(id);\n          }\n          /*\r\n           * For backward compatibility, report references as well.\r\n           * It looks unnecessary because declarations are reported.\r\n           */\n\n\n          for (const reference of variable.references) {\n            reportReferenceId(reference.identifier);\n          }\n        }\n      },\n\n      // Report camelcase in re-export -----------------------------------\n      [[\"ExportAllDeclaration > Identifier.exported\", \"ExportSpecifier > Identifier.exported\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      },\n\n      // Report camelcase in labels --------------------------------------\n      [[\"LabeledStatement > Identifier.label\",\n      /*\r\n       * For backward compatibility, report references as well.\r\n       * It looks unnecessary because declarations are reported.\r\n       */\n      \"BreakStatement > Identifier.label\", \"ContinueStatement > Identifier.label\"]](node) {\n        if (isGoodName(node.name)) {\n          return;\n        }\n\n        report(node);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/camelcase.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","ignoreDestructuring","default","ignoreImports","ignoreGlobals","enum","allow","items","minItems","uniqueItems","additionalProperties","messages","notCamelCase","notCamelCasePrivate","create","context","options","reported","Set","isUnderscored","name","nameBody","replace","includes","toUpperCase","isAllowed","some","entry","match","RegExp","isGoodName","isAssignmentTarget","node","parent","left","value","equalsToOriginalName","localName","valueNode","computed","key","local","getModuleExportName","imported","report","has","range","add","messageId","data","reportReferenceId","right","Program","scope","getScope","variable","variables","identifiers","length","reference","references","identifier","through","id","getDeclaredVariables","init","ImportDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag non-camelcased identifiers\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce camelcase naming convention\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/camelcase\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignoreDestructuring: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoreImports: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoreGlobals: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    properties: {\r\n                        enum: [\"always\", \"never\"]\r\n                    },\r\n                    allow: {\r\n                        type: \"array\",\r\n                        items: [\r\n                            {\r\n                                type: \"string\"\r\n                            }\r\n                        ],\r\n                        minItems: 0,\r\n                        uniqueItems: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            notCamelCase: \"Identifier '{{name}}' is not in camel case.\",\r\n            notCamelCasePrivate: \"#{{name}} is not in camel case.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const properties = options.properties === \"never\" ? \"never\" : \"always\";\r\n        const ignoreDestructuring = options.ignoreDestructuring;\r\n        const ignoreImports = options.ignoreImports;\r\n        const ignoreGlobals = options.ignoreGlobals;\r\n        const allow = options.allow || [];\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\r\n        const reported = new Set();\r\n\r\n        /**\r\n         * Checks if a string contains an underscore and isn't all upper-case\r\n         * @param {string} name The string to check.\r\n         * @returns {boolean} if the string is underscored\r\n         * @private\r\n         */\r\n        function isUnderscored(name) {\r\n            const nameBody = name.replace(/^_+|_+$/gu, \"\");\r\n\r\n            // if there's an underscore, it might be A_CONSTANT, which is okay\r\n            return nameBody.includes(\"_\") && nameBody !== nameBody.toUpperCase();\r\n        }\r\n\r\n        /**\r\n         * Checks if a string match the ignore list\r\n         * @param {string} name The string to check.\r\n         * @returns {boolean} if the string is ignored\r\n         * @private\r\n         */\r\n        function isAllowed(name) {\r\n            return allow.some(\r\n                entry => name === entry || name.match(new RegExp(entry, \"u\"))\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks if a given name is good or not.\r\n         * @param {string} name The name to check.\r\n         * @returns {boolean} `true` if the name is good.\r\n         * @private\r\n         */\r\n        function isGoodName(name) {\r\n            return !isUnderscored(name) || isAllowed(name);\r\n        }\r\n\r\n        /**\r\n         * Checks if a given identifier reference or member expression is an assignment\r\n         * target.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} `true` if the node is an assignment target.\r\n         */\r\n        function isAssignmentTarget(node) {\r\n            const parent = node.parent;\r\n\r\n            switch (parent.type) {\r\n                case \"AssignmentExpression\":\r\n                case \"AssignmentPattern\":\r\n                    return parent.left === node;\r\n\r\n                case \"Property\":\r\n                    return (\r\n                        parent.parent.type === \"ObjectPattern\" &&\r\n                        parent.value === node\r\n                    );\r\n                case \"ArrayPattern\":\r\n                case \"RestElement\":\r\n                    return true;\r\n\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks if a given binding identifier uses the original name as-is.\r\n         * - If it's in object destructuring or object expression, the original name is its property name.\r\n         * - If it's in import declaration, the original name is its exported name.\r\n         * @param {ASTNode} node The `Identifier` node to check.\r\n         * @returns {boolean} `true` if the identifier uses the original name as-is.\r\n         */\r\n        function equalsToOriginalName(node) {\r\n            const localName = node.name;\r\n            const valueNode = node.parent.type === \"AssignmentPattern\"\r\n                ? node.parent\r\n                : node;\r\n            const parent = valueNode.parent;\r\n\r\n            switch (parent.type) {\r\n                case \"Property\":\r\n                    return (\r\n                        (parent.parent.type === \"ObjectPattern\" || parent.parent.type === \"ObjectExpression\") &&\r\n                        parent.value === valueNode &&\r\n                        !parent.computed &&\r\n                        parent.key.type === \"Identifier\" &&\r\n                        parent.key.name === localName\r\n                    );\r\n\r\n                case \"ImportSpecifier\":\r\n                    return (\r\n                        parent.local === node &&\r\n                        astUtils.getModuleExportName(parent.imported) === localName\r\n                    );\r\n\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports an AST node as a rule violation.\r\n         * @param {ASTNode} node The node to report.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node) {\r\n            if (reported.has(node.range[0])) {\r\n                return;\r\n            }\r\n            reported.add(node.range[0]);\r\n\r\n            // Report it.\r\n            context.report({\r\n                node,\r\n                messageId: node.type === \"PrivateIdentifier\"\r\n                    ? \"notCamelCasePrivate\"\r\n                    : \"notCamelCase\",\r\n                data: { name: node.name }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports an identifier reference or a binding identifier.\r\n         * @param {ASTNode} node The `Identifier` node to report.\r\n         * @returns {void}\r\n         */\r\n        function reportReferenceId(node) {\r\n\r\n            /*\r\n             * For backward compatibility, if it's in callings then ignore it.\r\n             * Not sure why it is.\r\n             */\r\n            if (\r\n                node.parent.type === \"CallExpression\" ||\r\n                node.parent.type === \"NewExpression\"\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * For backward compatibility, if it's a default value of\r\n             * destructuring/parameters then ignore it.\r\n             * Not sure why it is.\r\n             */\r\n            if (\r\n                node.parent.type === \"AssignmentPattern\" &&\r\n                node.parent.right === node\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * The `ignoreDestructuring` flag skips the identifiers that uses\r\n             * the property name as-is.\r\n             */\r\n            if (ignoreDestructuring && equalsToOriginalName(node)) {\r\n                return;\r\n            }\r\n\r\n            report(node);\r\n        }\r\n\r\n        return {\r\n\r\n            // Report camelcase of global variable references ------------------\r\n            Program() {\r\n                const scope = context.getScope();\r\n\r\n                if (!ignoreGlobals) {\r\n\r\n                    // Defined globals in config files or directive comments.\r\n                    for (const variable of scope.variables) {\r\n                        if (\r\n                            variable.identifiers.length > 0 ||\r\n                            isGoodName(variable.name)\r\n                        ) {\r\n                            continue;\r\n                        }\r\n                        for (const reference of variable.references) {\r\n\r\n                            /*\r\n                             * For backward compatibility, this rule reports read-only\r\n                             * references as well.\r\n                             */\r\n                            reportReferenceId(reference.identifier);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Undefined globals.\r\n                for (const reference of scope.through) {\r\n                    const id = reference.identifier;\r\n\r\n                    if (isGoodName(id.name)) {\r\n                        continue;\r\n                    }\r\n\r\n                    /*\r\n                     * For backward compatibility, this rule reports read-only\r\n                     * references as well.\r\n                     */\r\n                    reportReferenceId(id);\r\n                }\r\n            },\r\n\r\n            // Report camelcase of declared variables --------------------------\r\n            [[\r\n                \"VariableDeclaration\",\r\n                \"FunctionDeclaration\",\r\n                \"FunctionExpression\",\r\n                \"ArrowFunctionExpression\",\r\n                \"ClassDeclaration\",\r\n                \"ClassExpression\",\r\n                \"CatchClause\"\r\n            ]](node) {\r\n                for (const variable of context.getDeclaredVariables(node)) {\r\n                    if (isGoodName(variable.name)) {\r\n                        continue;\r\n                    }\r\n                    const id = variable.identifiers[0];\r\n\r\n                    // Report declaration.\r\n                    if (!(ignoreDestructuring && equalsToOriginalName(id))) {\r\n                        report(id);\r\n                    }\r\n\r\n                    /*\r\n                     * For backward compatibility, report references as well.\r\n                     * It looks unnecessary because declarations are reported.\r\n                     */\r\n                    for (const reference of variable.references) {\r\n                        if (reference.init) {\r\n                            continue; // Skip the write references of initializers.\r\n                        }\r\n                        reportReferenceId(reference.identifier);\r\n                    }\r\n                }\r\n            },\r\n\r\n            // Report camelcase in properties ----------------------------------\r\n            [[\r\n                \"ObjectExpression > Property[computed!=true] > Identifier.key\",\r\n                \"MethodDefinition[computed!=true] > Identifier.key\",\r\n                \"PropertyDefinition[computed!=true] > Identifier.key\",\r\n                \"MethodDefinition > PrivateIdentifier.key\",\r\n                \"PropertyDefinition > PrivateIdentifier.key\"\r\n            ]](node) {\r\n                if (properties === \"never\" || isGoodName(node.name)) {\r\n                    return;\r\n                }\r\n                report(node);\r\n            },\r\n            \"MemberExpression[computed!=true] > Identifier.property\"(node) {\r\n                if (\r\n                    properties === \"never\" ||\r\n                    !isAssignmentTarget(node.parent) || // ← ignore read-only references.\r\n                    isGoodName(node.name)\r\n                ) {\r\n                    return;\r\n                }\r\n                report(node);\r\n            },\r\n\r\n            // Report camelcase in import --------------------------------------\r\n            ImportDeclaration(node) {\r\n                for (const variable of context.getDeclaredVariables(node)) {\r\n                    if (isGoodName(variable.name)) {\r\n                        continue;\r\n                    }\r\n                    const id = variable.identifiers[0];\r\n\r\n                    // Report declaration.\r\n                    if (!(ignoreImports && equalsToOriginalName(id))) {\r\n                        report(id);\r\n                    }\r\n\r\n                    /*\r\n                     * For backward compatibility, report references as well.\r\n                     * It looks unnecessary because declarations are reported.\r\n                     */\r\n                    for (const reference of variable.references) {\r\n                        reportReferenceId(reference.identifier);\r\n                    }\r\n                }\r\n            },\r\n\r\n            // Report camelcase in re-export -----------------------------------\r\n            [[\r\n                \"ExportAllDeclaration > Identifier.exported\",\r\n                \"ExportSpecifier > Identifier.exported\"\r\n            ]](node) {\r\n                if (isGoodName(node.name)) {\r\n                    return;\r\n                }\r\n                report(node);\r\n            },\r\n\r\n            // Report camelcase in labels --------------------------------------\r\n            [[\r\n                \"LabeledStatement > Identifier.label\",\r\n\r\n                /*\r\n                 * For backward compatibility, report references as well.\r\n                 * It looks unnecessary because declarations are reported.\r\n                 */\r\n                \"BreakStatement > Identifier.label\",\r\n                \"ContinueStatement > Identifier.label\"\r\n            ]](node) {\r\n                if (isGoodName(node.name)) {\r\n                    return;\r\n                }\r\n                report(node);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}