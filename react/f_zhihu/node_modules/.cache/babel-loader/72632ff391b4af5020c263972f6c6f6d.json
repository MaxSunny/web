{"ast":null,"code":"/**\r\n * @fileoverview A class to operate forking.\r\n *\r\n * This is state of forking.\r\n * This has a fork list and manages it.\r\n *\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      CodePathSegment = require(\"./code-path-segment\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets whether or not a given segment is reachable.\r\n * @param {CodePathSegment} segment A segment to get.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\r\n * Creates new segments from the specific range of `context.segmentsList`.\r\n *\r\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\r\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\r\n * This `h` is from `b`, `d`, and `f`.\r\n * @param {ForkContext} context An instance.\r\n * @param {number} begin The first index of the previous segments.\r\n * @param {number} end The last index of the previous segments.\r\n * @param {Function} create A factory function of new segments.\r\n * @returns {CodePathSegment[]} New segments.\r\n */\n\n\nfunction makeSegments(context, begin, end, create) {\n  const list = context.segmentsList;\n  const normalizedBegin = begin >= 0 ? begin : list.length + begin;\n  const normalizedEnd = end >= 0 ? end : list.length + end;\n  const segments = [];\n\n  for (let i = 0; i < context.count; ++i) {\n    const allPrevSegments = [];\n\n    for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\n      allPrevSegments.push(list[j][i]);\n    }\n\n    segments.push(create(context.idGenerator.next(), allPrevSegments));\n  }\n\n  return segments;\n}\n/**\r\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\r\n * control statement (such as `break`, `continue`) from the `finally` block, the\r\n * destination's segments may be half of the source segments. In that case, this\r\n * merges segments.\r\n * @param {ForkContext} context An instance.\r\n * @param {CodePathSegment[]} segments Segments to merge.\r\n * @returns {CodePathSegment[]} The merged segments.\r\n */\n\n\nfunction mergeExtraSegments(context, segments) {\n  let currentSegments = segments;\n\n  while (currentSegments.length > context.count) {\n    const merged = [];\n\n    for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\n      merged.push(CodePathSegment.newNext(context.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));\n    }\n\n    currentSegments = merged;\n  }\n\n  return currentSegments;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * A class to manage forking.\r\n */\n\n\nclass ForkContext {\n  /**\r\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\r\n   * @param {ForkContext|null} upper An upper fork context.\r\n   * @param {number} count A number of parallel segments.\r\n   */\n  constructor(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n  }\n  /**\r\n   * The head segments.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get head() {\n    const list = this.segmentsList;\n    return list.length === 0 ? [] : list[list.length - 1];\n  }\n  /**\r\n   * A flag which shows empty.\r\n   * @type {boolean}\r\n   */\n\n\n  get empty() {\n    return this.segmentsList.length === 0;\n  }\n  /**\r\n   * A flag which shows reachable.\r\n   * @type {boolean}\r\n   */\n\n\n  get reachable() {\n    const segments = this.head;\n    return segments.length > 0 && segments.some(isReachable);\n  }\n  /**\r\n   * Creates new segments from this context.\r\n   * @param {number} begin The first index of previous segments.\r\n   * @param {number} end The last index of previous segments.\r\n   * @returns {CodePathSegment[]} New segments.\r\n   */\n\n\n  makeNext(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newNext);\n  }\n  /**\r\n   * Creates new segments from this context.\r\n   * The new segments is always unreachable.\r\n   * @param {number} begin The first index of previous segments.\r\n   * @param {number} end The last index of previous segments.\r\n   * @returns {CodePathSegment[]} New segments.\r\n   */\n\n\n  makeUnreachable(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n  }\n  /**\r\n   * Creates new segments from this context.\r\n   * The new segments don't have connections for previous segments.\r\n   * But these inherit the reachable flag from this context.\r\n   * @param {number} begin The first index of previous segments.\r\n   * @param {number} end The last index of previous segments.\r\n   * @returns {CodePathSegment[]} New segments.\r\n   */\n\n\n  makeDisconnected(begin, end) {\n    return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n  }\n  /**\r\n   * Adds segments into this context.\r\n   * The added segments become the head.\r\n   * @param {CodePathSegment[]} segments Segments to add.\r\n   * @returns {void}\r\n   */\n\n\n  add(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.push(mergeExtraSegments(this, segments));\n  }\n  /**\r\n   * Replaces the head segments with given segments.\r\n   * The current head segments are removed.\r\n   * @param {CodePathSegment[]} segments Segments to add.\r\n   * @returns {void}\r\n   */\n\n\n  replaceHead(segments) {\n    assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\n    this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n  }\n  /**\r\n   * Adds all segments of a given fork context into this context.\r\n   * @param {ForkContext} context A fork context to add.\r\n   * @returns {void}\r\n   */\n\n\n  addAll(context) {\n    assert(context.count === this.count);\n    const source = context.segmentsList;\n\n    for (let i = 0; i < source.length; ++i) {\n      this.segmentsList.push(source[i]);\n    }\n  }\n  /**\r\n   * Clears all segments in this context.\r\n   * @returns {void}\r\n   */\n\n\n  clear() {\n    this.segmentsList = [];\n  }\n  /**\r\n   * Creates the root fork context.\r\n   * @param {IdGenerator} idGenerator An identifier generator for segments.\r\n   * @returns {ForkContext} New fork context.\r\n   */\n\n\n  static newRoot(idGenerator) {\n    const context = new ForkContext(idGenerator, null, 1);\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n    return context;\n  }\n  /**\r\n   * Creates an empty fork context preceded by a given context.\r\n   * @param {ForkContext} parentContext The parent fork context.\r\n   * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\r\n   * @returns {ForkContext} New fork context.\r\n   */\n\n\n  static newEmpty(parentContext, forkLeavingPath) {\n    return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);\n  }\n\n}\n\nmodule.exports = ForkContext;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/fork-context.js"],"names":["assert","require","CodePathSegment","isReachable","segment","reachable","makeSegments","context","begin","end","create","list","segmentsList","normalizedBegin","length","normalizedEnd","segments","i","count","allPrevSegments","j","push","idGenerator","next","mergeExtraSegments","currentSegments","merged","newNext","ForkContext","constructor","upper","head","empty","some","makeNext","makeUnreachable","newUnreachable","makeDisconnected","newDisconnected","add","replaceHead","splice","addAll","source","clear","newRoot","newEmpty","parentContext","forkLeavingPath","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;AAAA,MACIC,eAAe,GAAGD,OAAO,CAAC,qBAAD,CAD7B,C,CAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,SAASE,WAAT,CAAqBC,OAArB,EAA8B;AAC1B,SAAOA,OAAO,CAACC,SAAf;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,KAA/B,EAAsCC,GAAtC,EAA2CC,MAA3C,EAAmD;AAC/C,QAAMC,IAAI,GAAGJ,OAAO,CAACK,YAArB;AAEA,QAAMC,eAAe,GAAGL,KAAK,IAAI,CAAT,GAAaA,KAAb,GAAqBG,IAAI,CAACG,MAAL,GAAcN,KAA3D;AACA,QAAMO,aAAa,GAAGN,GAAG,IAAI,CAAP,GAAWA,GAAX,GAAiBE,IAAI,CAACG,MAAL,GAAcL,GAArD;AAEA,QAAMO,QAAQ,GAAG,EAAjB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,OAAO,CAACW,KAA5B,EAAmC,EAAED,CAArC,EAAwC;AACpC,UAAME,eAAe,GAAG,EAAxB;;AAEA,SAAK,IAAIC,CAAC,GAAGP,eAAb,EAA8BO,CAAC,IAAIL,aAAnC,EAAkD,EAAEK,CAApD,EAAuD;AACnDD,MAAAA,eAAe,CAACE,IAAhB,CAAqBV,IAAI,CAACS,CAAD,CAAJ,CAAQH,CAAR,CAArB;AACH;;AAEDD,IAAAA,QAAQ,CAACK,IAAT,CAAcX,MAAM,CAACH,OAAO,CAACe,WAAR,CAAoBC,IAApB,EAAD,EAA6BJ,eAA7B,CAApB;AACH;;AAED,SAAOH,QAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,kBAAT,CAA4BjB,OAA5B,EAAqCS,QAArC,EAA+C;AAC3C,MAAIS,eAAe,GAAGT,QAAtB;;AAEA,SAAOS,eAAe,CAACX,MAAhB,GAAyBP,OAAO,CAACW,KAAxC,EAA+C;AAC3C,UAAMQ,MAAM,GAAG,EAAf;;AAEA,SAAK,IAAIT,CAAC,GAAG,CAAR,EAAWH,MAAM,GAAGW,eAAe,CAACX,MAAhB,GAAyB,CAAzB,GAA6B,CAAtD,EAAyDG,CAAC,GAAGH,MAA7D,EAAqE,EAAEG,CAAvE,EAA0E;AACtES,MAAAA,MAAM,CAACL,IAAP,CAAYnB,eAAe,CAACyB,OAAhB,CACRpB,OAAO,CAACe,WAAR,CAAoBC,IAApB,EADQ,EAER,CAACE,eAAe,CAACR,CAAD,CAAhB,EAAqBQ,eAAe,CAACR,CAAC,GAAGH,MAAL,CAApC,CAFQ,CAAZ;AAIH;;AACDW,IAAAA,eAAe,GAAGC,MAAlB;AACH;;AACD,SAAOD,eAAP;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMG,WAAN,CAAkB;AAEd;AACJ;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACP,WAAD,EAAcQ,KAAd,EAAqBZ,KAArB,EAA4B;AACnC,SAAKI,WAAL,GAAmBA,WAAnB;AACA,SAAKQ,KAAL,GAAaA,KAAb;AACA,SAAKZ,KAAL,GAAaA,KAAb;AACA,SAAKN,YAAL,GAAoB,EAApB;AACH;AAED;AACJ;AACA;AACA;;;AACY,MAAJmB,IAAI,GAAG;AACP,UAAMpB,IAAI,GAAG,KAAKC,YAAlB;AAEA,WAAOD,IAAI,CAACG,MAAL,KAAgB,CAAhB,GAAoB,EAApB,GAAyBH,IAAI,CAACA,IAAI,CAACG,MAAL,GAAc,CAAf,CAApC;AACH;AAED;AACJ;AACA;AACA;;;AACa,MAALkB,KAAK,GAAG;AACR,WAAO,KAAKpB,YAAL,CAAkBE,MAAlB,KAA6B,CAApC;AACH;AAED;AACJ;AACA;AACA;;;AACiB,MAATT,SAAS,GAAG;AACZ,UAAMW,QAAQ,GAAG,KAAKe,IAAtB;AAEA,WAAOf,QAAQ,CAACF,MAAT,GAAkB,CAAlB,IAAuBE,QAAQ,CAACiB,IAAT,CAAc9B,WAAd,CAA9B;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI+B,EAAAA,QAAQ,CAAC1B,KAAD,EAAQC,GAAR,EAAa;AACjB,WAAOH,YAAY,CAAC,IAAD,EAAOE,KAAP,EAAcC,GAAd,EAAmBP,eAAe,CAACyB,OAAnC,CAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIQ,EAAAA,eAAe,CAAC3B,KAAD,EAAQC,GAAR,EAAa;AACxB,WAAOH,YAAY,CAAC,IAAD,EAAOE,KAAP,EAAcC,GAAd,EAAmBP,eAAe,CAACkC,cAAnC,CAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,gBAAgB,CAAC7B,KAAD,EAAQC,GAAR,EAAa;AACzB,WAAOH,YAAY,CAAC,IAAD,EAAOE,KAAP,EAAcC,GAAd,EAAmBP,eAAe,CAACoC,eAAnC,CAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,GAAG,CAACvB,QAAD,EAAW;AACVhB,IAAAA,MAAM,CAACgB,QAAQ,CAACF,MAAT,IAAmB,KAAKI,KAAzB,EAAiC,GAAEF,QAAQ,CAACF,MAAO,OAAM,KAAKI,KAAM,EAApE,CAAN;AAEA,SAAKN,YAAL,CAAkBS,IAAlB,CAAuBG,kBAAkB,CAAC,IAAD,EAAOR,QAAP,CAAzC;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIwB,EAAAA,WAAW,CAACxB,QAAD,EAAW;AAClBhB,IAAAA,MAAM,CAACgB,QAAQ,CAACF,MAAT,IAAmB,KAAKI,KAAzB,EAAiC,GAAEF,QAAQ,CAACF,MAAO,OAAM,KAAKI,KAAM,EAApE,CAAN;AAEA,SAAKN,YAAL,CAAkB6B,MAAlB,CAAyB,CAAC,CAA1B,EAA6B,CAA7B,EAAgCjB,kBAAkB,CAAC,IAAD,EAAOR,QAAP,CAAlD;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI0B,EAAAA,MAAM,CAACnC,OAAD,EAAU;AACZP,IAAAA,MAAM,CAACO,OAAO,CAACW,KAAR,KAAkB,KAAKA,KAAxB,CAAN;AAEA,UAAMyB,MAAM,GAAGpC,OAAO,CAACK,YAAvB;;AAEA,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0B,MAAM,CAAC7B,MAA3B,EAAmC,EAAEG,CAArC,EAAwC;AACpC,WAAKL,YAAL,CAAkBS,IAAlB,CAAuBsB,MAAM,CAAC1B,CAAD,CAA7B;AACH;AACJ;AAED;AACJ;AACA;AACA;;;AACI2B,EAAAA,KAAK,GAAG;AACJ,SAAKhC,YAAL,GAAoB,EAApB;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACkB,SAAPiC,OAAO,CAACvB,WAAD,EAAc;AACxB,UAAMf,OAAO,GAAG,IAAIqB,WAAJ,CAAgBN,WAAhB,EAA6B,IAA7B,EAAmC,CAAnC,CAAhB;AAEAf,IAAAA,OAAO,CAACgC,GAAR,CAAY,CAACrC,eAAe,CAAC2C,OAAhB,CAAwBvB,WAAW,CAACC,IAAZ,EAAxB,CAAD,CAAZ;AAEA,WAAOhB,OAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACmB,SAARuC,QAAQ,CAACC,aAAD,EAAgBC,eAAhB,EAAiC;AAC5C,WAAO,IAAIpB,WAAJ,CACHmB,aAAa,CAACzB,WADX,EAEHyB,aAFG,EAGH,CAACC,eAAe,GAAG,CAAH,GAAO,CAAvB,IAA4BD,aAAa,CAAC7B,KAHvC,CAAP;AAKH;;AAnJa;;AAsJlB+B,MAAM,CAACC,OAAP,GAAiBtB,WAAjB","sourcesContent":["/**\r\n * @fileoverview A class to operate forking.\r\n *\r\n * This is state of forking.\r\n * This has a fork list and manages it.\r\n *\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst assert = require(\"assert\"),\r\n    CodePathSegment = require(\"./code-path-segment\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets whether or not a given segment is reachable.\r\n * @param {CodePathSegment} segment A segment to get.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n/**\r\n * Creates new segments from the specific range of `context.segmentsList`.\r\n *\r\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\r\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\r\n * This `h` is from `b`, `d`, and `f`.\r\n * @param {ForkContext} context An instance.\r\n * @param {number} begin The first index of the previous segments.\r\n * @param {number} end The last index of the previous segments.\r\n * @param {Function} create A factory function of new segments.\r\n * @returns {CodePathSegment[]} New segments.\r\n */\r\nfunction makeSegments(context, begin, end, create) {\r\n    const list = context.segmentsList;\r\n\r\n    const normalizedBegin = begin >= 0 ? begin : list.length + begin;\r\n    const normalizedEnd = end >= 0 ? end : list.length + end;\r\n\r\n    const segments = [];\r\n\r\n    for (let i = 0; i < context.count; ++i) {\r\n        const allPrevSegments = [];\r\n\r\n        for (let j = normalizedBegin; j <= normalizedEnd; ++j) {\r\n            allPrevSegments.push(list[j][i]);\r\n        }\r\n\r\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\r\n    }\r\n\r\n    return segments;\r\n}\r\n\r\n/**\r\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\r\n * control statement (such as `break`, `continue`) from the `finally` block, the\r\n * destination's segments may be half of the source segments. In that case, this\r\n * merges segments.\r\n * @param {ForkContext} context An instance.\r\n * @param {CodePathSegment[]} segments Segments to merge.\r\n * @returns {CodePathSegment[]} The merged segments.\r\n */\r\nfunction mergeExtraSegments(context, segments) {\r\n    let currentSegments = segments;\r\n\r\n    while (currentSegments.length > context.count) {\r\n        const merged = [];\r\n\r\n        for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {\r\n            merged.push(CodePathSegment.newNext(\r\n                context.idGenerator.next(),\r\n                [currentSegments[i], currentSegments[i + length]]\r\n            ));\r\n        }\r\n        currentSegments = merged;\r\n    }\r\n    return currentSegments;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * A class to manage forking.\r\n */\r\nclass ForkContext {\r\n\r\n    /**\r\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\r\n     * @param {ForkContext|null} upper An upper fork context.\r\n     * @param {number} count A number of parallel segments.\r\n     */\r\n    constructor(idGenerator, upper, count) {\r\n        this.idGenerator = idGenerator;\r\n        this.upper = upper;\r\n        this.count = count;\r\n        this.segmentsList = [];\r\n    }\r\n\r\n    /**\r\n     * The head segments.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get head() {\r\n        const list = this.segmentsList;\r\n\r\n        return list.length === 0 ? [] : list[list.length - 1];\r\n    }\r\n\r\n    /**\r\n     * A flag which shows empty.\r\n     * @type {boolean}\r\n     */\r\n    get empty() {\r\n        return this.segmentsList.length === 0;\r\n    }\r\n\r\n    /**\r\n     * A flag which shows reachable.\r\n     * @type {boolean}\r\n     */\r\n    get reachable() {\r\n        const segments = this.head;\r\n\r\n        return segments.length > 0 && segments.some(isReachable);\r\n    }\r\n\r\n    /**\r\n     * Creates new segments from this context.\r\n     * @param {number} begin The first index of previous segments.\r\n     * @param {number} end The last index of previous segments.\r\n     * @returns {CodePathSegment[]} New segments.\r\n     */\r\n    makeNext(begin, end) {\r\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\r\n    }\r\n\r\n    /**\r\n     * Creates new segments from this context.\r\n     * The new segments is always unreachable.\r\n     * @param {number} begin The first index of previous segments.\r\n     * @param {number} end The last index of previous segments.\r\n     * @returns {CodePathSegment[]} New segments.\r\n     */\r\n    makeUnreachable(begin, end) {\r\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\r\n    }\r\n\r\n    /**\r\n     * Creates new segments from this context.\r\n     * The new segments don't have connections for previous segments.\r\n     * But these inherit the reachable flag from this context.\r\n     * @param {number} begin The first index of previous segments.\r\n     * @param {number} end The last index of previous segments.\r\n     * @returns {CodePathSegment[]} New segments.\r\n     */\r\n    makeDisconnected(begin, end) {\r\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\r\n    }\r\n\r\n    /**\r\n     * Adds segments into this context.\r\n     * The added segments become the head.\r\n     * @param {CodePathSegment[]} segments Segments to add.\r\n     * @returns {void}\r\n     */\r\n    add(segments) {\r\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\r\n\r\n        this.segmentsList.push(mergeExtraSegments(this, segments));\r\n    }\r\n\r\n    /**\r\n     * Replaces the head segments with given segments.\r\n     * The current head segments are removed.\r\n     * @param {CodePathSegment[]} segments Segments to add.\r\n     * @returns {void}\r\n     */\r\n    replaceHead(segments) {\r\n        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);\r\n\r\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\r\n    }\r\n\r\n    /**\r\n     * Adds all segments of a given fork context into this context.\r\n     * @param {ForkContext} context A fork context to add.\r\n     * @returns {void}\r\n     */\r\n    addAll(context) {\r\n        assert(context.count === this.count);\r\n\r\n        const source = context.segmentsList;\r\n\r\n        for (let i = 0; i < source.length; ++i) {\r\n            this.segmentsList.push(source[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears all segments in this context.\r\n     * @returns {void}\r\n     */\r\n    clear() {\r\n        this.segmentsList = [];\r\n    }\r\n\r\n    /**\r\n     * Creates the root fork context.\r\n     * @param {IdGenerator} idGenerator An identifier generator for segments.\r\n     * @returns {ForkContext} New fork context.\r\n     */\r\n    static newRoot(idGenerator) {\r\n        const context = new ForkContext(idGenerator, null, 1);\r\n\r\n        context.add([CodePathSegment.newRoot(idGenerator.next())]);\r\n\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Creates an empty fork context preceded by a given context.\r\n     * @param {ForkContext} parentContext The parent fork context.\r\n     * @param {boolean} forkLeavingPath A flag which shows inside of `finally` block.\r\n     * @returns {ForkContext} New fork context.\r\n     */\r\n    static newEmpty(parentContext, forkLeavingPath) {\r\n        return new ForkContext(\r\n            parentContext.idGenerator,\r\n            parentContext,\r\n            (forkLeavingPath ? 2 : 1) * parentContext.count\r\n        );\r\n    }\r\n}\r\n\r\nmodule.exports = ForkContext;\r\n"]},"metadata":{},"sourceType":"script"}