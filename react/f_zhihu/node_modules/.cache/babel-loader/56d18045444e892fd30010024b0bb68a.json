{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag blocks with no reason to exist\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary nested blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-lone-blocks\"\n    },\n    schema: [],\n    messages: {\n      redundantBlock: \"Block is redundant.\",\n      redundantNestedBlock: \"Nested block is redundant.\"\n    }\n  },\n\n  create(context) {\n    // A stack of lone blocks to be checked for block-level bindings\n    const loneBlocks = [];\n    let ruleDef;\n    /**\r\n     * Reports a node as invalid.\r\n     * @param {ASTNode} node The node to be reported.\r\n     * @returns {void}\r\n     */\n\n    function report(node) {\n      const messageId = node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\" ? \"redundantNestedBlock\" : \"redundantBlock\";\n      context.report({\n        node,\n        messageId\n      });\n    }\n    /**\r\n     * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} True if the node is a lone block.\r\n     */\n\n\n    function isLoneBlock(node) {\n      return node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\" || node.parent.type === \"Program\" || // Don't report blocks in switch cases if the block is the only statement of the case.\n      node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\n    }\n    /**\r\n     * Checks the enclosing block of the current node for block-level bindings,\r\n     * and \"marks it\" as valid if any.\r\n     * @returns {void}\r\n     */\n\n\n    function markLoneBlock() {\n      if (loneBlocks.length === 0) {\n        return;\n      }\n\n      const block = context.getAncestors().pop();\n\n      if (loneBlocks[loneBlocks.length - 1] === block) {\n        loneBlocks.pop();\n      }\n    } // Default rule definition: report all lone blocks\n\n\n    ruleDef = {\n      BlockStatement(node) {\n        if (isLoneBlock(node)) {\n          report(node);\n        }\n      }\n\n    }; // ES6: report blocks without block-level bindings, or that's only child of another block\n\n    if (context.parserOptions.ecmaVersion >= 6) {\n      ruleDef = {\n        BlockStatement(node) {\n          if (isLoneBlock(node)) {\n            loneBlocks.push(node);\n          }\n        },\n\n        \"BlockStatement:exit\"(node) {\n          if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n            loneBlocks.pop();\n            report(node);\n          } else if ((node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\") && node.parent.body.length === 1) {\n            report(node);\n          }\n        }\n\n      };\n\n      ruleDef.VariableDeclaration = function (node) {\n        if (node.kind === \"let\" || node.kind === \"const\") {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.FunctionDeclaration = function () {\n        if (context.getScope().isStrict) {\n          markLoneBlock();\n        }\n      };\n\n      ruleDef.ClassDeclaration = markLoneBlock;\n    }\n\n    return ruleDef;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-lone-blocks.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","redundantBlock","redundantNestedBlock","create","context","loneBlocks","ruleDef","report","node","messageId","parent","isLoneBlock","consequent","length","markLoneBlock","block","getAncestors","pop","BlockStatement","parserOptions","ecmaVersion","push","body","VariableDeclaration","kind","FunctionDeclaration","getScope","isStrict","ClassDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag blocks with no reason to exist\r\n * @author Brandon Mills\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary nested blocks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-lone-blocks\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            redundantBlock: \"Block is redundant.\",\r\n            redundantNestedBlock: \"Nested block is redundant.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        // A stack of lone blocks to be checked for block-level bindings\r\n        const loneBlocks = [];\r\n        let ruleDef;\r\n\r\n        /**\r\n         * Reports a node as invalid.\r\n         * @param {ASTNode} node The node to be reported.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            const messageId = node.parent.type === \"BlockStatement\" || node.parent.type === \"StaticBlock\"\r\n                ? \"redundantNestedBlock\"\r\n                : \"redundantBlock\";\r\n\r\n            context.report({\r\n                node,\r\n                messageId\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} True if the node is a lone block.\r\n         */\r\n        function isLoneBlock(node) {\r\n            return node.parent.type === \"BlockStatement\" ||\r\n                node.parent.type === \"StaticBlock\" ||\r\n                node.parent.type === \"Program\" ||\r\n\r\n                // Don't report blocks in switch cases if the block is the only statement of the case.\r\n                node.parent.type === \"SwitchCase\" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);\r\n        }\r\n\r\n        /**\r\n         * Checks the enclosing block of the current node for block-level bindings,\r\n         * and \"marks it\" as valid if any.\r\n         * @returns {void}\r\n         */\r\n        function markLoneBlock() {\r\n            if (loneBlocks.length === 0) {\r\n                return;\r\n            }\r\n\r\n            const block = context.getAncestors().pop();\r\n\r\n            if (loneBlocks[loneBlocks.length - 1] === block) {\r\n                loneBlocks.pop();\r\n            }\r\n        }\r\n\r\n        // Default rule definition: report all lone blocks\r\n        ruleDef = {\r\n            BlockStatement(node) {\r\n                if (isLoneBlock(node)) {\r\n                    report(node);\r\n                }\r\n            }\r\n        };\r\n\r\n        // ES6: report blocks without block-level bindings, or that's only child of another block\r\n        if (context.parserOptions.ecmaVersion >= 6) {\r\n            ruleDef = {\r\n                BlockStatement(node) {\r\n                    if (isLoneBlock(node)) {\r\n                        loneBlocks.push(node);\r\n                    }\r\n                },\r\n                \"BlockStatement:exit\"(node) {\r\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\r\n                        loneBlocks.pop();\r\n                        report(node);\r\n                    } else if (\r\n                        (\r\n                            node.parent.type === \"BlockStatement\" ||\r\n                            node.parent.type === \"StaticBlock\"\r\n                        ) &&\r\n                        node.parent.body.length === 1\r\n                    ) {\r\n                        report(node);\r\n                    }\r\n                }\r\n            };\r\n\r\n            ruleDef.VariableDeclaration = function(node) {\r\n                if (node.kind === \"let\" || node.kind === \"const\") {\r\n                    markLoneBlock();\r\n                }\r\n            };\r\n\r\n            ruleDef.FunctionDeclaration = function() {\r\n                if (context.getScope().isStrict) {\r\n                    markLoneBlock();\r\n                }\r\n            };\r\n\r\n            ruleDef.ClassDeclaration = markLoneBlock;\r\n        }\r\n\r\n        return ruleDef;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}