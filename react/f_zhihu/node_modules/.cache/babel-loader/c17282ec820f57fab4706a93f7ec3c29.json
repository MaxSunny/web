{"ast":null,"code":"/**\r\n * @fileoverview Abstraction of JavaScript source code.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst {\n  isCommentToken\n} = require(\"eslint-utils\"),\n      TokenStore = require(\"./token-store\"),\n      astUtils = require(\"../shared/ast-utils\"),\n      Traverser = require(\"../shared/traverser\"); //------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\r\n * Validates that the given AST has the required information.\r\n * @param {ASTNode} ast The Program node of the AST to check.\r\n * @throws {Error} If the AST doesn't contain the correct information.\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction validate(ast) {\n  if (!ast.tokens) {\n    throw new Error(\"AST is missing the tokens array.\");\n  }\n\n  if (!ast.comments) {\n    throw new Error(\"AST is missing the comments array.\");\n  }\n\n  if (!ast.loc) {\n    throw new Error(\"AST is missing location information.\");\n  }\n\n  if (!ast.range) {\n    throw new Error(\"AST is missing range information\");\n  }\n}\n/**\r\n * Check to see if its a ES6 export declaration.\r\n * @param {ASTNode} astNode An AST node.\r\n * @returns {boolean} whether the given node represents an export declaration.\r\n * @private\r\n */\n\n\nfunction looksLikeExport(astNode) {\n  return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" || astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n/**\r\n * Merges two sorted lists into a larger sorted list in O(n) time.\r\n * @param {Token[]} tokens The list of tokens.\r\n * @param {Token[]} comments The list of comments.\r\n * @returns {Token[]} A sorted list of tokens and comments.\r\n * @private\r\n */\n\n\nfunction sortedMerge(tokens, comments) {\n  const result = [];\n  let tokenIndex = 0;\n  let commentIndex = 0;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\n      result.push(tokens[tokenIndex++]);\n    } else {\n      result.push(comments[commentIndex++]);\n    }\n  }\n\n  return result;\n}\n/**\r\n * Determines if two nodes or tokens overlap.\r\n * @param {ASTNode|Token} first The first node or token to check.\r\n * @param {ASTNode|Token} second The second node or token to check.\r\n * @returns {boolean} True if the two nodes or tokens overlap.\r\n * @private\r\n */\n\n\nfunction nodesOrTokensOverlap(first, second) {\n  return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];\n}\n/**\r\n * Determines if two nodes or tokens have at least one whitespace character\r\n * between them. Order does not matter. Returns false if the given nodes or\r\n * tokens overlap.\r\n * @param {SourceCode} sourceCode The source code object.\r\n * @param {ASTNode|Token} first The first node or token to check between.\r\n * @param {ASTNode|Token} second The second node or token to check between.\r\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\r\n * @returns {boolean} True if there is a whitespace character between\r\n * any of the tokens found between the two given nodes or tokens.\r\n * @public\r\n */\n\n\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\n  if (nodesOrTokensOverlap(first, second)) {\n    return false;\n  }\n\n  const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];\n  const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\n  const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\n  let currentToken = firstToken;\n\n  while (currentToken !== finalToken) {\n    const nextToken = sourceCode.getTokenAfter(currentToken, {\n      includeComments: true\n    });\n\n    if (currentToken.range[1] !== nextToken.range[0] ||\n    /*\r\n     * For backward compatibility, check spaces in JSXText.\r\n     * https://github.com/eslint/eslint/issues/12614\r\n     */\n    checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === \"JSXText\" && /\\s/u.test(nextToken.value)) {\n      return true;\n    }\n\n    currentToken = nextToken;\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * Represents parsed source code.\r\n */\n\n\nclass SourceCode extends TokenStore {\n  /**\r\n   * @param {string|Object} textOrConfig The source code text or config object.\r\n   * @param {string} textOrConfig.text The source code text.\r\n   * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\r\n   * @param {Object|null} textOrConfig.parserServices The parser services.\r\n   * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\r\n   * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\r\n   * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\r\n   */\n  constructor(textOrConfig, astIfNoConfig) {\n    let text, ast, parserServices, scopeManager, visitorKeys; // Process overloading.\n\n    if (typeof textOrConfig === \"string\") {\n      text = textOrConfig;\n      ast = astIfNoConfig;\n    } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\n      text = textOrConfig.text;\n      ast = textOrConfig.ast;\n      parserServices = textOrConfig.parserServices;\n      scopeManager = textOrConfig.scopeManager;\n      visitorKeys = textOrConfig.visitorKeys;\n    }\n\n    validate(ast);\n    super(ast.tokens, ast.comments);\n    /**\r\n     * The flag to indicate that the source code has Unicode BOM.\r\n     * @type {boolean}\r\n     */\n\n    this.hasBOM = text.charCodeAt(0) === 0xFEFF;\n    /**\r\n     * The original text source code.\r\n     * BOM was stripped from this text.\r\n     * @type {string}\r\n     */\n\n    this.text = this.hasBOM ? text.slice(1) : text;\n    /**\r\n     * The parsed AST for the source code.\r\n     * @type {ASTNode}\r\n     */\n\n    this.ast = ast;\n    /**\r\n     * The parser services of this source code.\r\n     * @type {Object}\r\n     */\n\n    this.parserServices = parserServices || {};\n    /**\r\n     * The scope of this source code.\r\n     * @type {ScopeManager|null}\r\n     */\n\n    this.scopeManager = scopeManager || null;\n    /**\r\n     * The visitor keys to traverse AST.\r\n     * @type {Object}\r\n     */\n\n    this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS; // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\n\n    const shebangMatched = this.text.match(astUtils.shebangPattern);\n    const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\n\n    if (hasShebang) {\n      ast.comments[0].type = \"Shebang\";\n    }\n\n    this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\n    /**\r\n     * The source code split into lines according to ECMA-262 specification.\r\n     * This is done to avoid each rule needing to do so separately.\r\n     * @type {string[]}\r\n     */\n\n    this.lines = [];\n    this.lineStartIndices = [0];\n    const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\n    let match;\n    /*\r\n     * Previously, this was implemented using a regex that\r\n     * matched a sequence of non-linebreak characters followed by a\r\n     * linebreak, then adding the lengths of the matches. However,\r\n     * this caused a catastrophic backtracking issue when the end\r\n     * of a file contained a large number of non-newline characters.\r\n     * To avoid this, the current implementation just matches newlines\r\n     * and uses match.index to get the correct line start indices.\r\n     */\n\n    while (match = lineEndingPattern.exec(this.text)) {\n      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\n      this.lineStartIndices.push(match.index + match[0].length);\n    }\n\n    this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1])); // Cache for comments found using getComments().\n\n    this._commentCache = new WeakMap(); // don't allow modification of this object\n\n    Object.freeze(this);\n    Object.freeze(this.lines);\n  }\n  /**\r\n   * Split the source code into multiple lines based on the line delimiters.\r\n   * @param {string} text Source code as a string.\r\n   * @returns {string[]} Array of source code lines.\r\n   * @public\r\n   */\n\n\n  static splitLines(text) {\n    return text.split(astUtils.createGlobalLinebreakMatcher());\n  }\n  /**\r\n   * Gets the source code for the given node.\r\n   * @param {ASTNode} [node] The AST node to get the text for.\r\n   * @param {int} [beforeCount] The number of characters before the node to retrieve.\r\n   * @param {int} [afterCount] The number of characters after the node to retrieve.\r\n   * @returns {string} The text representing the AST node.\r\n   * @public\r\n   */\n\n\n  getText(node, beforeCount, afterCount) {\n    if (node) {\n      return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));\n    }\n\n    return this.text;\n  }\n  /**\r\n   * Gets the entire source text split into an array of lines.\r\n   * @returns {Array} The source text as an array of lines.\r\n   * @public\r\n   */\n\n\n  getLines() {\n    return this.lines;\n  }\n  /**\r\n   * Retrieves an array containing all comments in the source code.\r\n   * @returns {ASTNode[]} An array of comment nodes.\r\n   * @public\r\n   */\n\n\n  getAllComments() {\n    return this.ast.comments;\n  }\n  /**\r\n   * Gets all comments for the given node.\r\n   * @param {ASTNode} node The AST node to get the comments for.\r\n   * @returns {Object} An object containing a leading and trailing array\r\n   *      of comments indexed by their position.\r\n   * @public\r\n   * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\r\n   */\n\n\n  getComments(node) {\n    if (this._commentCache.has(node)) {\n      return this._commentCache.get(node);\n    }\n\n    const comments = {\n      leading: [],\n      trailing: []\n    };\n    /*\r\n     * Return all comments as leading comments of the Program node when\r\n     * there is no executable code.\r\n     */\n\n    if (node.type === \"Program\") {\n      if (node.body.length === 0) {\n        comments.leading = node.comments;\n      }\n    } else {\n      /*\r\n       * Return comments as trailing comments of nodes that only contain\r\n       * comments (to mimic the comment attachment behavior present in Espree).\r\n       */\n      if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 || node.type === \"ObjectExpression\" && node.properties.length === 0 || node.type === \"ArrayExpression\" && node.elements.length === 0 || node.type === \"SwitchStatement\" && node.cases.length === 0) {\n        comments.trailing = this.getTokens(node, {\n          includeComments: true,\n          filter: isCommentToken\n        });\n      }\n      /*\r\n       * Iterate over tokens before and after node and collect comment tokens.\r\n       * Do not include comments that exist outside of the parent node\r\n       * to avoid duplication.\r\n       */\n\n\n      let currentToken = this.getTokenBefore(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.start < node.parent.start) {\n          break;\n        }\n\n        comments.leading.push(currentToken);\n        currentToken = this.getTokenBefore(currentToken, {\n          includeComments: true\n        });\n      }\n\n      comments.leading.reverse();\n      currentToken = this.getTokenAfter(node, {\n        includeComments: true\n      });\n\n      while (currentToken && isCommentToken(currentToken)) {\n        if (node.parent && node.parent.type !== \"Program\" && currentToken.end > node.parent.end) {\n          break;\n        }\n\n        comments.trailing.push(currentToken);\n        currentToken = this.getTokenAfter(currentToken, {\n          includeComments: true\n        });\n      }\n    }\n\n    this._commentCache.set(node, comments);\n\n    return comments;\n  }\n  /**\r\n   * Retrieves the JSDoc comment for a given node.\r\n   * @param {ASTNode} node The AST node to get the comment for.\r\n   * @returns {Token|null} The Block comment token containing the JSDoc comment\r\n   *      for the given node or null if not found.\r\n   * @public\r\n   * @deprecated\r\n   */\n\n\n  getJSDocComment(node) {\n    /**\r\n     * Checks for the presence of a JSDoc comment for the given node and returns it.\r\n     * @param {ASTNode} astNode The AST node to get the comment for.\r\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\r\n     *      for the given node or null if not found.\r\n     * @private\r\n     */\n    const findJSDocComment = astNode => {\n      const tokenBefore = this.getTokenBefore(astNode, {\n        includeComments: true\n      });\n\n      if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === \"Block\" && tokenBefore.value.charAt(0) === \"*\" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {\n        return tokenBefore;\n      }\n\n      return null;\n    };\n\n    let parent = node.parent;\n\n    switch (node.type) {\n      case \"ClassDeclaration\":\n      case \"FunctionDeclaration\":\n        return findJSDocComment(looksLikeExport(parent) ? parent : node);\n\n      case \"ClassExpression\":\n        return findJSDocComment(parent.parent);\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n        if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n          while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n            parent = parent.parent;\n\n            if (!parent) {\n              break;\n            }\n          }\n\n          if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\n            return findJSDocComment(parent);\n          }\n        }\n\n        return findJSDocComment(node);\n      // falls through\n\n      default:\n        return null;\n    }\n  }\n  /**\r\n   * Gets the deepest node containing a range index.\r\n   * @param {int} index Range index of the desired node.\r\n   * @returns {ASTNode} The node if found or null if not found.\r\n   * @public\r\n   */\n\n\n  getNodeByRangeIndex(index) {\n    let result = null;\n    Traverser.traverse(this.ast, {\n      visitorKeys: this.visitorKeys,\n\n      enter(node) {\n        if (node.range[0] <= index && index < node.range[1]) {\n          result = node;\n        } else {\n          this.skip();\n        }\n      },\n\n      leave(node) {\n        if (node === result) {\n          this.break();\n        }\n      }\n\n    });\n    return result;\n  }\n  /**\r\n   * Determines if two nodes or tokens have at least one whitespace character\r\n   * between them. Order does not matter. Returns false if the given nodes or\r\n   * tokens overlap.\r\n   * @param {ASTNode|Token} first The first node or token to check between.\r\n   * @param {ASTNode|Token} second The second node or token to check between.\r\n   * @returns {boolean} True if there is a whitespace character between\r\n   * any of the tokens found between the two given nodes or tokens.\r\n   * @public\r\n   */\n\n\n  isSpaceBetween(first, second) {\n    return isSpaceBetween(this, first, second, false);\n  }\n  /**\r\n   * Determines if two nodes or tokens have at least one whitespace character\r\n   * between them. Order does not matter. Returns false if the given nodes or\r\n   * tokens overlap.\r\n   * For backward compatibility, this method returns true if there are\r\n   * `JSXText` tokens that contain whitespaces between the two.\r\n   * @param {ASTNode|Token} first The first node or token to check between.\r\n   * @param {ASTNode|Token} second The second node or token to check between.\r\n   * @returns {boolean} True if there is a whitespace character between\r\n   * any of the tokens found between the two given nodes or tokens.\r\n   * @deprecated in favor of isSpaceBetween().\r\n   * @public\r\n   */\n\n\n  isSpaceBetweenTokens(first, second) {\n    return isSpaceBetween(this, first, second, true);\n  }\n  /**\r\n   * Converts a source text index into a (line, column) pair.\r\n   * @param {number} index The index of a character in a file\r\n   * @throws {TypeError} If non-numeric index or index out of range.\r\n   * @returns {Object} A {line, column} location object with a 0-indexed column\r\n   * @public\r\n   */\n\n\n  getLocFromIndex(index) {\n    if (typeof index !== \"number\") {\n      throw new TypeError(\"Expected `index` to be a number.\");\n    }\n\n    if (index < 0 || index > this.text.length) {\n      throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\n    }\n    /*\r\n     * For an argument of this.text.length, return the location one \"spot\" past the last character\r\n     * of the file. If the last character is a linebreak, the location will be column 0 of the next\r\n     * line; otherwise, the location will be in the next column on the same line.\r\n     *\r\n     * See getIndexFromLoc for the motivation for this special case.\r\n     */\n\n\n    if (index === this.text.length) {\n      return {\n        line: this.lines.length,\n        column: this.lines[this.lines.length - 1].length\n      };\n    }\n    /*\r\n     * To figure out which line index is on, determine the last place at which index could\r\n     * be inserted into lineStartIndices to keep the list sorted.\r\n     */\n\n\n    const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(el => index < el);\n    return {\n      line: lineNumber,\n      column: index - this.lineStartIndices[lineNumber - 1]\n    };\n  }\n  /**\r\n   * Converts a (line, column) pair into a range index.\r\n   * @param {Object} loc A line/column location\r\n   * @param {number} loc.line The line number of the location (1-indexed)\r\n   * @param {number} loc.column The column number of the location (0-indexed)\r\n   * @throws {TypeError|RangeError} If `loc` is not an object with a numeric\r\n   *   `line` and `column`, if the `line` is less than or equal to zero or\r\n   *   the line or column is out of the expected range.\r\n   * @returns {number} The range index of the location in the file.\r\n   * @public\r\n   */\n\n\n  getIndexFromLoc(loc) {\n    if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\n      throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\n    }\n\n    if (loc.line <= 0) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\n    }\n\n    if (loc.line > this.lineStartIndices.length) {\n      throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\n    }\n\n    const lineStartIndex = this.lineStartIndices[loc.line - 1];\n    const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\n    const positionIndex = lineStartIndex + loc.column;\n    /*\r\n     * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\r\n     * the given line, provided that the line number is valid element of this.lines. Since the\r\n     * last element of this.lines is an empty string for files with trailing newlines, add a\r\n     * special case where getting the index for the first location after the end of the file\r\n     * will return the length of the file, rather than throwing an error. This allows rules to\r\n     * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\r\n     */\n\n    if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {\n      throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\n    }\n\n    return positionIndex;\n  }\n\n}\n\nmodule.exports = SourceCode;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/source-code/source-code.js"],"names":["isCommentToken","require","TokenStore","astUtils","Traverser","validate","ast","tokens","Error","comments","loc","range","looksLikeExport","astNode","type","sortedMerge","result","tokenIndex","commentIndex","length","push","nodesOrTokensOverlap","first","second","isSpaceBetween","sourceCode","checkInsideOfJSXText","startingNodeOrToken","endingNodeOrToken","firstToken","getLastToken","finalToken","getFirstToken","currentToken","nextToken","getTokenAfter","includeComments","test","value","SourceCode","constructor","textOrConfig","astIfNoConfig","text","parserServices","scopeManager","visitorKeys","hasBOM","charCodeAt","slice","DEFAULT_VISITOR_KEYS","shebangMatched","match","shebangPattern","hasShebang","tokensAndComments","lines","lineStartIndices","lineEndingPattern","createGlobalLinebreakMatcher","exec","index","_commentCache","WeakMap","Object","freeze","splitLines","split","getText","node","beforeCount","afterCount","Math","max","getLines","getAllComments","getComments","has","get","leading","trailing","body","properties","elements","cases","getTokens","filter","getTokenBefore","parent","start","reverse","end","set","getJSDocComment","findJSDocComment","tokenBefore","charAt","line","getCommentsBefore","getNodeByRangeIndex","traverse","enter","skip","leave","break","isSpaceBetweenTokens","getLocFromIndex","TypeError","RangeError","column","lineNumber","findIndex","el","getIndexFromLoc","lineStartIndex","lineEndIndex","positionIndex","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MACI;AAAEA,EAAAA;AAAF,IAAqBC,OAAO,CAAC,cAAD,CADhC;AAAA,MAEIC,UAAU,GAAGD,OAAO,CAAC,eAAD,CAFxB;AAAA,MAGIE,QAAQ,GAAGF,OAAO,CAAC,qBAAD,CAHtB;AAAA,MAIIG,SAAS,GAAGH,OAAO,CAAC,qBAAD,CAJvB,C,CAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,QAAT,CAAkBC,GAAlB,EAAuB;AACnB,MAAI,CAACA,GAAG,CAACC,MAAT,EAAiB;AACb,UAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;AACH;;AAED,MAAI,CAACF,GAAG,CAACG,QAAT,EAAmB;AACf,UAAM,IAAID,KAAJ,CAAU,oCAAV,CAAN;AACH;;AAED,MAAI,CAACF,GAAG,CAACI,GAAT,EAAc;AACV,UAAM,IAAIF,KAAJ,CAAU,sCAAV,CAAN;AACH;;AAED,MAAI,CAACF,GAAG,CAACK,KAAT,EAAgB;AACZ,UAAM,IAAIH,KAAJ,CAAU,kCAAV,CAAN;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,eAAT,CAAyBC,OAAzB,EAAkC;AAC9B,SAAOA,OAAO,CAACC,IAAR,KAAiB,0BAAjB,IAA+CD,OAAO,CAACC,IAAR,KAAiB,wBAAhE,IACHD,OAAO,CAACC,IAAR,KAAiB,sBADd,IACwCD,OAAO,CAACC,IAAR,KAAiB,iBADhE;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,WAAT,CAAqBR,MAArB,EAA6BE,QAA7B,EAAuC;AACnC,QAAMO,MAAM,GAAG,EAAf;AACA,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIC,YAAY,GAAG,CAAnB;;AAEA,SAAOD,UAAU,GAAGV,MAAM,CAACY,MAApB,IAA8BD,YAAY,GAAGT,QAAQ,CAACU,MAA7D,EAAqE;AACjE,QAAID,YAAY,IAAIT,QAAQ,CAACU,MAAzB,IAAmCF,UAAU,GAAGV,MAAM,CAACY,MAApB,IAA8BZ,MAAM,CAACU,UAAD,CAAN,CAAmBN,KAAnB,CAAyB,CAAzB,IAA8BF,QAAQ,CAACS,YAAD,CAAR,CAAuBP,KAAvB,CAA6B,CAA7B,CAAnG,EAAoI;AAChIK,MAAAA,MAAM,CAACI,IAAP,CAAYb,MAAM,CAACU,UAAU,EAAX,CAAlB;AACH,KAFD,MAEO;AACHD,MAAAA,MAAM,CAACI,IAAP,CAAYX,QAAQ,CAACS,YAAY,EAAb,CAApB;AACH;AACJ;;AAED,SAAOF,MAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,oBAAT,CAA8BC,KAA9B,EAAqCC,MAArC,EAA6C;AACzC,SAAQD,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAlB,IAAqCW,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAxD,IACFY,MAAM,CAACZ,KAAP,CAAa,CAAb,KAAmBW,KAAK,CAACX,KAAN,CAAY,CAAZ,CAAnB,IAAqCY,MAAM,CAACZ,KAAP,CAAa,CAAb,KAAmBW,KAAK,CAACX,KAAN,CAAY,CAAZ,CAD7D;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASa,cAAT,CAAwBC,UAAxB,EAAoCH,KAApC,EAA2CC,MAA3C,EAAmDG,oBAAnD,EAAyE;AACrE,MAAIL,oBAAoB,CAACC,KAAD,EAAQC,MAAR,CAAxB,EAAyC;AACrC,WAAO,KAAP;AACH;;AAED,QAAM,CAACI,mBAAD,EAAsBC,iBAAtB,IAA2CN,KAAK,CAACX,KAAN,CAAY,CAAZ,KAAkBY,MAAM,CAACZ,KAAP,CAAa,CAAb,CAAlB,GAC3C,CAACW,KAAD,EAAQC,MAAR,CAD2C,GAE3C,CAACA,MAAD,EAASD,KAAT,CAFN;AAGA,QAAMO,UAAU,GAAGJ,UAAU,CAACK,YAAX,CAAwBH,mBAAxB,KAAgDA,mBAAnE;AACA,QAAMI,UAAU,GAAGN,UAAU,CAACO,aAAX,CAAyBJ,iBAAzB,KAA+CA,iBAAlE;AACA,MAAIK,YAAY,GAAGJ,UAAnB;;AAEA,SAAOI,YAAY,KAAKF,UAAxB,EAAoC;AAChC,UAAMG,SAAS,GAAGT,UAAU,CAACU,aAAX,CAAyBF,YAAzB,EAAuC;AAAEG,MAAAA,eAAe,EAAE;AAAnB,KAAvC,CAAlB;;AAEA,QACIH,YAAY,CAACtB,KAAb,CAAmB,CAAnB,MAA0BuB,SAAS,CAACvB,KAAV,CAAgB,CAAhB,CAA1B;AAEI;AAChB;AACA;AACA;AAEoBe,IAAAA,oBAAoB,IACpBQ,SAAS,KAAKH,UADd,IAEAG,SAAS,CAACpB,IAAV,KAAmB,SAFnB,IAGA,MAAMuB,IAAN,CAAWH,SAAS,CAACI,KAArB,CAXZ,EAaE;AACE,aAAO,IAAP;AACH;;AAEDL,IAAAA,YAAY,GAAGC,SAAf;AACH;;AAED,SAAO,KAAP;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;;;AACA,MAAMK,UAAN,SAAyBrC,UAAzB,CAAoC;AAEhC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIsC,EAAAA,WAAW,CAACC,YAAD,EAAeC,aAAf,EAA8B;AACrC,QAAIC,IAAJ,EAAUrC,GAAV,EAAesC,cAAf,EAA+BC,YAA/B,EAA6CC,WAA7C,CADqC,CAGrC;;AACA,QAAI,OAAOL,YAAP,KAAwB,QAA5B,EAAsC;AAClCE,MAAAA,IAAI,GAAGF,YAAP;AACAnC,MAAAA,GAAG,GAAGoC,aAAN;AACH,KAHD,MAGO,IAAI,OAAOD,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,KAAK,IAAzD,EAA+D;AAClEE,MAAAA,IAAI,GAAGF,YAAY,CAACE,IAApB;AACArC,MAAAA,GAAG,GAAGmC,YAAY,CAACnC,GAAnB;AACAsC,MAAAA,cAAc,GAAGH,YAAY,CAACG,cAA9B;AACAC,MAAAA,YAAY,GAAGJ,YAAY,CAACI,YAA5B;AACAC,MAAAA,WAAW,GAAGL,YAAY,CAACK,WAA3B;AACH;;AAEDzC,IAAAA,QAAQ,CAACC,GAAD,CAAR;AACA,UAAMA,GAAG,CAACC,MAAV,EAAkBD,GAAG,CAACG,QAAtB;AAEA;AACR;AACA;AACA;;AACQ,SAAKsC,MAAL,GAAeJ,IAAI,CAACK,UAAL,CAAgB,CAAhB,MAAuB,MAAtC;AAEA;AACR;AACA;AACA;AACA;;AACQ,SAAKL,IAAL,GAAa,KAAKI,MAAL,GAAcJ,IAAI,CAACM,KAAL,CAAW,CAAX,CAAd,GAA8BN,IAA3C;AAEA;AACR;AACA;AACA;;AACQ,SAAKrC,GAAL,GAAWA,GAAX;AAEA;AACR;AACA;AACA;;AACQ,SAAKsC,cAAL,GAAsBA,cAAc,IAAI,EAAxC;AAEA;AACR;AACA;AACA;;AACQ,SAAKC,YAAL,GAAoBA,YAAY,IAAI,IAApC;AAEA;AACR;AACA;AACA;;AACQ,SAAKC,WAAL,GAAmBA,WAAW,IAAI1C,SAAS,CAAC8C,oBAA5C,CArDqC,CAuDrC;;AACA,UAAMC,cAAc,GAAG,KAAKR,IAAL,CAAUS,KAAV,CAAgBjD,QAAQ,CAACkD,cAAzB,CAAvB;AACA,UAAMC,UAAU,GAAGH,cAAc,IAAI7C,GAAG,CAACG,QAAJ,CAAaU,MAA/B,IAAyCb,GAAG,CAACG,QAAJ,CAAa,CAAb,EAAgB6B,KAAhB,KAA0Ba,cAAc,CAAC,CAAD,CAApG;;AAEA,QAAIG,UAAJ,EAAgB;AACZhD,MAAAA,GAAG,CAACG,QAAJ,CAAa,CAAb,EAAgBK,IAAhB,GAAuB,SAAvB;AACH;;AAED,SAAKyC,iBAAL,GAAyBxC,WAAW,CAACT,GAAG,CAACC,MAAL,EAAaD,GAAG,CAACG,QAAjB,CAApC;AAEA;AACR;AACA;AACA;AACA;;AACQ,SAAK+C,KAAL,GAAa,EAAb;AACA,SAAKC,gBAAL,GAAwB,CAAC,CAAD,CAAxB;AAEA,UAAMC,iBAAiB,GAAGvD,QAAQ,CAACwD,4BAAT,EAA1B;AACA,QAAIP,KAAJ;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,WAAQA,KAAK,GAAGM,iBAAiB,CAACE,IAAlB,CAAuB,KAAKjB,IAA5B,CAAhB,EAAoD;AAChD,WAAKa,KAAL,CAAWpC,IAAX,CAAgB,KAAKuB,IAAL,CAAUM,KAAV,CAAgB,KAAKQ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAhB,EAAyEiC,KAAK,CAACS,KAA/E,CAAhB;AACA,WAAKJ,gBAAL,CAAsBrC,IAAtB,CAA2BgC,KAAK,CAACS,KAAN,GAAcT,KAAK,CAAC,CAAD,CAAL,CAASjC,MAAlD;AACH;;AACD,SAAKqC,KAAL,CAAWpC,IAAX,CAAgB,KAAKuB,IAAL,CAAUM,KAAV,CAAgB,KAAKQ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAhB,CAAhB,EAzFqC,CA2FrC;;AACA,SAAK2C,aAAL,GAAqB,IAAIC,OAAJ,EAArB,CA5FqC,CA8FrC;;AACAC,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd;AACAD,IAAAA,MAAM,CAACC,MAAP,CAAc,KAAKT,KAAnB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACqB,SAAVU,UAAU,CAACvB,IAAD,EAAO;AACpB,WAAOA,IAAI,CAACwB,KAAL,CAAWhE,QAAQ,CAACwD,4BAAT,EAAX,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIS,EAAAA,OAAO,CAACC,IAAD,EAAOC,WAAP,EAAoBC,UAApB,EAAgC;AACnC,QAAIF,IAAJ,EAAU;AACN,aAAO,KAAK1B,IAAL,CAAUM,KAAV,CAAgBuB,IAAI,CAACC,GAAL,CAASJ,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiB2D,WAAW,IAAI,CAAhC,CAAT,EAA6C,CAA7C,CAAhB,EACHD,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiB4D,UAAU,IAAI,CAA/B,CADG,CAAP;AAEH;;AACD,WAAO,KAAK5B,IAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI+B,EAAAA,QAAQ,GAAG;AACP,WAAO,KAAKlB,KAAZ;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACImB,EAAAA,cAAc,GAAG;AACb,WAAO,KAAKrE,GAAL,CAASG,QAAhB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACImE,EAAAA,WAAW,CAACP,IAAD,EAAO;AACd,QAAI,KAAKP,aAAL,CAAmBe,GAAnB,CAAuBR,IAAvB,CAAJ,EAAkC;AAC9B,aAAO,KAAKP,aAAL,CAAmBgB,GAAnB,CAAuBT,IAAvB,CAAP;AACH;;AAED,UAAM5D,QAAQ,GAAG;AACbsE,MAAAA,OAAO,EAAE,EADI;AAEbC,MAAAA,QAAQ,EAAE;AAFG,KAAjB;AAKA;AACR;AACA;AACA;;AACQ,QAAIX,IAAI,CAACvD,IAAL,KAAc,SAAlB,EAA6B;AACzB,UAAIuD,IAAI,CAACY,IAAL,CAAU9D,MAAV,KAAqB,CAAzB,EAA4B;AACxBV,QAAAA,QAAQ,CAACsE,OAAT,GAAmBV,IAAI,CAAC5D,QAAxB;AACH;AACJ,KAJD,MAIO;AAEH;AACZ;AACA;AACA;AACY,UAAI,CAAC4D,IAAI,CAACvD,IAAL,KAAc,gBAAd,IAAkCuD,IAAI,CAACvD,IAAL,KAAc,WAAjD,KAAiEuD,IAAI,CAACY,IAAL,CAAU9D,MAAV,KAAqB,CAAtF,IACAkD,IAAI,CAACvD,IAAL,KAAc,kBAAd,IAAoCuD,IAAI,CAACa,UAAL,CAAgB/D,MAAhB,KAA2B,CAD/D,IAEAkD,IAAI,CAACvD,IAAL,KAAc,iBAAd,IAAmCuD,IAAI,CAACc,QAAL,CAAchE,MAAd,KAAyB,CAF5D,IAGAkD,IAAI,CAACvD,IAAL,KAAc,iBAAd,IAAmCuD,IAAI,CAACe,KAAL,CAAWjE,MAAX,KAAsB,CAH7D,EAIE;AACEV,QAAAA,QAAQ,CAACuE,QAAT,GAAoB,KAAKK,SAAL,CAAehB,IAAf,EAAqB;AACrCjC,UAAAA,eAAe,EAAE,IADoB;AAErCkD,UAAAA,MAAM,EAAEtF;AAF6B,SAArB,CAApB;AAIH;AAED;AACZ;AACA;AACA;AACA;;;AACY,UAAIiC,YAAY,GAAG,KAAKsD,cAAL,CAAoBlB,IAApB,EAA0B;AAAEjC,QAAAA,eAAe,EAAE;AAAnB,OAA1B,CAAnB;;AAEA,aAAOH,YAAY,IAAIjC,cAAc,CAACiC,YAAD,CAArC,EAAqD;AACjD,YAAIoC,IAAI,CAACmB,MAAL,IAAenB,IAAI,CAACmB,MAAL,CAAY1E,IAAZ,KAAqB,SAApC,IAAkDmB,YAAY,CAACwD,KAAb,GAAqBpB,IAAI,CAACmB,MAAL,CAAYC,KAAvF,EAA+F;AAC3F;AACH;;AACDhF,QAAAA,QAAQ,CAACsE,OAAT,CAAiB3D,IAAjB,CAAsBa,YAAtB;AACAA,QAAAA,YAAY,GAAG,KAAKsD,cAAL,CAAoBtD,YAApB,EAAkC;AAAEG,UAAAA,eAAe,EAAE;AAAnB,SAAlC,CAAf;AACH;;AAED3B,MAAAA,QAAQ,CAACsE,OAAT,CAAiBW,OAAjB;AAEAzD,MAAAA,YAAY,GAAG,KAAKE,aAAL,CAAmBkC,IAAnB,EAAyB;AAAEjC,QAAAA,eAAe,EAAE;AAAnB,OAAzB,CAAf;;AAEA,aAAOH,YAAY,IAAIjC,cAAc,CAACiC,YAAD,CAArC,EAAqD;AACjD,YAAIoC,IAAI,CAACmB,MAAL,IAAenB,IAAI,CAACmB,MAAL,CAAY1E,IAAZ,KAAqB,SAApC,IAAkDmB,YAAY,CAAC0D,GAAb,GAAmBtB,IAAI,CAACmB,MAAL,CAAYG,GAArF,EAA2F;AACvF;AACH;;AACDlF,QAAAA,QAAQ,CAACuE,QAAT,CAAkB5D,IAAlB,CAAuBa,YAAvB;AACAA,QAAAA,YAAY,GAAG,KAAKE,aAAL,CAAmBF,YAAnB,EAAiC;AAAEG,UAAAA,eAAe,EAAE;AAAnB,SAAjC,CAAf;AACH;AACJ;;AAED,SAAK0B,aAAL,CAAmB8B,GAAnB,CAAuBvB,IAAvB,EAA6B5D,QAA7B;;AACA,WAAOA,QAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIoF,EAAAA,eAAe,CAACxB,IAAD,EAAO;AAElB;AACR;AACA;AACA;AACA;AACA;AACA;AACQ,UAAMyB,gBAAgB,GAAGjF,OAAO,IAAI;AAChC,YAAMkF,WAAW,GAAG,KAAKR,cAAL,CAAoB1E,OAApB,EAA6B;AAAEuB,QAAAA,eAAe,EAAE;AAAnB,OAA7B,CAApB;;AAEA,UACI2D,WAAW,IACX/F,cAAc,CAAC+F,WAAD,CADd,IAEAA,WAAW,CAACjF,IAAZ,KAAqB,OAFrB,IAGAiF,WAAW,CAACzD,KAAZ,CAAkB0D,MAAlB,CAAyB,CAAzB,MAAgC,GAHhC,IAIAnF,OAAO,CAACH,GAAR,CAAY+E,KAAZ,CAAkBQ,IAAlB,GAAyBF,WAAW,CAACrF,GAAZ,CAAgBiF,GAAhB,CAAoBM,IAA7C,IAAqD,CALzD,EAME;AACE,eAAOF,WAAP;AACH;;AAED,aAAO,IAAP;AACH,KAdD;;AAeA,QAAIP,MAAM,GAAGnB,IAAI,CAACmB,MAAlB;;AAEA,YAAQnB,IAAI,CAACvD,IAAb;AACI,WAAK,kBAAL;AACA,WAAK,qBAAL;AACI,eAAOgF,gBAAgB,CAAClF,eAAe,CAAC4E,MAAD,CAAf,GAA0BA,MAA1B,GAAmCnB,IAApC,CAAvB;;AAEJ,WAAK,iBAAL;AACI,eAAOyB,gBAAgB,CAACN,MAAM,CAACA,MAAR,CAAvB;;AAEJ,WAAK,yBAAL;AACA,WAAK,oBAAL;AACI,YAAIA,MAAM,CAAC1E,IAAP,KAAgB,gBAAhB,IAAoC0E,MAAM,CAAC1E,IAAP,KAAgB,eAAxD,EAAyE;AACrE,iBACI,CAAC,KAAKoF,iBAAL,CAAuBV,MAAvB,EAA+BrE,MAAhC,IACA,CAAC,YAAYkB,IAAZ,CAAiBmD,MAAM,CAAC1E,IAAxB,CADD,IAEA0E,MAAM,CAAC1E,IAAP,KAAgB,kBAFhB,IAGA0E,MAAM,CAAC1E,IAAP,KAAgB,UAJpB,EAKE;AACE0E,YAAAA,MAAM,GAAGA,MAAM,CAACA,MAAhB;;AAEA,gBAAI,CAACA,MAAL,EAAa;AACT;AACH;AACJ;;AAED,cAAIA,MAAM,IAAIA,MAAM,CAAC1E,IAAP,KAAgB,qBAA1B,IAAmD0E,MAAM,CAAC1E,IAAP,KAAgB,SAAvE,EAAkF;AAC9E,mBAAOgF,gBAAgB,CAACN,MAAD,CAAvB;AACH;AACJ;;AAED,eAAOM,gBAAgB,CAACzB,IAAD,CAAvB;AAEJ;;AACA;AACI,eAAO,IAAP;AAjCR;AAmCH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACI8B,EAAAA,mBAAmB,CAACtC,KAAD,EAAQ;AACvB,QAAI7C,MAAM,GAAG,IAAb;AAEAZ,IAAAA,SAAS,CAACgG,QAAV,CAAmB,KAAK9F,GAAxB,EAA6B;AACzBwC,MAAAA,WAAW,EAAE,KAAKA,WADO;;AAEzBuD,MAAAA,KAAK,CAAChC,IAAD,EAAO;AACR,YAAIA,IAAI,CAAC1D,KAAL,CAAW,CAAX,KAAiBkD,KAAjB,IAA0BA,KAAK,GAAGQ,IAAI,CAAC1D,KAAL,CAAW,CAAX,CAAtC,EAAqD;AACjDK,UAAAA,MAAM,GAAGqD,IAAT;AACH,SAFD,MAEO;AACH,eAAKiC,IAAL;AACH;AACJ,OARwB;;AASzBC,MAAAA,KAAK,CAAClC,IAAD,EAAO;AACR,YAAIA,IAAI,KAAKrD,MAAb,EAAqB;AACjB,eAAKwF,KAAL;AACH;AACJ;;AAbwB,KAA7B;AAgBA,WAAOxF,MAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIQ,EAAAA,cAAc,CAACF,KAAD,EAAQC,MAAR,EAAgB;AAC1B,WAAOC,cAAc,CAAC,IAAD,EAAOF,KAAP,EAAcC,MAAd,EAAsB,KAAtB,CAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIkF,EAAAA,oBAAoB,CAACnF,KAAD,EAAQC,MAAR,EAAgB;AAChC,WAAOC,cAAc,CAAC,IAAD,EAAOF,KAAP,EAAcC,MAAd,EAAsB,IAAtB,CAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACImF,EAAAA,eAAe,CAAC7C,KAAD,EAAQ;AACnB,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,YAAM,IAAI8C,SAAJ,CAAc,kCAAd,CAAN;AACH;;AAED,QAAI9C,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,KAAKlB,IAAL,CAAUxB,MAAnC,EAA2C;AACvC,YAAM,IAAIyF,UAAJ,CAAgB,uCAAsC/C,KAAM,gCAA+B,KAAKlB,IAAL,CAAUxB,MAAO,IAA5G,CAAN;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,QAAI0C,KAAK,KAAK,KAAKlB,IAAL,CAAUxB,MAAxB,EAAgC;AAC5B,aAAO;AAAE8E,QAAAA,IAAI,EAAE,KAAKzC,KAAL,CAAWrC,MAAnB;AAA2B0F,QAAAA,MAAM,EAAE,KAAKrD,KAAL,CAAW,KAAKA,KAAL,CAAWrC,MAAX,GAAoB,CAA/B,EAAkCA;AAArE,OAAP;AACH;AAED;AACR;AACA;AACA;;;AACQ,UAAM2F,UAAU,GAAGjD,KAAK,IAAI,KAAKJ,gBAAL,CAAsB,KAAKA,gBAAL,CAAsBtC,MAAtB,GAA+B,CAArD,CAAT,GACb,KAAKsC,gBAAL,CAAsBtC,MADT,GAEb,KAAKsC,gBAAL,CAAsBsD,SAAtB,CAAgCC,EAAE,IAAInD,KAAK,GAAGmD,EAA9C,CAFN;AAIA,WAAO;AAAEf,MAAAA,IAAI,EAAEa,UAAR;AAAoBD,MAAAA,MAAM,EAAEhD,KAAK,GAAG,KAAKJ,gBAAL,CAAsBqD,UAAU,GAAG,CAAnC;AAApC,KAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIG,EAAAA,eAAe,CAACvG,GAAD,EAAM;AACjB,QAAI,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAG,CAACuF,IAAX,KAAoB,QAA/C,IAA2D,OAAOvF,GAAG,CAACmG,MAAX,KAAsB,QAArF,EAA+F;AAC3F,YAAM,IAAIF,SAAJ,CAAc,6EAAd,CAAN;AACH;;AAED,QAAIjG,GAAG,CAACuF,IAAJ,IAAY,CAAhB,EAAmB;AACf,YAAM,IAAIW,UAAJ,CAAgB,kCAAiClG,GAAG,CAACuF,IAAK,8CAA1D,CAAN;AACH;;AAED,QAAIvF,GAAG,CAACuF,IAAJ,GAAW,KAAKxC,gBAAL,CAAsBtC,MAArC,EAA6C;AACzC,YAAM,IAAIyF,UAAJ,CAAgB,kCAAiClG,GAAG,CAACuF,IAAK,wBAAuB,KAAKxC,gBAAL,CAAsBtC,MAAO,kBAA9G,CAAN;AACH;;AAED,UAAM+F,cAAc,GAAG,KAAKzD,gBAAL,CAAsB/C,GAAG,CAACuF,IAAJ,GAAW,CAAjC,CAAvB;AACA,UAAMkB,YAAY,GAAGzG,GAAG,CAACuF,IAAJ,KAAa,KAAKxC,gBAAL,CAAsBtC,MAAnC,GAA4C,KAAKwB,IAAL,CAAUxB,MAAtD,GAA+D,KAAKsC,gBAAL,CAAsB/C,GAAG,CAACuF,IAA1B,CAApF;AACA,UAAMmB,aAAa,GAAGF,cAAc,GAAGxG,GAAG,CAACmG,MAA3C;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,QACInG,GAAG,CAACuF,IAAJ,KAAa,KAAKxC,gBAAL,CAAsBtC,MAAnC,IAA6CiG,aAAa,GAAGD,YAA7D,IACAzG,GAAG,CAACuF,IAAJ,GAAW,KAAKxC,gBAAL,CAAsBtC,MAAjC,IAA2CiG,aAAa,IAAID,YAFhE,EAGE;AACE,YAAM,IAAIP,UAAJ,CAAgB,sCAAqClG,GAAG,CAACmG,MAAO,sCAAqCnG,GAAG,CAACuF,IAAK,OAAMkB,YAAY,GAAGD,cAAe,IAAlJ,CAAN;AACH;;AAED,WAAOE,aAAP;AACH;;AAzb+B;;AA4bpCC,MAAM,CAACC,OAAP,GAAiB/E,UAAjB","sourcesContent":["/**\r\n * @fileoverview Abstraction of JavaScript source code.\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst\r\n    { isCommentToken } = require(\"eslint-utils\"),\r\n    TokenStore = require(\"./token-store\"),\r\n    astUtils = require(\"../shared/ast-utils\"),\r\n    Traverser = require(\"../shared/traverser\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Private\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Validates that the given AST has the required information.\r\n * @param {ASTNode} ast The Program node of the AST to check.\r\n * @throws {Error} If the AST doesn't contain the correct information.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction validate(ast) {\r\n    if (!ast.tokens) {\r\n        throw new Error(\"AST is missing the tokens array.\");\r\n    }\r\n\r\n    if (!ast.comments) {\r\n        throw new Error(\"AST is missing the comments array.\");\r\n    }\r\n\r\n    if (!ast.loc) {\r\n        throw new Error(\"AST is missing location information.\");\r\n    }\r\n\r\n    if (!ast.range) {\r\n        throw new Error(\"AST is missing range information\");\r\n    }\r\n}\r\n\r\n/**\r\n * Check to see if its a ES6 export declaration.\r\n * @param {ASTNode} astNode An AST node.\r\n * @returns {boolean} whether the given node represents an export declaration.\r\n * @private\r\n */\r\nfunction looksLikeExport(astNode) {\r\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\r\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\r\n}\r\n\r\n/**\r\n * Merges two sorted lists into a larger sorted list in O(n) time.\r\n * @param {Token[]} tokens The list of tokens.\r\n * @param {Token[]} comments The list of comments.\r\n * @returns {Token[]} A sorted list of tokens and comments.\r\n * @private\r\n */\r\nfunction sortedMerge(tokens, comments) {\r\n    const result = [];\r\n    let tokenIndex = 0;\r\n    let commentIndex = 0;\r\n\r\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\r\n        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {\r\n            result.push(tokens[tokenIndex++]);\r\n        } else {\r\n            result.push(comments[commentIndex++]);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Determines if two nodes or tokens overlap.\r\n * @param {ASTNode|Token} first The first node or token to check.\r\n * @param {ASTNode|Token} second The second node or token to check.\r\n * @returns {boolean} True if the two nodes or tokens overlap.\r\n * @private\r\n */\r\nfunction nodesOrTokensOverlap(first, second) {\r\n    return (first.range[0] <= second.range[0] && first.range[1] >= second.range[0]) ||\r\n        (second.range[0] <= first.range[0] && second.range[1] >= first.range[0]);\r\n}\r\n\r\n/**\r\n * Determines if two nodes or tokens have at least one whitespace character\r\n * between them. Order does not matter. Returns false if the given nodes or\r\n * tokens overlap.\r\n * @param {SourceCode} sourceCode The source code object.\r\n * @param {ASTNode|Token} first The first node or token to check between.\r\n * @param {ASTNode|Token} second The second node or token to check between.\r\n * @param {boolean} checkInsideOfJSXText If `true` is present, check inside of JSXText tokens for backward compatibility.\r\n * @returns {boolean} True if there is a whitespace character between\r\n * any of the tokens found between the two given nodes or tokens.\r\n * @public\r\n */\r\nfunction isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {\r\n    if (nodesOrTokensOverlap(first, second)) {\r\n        return false;\r\n    }\r\n\r\n    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0]\r\n        ? [first, second]\r\n        : [second, first];\r\n    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;\r\n    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;\r\n    let currentToken = firstToken;\r\n\r\n    while (currentToken !== finalToken) {\r\n        const nextToken = sourceCode.getTokenAfter(currentToken, { includeComments: true });\r\n\r\n        if (\r\n            currentToken.range[1] !== nextToken.range[0] ||\r\n\r\n                /*\r\n                 * For backward compatibility, check spaces in JSXText.\r\n                 * https://github.com/eslint/eslint/issues/12614\r\n                 */\r\n                (\r\n                    checkInsideOfJSXText &&\r\n                    nextToken !== finalToken &&\r\n                    nextToken.type === \"JSXText\" &&\r\n                    /\\s/u.test(nextToken.value)\r\n                )\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        currentToken = nextToken;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Represents parsed source code.\r\n */\r\nclass SourceCode extends TokenStore {\r\n\r\n    /**\r\n     * @param {string|Object} textOrConfig The source code text or config object.\r\n     * @param {string} textOrConfig.text The source code text.\r\n     * @param {ASTNode} textOrConfig.ast The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\r\n     * @param {Object|null} textOrConfig.parserServices The parser services.\r\n     * @param {ScopeManager|null} textOrConfig.scopeManager The scope of this source code.\r\n     * @param {Object|null} textOrConfig.visitorKeys The visitor keys to traverse AST.\r\n     * @param {ASTNode} [astIfNoConfig] The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\r\n     */\r\n    constructor(textOrConfig, astIfNoConfig) {\r\n        let text, ast, parserServices, scopeManager, visitorKeys;\r\n\r\n        // Process overloading.\r\n        if (typeof textOrConfig === \"string\") {\r\n            text = textOrConfig;\r\n            ast = astIfNoConfig;\r\n        } else if (typeof textOrConfig === \"object\" && textOrConfig !== null) {\r\n            text = textOrConfig.text;\r\n            ast = textOrConfig.ast;\r\n            parserServices = textOrConfig.parserServices;\r\n            scopeManager = textOrConfig.scopeManager;\r\n            visitorKeys = textOrConfig.visitorKeys;\r\n        }\r\n\r\n        validate(ast);\r\n        super(ast.tokens, ast.comments);\r\n\r\n        /**\r\n         * The flag to indicate that the source code has Unicode BOM.\r\n         * @type {boolean}\r\n         */\r\n        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\r\n\r\n        /**\r\n         * The original text source code.\r\n         * BOM was stripped from this text.\r\n         * @type {string}\r\n         */\r\n        this.text = (this.hasBOM ? text.slice(1) : text);\r\n\r\n        /**\r\n         * The parsed AST for the source code.\r\n         * @type {ASTNode}\r\n         */\r\n        this.ast = ast;\r\n\r\n        /**\r\n         * The parser services of this source code.\r\n         * @type {Object}\r\n         */\r\n        this.parserServices = parserServices || {};\r\n\r\n        /**\r\n         * The scope of this source code.\r\n         * @type {ScopeManager|null}\r\n         */\r\n        this.scopeManager = scopeManager || null;\r\n\r\n        /**\r\n         * The visitor keys to traverse AST.\r\n         * @type {Object}\r\n         */\r\n        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;\r\n\r\n        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.\r\n        const shebangMatched = this.text.match(astUtils.shebangPattern);\r\n        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];\r\n\r\n        if (hasShebang) {\r\n            ast.comments[0].type = \"Shebang\";\r\n        }\r\n\r\n        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);\r\n\r\n        /**\r\n         * The source code split into lines according to ECMA-262 specification.\r\n         * This is done to avoid each rule needing to do so separately.\r\n         * @type {string[]}\r\n         */\r\n        this.lines = [];\r\n        this.lineStartIndices = [0];\r\n\r\n        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();\r\n        let match;\r\n\r\n        /*\r\n         * Previously, this was implemented using a regex that\r\n         * matched a sequence of non-linebreak characters followed by a\r\n         * linebreak, then adding the lengths of the matches. However,\r\n         * this caused a catastrophic backtracking issue when the end\r\n         * of a file contained a large number of non-newline characters.\r\n         * To avoid this, the current implementation just matches newlines\r\n         * and uses match.index to get the correct line start indices.\r\n         */\r\n        while ((match = lineEndingPattern.exec(this.text))) {\r\n            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));\r\n            this.lineStartIndices.push(match.index + match[0].length);\r\n        }\r\n        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));\r\n\r\n        // Cache for comments found using getComments().\r\n        this._commentCache = new WeakMap();\r\n\r\n        // don't allow modification of this object\r\n        Object.freeze(this);\r\n        Object.freeze(this.lines);\r\n    }\r\n\r\n    /**\r\n     * Split the source code into multiple lines based on the line delimiters.\r\n     * @param {string} text Source code as a string.\r\n     * @returns {string[]} Array of source code lines.\r\n     * @public\r\n     */\r\n    static splitLines(text) {\r\n        return text.split(astUtils.createGlobalLinebreakMatcher());\r\n    }\r\n\r\n    /**\r\n     * Gets the source code for the given node.\r\n     * @param {ASTNode} [node] The AST node to get the text for.\r\n     * @param {int} [beforeCount] The number of characters before the node to retrieve.\r\n     * @param {int} [afterCount] The number of characters after the node to retrieve.\r\n     * @returns {string} The text representing the AST node.\r\n     * @public\r\n     */\r\n    getText(node, beforeCount, afterCount) {\r\n        if (node) {\r\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\r\n                node.range[1] + (afterCount || 0));\r\n        }\r\n        return this.text;\r\n    }\r\n\r\n    /**\r\n     * Gets the entire source text split into an array of lines.\r\n     * @returns {Array} The source text as an array of lines.\r\n     * @public\r\n     */\r\n    getLines() {\r\n        return this.lines;\r\n    }\r\n\r\n    /**\r\n     * Retrieves an array containing all comments in the source code.\r\n     * @returns {ASTNode[]} An array of comment nodes.\r\n     * @public\r\n     */\r\n    getAllComments() {\r\n        return this.ast.comments;\r\n    }\r\n\r\n    /**\r\n     * Gets all comments for the given node.\r\n     * @param {ASTNode} node The AST node to get the comments for.\r\n     * @returns {Object} An object containing a leading and trailing array\r\n     *      of comments indexed by their position.\r\n     * @public\r\n     * @deprecated replaced by getCommentsBefore(), getCommentsAfter(), and getCommentsInside().\r\n     */\r\n    getComments(node) {\r\n        if (this._commentCache.has(node)) {\r\n            return this._commentCache.get(node);\r\n        }\r\n\r\n        const comments = {\r\n            leading: [],\r\n            trailing: []\r\n        };\r\n\r\n        /*\r\n         * Return all comments as leading comments of the Program node when\r\n         * there is no executable code.\r\n         */\r\n        if (node.type === \"Program\") {\r\n            if (node.body.length === 0) {\r\n                comments.leading = node.comments;\r\n            }\r\n        } else {\r\n\r\n            /*\r\n             * Return comments as trailing comments of nodes that only contain\r\n             * comments (to mimic the comment attachment behavior present in Espree).\r\n             */\r\n            if ((node.type === \"BlockStatement\" || node.type === \"ClassBody\") && node.body.length === 0 ||\r\n                node.type === \"ObjectExpression\" && node.properties.length === 0 ||\r\n                node.type === \"ArrayExpression\" && node.elements.length === 0 ||\r\n                node.type === \"SwitchStatement\" && node.cases.length === 0\r\n            ) {\r\n                comments.trailing = this.getTokens(node, {\r\n                    includeComments: true,\r\n                    filter: isCommentToken\r\n                });\r\n            }\r\n\r\n            /*\r\n             * Iterate over tokens before and after node and collect comment tokens.\r\n             * Do not include comments that exist outside of the parent node\r\n             * to avoid duplication.\r\n             */\r\n            let currentToken = this.getTokenBefore(node, { includeComments: true });\r\n\r\n            while (currentToken && isCommentToken(currentToken)) {\r\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.start < node.parent.start)) {\r\n                    break;\r\n                }\r\n                comments.leading.push(currentToken);\r\n                currentToken = this.getTokenBefore(currentToken, { includeComments: true });\r\n            }\r\n\r\n            comments.leading.reverse();\r\n\r\n            currentToken = this.getTokenAfter(node, { includeComments: true });\r\n\r\n            while (currentToken && isCommentToken(currentToken)) {\r\n                if (node.parent && node.parent.type !== \"Program\" && (currentToken.end > node.parent.end)) {\r\n                    break;\r\n                }\r\n                comments.trailing.push(currentToken);\r\n                currentToken = this.getTokenAfter(currentToken, { includeComments: true });\r\n            }\r\n        }\r\n\r\n        this._commentCache.set(node, comments);\r\n        return comments;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the JSDoc comment for a given node.\r\n     * @param {ASTNode} node The AST node to get the comment for.\r\n     * @returns {Token|null} The Block comment token containing the JSDoc comment\r\n     *      for the given node or null if not found.\r\n     * @public\r\n     * @deprecated\r\n     */\r\n    getJSDocComment(node) {\r\n\r\n        /**\r\n         * Checks for the presence of a JSDoc comment for the given node and returns it.\r\n         * @param {ASTNode} astNode The AST node to get the comment for.\r\n         * @returns {Token|null} The Block comment token containing the JSDoc comment\r\n         *      for the given node or null if not found.\r\n         * @private\r\n         */\r\n        const findJSDocComment = astNode => {\r\n            const tokenBefore = this.getTokenBefore(astNode, { includeComments: true });\r\n\r\n            if (\r\n                tokenBefore &&\r\n                isCommentToken(tokenBefore) &&\r\n                tokenBefore.type === \"Block\" &&\r\n                tokenBefore.value.charAt(0) === \"*\" &&\r\n                astNode.loc.start.line - tokenBefore.loc.end.line <= 1\r\n            ) {\r\n                return tokenBefore;\r\n            }\r\n\r\n            return null;\r\n        };\r\n        let parent = node.parent;\r\n\r\n        switch (node.type) {\r\n            case \"ClassDeclaration\":\r\n            case \"FunctionDeclaration\":\r\n                return findJSDocComment(looksLikeExport(parent) ? parent : node);\r\n\r\n            case \"ClassExpression\":\r\n                return findJSDocComment(parent.parent);\r\n\r\n            case \"ArrowFunctionExpression\":\r\n            case \"FunctionExpression\":\r\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\r\n                    while (\r\n                        !this.getCommentsBefore(parent).length &&\r\n                        !/Function/u.test(parent.type) &&\r\n                        parent.type !== \"MethodDefinition\" &&\r\n                        parent.type !== \"Property\"\r\n                    ) {\r\n                        parent = parent.parent;\r\n\r\n                        if (!parent) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (parent && parent.type !== \"FunctionDeclaration\" && parent.type !== \"Program\") {\r\n                        return findJSDocComment(parent);\r\n                    }\r\n                }\r\n\r\n                return findJSDocComment(node);\r\n\r\n            // falls through\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the deepest node containing a range index.\r\n     * @param {int} index Range index of the desired node.\r\n     * @returns {ASTNode} The node if found or null if not found.\r\n     * @public\r\n     */\r\n    getNodeByRangeIndex(index) {\r\n        let result = null;\r\n\r\n        Traverser.traverse(this.ast, {\r\n            visitorKeys: this.visitorKeys,\r\n            enter(node) {\r\n                if (node.range[0] <= index && index < node.range[1]) {\r\n                    result = node;\r\n                } else {\r\n                    this.skip();\r\n                }\r\n            },\r\n            leave(node) {\r\n                if (node === result) {\r\n                    this.break();\r\n                }\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Determines if two nodes or tokens have at least one whitespace character\r\n     * between them. Order does not matter. Returns false if the given nodes or\r\n     * tokens overlap.\r\n     * @param {ASTNode|Token} first The first node or token to check between.\r\n     * @param {ASTNode|Token} second The second node or token to check between.\r\n     * @returns {boolean} True if there is a whitespace character between\r\n     * any of the tokens found between the two given nodes or tokens.\r\n     * @public\r\n     */\r\n    isSpaceBetween(first, second) {\r\n        return isSpaceBetween(this, first, second, false);\r\n    }\r\n\r\n    /**\r\n     * Determines if two nodes or tokens have at least one whitespace character\r\n     * between them. Order does not matter. Returns false if the given nodes or\r\n     * tokens overlap.\r\n     * For backward compatibility, this method returns true if there are\r\n     * `JSXText` tokens that contain whitespaces between the two.\r\n     * @param {ASTNode|Token} first The first node or token to check between.\r\n     * @param {ASTNode|Token} second The second node or token to check between.\r\n     * @returns {boolean} True if there is a whitespace character between\r\n     * any of the tokens found between the two given nodes or tokens.\r\n     * @deprecated in favor of isSpaceBetween().\r\n     * @public\r\n     */\r\n    isSpaceBetweenTokens(first, second) {\r\n        return isSpaceBetween(this, first, second, true);\r\n    }\r\n\r\n    /**\r\n     * Converts a source text index into a (line, column) pair.\r\n     * @param {number} index The index of a character in a file\r\n     * @throws {TypeError} If non-numeric index or index out of range.\r\n     * @returns {Object} A {line, column} location object with a 0-indexed column\r\n     * @public\r\n     */\r\n    getLocFromIndex(index) {\r\n        if (typeof index !== \"number\") {\r\n            throw new TypeError(\"Expected `index` to be a number.\");\r\n        }\r\n\r\n        if (index < 0 || index > this.text.length) {\r\n            throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);\r\n        }\r\n\r\n        /*\r\n         * For an argument of this.text.length, return the location one \"spot\" past the last character\r\n         * of the file. If the last character is a linebreak, the location will be column 0 of the next\r\n         * line; otherwise, the location will be in the next column on the same line.\r\n         *\r\n         * See getIndexFromLoc for the motivation for this special case.\r\n         */\r\n        if (index === this.text.length) {\r\n            return { line: this.lines.length, column: this.lines[this.lines.length - 1].length };\r\n        }\r\n\r\n        /*\r\n         * To figure out which line index is on, determine the last place at which index could\r\n         * be inserted into lineStartIndices to keep the list sorted.\r\n         */\r\n        const lineNumber = index >= this.lineStartIndices[this.lineStartIndices.length - 1]\r\n            ? this.lineStartIndices.length\r\n            : this.lineStartIndices.findIndex(el => index < el);\r\n\r\n        return { line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] };\r\n    }\r\n\r\n    /**\r\n     * Converts a (line, column) pair into a range index.\r\n     * @param {Object} loc A line/column location\r\n     * @param {number} loc.line The line number of the location (1-indexed)\r\n     * @param {number} loc.column The column number of the location (0-indexed)\r\n     * @throws {TypeError|RangeError} If `loc` is not an object with a numeric\r\n     *   `line` and `column`, if the `line` is less than or equal to zero or\r\n     *   the line or column is out of the expected range.\r\n     * @returns {number} The range index of the location in the file.\r\n     * @public\r\n     */\r\n    getIndexFromLoc(loc) {\r\n        if (typeof loc !== \"object\" || typeof loc.line !== \"number\" || typeof loc.column !== \"number\") {\r\n            throw new TypeError(\"Expected `loc` to be an object with numeric `line` and `column` properties.\");\r\n        }\r\n\r\n        if (loc.line <= 0) {\r\n            throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);\r\n        }\r\n\r\n        if (loc.line > this.lineStartIndices.length) {\r\n            throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);\r\n        }\r\n\r\n        const lineStartIndex = this.lineStartIndices[loc.line - 1];\r\n        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];\r\n        const positionIndex = lineStartIndex + loc.column;\r\n\r\n        /*\r\n         * By design, getIndexFromLoc({ line: lineNum, column: 0 }) should return the start index of\r\n         * the given line, provided that the line number is valid element of this.lines. Since the\r\n         * last element of this.lines is an empty string for files with trailing newlines, add a\r\n         * special case where getting the index for the first location after the end of the file\r\n         * will return the length of the file, rather than throwing an error. This allows rules to\r\n         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.\r\n         */\r\n        if (\r\n            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||\r\n            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex\r\n        ) {\r\n            throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);\r\n        }\r\n\r\n        return positionIndex;\r\n    }\r\n}\r\n\r\nmodule.exports = SourceCode;\r\n"]},"metadata":{},"sourceType":"script"}