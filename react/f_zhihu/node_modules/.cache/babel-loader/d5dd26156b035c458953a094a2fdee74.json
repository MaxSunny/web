{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag non-quoted property names in object literals.\r\n * @author Mathias Bynens <http://mathiasbynens.be/>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst espree = require(\"espree\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require quotes around object literal property names\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quote-props\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\n        }, {\n          type: \"object\",\n          properties: {\n            keywords: {\n              type: \"boolean\"\n            },\n            unnecessary: {\n              type: \"boolean\"\n            },\n            numbers: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\n      inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\n      unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\n      unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\n      unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\n      unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\n      redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\n    }\n  },\n\n  create(context) {\n    const MODE = context.options[0],\n          KEYWORDS = context.options[1] && context.options[1].keywords,\n          CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\n          NUMBERS = context.options[1] && context.options[1].numbers,\n          sourceCode = context.getSourceCode();\n    /**\r\n     * Checks whether a certain string constitutes an ES3 token\r\n     * @param {string} tokenStr The string to be checked.\r\n     * @returns {boolean} `true` if it is an ES3 token.\r\n     */\n\n    function isKeyword(tokenStr) {\n      return keywords.indexOf(tokenStr) >= 0;\n    }\n    /**\r\n     * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\r\n     * @param {string} rawKey The raw key value from the source\r\n     * @param {espreeTokens} tokens The espree-tokenized node key\r\n     * @param {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\r\n     * @returns {boolean} Whether or not a key has redundant quotes.\r\n     * @private\r\n     */\n\n\n    function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\n      return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 || tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);\n    }\n    /**\r\n     * Returns a string representation of a property node with quotes removed\r\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\r\n     * @returns {string} A replacement string for this property\r\n     */\n\n\n    function getUnquotedKey(key) {\n      return key.type === \"Identifier\" ? key.name : key.value;\n    }\n    /**\r\n     * Returns a string representation of a property node with quotes added\r\n     * @param {ASTNode} key Key AST Node, which may or may not be quoted\r\n     * @returns {string} A replacement string for this property\r\n     */\n\n\n    function getQuotedKey(key) {\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        // If the key is already a string literal, don't replace the quotes with double quotes.\n        return sourceCode.getText(key);\n      } // Otherwise, the key is either an identifier or a number literal.\n\n\n      return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\n    }\n    /**\r\n     * Ensures that a property's key is quoted only when necessary\r\n     * @param {ASTNode} node Property AST node\r\n     * @returns {void}\r\n     */\n\n\n    function checkUnnecessaryQuotes(node) {\n      const key = node.key;\n\n      if (node.method || node.computed || node.shorthand) {\n        return;\n      }\n\n      if (key.type === \"Literal\" && typeof key.value === \"string\") {\n        let tokens;\n\n        try {\n          tokens = espree.tokenize(key.value);\n        } catch {\n          return;\n        }\n\n        if (tokens.length !== 1) {\n          return;\n        }\n\n        const isKeywordToken = isKeyword(tokens[0].value);\n\n        if (isKeywordToken && KEYWORDS) {\n          return;\n        }\n\n        if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\n          context.report({\n            node,\n            messageId: \"unnecessarilyQuotedProperty\",\n            data: {\n              property: key.value\n            },\n            fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\n          });\n        }\n      } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\n        context.report({\n          node,\n          messageId: \"unquotedReservedProperty\",\n          data: {\n            property: key.name\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\n        context.report({\n          node,\n          messageId: \"unquotedNumericProperty\",\n          data: {\n            property: key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\r\n     * Ensures that a property's key is quoted\r\n     * @param {ASTNode} node Property AST node\r\n     * @returns {void}\r\n     */\n\n\n    function checkOmittedQuotes(node) {\n      const key = node.key;\n\n      if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\n        context.report({\n          node,\n          messageId: \"unquotedPropertyFound\",\n          data: {\n            property: key.name || key.value\n          },\n          fix: fixer => fixer.replaceText(key, getQuotedKey(key))\n        });\n      }\n    }\n    /**\r\n     * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\r\n     * @param {ASTNode} node Property AST node\r\n     * @param {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\r\n     * @returns {void}\r\n     */\n\n\n    function checkConsistency(node, checkQuotesRedundancy) {\n      const quotedProps = [],\n            unquotedProps = [];\n      let keywordKeyName = null,\n          necessaryQuotes = false;\n      node.properties.forEach(property => {\n        const key = property.key;\n\n        if (!key || property.method || property.computed || property.shorthand) {\n          return;\n        }\n\n        if (key.type === \"Literal\" && typeof key.value === \"string\") {\n          quotedProps.push(property);\n\n          if (checkQuotesRedundancy) {\n            let tokens;\n\n            try {\n              tokens = espree.tokenize(key.value);\n            } catch {\n              necessaryQuotes = true;\n              return;\n            }\n\n            necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\n          }\n        } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\n          unquotedProps.push(property);\n          necessaryQuotes = true;\n          keywordKeyName = key.name;\n        } else {\n          unquotedProps.push(property);\n        }\n      });\n\n      if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\n        quotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"redundantQuoting\",\n            fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\n          });\n        });\n      } else if (unquotedProps.length && keywordKeyName) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"requireQuotesDueToReservedWord\",\n            data: {\n              property: keywordKeyName\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      } else if (quotedProps.length && unquotedProps.length) {\n        unquotedProps.forEach(property => {\n          context.report({\n            node: property,\n            messageId: \"inconsistentlyQuotedProperty\",\n            data: {\n              key: property.key.name || property.key.value\n            },\n            fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\n          });\n        });\n      }\n    }\n\n    return {\n      Property(node) {\n        if (MODE === \"always\" || !MODE) {\n          checkOmittedQuotes(node);\n        }\n\n        if (MODE === \"as-needed\") {\n          checkUnnecessaryQuotes(node);\n        }\n      },\n\n      ObjectExpression(node) {\n        if (MODE === \"consistent\") {\n          checkConsistency(node, false);\n        }\n\n        if (MODE === \"consistent-as-needed\") {\n          checkConsistency(node, true);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/quote-props.js"],"names":["espree","require","astUtils","keywords","module","exports","meta","type","docs","description","recommended","url","schema","anyOf","items","enum","minItems","maxItems","properties","unnecessary","numbers","additionalProperties","fixable","messages","requireQuotesDueToReservedWord","inconsistentlyQuotedProperty","unnecessarilyQuotedProperty","unquotedReservedProperty","unquotedNumericProperty","unquotedPropertyFound","redundantQuoting","create","context","MODE","options","KEYWORDS","CHECK_UNNECESSARY","NUMBERS","sourceCode","getSourceCode","isKeyword","tokenStr","indexOf","areQuotesRedundant","rawKey","tokens","skipNumberLiterals","length","start","end","String","value","getUnquotedKey","key","name","getQuotedKey","getText","checkUnnecessaryQuotes","node","method","computed","shorthand","tokenize","isKeywordToken","report","messageId","data","property","fix","fixer","replaceText","isNumericLiteral","checkOmittedQuotes","checkConsistency","checkQuotesRedundancy","quotedProps","unquotedProps","keywordKeyName","necessaryQuotes","forEach","push","Property","ObjectExpression"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,kBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;;;AACAG,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,qDADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE;AACJC,MAAAA,KAAK,EAAE,CACH;AACIN,QAAAA,IAAI,EAAE,OADV;AAEIO,QAAAA,KAAK,EAAE,CACH;AACIC,UAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,WAAX,EAAwB,YAAxB,EAAsC,sBAAtC;AADV,SADG,CAFX;AAOIC,QAAAA,QAAQ,EAAE,CAPd;AAQIC,QAAAA,QAAQ,EAAE;AARd,OADG,EAWH;AACIV,QAAAA,IAAI,EAAE,OADV;AAEIO,QAAAA,KAAK,EAAE,CACH;AACIC,UAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,WAAX,EAAwB,YAAxB,EAAsC,sBAAtC;AADV,SADG,EAIH;AACIR,UAAAA,IAAI,EAAE,QADV;AAEIW,UAAAA,UAAU,EAAE;AACRf,YAAAA,QAAQ,EAAE;AACNI,cAAAA,IAAI,EAAE;AADA,aADF;AAIRY,YAAAA,WAAW,EAAE;AACTZ,cAAAA,IAAI,EAAE;AADG,aAJL;AAORa,YAAAA,OAAO,EAAE;AACLb,cAAAA,IAAI,EAAE;AADD;AAPD,WAFhB;AAaIc,UAAAA,oBAAoB,EAAE;AAb1B,SAJG,CAFX;AAsBIL,QAAAA,QAAQ,EAAE,CAtBd;AAuBIC,QAAAA,QAAQ,EAAE;AAvBd,OAXG;AADH,KATN;AAiDFK,IAAAA,OAAO,EAAE,MAjDP;AAkDFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,8BAA8B,EAAE,mEAD1B;AAENC,MAAAA,4BAA4B,EAAE,iDAFxB;AAGNC,MAAAA,2BAA2B,EAAE,qDAHvB;AAINC,MAAAA,wBAAwB,EAAE,oDAJpB;AAKNC,MAAAA,uBAAuB,EAAE,qDALnB;AAMNC,MAAAA,qBAAqB,EAAE,yCANjB;AAONC,MAAAA,gBAAgB,EAAE;AAPZ;AAlDR,GADO;;AA8DbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,IAAI,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAb;AAAA,UACIC,QAAQ,GAAGH,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsBF,OAAO,CAACE,OAAR,CAAgB,CAAhB,EAAmB/B,QADxD;AAAA,UAEIiC,iBAAiB,GAAG,CAACJ,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,IAAuBF,OAAO,CAACE,OAAR,CAAgB,CAAhB,EAAmBf,WAAnB,KAAmC,KAFlF;AAAA,UAGIkB,OAAO,GAAGL,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsBF,OAAO,CAACE,OAAR,CAAgB,CAAhB,EAAmBd,OAHvD;AAAA,UAKIkB,UAAU,GAAGN,OAAO,CAACO,aAAR,EALjB;AAQA;AACR;AACA;AACA;AACA;;AACQ,aAASC,SAAT,CAAmBC,QAAnB,EAA6B;AACzB,aAAOtC,QAAQ,CAACuC,OAAT,CAAiBD,QAAjB,KAA8B,CAArC;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASE,kBAAT,CAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,kBAA5C,EAAgE;AAC5D,aAAOD,MAAM,CAACE,MAAP,KAAkB,CAAlB,IAAuBF,MAAM,CAAC,CAAD,CAAN,CAAUG,KAAV,KAAoB,CAA3C,IAAgDH,MAAM,CAAC,CAAD,CAAN,CAAUI,GAAV,KAAkBL,MAAM,CAACG,MAAzE,KACF,CAAC,YAAD,EAAe,SAAf,EAA0B,MAA1B,EAAkC,SAAlC,EAA6CL,OAA7C,CAAqDG,MAAM,CAAC,CAAD,CAAN,CAAUtC,IAA/D,KAAwE,CAAxE,IACAsC,MAAM,CAAC,CAAD,CAAN,CAAUtC,IAAV,KAAmB,SAAnB,IAAgC,CAACuC,kBAAjC,IAAuDI,MAAM,CAAC,CAACL,MAAM,CAAC,CAAD,CAAN,CAAUM,KAAZ,CAAN,KAA6BN,MAAM,CAAC,CAAD,CAAN,CAAUM,KAF5F,CAAP;AAGH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,cAAT,CAAwBC,GAAxB,EAA6B;AACzB,aAAOA,GAAG,CAAC9C,IAAJ,KAAa,YAAb,GAA4B8C,GAAG,CAACC,IAAhC,GAAuCD,GAAG,CAACF,KAAlD;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASI,YAAT,CAAsBF,GAAtB,EAA2B;AACvB,UAAIA,GAAG,CAAC9C,IAAJ,KAAa,SAAb,IAA0B,OAAO8C,GAAG,CAACF,KAAX,KAAqB,QAAnD,EAA6D;AAEzD;AACA,eAAOb,UAAU,CAACkB,OAAX,CAAmBH,GAAnB,CAAP;AACH,OALsB,CAOvB;;;AACA,aAAQ,IAAGA,GAAG,CAAC9C,IAAJ,KAAa,YAAb,GAA4B8C,GAAG,CAACC,IAAhC,GAAuCD,GAAG,CAACF,KAAM,GAA5D;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASM,sBAAT,CAAgCC,IAAhC,EAAsC;AAClC,YAAML,GAAG,GAAGK,IAAI,CAACL,GAAjB;;AAEA,UAAIK,IAAI,CAACC,MAAL,IAAeD,IAAI,CAACE,QAApB,IAAgCF,IAAI,CAACG,SAAzC,EAAoD;AAChD;AACH;;AAED,UAAIR,GAAG,CAAC9C,IAAJ,KAAa,SAAb,IAA0B,OAAO8C,GAAG,CAACF,KAAX,KAAqB,QAAnD,EAA6D;AACzD,YAAIN,MAAJ;;AAEA,YAAI;AACAA,UAAAA,MAAM,GAAG7C,MAAM,CAAC8D,QAAP,CAAgBT,GAAG,CAACF,KAApB,CAAT;AACH,SAFD,CAEE,MAAM;AACJ;AACH;;AAED,YAAIN,MAAM,CAACE,MAAP,KAAkB,CAAtB,EAAyB;AACrB;AACH;;AAED,cAAMgB,cAAc,GAAGvB,SAAS,CAACK,MAAM,CAAC,CAAD,CAAN,CAAUM,KAAX,CAAhC;;AAEA,YAAIY,cAAc,IAAI5B,QAAtB,EAAgC;AAC5B;AACH;;AAED,YAAIC,iBAAiB,IAAIO,kBAAkB,CAACU,GAAG,CAACF,KAAL,EAAYN,MAAZ,EAAoBR,OAApB,CAA3C,EAAyE;AACrEL,UAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,YAAAA,IADW;AAEXO,YAAAA,SAAS,EAAE,6BAFA;AAGXC,YAAAA,IAAI,EAAE;AAAEC,cAAAA,QAAQ,EAAEd,GAAG,CAACF;AAAhB,aAHK;AAIXiB,YAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBjB,GAAlB,EAAuBD,cAAc,CAACC,GAAD,CAArC;AAJH,WAAf;AAMH;AACJ,OA3BD,MA2BO,IAAIlB,QAAQ,IAAIkB,GAAG,CAAC9C,IAAJ,KAAa,YAAzB,IAAyCiC,SAAS,CAACa,GAAG,CAACC,IAAL,CAAtD,EAAkE;AACrEtB,QAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,UAAAA,IADW;AAEXO,UAAAA,SAAS,EAAE,0BAFA;AAGXC,UAAAA,IAAI,EAAE;AAAEC,YAAAA,QAAQ,EAAEd,GAAG,CAACC;AAAhB,WAHK;AAIXc,UAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBjB,GAAlB,EAAuBE,YAAY,CAACF,GAAD,CAAnC;AAJH,SAAf;AAMH,OAPM,MAOA,IAAIhB,OAAO,IAAIgB,GAAG,CAAC9C,IAAJ,KAAa,SAAxB,IAAqCL,QAAQ,CAACqE,gBAAT,CAA0BlB,GAA1B,CAAzC,EAAyE;AAC5ErB,QAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,UAAAA,IADW;AAEXO,UAAAA,SAAS,EAAE,yBAFA;AAGXC,UAAAA,IAAI,EAAE;AAAEC,YAAAA,QAAQ,EAAEd,GAAG,CAACF;AAAhB,WAHK;AAIXiB,UAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBjB,GAAlB,EAAuBE,YAAY,CAACF,GAAD,CAAnC;AAJH,SAAf;AAMH;AACJ;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASmB,kBAAT,CAA4Bd,IAA5B,EAAkC;AAC9B,YAAML,GAAG,GAAGK,IAAI,CAACL,GAAjB;;AAEA,UAAI,CAACK,IAAI,CAACC,MAAN,IAAgB,CAACD,IAAI,CAACE,QAAtB,IAAkC,CAACF,IAAI,CAACG,SAAxC,IAAqD,EAAER,GAAG,CAAC9C,IAAJ,KAAa,SAAb,IAA0B,OAAO8C,GAAG,CAACF,KAAX,KAAqB,QAAjD,CAAzD,EAAqH;AACjHnB,QAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,UAAAA,IADW;AAEXO,UAAAA,SAAS,EAAE,uBAFA;AAGXC,UAAAA,IAAI,EAAE;AAAEC,YAAAA,QAAQ,EAAEd,GAAG,CAACC,IAAJ,IAAYD,GAAG,CAACF;AAA5B,WAHK;AAIXiB,UAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBjB,GAAlB,EAAuBE,YAAY,CAACF,GAAD,CAAnC;AAJH,SAAf;AAMH;AACJ;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASoB,gBAAT,CAA0Bf,IAA1B,EAAgCgB,qBAAhC,EAAuD;AACnD,YAAMC,WAAW,GAAG,EAApB;AAAA,YACIC,aAAa,GAAG,EADpB;AAEA,UAAIC,cAAc,GAAG,IAArB;AAAA,UACIC,eAAe,GAAG,KADtB;AAGApB,MAAAA,IAAI,CAACxC,UAAL,CAAgB6D,OAAhB,CAAwBZ,QAAQ,IAAI;AAChC,cAAMd,GAAG,GAAGc,QAAQ,CAACd,GAArB;;AAEA,YAAI,CAACA,GAAD,IAAQc,QAAQ,CAACR,MAAjB,IAA2BQ,QAAQ,CAACP,QAApC,IAAgDO,QAAQ,CAACN,SAA7D,EAAwE;AACpE;AACH;;AAED,YAAIR,GAAG,CAAC9C,IAAJ,KAAa,SAAb,IAA0B,OAAO8C,GAAG,CAACF,KAAX,KAAqB,QAAnD,EAA6D;AAEzDwB,UAAAA,WAAW,CAACK,IAAZ,CAAiBb,QAAjB;;AAEA,cAAIO,qBAAJ,EAA2B;AACvB,gBAAI7B,MAAJ;;AAEA,gBAAI;AACAA,cAAAA,MAAM,GAAG7C,MAAM,CAAC8D,QAAP,CAAgBT,GAAG,CAACF,KAApB,CAAT;AACH,aAFD,CAEE,MAAM;AACJ2B,cAAAA,eAAe,GAAG,IAAlB;AACA;AACH;;AAEDA,YAAAA,eAAe,GAAGA,eAAe,IAAI,CAACnC,kBAAkB,CAACU,GAAG,CAACF,KAAL,EAAYN,MAAZ,CAAtC,IAA6DV,QAAQ,IAAIK,SAAS,CAACK,MAAM,CAAC,CAAD,CAAN,CAAUM,KAAX,CAApG;AACH;AACJ,SAhBD,MAgBO,IAAIhB,QAAQ,IAAIuC,qBAAZ,IAAqCrB,GAAG,CAAC9C,IAAJ,KAAa,YAAlD,IAAkEiC,SAAS,CAACa,GAAG,CAACC,IAAL,CAA/E,EAA2F;AAC9FsB,UAAAA,aAAa,CAACI,IAAd,CAAmBb,QAAnB;AACAW,UAAAA,eAAe,GAAG,IAAlB;AACAD,UAAAA,cAAc,GAAGxB,GAAG,CAACC,IAArB;AACH,SAJM,MAIA;AACHsB,UAAAA,aAAa,CAACI,IAAd,CAAmBb,QAAnB;AACH;AACJ,OA9BD;;AAgCA,UAAIO,qBAAqB,IAAIC,WAAW,CAAC5B,MAArC,IAA+C,CAAC+B,eAApD,EAAqE;AACjEH,QAAAA,WAAW,CAACI,OAAZ,CAAoBZ,QAAQ,IAAI;AAC5BnC,UAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,YAAAA,IAAI,EAAES,QADK;AAEXF,YAAAA,SAAS,EAAE,kBAFA;AAGXG,YAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBH,QAAQ,CAACd,GAA3B,EAAgCD,cAAc,CAACe,QAAQ,CAACd,GAAV,CAA9C;AAHH,WAAf;AAKH,SAND;AAOH,OARD,MAQO,IAAIuB,aAAa,CAAC7B,MAAd,IAAwB8B,cAA5B,EAA4C;AAC/CD,QAAAA,aAAa,CAACG,OAAd,CAAsBZ,QAAQ,IAAI;AAC9BnC,UAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,YAAAA,IAAI,EAAES,QADK;AAEXF,YAAAA,SAAS,EAAE,gCAFA;AAGXC,YAAAA,IAAI,EAAE;AAAEC,cAAAA,QAAQ,EAAEU;AAAZ,aAHK;AAIXT,YAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBH,QAAQ,CAACd,GAA3B,EAAgCE,YAAY,CAACY,QAAQ,CAACd,GAAV,CAA5C;AAJH,WAAf;AAMH,SAPD;AAQH,OATM,MASA,IAAIsB,WAAW,CAAC5B,MAAZ,IAAsB6B,aAAa,CAAC7B,MAAxC,EAAgD;AACnD6B,QAAAA,aAAa,CAACG,OAAd,CAAsBZ,QAAQ,IAAI;AAC9BnC,UAAAA,OAAO,CAACgC,MAAR,CAAe;AACXN,YAAAA,IAAI,EAAES,QADK;AAEXF,YAAAA,SAAS,EAAE,8BAFA;AAGXC,YAAAA,IAAI,EAAE;AAAEb,cAAAA,GAAG,EAAEc,QAAQ,CAACd,GAAT,CAAaC,IAAb,IAAqBa,QAAQ,CAACd,GAAT,CAAaF;AAAzC,aAHK;AAIXiB,YAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,WAAN,CAAkBH,QAAQ,CAACd,GAA3B,EAAgCE,YAAY,CAACY,QAAQ,CAACd,GAAV,CAA5C;AAJH,WAAf;AAMH,SAPD;AAQH;AACJ;;AAED,WAAO;AACH4B,MAAAA,QAAQ,CAACvB,IAAD,EAAO;AACX,YAAIzB,IAAI,KAAK,QAAT,IAAqB,CAACA,IAA1B,EAAgC;AAC5BuC,UAAAA,kBAAkB,CAACd,IAAD,CAAlB;AACH;;AACD,YAAIzB,IAAI,KAAK,WAAb,EAA0B;AACtBwB,UAAAA,sBAAsB,CAACC,IAAD,CAAtB;AACH;AACJ,OARE;;AASHwB,MAAAA,gBAAgB,CAACxB,IAAD,EAAO;AACnB,YAAIzB,IAAI,KAAK,YAAb,EAA2B;AACvBwC,UAAAA,gBAAgB,CAACf,IAAD,EAAO,KAAP,CAAhB;AACH;;AACD,YAAIzB,IAAI,KAAK,sBAAb,EAAqC;AACjCwC,UAAAA,gBAAgB,CAACf,IAAD,EAAO,IAAP,CAAhB;AACH;AACJ;;AAhBE,KAAP;AAmBH;;AA9RY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag non-quoted property names in object literals.\r\n * @author Mathias Bynens <http://mathiasbynens.be/>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst espree = require(\"espree\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst keywords = require(\"./utils/keywords\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require quotes around object literal property names\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/quote-props\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 1\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"as-needed\", \"consistent\", \"consistent-as-needed\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                keywords: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                unnecessary: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                numbers: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            requireQuotesDueToReservedWord: \"Properties should be quoted as '{{property}}' is a reserved word.\",\r\n            inconsistentlyQuotedProperty: \"Inconsistently quoted property '{{key}}' found.\",\r\n            unnecessarilyQuotedProperty: \"Unnecessarily quoted property '{{property}}' found.\",\r\n            unquotedReservedProperty: \"Unquoted reserved word '{{property}}' used as key.\",\r\n            unquotedNumericProperty: \"Unquoted number literal '{{property}}' used as key.\",\r\n            unquotedPropertyFound: \"Unquoted property '{{property}}' found.\",\r\n            redundantQuoting: \"Properties shouldn't be quoted as all quotes are redundant.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const MODE = context.options[0],\r\n            KEYWORDS = context.options[1] && context.options[1].keywords,\r\n            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,\r\n            NUMBERS = context.options[1] && context.options[1].numbers,\r\n\r\n            sourceCode = context.getSourceCode();\r\n\r\n\r\n        /**\r\n         * Checks whether a certain string constitutes an ES3 token\r\n         * @param {string} tokenStr The string to be checked.\r\n         * @returns {boolean} `true` if it is an ES3 token.\r\n         */\r\n        function isKeyword(tokenStr) {\r\n            return keywords.indexOf(tokenStr) >= 0;\r\n        }\r\n\r\n        /**\r\n         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)\r\n         * @param {string} rawKey The raw key value from the source\r\n         * @param {espreeTokens} tokens The espree-tokenized node key\r\n         * @param {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked\r\n         * @returns {boolean} Whether or not a key has redundant quotes.\r\n         * @private\r\n         */\r\n        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {\r\n            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&\r\n                ([\"Identifier\", \"Keyword\", \"Null\", \"Boolean\"].indexOf(tokens[0].type) >= 0 ||\r\n                (tokens[0].type === \"Numeric\" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));\r\n        }\r\n\r\n        /**\r\n         * Returns a string representation of a property node with quotes removed\r\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\r\n         * @returns {string} A replacement string for this property\r\n         */\r\n        function getUnquotedKey(key) {\r\n            return key.type === \"Identifier\" ? key.name : key.value;\r\n        }\r\n\r\n        /**\r\n         * Returns a string representation of a property node with quotes added\r\n         * @param {ASTNode} key Key AST Node, which may or may not be quoted\r\n         * @returns {string} A replacement string for this property\r\n         */\r\n        function getQuotedKey(key) {\r\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\r\n\r\n                // If the key is already a string literal, don't replace the quotes with double quotes.\r\n                return sourceCode.getText(key);\r\n            }\r\n\r\n            // Otherwise, the key is either an identifier or a number literal.\r\n            return `\"${key.type === \"Identifier\" ? key.name : key.value}\"`;\r\n        }\r\n\r\n        /**\r\n         * Ensures that a property's key is quoted only when necessary\r\n         * @param {ASTNode} node Property AST node\r\n         * @returns {void}\r\n         */\r\n        function checkUnnecessaryQuotes(node) {\r\n            const key = node.key;\r\n\r\n            if (node.method || node.computed || node.shorthand) {\r\n                return;\r\n            }\r\n\r\n            if (key.type === \"Literal\" && typeof key.value === \"string\") {\r\n                let tokens;\r\n\r\n                try {\r\n                    tokens = espree.tokenize(key.value);\r\n                } catch {\r\n                    return;\r\n                }\r\n\r\n                if (tokens.length !== 1) {\r\n                    return;\r\n                }\r\n\r\n                const isKeywordToken = isKeyword(tokens[0].value);\r\n\r\n                if (isKeywordToken && KEYWORDS) {\r\n                    return;\r\n                }\r\n\r\n                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unnecessarilyQuotedProperty\",\r\n                        data: { property: key.value },\r\n                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))\r\n                    });\r\n                }\r\n            } else if (KEYWORDS && key.type === \"Identifier\" && isKeyword(key.name)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unquotedReservedProperty\",\r\n                    data: { property: key.name },\r\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\r\n                });\r\n            } else if (NUMBERS && key.type === \"Literal\" && astUtils.isNumericLiteral(key)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unquotedNumericProperty\",\r\n                    data: { property: key.value },\r\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Ensures that a property's key is quoted\r\n         * @param {ASTNode} node Property AST node\r\n         * @returns {void}\r\n         */\r\n        function checkOmittedQuotes(node) {\r\n            const key = node.key;\r\n\r\n            if (!node.method && !node.computed && !node.shorthand && !(key.type === \"Literal\" && typeof key.value === \"string\")) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unquotedPropertyFound\",\r\n                    data: { property: key.name || key.value },\r\n                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes\r\n         * @param {ASTNode} node Property AST node\r\n         * @param {boolean} checkQuotesRedundancy Whether to check quotes' redundancy\r\n         * @returns {void}\r\n         */\r\n        function checkConsistency(node, checkQuotesRedundancy) {\r\n            const quotedProps = [],\r\n                unquotedProps = [];\r\n            let keywordKeyName = null,\r\n                necessaryQuotes = false;\r\n\r\n            node.properties.forEach(property => {\r\n                const key = property.key;\r\n\r\n                if (!key || property.method || property.computed || property.shorthand) {\r\n                    return;\r\n                }\r\n\r\n                if (key.type === \"Literal\" && typeof key.value === \"string\") {\r\n\r\n                    quotedProps.push(property);\r\n\r\n                    if (checkQuotesRedundancy) {\r\n                        let tokens;\r\n\r\n                        try {\r\n                            tokens = espree.tokenize(key.value);\r\n                        } catch {\r\n                            necessaryQuotes = true;\r\n                            return;\r\n                        }\r\n\r\n                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);\r\n                    }\r\n                } else if (KEYWORDS && checkQuotesRedundancy && key.type === \"Identifier\" && isKeyword(key.name)) {\r\n                    unquotedProps.push(property);\r\n                    necessaryQuotes = true;\r\n                    keywordKeyName = key.name;\r\n                } else {\r\n                    unquotedProps.push(property);\r\n                }\r\n            });\r\n\r\n            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {\r\n                quotedProps.forEach(property => {\r\n                    context.report({\r\n                        node: property,\r\n                        messageId: \"redundantQuoting\",\r\n                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))\r\n                    });\r\n                });\r\n            } else if (unquotedProps.length && keywordKeyName) {\r\n                unquotedProps.forEach(property => {\r\n                    context.report({\r\n                        node: property,\r\n                        messageId: \"requireQuotesDueToReservedWord\",\r\n                        data: { property: keywordKeyName },\r\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\r\n                    });\r\n                });\r\n            } else if (quotedProps.length && unquotedProps.length) {\r\n                unquotedProps.forEach(property => {\r\n                    context.report({\r\n                        node: property,\r\n                        messageId: \"inconsistentlyQuotedProperty\",\r\n                        data: { key: property.key.name || property.key.value },\r\n                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))\r\n                    });\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            Property(node) {\r\n                if (MODE === \"always\" || !MODE) {\r\n                    checkOmittedQuotes(node);\r\n                }\r\n                if (MODE === \"as-needed\") {\r\n                    checkUnnecessaryQuotes(node);\r\n                }\r\n            },\r\n            ObjectExpression(node) {\r\n                if (MODE === \"consistent\") {\r\n                    checkConsistency(node, false);\r\n                }\r\n                if (MODE === \"consistent-as-needed\") {\r\n                    checkConsistency(node, true);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}