{"ast":null,"code":"/**\r\n * @fileoverview enforce the location of arrow function bodies\r\n * @author Sharmila Jesupaul\r\n */\n\"use strict\";\n\nconst {\n  isCommentToken,\n  isNotOpeningParenToken\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the location of arrow function bodies\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"beside\", \"below\"]\n    }],\n    messages: {\n      expected: \"Expected a linebreak before this expression.\",\n      unexpected: \"Expected no linebreak before this expression.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"beside\";\n    /**\r\n     * Validates the location of an arrow function body\r\n     * @param {ASTNode} node The arrow function body\r\n     * @returns {void}\r\n     */\n\n    function validateExpression(node) {\n      if (node.body.type === \"BlockStatement\") {\n        return;\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\n      const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\n\n      if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"expected\",\n          fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\n        });\n      } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\n        context.report({\n          node: firstTokenOfBody,\n          messageId: \"unexpected\",\n\n          fix(fixer) {\n            if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {\n              includeComments: true,\n              filter: isCommentToken\n            })) {\n              return null;\n            }\n\n            return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\n          }\n\n        });\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: node => validateExpression(node)\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/implicit-arrow-linebreak.js"],"names":["isCommentToken","isNotOpeningParenToken","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","messages","expected","unexpected","create","context","sourceCode","getSourceCode","option","options","validateExpression","node","body","arrowToken","getTokenBefore","firstTokenOfBody","getTokenAfter","loc","end","line","start","report","messageId","fix","fixer","insertTextBefore","getFirstTokenBetween","includeComments","filter","replaceTextRange","range","ArrowFunctionExpression"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AAAEA,EAAAA,cAAF;AAAkBC,EAAAA;AAAlB,IAA6CC,OAAO,CAAC,mBAAD,CAA1D,C,CAEA;AACA;AACA;;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,QADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,+CADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,OAAO,EAAE,YATP;AAWFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX;AADV,KADI,CAXN;AAgBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,QAAQ,EAAE,8CADJ;AAENC,MAAAA,UAAU,EAAE;AAFN;AAhBR,GADO;;AAuBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AACA,UAAMC,MAAM,GAAGH,OAAO,CAACI,OAAR,CAAgB,CAAhB,KAAsB,QAArC;AAEA;AACR;AACA;AACA;AACA;;AACQ,aAASC,kBAAT,CAA4BC,IAA5B,EAAkC;AAC9B,UAAIA,IAAI,CAACC,IAAL,CAAUnB,IAAV,KAAmB,gBAAvB,EAAyC;AACrC;AACH;;AAED,YAAMoB,UAAU,GAAGP,UAAU,CAACQ,cAAX,CAA0BH,IAAI,CAACC,IAA/B,EAAqCxB,sBAArC,CAAnB;AACA,YAAM2B,gBAAgB,GAAGT,UAAU,CAACU,aAAX,CAAyBH,UAAzB,CAAzB;;AAEA,UAAIA,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,OAA9E,EAAuF;AACnFH,QAAAA,OAAO,CAACgB,MAAR,CAAe;AACXV,UAAAA,IAAI,EAAEI,gBADK;AAEXO,UAAAA,SAAS,EAAE,UAFA;AAGXC,UAAAA,GAAG,EAAEC,KAAK,IAAIA,KAAK,CAACC,gBAAN,CAAuBV,gBAAvB,EAAyC,IAAzC;AAHH,SAAf;AAKH,OAND,MAMO,IAAIF,UAAU,CAACI,GAAX,CAAeC,GAAf,CAAmBC,IAAnB,KAA4BJ,gBAAgB,CAACE,GAAjB,CAAqBG,KAArB,CAA2BD,IAAvD,IAA+DX,MAAM,KAAK,QAA9E,EAAwF;AAC3FH,QAAAA,OAAO,CAACgB,MAAR,CAAe;AACXV,UAAAA,IAAI,EAAEI,gBADK;AAEXO,UAAAA,SAAS,EAAE,YAFA;;AAGXC,UAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,gBAAIlB,UAAU,CAACoB,oBAAX,CAAgCb,UAAhC,EAA4CE,gBAA5C,EAA8D;AAAEY,cAAAA,eAAe,EAAE,IAAnB;AAAyBC,cAAAA,MAAM,EAAEzC;AAAjC,aAA9D,CAAJ,EAAsH;AAClH,qBAAO,IAAP;AACH;;AAED,mBAAOqC,KAAK,CAACK,gBAAN,CAAuB,CAAChB,UAAU,CAACiB,KAAX,CAAiB,CAAjB,CAAD,EAAsBf,gBAAgB,CAACe,KAAjB,CAAuB,CAAvB,CAAtB,CAAvB,EAAyE,GAAzE,CAAP;AACH;;AATU,SAAf;AAWH;AACJ,KApCW,CAsCZ;AACA;AACA;;;AACA,WAAO;AACHC,MAAAA,uBAAuB,EAAEpB,IAAI,IAAID,kBAAkB,CAACC,IAAD;AADhD,KAAP;AAGH;;AAnEY,CAAjB","sourcesContent":["/**\r\n * @fileoverview enforce the location of arrow function bodies\r\n * @author Sharmila Jesupaul\r\n */\r\n\"use strict\";\r\n\r\nconst { isCommentToken, isNotOpeningParenToken } = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce the location of arrow function bodies\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/implicit-arrow-linebreak\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"beside\", \"below\"]\r\n            }\r\n        ],\r\n        messages: {\r\n            expected: \"Expected a linebreak before this expression.\",\r\n            unexpected: \"Expected no linebreak before this expression.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const option = context.options[0] || \"beside\";\r\n\r\n        /**\r\n         * Validates the location of an arrow function body\r\n         * @param {ASTNode} node The arrow function body\r\n         * @returns {void}\r\n         */\r\n        function validateExpression(node) {\r\n            if (node.body.type === \"BlockStatement\") {\r\n                return;\r\n            }\r\n\r\n            const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);\r\n            const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);\r\n\r\n            if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === \"below\") {\r\n                context.report({\r\n                    node: firstTokenOfBody,\r\n                    messageId: \"expected\",\r\n                    fix: fixer => fixer.insertTextBefore(firstTokenOfBody, \"\\n\")\r\n                });\r\n            } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === \"beside\") {\r\n                context.report({\r\n                    node: firstTokenOfBody,\r\n                    messageId: \"unexpected\",\r\n                    fix(fixer) {\r\n                        if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, { includeComments: true, filter: isCommentToken })) {\r\n                            return null;\r\n                        }\r\n\r\n                        return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], \" \");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n        return {\r\n            ArrowFunctionExpression: node => validateExpression(node)\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}