{"ast":null,"code":"/**\r\n * @fileoverview Rule to require or disallow newlines between statements\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\nconst PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`, \"u\");\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\nconst CJS_IMPORT = /^require\\(/u;\n/**\r\n * Creates tester which check if a node starts with specific keyword.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\n\nfunction newKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\r\n * Creates tester which check if a node starts with specific keyword and spans a single line.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\n\n\nfunction newSinglelineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\r\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\n\n\nfunction newMultilineKeywordTester(keyword) {\n  return {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword\n  };\n}\n/**\r\n * Creates tester which check if a node is specific type.\r\n * @param {string} type The node type to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\n\n\nfunction newNodeTypeTester(type) {\n  return {\n    test: node => node.type === type\n  };\n}\n/**\r\n * Checks the given node is an expression statement of IIFE.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\r\n * @private\r\n */\n\n\nfunction isIIFEStatement(node) {\n  if (node.type === \"ExpressionStatement\") {\n    let call = astUtils.skipChainExpression(node.expression);\n\n    if (call.type === \"UnaryExpression\") {\n      call = astUtils.skipChainExpression(call.argument);\n    }\n\n    return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\n  }\n\n  return false;\n}\n/**\r\n * Checks whether the given node is a block-like statement.\r\n * This checks the last token of the node is the closing brace of a block.\r\n * @param {SourceCode} sourceCode The source code to get tokens.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a block-like statement.\r\n * @private\r\n */\n\n\nfunction isBlockLikeStatement(sourceCode, node) {\n  // do-while with a block is a block-like statement.\n  if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\n    return true;\n  }\n  /*\r\n   * IIFE is a block-like statement specially from\r\n   * JSCS#disallowPaddingNewLinesAfterBlocks.\r\n   */\n\n\n  if (isIIFEStatement(node)) {\n    return true;\n  } // Checks the last token is a closing brace of blocks.\n\n\n  const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\n  const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;\n  return Boolean(belongingNode) && (belongingNode.type === \"BlockStatement\" || belongingNode.type === \"SwitchStatement\");\n}\n/**\r\n * Check whether the given node is a directive or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {boolean} `true` if the node is a directive.\r\n */\n\n\nfunction isDirective(node, sourceCode) {\n  return node.type === \"ExpressionStatement\" && (node.parent.type === \"Program\" || node.parent.type === \"BlockStatement\" && astUtils.isFunction(node.parent.parent)) && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\" && !astUtils.isParenthesised(sourceCode, node.expression);\n}\n/**\r\n * Check whether the given node is a part of directive prologue or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {boolean} `true` if the node is a part of directive prologue.\r\n */\n\n\nfunction isDirectivePrologue(node, sourceCode) {\n  if (isDirective(node, sourceCode)) {\n    for (const sibling of node.parent.body) {\n      if (sibling === node) {\n        break;\n      }\n\n      if (!isDirective(sibling, sourceCode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Gets the actual last token.\r\n *\r\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\r\n * For example:\r\n *\r\n *     foo()\r\n *     ;[1, 2, 3].forEach(bar)\r\n * @param {SourceCode} sourceCode The source code to get tokens.\r\n * @param {ASTNode} node The node to get.\r\n * @returns {Token} The actual last token.\r\n * @private\r\n */\n\n\nfunction getActualLastToken(sourceCode, node) {\n  const semiToken = sourceCode.getLastToken(node);\n  const prevToken = sourceCode.getTokenBefore(semiToken);\n  const nextToken = sourceCode.getTokenAfter(semiToken);\n  const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);\n  return isSemicolonLessStyle ? prevToken : semiToken;\n}\n/**\r\n * This returns the concatenation of the first 2 captured strings.\r\n * @param {string} _ Unused. Whole matched string.\r\n * @param {string} trailingSpaces The trailing spaces of the first line.\r\n * @param {string} indentSpaces The indentation spaces of the last line.\r\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\r\n * @private\r\n */\n\n\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\n  return trailingSpaces + indentSpaces;\n}\n/**\r\n * Check and report statements for `any` configuration.\r\n * It does nothing.\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction verifyForAny() {}\n/**\r\n * Check and report statements for `never` configuration.\r\n * This autofix removes blank lines between the given 2 statements.\r\n * However, if comments exist between 2 blank lines, it does not remove those\r\n * blank lines automatically.\r\n * @param {RuleContext} context The rule context to report.\r\n * @param {ASTNode} _ Unused. The previous node to check.\r\n * @param {ASTNode} nextNode The next node to check.\r\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\r\n * lines exist between the pair.\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction verifyForNever(context, _, nextNode, paddingLines) {\n  if (paddingLines.length === 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"unexpectedBlankLine\",\n\n    fix(fixer) {\n      if (paddingLines.length >= 2) {\n        return null;\n      }\n\n      const prevToken = paddingLines[0][0];\n      const nextToken = paddingLines[0][1];\n      const start = prevToken.range[1];\n      const end = nextToken.range[0];\n      const text = context.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\n      return fixer.replaceTextRange([start, end], text);\n    }\n\n  });\n}\n/**\r\n * Check and report statements for `always` configuration.\r\n * This autofix inserts a blank line between the given 2 statements.\r\n * If the `prevNode` has trailing comments, it inserts a blank line after the\r\n * trailing comments.\r\n * @param {RuleContext} context The rule context to report.\r\n * @param {ASTNode} prevNode The previous node to check.\r\n * @param {ASTNode} nextNode The next node to check.\r\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\r\n * lines exist between the pair.\r\n * @returns {void}\r\n * @private\r\n */\n\n\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\n  if (paddingLines.length > 0) {\n    return;\n  }\n\n  context.report({\n    node: nextNode,\n    messageId: \"expectedBlankLine\",\n\n    fix(fixer) {\n      const sourceCode = context.getSourceCode();\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n      const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {\n        includeComments: true,\n\n        /**\r\n         * Skip the trailing comments of the previous node.\r\n         * This inserts a blank line after the last trailing comment.\r\n         *\r\n         * For example:\r\n         *\r\n         *     foo(); // trailing comment.\r\n         *     // comment.\r\n         *     bar();\r\n         *\r\n         * Get fixed to:\r\n         *\r\n         *     foo(); // trailing comment.\r\n         *\r\n         *     // comment.\r\n         *     bar();\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} `true` if the token is not a trailing comment.\r\n         * @private\r\n         */\n        filter(token) {\n          if (astUtils.isTokenOnSameLine(prevToken, token)) {\n            prevToken = token;\n            return false;\n          }\n\n          return true;\n        }\n\n      }) || nextNode;\n      const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? \"\\n\\n\" : \"\\n\";\n      return fixer.insertTextAfter(prevToken, insertText);\n    }\n\n  });\n}\n/**\r\n * Types of blank lines.\r\n * `any`, `never`, and `always` are defined.\r\n * Those have `verify` method to check and report statements.\r\n * @private\r\n */\n\n\nconst PaddingTypes = {\n  any: {\n    verify: verifyForAny\n  },\n  never: {\n    verify: verifyForNever\n  },\n  always: {\n    verify: verifyForAlways\n  }\n};\n/**\r\n * Types of statements.\r\n * Those have `test` method to check it matches to the given statement.\r\n * @private\r\n */\n\nconst StatementTypes = {\n  \"*\": {\n    test: () => true\n  },\n  \"block-like\": {\n    test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\n  },\n  \"cjs-export\": {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && node.expression.type === \"AssignmentExpression\" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))\n  },\n  \"cjs-import\": {\n    test: (node, sourceCode) => node.type === \"VariableDeclaration\" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\n  },\n  directive: {\n    test: isDirectivePrologue\n  },\n  expression: {\n    test: (node, sourceCode) => node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  iife: {\n    test: isIIFEStatement\n  },\n  \"multiline-block-like\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)\n  },\n  \"multiline-expression\": {\n    test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === \"ExpressionStatement\" && !isDirectivePrologue(node, sourceCode)\n  },\n  \"multiline-const\": newMultilineKeywordTester(\"const\"),\n  \"multiline-let\": newMultilineKeywordTester(\"let\"),\n  \"multiline-var\": newMultilineKeywordTester(\"var\"),\n  \"singleline-const\": newSinglelineKeywordTester(\"const\"),\n  \"singleline-let\": newSinglelineKeywordTester(\"let\"),\n  \"singleline-var\": newSinglelineKeywordTester(\"var\"),\n  block: newNodeTypeTester(\"BlockStatement\"),\n  empty: newNodeTypeTester(\"EmptyStatement\"),\n  function: newNodeTypeTester(\"FunctionDeclaration\"),\n  break: newKeywordTester(\"break\"),\n  case: newKeywordTester(\"case\"),\n  class: newKeywordTester(\"class\"),\n  const: newKeywordTester(\"const\"),\n  continue: newKeywordTester(\"continue\"),\n  debugger: newKeywordTester(\"debugger\"),\n  default: newKeywordTester(\"default\"),\n  do: newKeywordTester(\"do\"),\n  export: newKeywordTester(\"export\"),\n  for: newKeywordTester(\"for\"),\n  if: newKeywordTester(\"if\"),\n  import: newKeywordTester(\"import\"),\n  let: newKeywordTester(\"let\"),\n  return: newKeywordTester(\"return\"),\n  switch: newKeywordTester(\"switch\"),\n  throw: newKeywordTester(\"throw\"),\n  try: newKeywordTester(\"try\"),\n  var: newKeywordTester(\"var\"),\n  while: newKeywordTester(\"while\"),\n  with: newKeywordTester(\"with\")\n}; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding lines between statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        paddingType: {\n          enum: Object.keys(PaddingTypes)\n        },\n        statementType: {\n          anyOf: [{\n            enum: Object.keys(StatementTypes)\n          }, {\n            type: \"array\",\n            items: {\n              enum: Object.keys(StatementTypes)\n            },\n            minItems: 1,\n            uniqueItems: true,\n            additionalItems: false\n          }]\n        }\n      },\n      type: \"array\",\n      items: {\n        type: \"object\",\n        properties: {\n          blankLine: {\n            $ref: \"#/definitions/paddingType\"\n          },\n          prev: {\n            $ref: \"#/definitions/statementType\"\n          },\n          next: {\n            $ref: \"#/definitions/statementType\"\n          }\n        },\n        additionalProperties: false,\n        required: [\"blankLine\", \"prev\", \"next\"]\n      },\n      additionalItems: false\n    },\n    messages: {\n      unexpectedBlankLine: \"Unexpected blank line before this statement.\",\n      expectedBlankLine: \"Expected blank line before this statement.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const configureList = context.options || [];\n    let scopeInfo = null;\n    /**\r\n     * Processes to enter to new scope.\r\n     * This manages the current previous statement.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function enterScope() {\n      scopeInfo = {\n        upper: scopeInfo,\n        prevNode: null\n      };\n    }\n    /**\r\n     * Processes to exit from the current scope.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function exitScope() {\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\r\n     * Checks whether the given node matches the given type.\r\n     * @param {ASTNode} node The statement node to check.\r\n     * @param {string|string[]} type The statement type to check.\r\n     * @returns {boolean} `true` if the statement node matched the type.\r\n     * @private\r\n     */\n\n\n    function match(node, type) {\n      let innerStatementNode = node;\n\n      while (innerStatementNode.type === \"LabeledStatement\") {\n        innerStatementNode = innerStatementNode.body;\n      }\n\n      if (Array.isArray(type)) {\n        return type.some(match.bind(null, innerStatementNode));\n      }\n\n      return StatementTypes[type].test(innerStatementNode, sourceCode);\n    }\n    /**\r\n     * Finds the last matched configure from configureList.\r\n     * @param {ASTNode} prevNode The previous statement to match.\r\n     * @param {ASTNode} nextNode The current statement to match.\r\n     * @returns {Object} The tester of the last matched configure.\r\n     * @private\r\n     */\n\n\n    function getPaddingType(prevNode, nextNode) {\n      for (let i = configureList.length - 1; i >= 0; --i) {\n        const configure = configureList[i];\n        const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);\n\n        if (matched) {\n          return PaddingTypes[configure.blankLine];\n        }\n      }\n\n      return PaddingTypes.any;\n    }\n    /**\r\n     * Gets padding line sequences between the given 2 statements.\r\n     * Comments are separators of the padding line sequences.\r\n     * @param {ASTNode} prevNode The previous statement to count.\r\n     * @param {ASTNode} nextNode The current statement to count.\r\n     * @returns {Array<Token[]>} The array of token pairs.\r\n     * @private\r\n     */\n\n\n    function getPaddingLineSequences(prevNode, nextNode) {\n      const pairs = [];\n      let prevToken = getActualLastToken(sourceCode, prevNode);\n\n      if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\n        do {\n          const token = sourceCode.getTokenAfter(prevToken, {\n            includeComments: true\n          });\n\n          if (token.loc.start.line - prevToken.loc.end.line >= 2) {\n            pairs.push([prevToken, token]);\n          }\n\n          prevToken = token;\n        } while (prevToken.range[0] < nextNode.range[0]);\n      }\n\n      return pairs;\n    }\n    /**\r\n     * Verify padding lines between the given node and the previous node.\r\n     * @param {ASTNode} node The node to verify.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function verify(node) {\n      const parentType = node.parent.type;\n      const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === \"SwitchStatement\";\n\n      if (!validParent) {\n        return;\n      } // Save this node as the current previous statement.\n\n\n      const prevNode = scopeInfo.prevNode; // Verify.\n\n      if (prevNode) {\n        const type = getPaddingType(prevNode, node);\n        const paddingLines = getPaddingLineSequences(prevNode, node);\n        type.verify(context, prevNode, node, paddingLines);\n      }\n\n      scopeInfo.prevNode = node;\n    }\n    /**\r\n     * Verify padding lines between the given node and the previous node.\r\n     * Then process to enter to new scope.\r\n     * @param {ASTNode} node The node to verify.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function verifyThenEnterScope(node) {\n      verify(node);\n      enterScope();\n    }\n\n    return {\n      Program: enterScope,\n      BlockStatement: enterScope,\n      SwitchStatement: enterScope,\n      StaticBlock: enterScope,\n      \"Program:exit\": exitScope,\n      \"BlockStatement:exit\": exitScope,\n      \"SwitchStatement:exit\": exitScope,\n      \"StaticBlock:exit\": exitScope,\n      \":statement\": verify,\n      SwitchCase: verifyThenEnterScope,\n      \"SwitchCase:exit\": exitScope\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/padding-line-between-statements.js"],"names":["astUtils","require","LT","Array","from","LINEBREAKS","join","PADDING_LINE_SEQUENCE","RegExp","String","raw","CJS_EXPORT","CJS_IMPORT","newKeywordTester","keyword","test","node","sourceCode","getFirstToken","value","newSinglelineKeywordTester","loc","start","line","end","newMultilineKeywordTester","newNodeTypeTester","type","isIIFEStatement","call","skipChainExpression","expression","argument","isFunction","callee","isBlockLikeStatement","body","lastToken","getLastToken","isNotSemicolonToken","belongingNode","isClosingBraceToken","getNodeByRangeIndex","range","Boolean","isDirective","parent","isParenthesised","isDirectivePrologue","sibling","getActualLastToken","semiToken","prevToken","getTokenBefore","nextToken","getTokenAfter","isSemicolonLessStyle","isSemicolonToken","replacerToRemovePaddingLines","_","trailingSpaces","indentSpaces","verifyForAny","verifyForNever","context","nextNode","paddingLines","length","report","messageId","fix","fixer","text","getSourceCode","slice","replace","replaceTextRange","verifyForAlways","prevNode","getFirstTokenBetween","includeComments","filter","token","isTokenOnSameLine","insertText","insertTextAfter","PaddingTypes","any","verify","never","always","StatementTypes","getText","left","declarations","init","directive","iife","block","empty","function","break","case","class","const","continue","debugger","default","do","export","for","if","import","let","return","switch","throw","try","var","while","with","module","exports","meta","docs","description","recommended","url","fixable","schema","definitions","paddingType","enum","Object","keys","statementType","anyOf","items","minItems","uniqueItems","additionalItems","properties","blankLine","$ref","prev","next","additionalProperties","required","messages","unexpectedBlankLine","expectedBlankLine","create","configureList","options","scopeInfo","enterScope","upper","exitScope","match","innerStatementNode","isArray","some","bind","getPaddingType","i","configure","matched","getPaddingLineSequences","pairs","push","parentType","validParent","STATEMENT_LIST_PARENTS","has","verifyThenEnterScope","Program","BlockStatement","SwitchStatement","StaticBlock","SwitchCase"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,EAAE,GAAI,IAAGC,KAAK,CAACC,IAAN,CAAWJ,QAAQ,CAACK,UAApB,EAAgCC,IAAhC,CAAqC,EAArC,CAAyC,GAAxD;AACA,MAAMC,qBAAqB,GAAG,IAAIC,MAAJ,CAC1BC,MAAM,CAACC,GAAI,SAAQR,EAAG,OAAMA,EAAG,UADL,EAE1B,GAF0B,CAA9B;AAIA,MAAMS,UAAU,GAAG,+CAAnB;AACA,MAAMC,UAAU,GAAG,aAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,gBAAT,CAA0BC,OAA1B,EAAmC;AAC/B,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFA,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAF1C,GAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,0BAAT,CAAoCN,OAApC,EAA6C;AACzC,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAH1C,GAAP;AAKH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,yBAAT,CAAmCX,OAAnC,EAA4C;AACxC,SAAO;AACHC,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAN,UAAU,CAACC,aAAX,CAAyBF,IAAzB,EAA+BG,KAA/B,KAAyCL;AAH1C,GAAP;AAKH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASY,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7B,SAAO;AACHZ,IAAAA,IAAI,EAAEC,IAAI,IACNA,IAAI,CAACW,IAAL,KAAcA;AAFf,GAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,eAAT,CAAyBZ,IAAzB,EAA+B;AAC3B,MAAIA,IAAI,CAACW,IAAL,KAAc,qBAAlB,EAAyC;AACrC,QAAIE,IAAI,GAAG7B,QAAQ,CAAC8B,mBAAT,CAA6Bd,IAAI,CAACe,UAAlC,CAAX;;AAEA,QAAIF,IAAI,CAACF,IAAL,KAAc,iBAAlB,EAAqC;AACjCE,MAAAA,IAAI,GAAG7B,QAAQ,CAAC8B,mBAAT,CAA6BD,IAAI,CAACG,QAAlC,CAAP;AACH;;AACD,WAAOH,IAAI,CAACF,IAAL,KAAc,gBAAd,IAAkC3B,QAAQ,CAACiC,UAAT,CAAoBJ,IAAI,CAACK,MAAzB,CAAzC;AACH;;AACD,SAAO,KAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,oBAAT,CAA8BlB,UAA9B,EAA0CD,IAA1C,EAAgD;AAE5C;AACA,MAAIA,IAAI,CAACW,IAAL,KAAc,kBAAd,IAAoCX,IAAI,CAACoB,IAAL,CAAUT,IAAV,KAAmB,gBAA3D,EAA6E;AACzE,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;;;AACI,MAAIC,eAAe,CAACZ,IAAD,CAAnB,EAA2B;AACvB,WAAO,IAAP;AACH,GAb2C,CAe5C;;;AACA,QAAMqB,SAAS,GAAGpB,UAAU,CAACqB,YAAX,CAAwBtB,IAAxB,EAA8BhB,QAAQ,CAACuC,mBAAvC,CAAlB;AACA,QAAMC,aAAa,GAAGH,SAAS,IAAIrC,QAAQ,CAACyC,mBAAT,CAA6BJ,SAA7B,CAAb,GAChBpB,UAAU,CAACyB,mBAAX,CAA+BL,SAAS,CAACM,KAAV,CAAgB,CAAhB,CAA/B,CADgB,GAEhB,IAFN;AAIA,SAAOC,OAAO,CAACJ,aAAD,CAAP,KACHA,aAAa,CAACb,IAAd,KAAuB,gBAAvB,IACAa,aAAa,CAACb,IAAd,KAAuB,iBAFpB,CAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASkB,WAAT,CAAqB7B,IAArB,EAA2BC,UAA3B,EAAuC;AACnC,SACID,IAAI,CAACW,IAAL,KAAc,qBAAd,KAEIX,IAAI,CAAC8B,MAAL,CAAYnB,IAAZ,KAAqB,SAArB,IAEIX,IAAI,CAAC8B,MAAL,CAAYnB,IAAZ,KAAqB,gBAArB,IACA3B,QAAQ,CAACiC,UAAT,CAAoBjB,IAAI,CAAC8B,MAAL,CAAYA,MAAhC,CALR,KAQA9B,IAAI,CAACe,UAAL,CAAgBJ,IAAhB,KAAyB,SARzB,IASA,OAAOX,IAAI,CAACe,UAAL,CAAgBZ,KAAvB,KAAiC,QATjC,IAUA,CAACnB,QAAQ,CAAC+C,eAAT,CAAyB9B,UAAzB,EAAqCD,IAAI,CAACe,UAA1C,CAXL;AAaH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiB,mBAAT,CAA6BhC,IAA7B,EAAmCC,UAAnC,EAA+C;AAC3C,MAAI4B,WAAW,CAAC7B,IAAD,EAAOC,UAAP,CAAf,EAAmC;AAC/B,SAAK,MAAMgC,OAAX,IAAsBjC,IAAI,CAAC8B,MAAL,CAAYV,IAAlC,EAAwC;AACpC,UAAIa,OAAO,KAAKjC,IAAhB,EAAsB;AAClB;AACH;;AACD,UAAI,CAAC6B,WAAW,CAACI,OAAD,EAAUhC,UAAV,CAAhB,EAAuC;AACnC,eAAO,KAAP;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASiC,kBAAT,CAA4BjC,UAA5B,EAAwCD,IAAxC,EAA8C;AAC1C,QAAMmC,SAAS,GAAGlC,UAAU,CAACqB,YAAX,CAAwBtB,IAAxB,CAAlB;AACA,QAAMoC,SAAS,GAAGnC,UAAU,CAACoC,cAAX,CAA0BF,SAA1B,CAAlB;AACA,QAAMG,SAAS,GAAGrC,UAAU,CAACsC,aAAX,CAAyBJ,SAAzB,CAAlB;AACA,QAAMK,oBAAoB,GAAGZ,OAAO,CAChCQ,SAAS,IACTE,SADA,IAEAF,SAAS,CAACT,KAAV,CAAgB,CAAhB,KAAsB3B,IAAI,CAAC2B,KAAL,CAAW,CAAX,CAFtB,IAGA3C,QAAQ,CAACyD,gBAAT,CAA0BN,SAA1B,CAHA,IAIAA,SAAS,CAAC9B,GAAV,CAAcC,KAAd,CAAoBC,IAApB,KAA6B6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAJ/C,IAKA4B,SAAS,CAAC9B,GAAV,CAAcG,GAAd,CAAkBD,IAAlB,KAA2B+B,SAAS,CAACjC,GAAV,CAAcC,KAAd,CAAoBC,IANf,CAApC;AASA,SAAOiC,oBAAoB,GAAGJ,SAAH,GAAeD,SAA1C;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,4BAAT,CAAsCC,CAAtC,EAAyCC,cAAzC,EAAyDC,YAAzD,EAAuE;AACnE,SAAOD,cAAc,GAAGC,YAAxB;AACH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,YAAT,GAAwB,CACvB;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,OAAxB,EAAiCL,CAAjC,EAAoCM,QAApC,EAA8CC,YAA9C,EAA4D;AACxD,MAAIA,YAAY,CAACC,MAAb,KAAwB,CAA5B,EAA+B;AAC3B;AACH;;AAEDH,EAAAA,OAAO,CAACI,MAAR,CAAe;AACXpD,IAAAA,IAAI,EAAEiD,QADK;AAEXI,IAAAA,SAAS,EAAE,qBAFA;;AAGXC,IAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,UAAIL,YAAY,CAACC,MAAb,IAAuB,CAA3B,EAA8B;AAC1B,eAAO,IAAP;AACH;;AAED,YAAMf,SAAS,GAAGc,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;AACA,YAAMZ,SAAS,GAAGY,YAAY,CAAC,CAAD,CAAZ,CAAgB,CAAhB,CAAlB;AACA,YAAM5C,KAAK,GAAG8B,SAAS,CAACT,KAAV,CAAgB,CAAhB,CAAd;AACA,YAAMnB,GAAG,GAAG8B,SAAS,CAACX,KAAV,CAAgB,CAAhB,CAAZ;AACA,YAAM6B,IAAI,GAAGR,OAAO,CAACS,aAAR,GAAwBD,IAAxB,CACRE,KADQ,CACFpD,KADE,EACKE,GADL,EAERmD,OAFQ,CAEApE,qBAFA,EAEuBmD,4BAFvB,CAAb;AAIA,aAAOa,KAAK,CAACK,gBAAN,CAAuB,CAACtD,KAAD,EAAQE,GAAR,CAAvB,EAAqCgD,IAArC,CAAP;AACH;;AAjBU,GAAf;AAmBH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,eAAT,CAAyBb,OAAzB,EAAkCc,QAAlC,EAA4Cb,QAA5C,EAAsDC,YAAtD,EAAoE;AAChE,MAAIA,YAAY,CAACC,MAAb,GAAsB,CAA1B,EAA6B;AACzB;AACH;;AAEDH,EAAAA,OAAO,CAACI,MAAR,CAAe;AACXpD,IAAAA,IAAI,EAAEiD,QADK;AAEXI,IAAAA,SAAS,EAAE,mBAFA;;AAGXC,IAAAA,GAAG,CAACC,KAAD,EAAQ;AACP,YAAMtD,UAAU,GAAG+C,OAAO,CAACS,aAAR,EAAnB;AACA,UAAIrB,SAAS,GAAGF,kBAAkB,CAACjC,UAAD,EAAa6D,QAAb,CAAlC;AACA,YAAMxB,SAAS,GAAGrC,UAAU,CAAC8D,oBAAX,CACd3B,SADc,EAEda,QAFc,EAGd;AACIe,QAAAA,eAAe,EAAE,IADrB;;AAGI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACoBC,QAAAA,MAAM,CAACC,KAAD,EAAQ;AACV,cAAIlF,QAAQ,CAACmF,iBAAT,CAA2B/B,SAA3B,EAAsC8B,KAAtC,CAAJ,EAAkD;AAC9C9B,YAAAA,SAAS,GAAG8B,KAAZ;AACA,mBAAO,KAAP;AACH;;AACD,iBAAO,IAAP;AACH;;AA7BL,OAHc,KAkCbjB,QAlCL;AAmCA,YAAMmB,UAAU,GAAGpF,QAAQ,CAACmF,iBAAT,CAA2B/B,SAA3B,EAAsCE,SAAtC,IACb,MADa,GAEb,IAFN;AAIA,aAAOiB,KAAK,CAACc,eAAN,CAAsBjC,SAAtB,EAAiCgC,UAAjC,CAAP;AACH;;AA9CU,GAAf;AAgDH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAME,YAAY,GAAG;AACjBC,EAAAA,GAAG,EAAE;AAAEC,IAAAA,MAAM,EAAE1B;AAAV,GADY;AAEjB2B,EAAAA,KAAK,EAAE;AAAED,IAAAA,MAAM,EAAEzB;AAAV,GAFU;AAGjB2B,EAAAA,MAAM,EAAE;AAAEF,IAAAA,MAAM,EAAEX;AAAV;AAHS,CAArB;AAMA;AACA;AACA;AACA;AACA;;AACA,MAAMc,cAAc,GAAG;AACnB,OAAK;AAAE5E,IAAAA,IAAI,EAAE,MAAM;AAAd,GADc;AAEnB,gBAAc;AACVA,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KAAsBkB,oBAAoB,CAAClB,UAAD,EAAaD,IAAb;AADtC,GAFK;AAKnB,gBAAc;AACVD,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAACe,UAAL,CAAgBJ,IAAhB,KAAyB,sBADzB,IAEAhB,UAAU,CAACI,IAAX,CAAgBE,UAAU,CAAC2E,OAAX,CAAmB5E,IAAI,CAACe,UAAL,CAAgB8D,IAAnC,CAAhB;AAJM,GALK;AAWnB,gBAAc;AACV9E,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACAX,IAAI,CAAC8E,YAAL,CAAkB3B,MAAlB,GAA2B,CAD3B,IAEAvB,OAAO,CAAC5B,IAAI,CAAC8E,YAAL,CAAkB,CAAlB,EAAqBC,IAAtB,CAFP,IAGAnF,UAAU,CAACG,IAAX,CAAgBE,UAAU,CAAC2E,OAAX,CAAmB5E,IAAI,CAAC8E,YAAL,CAAkB,CAAlB,EAAqBC,IAAxC,CAAhB;AALM,GAXK;AAkBnBC,EAAAA,SAAS,EAAE;AACPjF,IAAAA,IAAI,EAAEiC;AADC,GAlBQ;AAqBnBjB,EAAAA,UAAU,EAAE;AACRhB,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACW,IAAL,KAAc,qBAAd,IACA,CAACqB,mBAAmB,CAAChC,IAAD,EAAOC,UAAP;AAHhB,GArBO;AA0BnBgF,EAAAA,IAAI,EAAE;AACFlF,IAAAA,IAAI,EAAEa;AADJ,GA1Ba;AA6BnB,0BAAwB;AACpBb,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAY,oBAAoB,CAAClB,UAAD,EAAaD,IAAb;AAHJ,GA7BL;AAkCnB,0BAAwB;AACpBD,IAAAA,IAAI,EAAE,CAACC,IAAD,EAAOC,UAAP,KACFD,IAAI,CAACK,GAAL,CAASC,KAAT,CAAeC,IAAf,KAAwBP,IAAI,CAACK,GAAL,CAASG,GAAT,CAAaD,IAArC,IACAP,IAAI,CAACW,IAAL,KAAc,qBADd,IAEA,CAACqB,mBAAmB,CAAChC,IAAD,EAAOC,UAAP;AAJJ,GAlCL;AAyCnB,qBAAmBQ,yBAAyB,CAAC,OAAD,CAzCzB;AA0CnB,mBAAiBA,yBAAyB,CAAC,KAAD,CA1CvB;AA2CnB,mBAAiBA,yBAAyB,CAAC,KAAD,CA3CvB;AA4CnB,sBAAoBL,0BAA0B,CAAC,OAAD,CA5C3B;AA6CnB,oBAAkBA,0BAA0B,CAAC,KAAD,CA7CzB;AA8CnB,oBAAkBA,0BAA0B,CAAC,KAAD,CA9CzB;AAgDnB8E,EAAAA,KAAK,EAAExE,iBAAiB,CAAC,gBAAD,CAhDL;AAiDnByE,EAAAA,KAAK,EAAEzE,iBAAiB,CAAC,gBAAD,CAjDL;AAkDnB0E,EAAAA,QAAQ,EAAE1E,iBAAiB,CAAC,qBAAD,CAlDR;AAoDnB2E,EAAAA,KAAK,EAAExF,gBAAgB,CAAC,OAAD,CApDJ;AAqDnByF,EAAAA,IAAI,EAAEzF,gBAAgB,CAAC,MAAD,CArDH;AAsDnB0F,EAAAA,KAAK,EAAE1F,gBAAgB,CAAC,OAAD,CAtDJ;AAuDnB2F,EAAAA,KAAK,EAAE3F,gBAAgB,CAAC,OAAD,CAvDJ;AAwDnB4F,EAAAA,QAAQ,EAAE5F,gBAAgB,CAAC,UAAD,CAxDP;AAyDnB6F,EAAAA,QAAQ,EAAE7F,gBAAgB,CAAC,UAAD,CAzDP;AA0DnB8F,EAAAA,OAAO,EAAE9F,gBAAgB,CAAC,SAAD,CA1DN;AA2DnB+F,EAAAA,EAAE,EAAE/F,gBAAgB,CAAC,IAAD,CA3DD;AA4DnBgG,EAAAA,MAAM,EAAEhG,gBAAgB,CAAC,QAAD,CA5DL;AA6DnBiG,EAAAA,GAAG,EAAEjG,gBAAgB,CAAC,KAAD,CA7DF;AA8DnBkG,EAAAA,EAAE,EAAElG,gBAAgB,CAAC,IAAD,CA9DD;AA+DnBmG,EAAAA,MAAM,EAAEnG,gBAAgB,CAAC,QAAD,CA/DL;AAgEnBoG,EAAAA,GAAG,EAAEpG,gBAAgB,CAAC,KAAD,CAhEF;AAiEnBqG,EAAAA,MAAM,EAAErG,gBAAgB,CAAC,QAAD,CAjEL;AAkEnBsG,EAAAA,MAAM,EAAEtG,gBAAgB,CAAC,QAAD,CAlEL;AAmEnBuG,EAAAA,KAAK,EAAEvG,gBAAgB,CAAC,OAAD,CAnEJ;AAoEnBwG,EAAAA,GAAG,EAAExG,gBAAgB,CAAC,KAAD,CApEF;AAqEnByG,EAAAA,GAAG,EAAEzG,gBAAgB,CAAC,KAAD,CArEF;AAsEnB0G,EAAAA,KAAK,EAAE1G,gBAAgB,CAAC,OAAD,CAtEJ;AAuEnB2G,EAAAA,IAAI,EAAE3G,gBAAgB,CAAC,MAAD;AAvEH,CAAvB,C,CA0EA;AACA;AACA;;AAEA;;AACA4G,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFhG,IAAAA,IAAI,EAAE,QADJ;AAGFiG,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,sDADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,OAAO,EAAE,YATP;AAWFC,IAAAA,MAAM,EAAE;AACJC,MAAAA,WAAW,EAAE;AACTC,QAAAA,WAAW,EAAE;AACTC,UAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAYhD,YAAZ;AADG,SADJ;AAITiD,QAAAA,aAAa,EAAE;AACXC,UAAAA,KAAK,EAAE,CACH;AAAEJ,YAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY3C,cAAZ;AAAR,WADG,EAEH;AACIhE,YAAAA,IAAI,EAAE,OADV;AAEI8G,YAAAA,KAAK,EAAE;AAAEL,cAAAA,IAAI,EAAEC,MAAM,CAACC,IAAP,CAAY3C,cAAZ;AAAR,aAFX;AAGI+C,YAAAA,QAAQ,EAAE,CAHd;AAIIC,YAAAA,WAAW,EAAE,IAJjB;AAKIC,YAAAA,eAAe,EAAE;AALrB,WAFG;AADI;AAJN,OADT;AAkBJjH,MAAAA,IAAI,EAAE,OAlBF;AAmBJ8G,MAAAA,KAAK,EAAE;AACH9G,QAAAA,IAAI,EAAE,QADH;AAEHkH,QAAAA,UAAU,EAAE;AACRC,UAAAA,SAAS,EAAE;AAAEC,YAAAA,IAAI,EAAE;AAAR,WADH;AAERC,UAAAA,IAAI,EAAE;AAAED,YAAAA,IAAI,EAAE;AAAR,WAFE;AAGRE,UAAAA,IAAI,EAAE;AAAEF,YAAAA,IAAI,EAAE;AAAR;AAHE,SAFT;AAOHG,QAAAA,oBAAoB,EAAE,KAPnB;AAQHC,QAAAA,QAAQ,EAAE,CAAC,WAAD,EAAc,MAAd,EAAsB,MAAtB;AARP,OAnBH;AA6BJP,MAAAA,eAAe,EAAE;AA7Bb,KAXN;AA2CFQ,IAAAA,QAAQ,EAAE;AACNC,MAAAA,mBAAmB,EAAE,8CADf;AAENC,MAAAA,iBAAiB,EAAE;AAFb;AA3CR,GADO;;AAkDbC,EAAAA,MAAM,CAACvF,OAAD,EAAU;AACZ,UAAM/C,UAAU,GAAG+C,OAAO,CAACS,aAAR,EAAnB;AACA,UAAM+E,aAAa,GAAGxF,OAAO,CAACyF,OAAR,IAAmB,EAAzC;AACA,QAAIC,SAAS,GAAG,IAAhB;AAEA;AACR;AACA;AACA;AACA;AACA;;AACQ,aAASC,UAAT,GAAsB;AAClBD,MAAAA,SAAS,GAAG;AACRE,QAAAA,KAAK,EAAEF,SADC;AAER5E,QAAAA,QAAQ,EAAE;AAFF,OAAZ;AAIH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAAS+E,SAAT,GAAqB;AACjBH,MAAAA,SAAS,GAAGA,SAAS,CAACE,KAAtB;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASE,KAAT,CAAe9I,IAAf,EAAqBW,IAArB,EAA2B;AACvB,UAAIoI,kBAAkB,GAAG/I,IAAzB;;AAEA,aAAO+I,kBAAkB,CAACpI,IAAnB,KAA4B,kBAAnC,EAAuD;AACnDoI,QAAAA,kBAAkB,GAAGA,kBAAkB,CAAC3H,IAAxC;AACH;;AACD,UAAIjC,KAAK,CAAC6J,OAAN,CAAcrI,IAAd,CAAJ,EAAyB;AACrB,eAAOA,IAAI,CAACsI,IAAL,CAAUH,KAAK,CAACI,IAAN,CAAW,IAAX,EAAiBH,kBAAjB,CAAV,CAAP;AACH;;AACD,aAAOpE,cAAc,CAAChE,IAAD,CAAd,CAAqBZ,IAArB,CAA0BgJ,kBAA1B,EAA8C9I,UAA9C,CAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASkJ,cAAT,CAAwBrF,QAAxB,EAAkCb,QAAlC,EAA4C;AACxC,WAAK,IAAImG,CAAC,GAAGZ,aAAa,CAACrF,MAAd,GAAuB,CAApC,EAAuCiG,CAAC,IAAI,CAA5C,EAA+C,EAAEA,CAAjD,EAAoD;AAChD,cAAMC,SAAS,GAAGb,aAAa,CAACY,CAAD,CAA/B;AACA,cAAME,OAAO,GACTR,KAAK,CAAChF,QAAD,EAAWuF,SAAS,CAACrB,IAArB,CAAL,IACAc,KAAK,CAAC7F,QAAD,EAAWoG,SAAS,CAACpB,IAArB,CAFT;;AAIA,YAAIqB,OAAJ,EAAa;AACT,iBAAOhF,YAAY,CAAC+E,SAAS,CAACvB,SAAX,CAAnB;AACH;AACJ;;AACD,aAAOxD,YAAY,CAACC,GAApB;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASgF,uBAAT,CAAiCzF,QAAjC,EAA2Cb,QAA3C,EAAqD;AACjD,YAAMuG,KAAK,GAAG,EAAd;AACA,UAAIpH,SAAS,GAAGF,kBAAkB,CAACjC,UAAD,EAAa6D,QAAb,CAAlC;;AAEA,UAAIb,QAAQ,CAAC5C,GAAT,CAAaC,KAAb,CAAmBC,IAAnB,GAA0B6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAA5C,IAAoD,CAAxD,EAA2D;AACvD,WAAG;AACC,gBAAM2D,KAAK,GAAGjE,UAAU,CAACsC,aAAX,CACVH,SADU,EAEV;AAAE4B,YAAAA,eAAe,EAAE;AAAnB,WAFU,CAAd;;AAKA,cAAIE,KAAK,CAAC7D,GAAN,CAAUC,KAAV,CAAgBC,IAAhB,GAAuB6B,SAAS,CAAC/B,GAAV,CAAcG,GAAd,CAAkBD,IAAzC,IAAiD,CAArD,EAAwD;AACpDiJ,YAAAA,KAAK,CAACC,IAAN,CAAW,CAACrH,SAAD,EAAY8B,KAAZ,CAAX;AACH;;AACD9B,UAAAA,SAAS,GAAG8B,KAAZ;AAEH,SAXD,QAWS9B,SAAS,CAACT,KAAV,CAAgB,CAAhB,IAAqBsB,QAAQ,CAACtB,KAAT,CAAe,CAAf,CAX9B;AAYH;;AAED,aAAO6H,KAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAAShF,MAAT,CAAgBxE,IAAhB,EAAsB;AAClB,YAAM0J,UAAU,GAAG1J,IAAI,CAAC8B,MAAL,CAAYnB,IAA/B;AACA,YAAMgJ,WAAW,GACb3K,QAAQ,CAAC4K,sBAAT,CAAgCC,GAAhC,CAAoCH,UAApC,KACAA,UAAU,KAAK,iBAFnB;;AAIA,UAAI,CAACC,WAAL,EAAkB;AACd;AACH,OARiB,CAUlB;;;AACA,YAAM7F,QAAQ,GAAG4E,SAAS,CAAC5E,QAA3B,CAXkB,CAalB;;AACA,UAAIA,QAAJ,EAAc;AACV,cAAMnD,IAAI,GAAGwI,cAAc,CAACrF,QAAD,EAAW9D,IAAX,CAA3B;AACA,cAAMkD,YAAY,GAAGqG,uBAAuB,CAACzF,QAAD,EAAW9D,IAAX,CAA5C;AAEAW,QAAAA,IAAI,CAAC6D,MAAL,CAAYxB,OAAZ,EAAqBc,QAArB,EAA+B9D,IAA/B,EAAqCkD,YAArC;AACH;;AAEDwF,MAAAA,SAAS,CAAC5E,QAAV,GAAqB9D,IAArB;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAAS8J,oBAAT,CAA8B9J,IAA9B,EAAoC;AAChCwE,MAAAA,MAAM,CAACxE,IAAD,CAAN;AACA2I,MAAAA,UAAU;AACb;;AAED,WAAO;AACHoB,MAAAA,OAAO,EAAEpB,UADN;AAEHqB,MAAAA,cAAc,EAAErB,UAFb;AAGHsB,MAAAA,eAAe,EAAEtB,UAHd;AAIHuB,MAAAA,WAAW,EAAEvB,UAJV;AAKH,sBAAgBE,SALb;AAMH,6BAAuBA,SANpB;AAOH,8BAAwBA,SAPrB;AAQH,0BAAoBA,SARjB;AAUH,oBAAcrE,MAVX;AAYH2F,MAAAA,UAAU,EAAEL,oBAZT;AAaH,yBAAmBjB;AAbhB,KAAP;AAeH;;AA5MY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to require or disallow newlines between statements\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst LT = `[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`;\r\nconst PADDING_LINE_SEQUENCE = new RegExp(\r\n    String.raw`^(\\s*?${LT})\\s*${LT}(\\s*;?)$`,\r\n    \"u\"\r\n);\r\nconst CJS_EXPORT = /^(?:module\\s*\\.\\s*)?exports(?:\\s*\\.|\\s*\\[|$)/u;\r\nconst CJS_IMPORT = /^require\\(/u;\r\n\r\n/**\r\n * Creates tester which check if a node starts with specific keyword.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\r\nfunction newKeywordTester(keyword) {\r\n    return {\r\n        test: (node, sourceCode) =>\r\n            sourceCode.getFirstToken(node).value === keyword\r\n    };\r\n}\r\n\r\n/**\r\n * Creates tester which check if a node starts with specific keyword and spans a single line.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\r\nfunction newSinglelineKeywordTester(keyword) {\r\n    return {\r\n        test: (node, sourceCode) =>\r\n            node.loc.start.line === node.loc.end.line &&\r\n            sourceCode.getFirstToken(node).value === keyword\r\n    };\r\n}\r\n\r\n/**\r\n * Creates tester which check if a node starts with specific keyword and spans multiple lines.\r\n * @param {string} keyword The keyword to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\r\nfunction newMultilineKeywordTester(keyword) {\r\n    return {\r\n        test: (node, sourceCode) =>\r\n            node.loc.start.line !== node.loc.end.line &&\r\n            sourceCode.getFirstToken(node).value === keyword\r\n    };\r\n}\r\n\r\n/**\r\n * Creates tester which check if a node is specific type.\r\n * @param {string} type The node type to test.\r\n * @returns {Object} the created tester.\r\n * @private\r\n */\r\nfunction newNodeTypeTester(type) {\r\n    return {\r\n        test: node =>\r\n            node.type === type\r\n    };\r\n}\r\n\r\n/**\r\n * Checks the given node is an expression statement of IIFE.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is an expression statement of IIFE.\r\n * @private\r\n */\r\nfunction isIIFEStatement(node) {\r\n    if (node.type === \"ExpressionStatement\") {\r\n        let call = astUtils.skipChainExpression(node.expression);\r\n\r\n        if (call.type === \"UnaryExpression\") {\r\n            call = astUtils.skipChainExpression(call.argument);\r\n        }\r\n        return call.type === \"CallExpression\" && astUtils.isFunction(call.callee);\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether the given node is a block-like statement.\r\n * This checks the last token of the node is the closing brace of a block.\r\n * @param {SourceCode} sourceCode The source code to get tokens.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is a block-like statement.\r\n * @private\r\n */\r\nfunction isBlockLikeStatement(sourceCode, node) {\r\n\r\n    // do-while with a block is a block-like statement.\r\n    if (node.type === \"DoWhileStatement\" && node.body.type === \"BlockStatement\") {\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * IIFE is a block-like statement specially from\r\n     * JSCS#disallowPaddingNewLinesAfterBlocks.\r\n     */\r\n    if (isIIFEStatement(node)) {\r\n        return true;\r\n    }\r\n\r\n    // Checks the last token is a closing brace of blocks.\r\n    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);\r\n    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)\r\n        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])\r\n        : null;\r\n\r\n    return Boolean(belongingNode) && (\r\n        belongingNode.type === \"BlockStatement\" ||\r\n        belongingNode.type === \"SwitchStatement\"\r\n    );\r\n}\r\n\r\n/**\r\n * Check whether the given node is a directive or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {boolean} `true` if the node is a directive.\r\n */\r\nfunction isDirective(node, sourceCode) {\r\n    return (\r\n        node.type === \"ExpressionStatement\" &&\r\n        (\r\n            node.parent.type === \"Program\" ||\r\n            (\r\n                node.parent.type === \"BlockStatement\" &&\r\n                astUtils.isFunction(node.parent.parent)\r\n            )\r\n        ) &&\r\n        node.expression.type === \"Literal\" &&\r\n        typeof node.expression.value === \"string\" &&\r\n        !astUtils.isParenthesised(sourceCode, node.expression)\r\n    );\r\n}\r\n\r\n/**\r\n * Check whether the given node is a part of directive prologue or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {boolean} `true` if the node is a part of directive prologue.\r\n */\r\nfunction isDirectivePrologue(node, sourceCode) {\r\n    if (isDirective(node, sourceCode)) {\r\n        for (const sibling of node.parent.body) {\r\n            if (sibling === node) {\r\n                break;\r\n            }\r\n            if (!isDirective(sibling, sourceCode)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Gets the actual last token.\r\n *\r\n * If a semicolon is semicolon-less style's semicolon, this ignores it.\r\n * For example:\r\n *\r\n *     foo()\r\n *     ;[1, 2, 3].forEach(bar)\r\n * @param {SourceCode} sourceCode The source code to get tokens.\r\n * @param {ASTNode} node The node to get.\r\n * @returns {Token} The actual last token.\r\n * @private\r\n */\r\nfunction getActualLastToken(sourceCode, node) {\r\n    const semiToken = sourceCode.getLastToken(node);\r\n    const prevToken = sourceCode.getTokenBefore(semiToken);\r\n    const nextToken = sourceCode.getTokenAfter(semiToken);\r\n    const isSemicolonLessStyle = Boolean(\r\n        prevToken &&\r\n        nextToken &&\r\n        prevToken.range[0] >= node.range[0] &&\r\n        astUtils.isSemicolonToken(semiToken) &&\r\n        semiToken.loc.start.line !== prevToken.loc.end.line &&\r\n        semiToken.loc.end.line === nextToken.loc.start.line\r\n    );\r\n\r\n    return isSemicolonLessStyle ? prevToken : semiToken;\r\n}\r\n\r\n/**\r\n * This returns the concatenation of the first 2 captured strings.\r\n * @param {string} _ Unused. Whole matched string.\r\n * @param {string} trailingSpaces The trailing spaces of the first line.\r\n * @param {string} indentSpaces The indentation spaces of the last line.\r\n * @returns {string} The concatenation of trailingSpaces and indentSpaces.\r\n * @private\r\n */\r\nfunction replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {\r\n    return trailingSpaces + indentSpaces;\r\n}\r\n\r\n/**\r\n * Check and report statements for `any` configuration.\r\n * It does nothing.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction verifyForAny() {\r\n}\r\n\r\n/**\r\n * Check and report statements for `never` configuration.\r\n * This autofix removes blank lines between the given 2 statements.\r\n * However, if comments exist between 2 blank lines, it does not remove those\r\n * blank lines automatically.\r\n * @param {RuleContext} context The rule context to report.\r\n * @param {ASTNode} _ Unused. The previous node to check.\r\n * @param {ASTNode} nextNode The next node to check.\r\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\r\n * lines exist between the pair.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction verifyForNever(context, _, nextNode, paddingLines) {\r\n    if (paddingLines.length === 0) {\r\n        return;\r\n    }\r\n\r\n    context.report({\r\n        node: nextNode,\r\n        messageId: \"unexpectedBlankLine\",\r\n        fix(fixer) {\r\n            if (paddingLines.length >= 2) {\r\n                return null;\r\n            }\r\n\r\n            const prevToken = paddingLines[0][0];\r\n            const nextToken = paddingLines[0][1];\r\n            const start = prevToken.range[1];\r\n            const end = nextToken.range[0];\r\n            const text = context.getSourceCode().text\r\n                .slice(start, end)\r\n                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);\r\n\r\n            return fixer.replaceTextRange([start, end], text);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Check and report statements for `always` configuration.\r\n * This autofix inserts a blank line between the given 2 statements.\r\n * If the `prevNode` has trailing comments, it inserts a blank line after the\r\n * trailing comments.\r\n * @param {RuleContext} context The rule context to report.\r\n * @param {ASTNode} prevNode The previous node to check.\r\n * @param {ASTNode} nextNode The next node to check.\r\n * @param {Array<Token[]>} paddingLines The array of token pairs that blank\r\n * lines exist between the pair.\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction verifyForAlways(context, prevNode, nextNode, paddingLines) {\r\n    if (paddingLines.length > 0) {\r\n        return;\r\n    }\r\n\r\n    context.report({\r\n        node: nextNode,\r\n        messageId: \"expectedBlankLine\",\r\n        fix(fixer) {\r\n            const sourceCode = context.getSourceCode();\r\n            let prevToken = getActualLastToken(sourceCode, prevNode);\r\n            const nextToken = sourceCode.getFirstTokenBetween(\r\n                prevToken,\r\n                nextNode,\r\n                {\r\n                    includeComments: true,\r\n\r\n                    /**\r\n                     * Skip the trailing comments of the previous node.\r\n                     * This inserts a blank line after the last trailing comment.\r\n                     *\r\n                     * For example:\r\n                     *\r\n                     *     foo(); // trailing comment.\r\n                     *     // comment.\r\n                     *     bar();\r\n                     *\r\n                     * Get fixed to:\r\n                     *\r\n                     *     foo(); // trailing comment.\r\n                     *\r\n                     *     // comment.\r\n                     *     bar();\r\n                     * @param {Token} token The token to check.\r\n                     * @returns {boolean} `true` if the token is not a trailing comment.\r\n                     * @private\r\n                     */\r\n                    filter(token) {\r\n                        if (astUtils.isTokenOnSameLine(prevToken, token)) {\r\n                            prevToken = token;\r\n                            return false;\r\n                        }\r\n                        return true;\r\n                    }\r\n                }\r\n            ) || nextNode;\r\n            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)\r\n                ? \"\\n\\n\"\r\n                : \"\\n\";\r\n\r\n            return fixer.insertTextAfter(prevToken, insertText);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Types of blank lines.\r\n * `any`, `never`, and `always` are defined.\r\n * Those have `verify` method to check and report statements.\r\n * @private\r\n */\r\nconst PaddingTypes = {\r\n    any: { verify: verifyForAny },\r\n    never: { verify: verifyForNever },\r\n    always: { verify: verifyForAlways }\r\n};\r\n\r\n/**\r\n * Types of statements.\r\n * Those have `test` method to check it matches to the given statement.\r\n * @private\r\n */\r\nconst StatementTypes = {\r\n    \"*\": { test: () => true },\r\n    \"block-like\": {\r\n        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)\r\n    },\r\n    \"cjs-export\": {\r\n        test: (node, sourceCode) =>\r\n            node.type === \"ExpressionStatement\" &&\r\n            node.expression.type === \"AssignmentExpression\" &&\r\n            CJS_EXPORT.test(sourceCode.getText(node.expression.left))\r\n    },\r\n    \"cjs-import\": {\r\n        test: (node, sourceCode) =>\r\n            node.type === \"VariableDeclaration\" &&\r\n            node.declarations.length > 0 &&\r\n            Boolean(node.declarations[0].init) &&\r\n            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))\r\n    },\r\n    directive: {\r\n        test: isDirectivePrologue\r\n    },\r\n    expression: {\r\n        test: (node, sourceCode) =>\r\n            node.type === \"ExpressionStatement\" &&\r\n            !isDirectivePrologue(node, sourceCode)\r\n    },\r\n    iife: {\r\n        test: isIIFEStatement\r\n    },\r\n    \"multiline-block-like\": {\r\n        test: (node, sourceCode) =>\r\n            node.loc.start.line !== node.loc.end.line &&\r\n            isBlockLikeStatement(sourceCode, node)\r\n    },\r\n    \"multiline-expression\": {\r\n        test: (node, sourceCode) =>\r\n            node.loc.start.line !== node.loc.end.line &&\r\n            node.type === \"ExpressionStatement\" &&\r\n            !isDirectivePrologue(node, sourceCode)\r\n    },\r\n\r\n    \"multiline-const\": newMultilineKeywordTester(\"const\"),\r\n    \"multiline-let\": newMultilineKeywordTester(\"let\"),\r\n    \"multiline-var\": newMultilineKeywordTester(\"var\"),\r\n    \"singleline-const\": newSinglelineKeywordTester(\"const\"),\r\n    \"singleline-let\": newSinglelineKeywordTester(\"let\"),\r\n    \"singleline-var\": newSinglelineKeywordTester(\"var\"),\r\n\r\n    block: newNodeTypeTester(\"BlockStatement\"),\r\n    empty: newNodeTypeTester(\"EmptyStatement\"),\r\n    function: newNodeTypeTester(\"FunctionDeclaration\"),\r\n\r\n    break: newKeywordTester(\"break\"),\r\n    case: newKeywordTester(\"case\"),\r\n    class: newKeywordTester(\"class\"),\r\n    const: newKeywordTester(\"const\"),\r\n    continue: newKeywordTester(\"continue\"),\r\n    debugger: newKeywordTester(\"debugger\"),\r\n    default: newKeywordTester(\"default\"),\r\n    do: newKeywordTester(\"do\"),\r\n    export: newKeywordTester(\"export\"),\r\n    for: newKeywordTester(\"for\"),\r\n    if: newKeywordTester(\"if\"),\r\n    import: newKeywordTester(\"import\"),\r\n    let: newKeywordTester(\"let\"),\r\n    return: newKeywordTester(\"return\"),\r\n    switch: newKeywordTester(\"switch\"),\r\n    throw: newKeywordTester(\"throw\"),\r\n    try: newKeywordTester(\"try\"),\r\n    var: newKeywordTester(\"var\"),\r\n    while: newKeywordTester(\"while\"),\r\n    with: newKeywordTester(\"with\")\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow padding lines between statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/padding-line-between-statements\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: {\r\n            definitions: {\r\n                paddingType: {\r\n                    enum: Object.keys(PaddingTypes)\r\n                },\r\n                statementType: {\r\n                    anyOf: [\r\n                        { enum: Object.keys(StatementTypes) },\r\n                        {\r\n                            type: \"array\",\r\n                            items: { enum: Object.keys(StatementTypes) },\r\n                            minItems: 1,\r\n                            uniqueItems: true,\r\n                            additionalItems: false\r\n                        }\r\n                    ]\r\n                }\r\n            },\r\n            type: \"array\",\r\n            items: {\r\n                type: \"object\",\r\n                properties: {\r\n                    blankLine: { $ref: \"#/definitions/paddingType\" },\r\n                    prev: { $ref: \"#/definitions/statementType\" },\r\n                    next: { $ref: \"#/definitions/statementType\" }\r\n                },\r\n                additionalProperties: false,\r\n                required: [\"blankLine\", \"prev\", \"next\"]\r\n            },\r\n            additionalItems: false\r\n        },\r\n\r\n        messages: {\r\n            unexpectedBlankLine: \"Unexpected blank line before this statement.\",\r\n            expectedBlankLine: \"Expected blank line before this statement.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const configureList = context.options || [];\r\n        let scopeInfo = null;\r\n\r\n        /**\r\n         * Processes to enter to new scope.\r\n         * This manages the current previous statement.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function enterScope() {\r\n            scopeInfo = {\r\n                upper: scopeInfo,\r\n                prevNode: null\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Processes to exit from the current scope.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function exitScope() {\r\n            scopeInfo = scopeInfo.upper;\r\n        }\r\n\r\n        /**\r\n         * Checks whether the given node matches the given type.\r\n         * @param {ASTNode} node The statement node to check.\r\n         * @param {string|string[]} type The statement type to check.\r\n         * @returns {boolean} `true` if the statement node matched the type.\r\n         * @private\r\n         */\r\n        function match(node, type) {\r\n            let innerStatementNode = node;\r\n\r\n            while (innerStatementNode.type === \"LabeledStatement\") {\r\n                innerStatementNode = innerStatementNode.body;\r\n            }\r\n            if (Array.isArray(type)) {\r\n                return type.some(match.bind(null, innerStatementNode));\r\n            }\r\n            return StatementTypes[type].test(innerStatementNode, sourceCode);\r\n        }\r\n\r\n        /**\r\n         * Finds the last matched configure from configureList.\r\n         * @param {ASTNode} prevNode The previous statement to match.\r\n         * @param {ASTNode} nextNode The current statement to match.\r\n         * @returns {Object} The tester of the last matched configure.\r\n         * @private\r\n         */\r\n        function getPaddingType(prevNode, nextNode) {\r\n            for (let i = configureList.length - 1; i >= 0; --i) {\r\n                const configure = configureList[i];\r\n                const matched =\r\n                    match(prevNode, configure.prev) &&\r\n                    match(nextNode, configure.next);\r\n\r\n                if (matched) {\r\n                    return PaddingTypes[configure.blankLine];\r\n                }\r\n            }\r\n            return PaddingTypes.any;\r\n        }\r\n\r\n        /**\r\n         * Gets padding line sequences between the given 2 statements.\r\n         * Comments are separators of the padding line sequences.\r\n         * @param {ASTNode} prevNode The previous statement to count.\r\n         * @param {ASTNode} nextNode The current statement to count.\r\n         * @returns {Array<Token[]>} The array of token pairs.\r\n         * @private\r\n         */\r\n        function getPaddingLineSequences(prevNode, nextNode) {\r\n            const pairs = [];\r\n            let prevToken = getActualLastToken(sourceCode, prevNode);\r\n\r\n            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {\r\n                do {\r\n                    const token = sourceCode.getTokenAfter(\r\n                        prevToken,\r\n                        { includeComments: true }\r\n                    );\r\n\r\n                    if (token.loc.start.line - prevToken.loc.end.line >= 2) {\r\n                        pairs.push([prevToken, token]);\r\n                    }\r\n                    prevToken = token;\r\n\r\n                } while (prevToken.range[0] < nextNode.range[0]);\r\n            }\r\n\r\n            return pairs;\r\n        }\r\n\r\n        /**\r\n         * Verify padding lines between the given node and the previous node.\r\n         * @param {ASTNode} node The node to verify.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function verify(node) {\r\n            const parentType = node.parent.type;\r\n            const validParent =\r\n                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||\r\n                parentType === \"SwitchStatement\";\r\n\r\n            if (!validParent) {\r\n                return;\r\n            }\r\n\r\n            // Save this node as the current previous statement.\r\n            const prevNode = scopeInfo.prevNode;\r\n\r\n            // Verify.\r\n            if (prevNode) {\r\n                const type = getPaddingType(prevNode, node);\r\n                const paddingLines = getPaddingLineSequences(prevNode, node);\r\n\r\n                type.verify(context, prevNode, node, paddingLines);\r\n            }\r\n\r\n            scopeInfo.prevNode = node;\r\n        }\r\n\r\n        /**\r\n         * Verify padding lines between the given node and the previous node.\r\n         * Then process to enter to new scope.\r\n         * @param {ASTNode} node The node to verify.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function verifyThenEnterScope(node) {\r\n            verify(node);\r\n            enterScope();\r\n        }\r\n\r\n        return {\r\n            Program: enterScope,\r\n            BlockStatement: enterScope,\r\n            SwitchStatement: enterScope,\r\n            StaticBlock: enterScope,\r\n            \"Program:exit\": exitScope,\r\n            \"BlockStatement:exit\": exitScope,\r\n            \"SwitchStatement:exit\": exitScope,\r\n            \"StaticBlock:exit\": exitScope,\r\n\r\n            \":statement\": verify,\r\n\r\n            SwitchCase: verifyThenEnterScope,\r\n            \"SwitchCase:exit\": exitScope\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}