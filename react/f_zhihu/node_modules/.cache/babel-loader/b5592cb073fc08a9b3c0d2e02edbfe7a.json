{"ast":null,"code":"/**\r\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\r\n * @author Benoît Zugmeyer\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent linebreak style for operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-linebreak\"\n    },\n    schema: [{\n      enum: [\"after\", \"before\", \"none\", null]\n    }, {\n      type: \"object\",\n      properties: {\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            enum: [\"after\", \"before\", \"none\", \"ignore\"]\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\n      operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\n      badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\n      noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\n    }\n  },\n\n  create(context) {\n    const usedDefaultGlobal = !context.options[0];\n    const globalStyle = context.options[0] || \"after\";\n    const options = context.options[1] || {};\n    const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\n\n    if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n      styleOverrides[\"?\"] = \"before\";\n    }\n\n    if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n      styleOverrides[\":\"] = \"before\";\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Gets a fixer function to fix rule issues\r\n     * @param {Token} operatorToken The operator token of an expression\r\n     * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\r\n     * @returns {Function} A fixer function\r\n     */\n\n    function getFixer(operatorToken, desiredStyle) {\n      return fixer => {\n        const tokenBefore = sourceCode.getTokenBefore(operatorToken);\n        const tokenAfter = sourceCode.getTokenAfter(operatorToken);\n        const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\n        const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\n        const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\n        const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\n        let newTextBefore, newTextAfter;\n\n        if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\n          // If there is a comment before and after the operator, don't do a fix.\n          if (sourceCode.getTokenBefore(operatorToken, {\n            includeComments: true\n          }) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {\n            includeComments: true\n          }) !== tokenAfter) {\n            return null;\n          }\n          /*\r\n           * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\r\n           * foo &&\r\n           *           bar\r\n           * would get fixed to\r\n           * foo\r\n           *        && bar\r\n           */\n\n\n          newTextBefore = textAfter;\n          newTextAfter = textBefore;\n        } else {\n          const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher(); // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\n\n          newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\n          newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\"); // If there was no change (due to interfering comments), don't output a fix.\n\n          if (newTextBefore === textBefore && newTextAfter === textAfter) {\n            return null;\n          }\n        }\n\n        if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\n          // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\n          newTextAfter += \" \";\n        }\n\n        return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\n      };\n    }\n    /**\r\n     * Checks the operator placement\r\n     * @param {ASTNode} node The node to check\r\n     * @param {ASTNode} rightSide The node that comes after the operator in `node`\r\n     * @param {string} operator The operator\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    function validateNode(node, rightSide, operator) {\n      /*\r\n       * Find the operator token by searching from the right side, because between the left side and the operator\r\n       * there could be additional tokens from type annotations. Search specifically for the token which\r\n       * value equals the operator, in order to skip possible opening parentheses before the right side node.\r\n       */\n      const operatorToken = sourceCode.getTokenBefore(rightSide, token => token.value === operator);\n      const leftToken = sourceCode.getTokenBefore(operatorToken);\n      const rightToken = sourceCode.getTokenAfter(operatorToken);\n      const operatorStyleOverride = styleOverrides[operator];\n      const style = operatorStyleOverride || globalStyle;\n      const fix = getFixer(operatorToken, style); // if single line\n\n      if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {// do nothing.\n      } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        // lone operator\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"badLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtBeginning\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"operatorAtEnd\",\n          data: {\n            operator\n          },\n          fix\n        });\n      } else if (style === \"none\") {\n        context.report({\n          node,\n          loc: operatorToken.loc,\n          messageId: \"noLinebreak\",\n          data: {\n            operator\n          },\n          fix\n        });\n      }\n    }\n    /**\r\n     * Validates a binary expression using `validateNode`\r\n     * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\r\n     * @returns {void}\r\n     */\n\n\n    function validateBinaryExpression(node) {\n      validateNode(node, node.right, node.operator);\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression: validateBinaryExpression,\n      LogicalExpression: validateBinaryExpression,\n      AssignmentExpression: validateBinaryExpression,\n\n      VariableDeclarator(node) {\n        if (node.init) {\n          validateNode(node, node.init, \"=\");\n        }\n      },\n\n      PropertyDefinition(node) {\n        if (node.value) {\n          validateNode(node, node.value, \"=\");\n        }\n      },\n\n      ConditionalExpression(node) {\n        validateNode(node, node.consequent, \"?\");\n        validateNode(node, node.alternate, \":\");\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/operator-linebreak.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","properties","overrides","additionalProperties","fixable","messages","operatorAtBeginning","operatorAtEnd","badLinebreak","noLinebreak","create","context","usedDefaultGlobal","options","globalStyle","styleOverrides","Object","assign","sourceCode","getSourceCode","getFixer","operatorToken","desiredStyle","fixer","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","textBefore","text","slice","range","textAfter","hasLinebreakBefore","isTokenOnSameLine","hasLinebreakAfter","newTextBefore","newTextAfter","includeComments","LINEBREAK_REGEX","createGlobalLinebreakMatcher","trim","replace","includes","value","replaceTextRange","validateNode","node","rightSide","operator","token","leftToken","rightToken","operatorStyleOverride","style","fix","report","loc","messageId","data","validateBinaryExpression","right","BinaryExpression","LogicalExpression","AssignmentExpression","VariableDeclarator","init","PropertyDefinition","ConditionalExpression","consequent","alternate"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\r\n * @author Benoît Zugmeyer\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent linebreak style for operators\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/operator-linebreak\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"after\", \"before\", \"none\", null]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    overrides: {\r\n                        type: \"object\",\r\n                        additionalProperties: {\r\n                            enum: [\"after\", \"before\", \"none\", \"ignore\"]\r\n                        }\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            operatorAtBeginning: \"'{{operator}}' should be placed at the beginning of the line.\",\r\n            operatorAtEnd: \"'{{operator}}' should be placed at the end of the line.\",\r\n            badLinebreak: \"Bad line breaking before and after '{{operator}}'.\",\r\n            noLinebreak: \"There should be no line break before or after '{{operator}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const usedDefaultGlobal = !context.options[0];\r\n        const globalStyle = context.options[0] || \"after\";\r\n        const options = context.options[1] || {};\r\n        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};\r\n\r\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\r\n            styleOverrides[\"?\"] = \"before\";\r\n        }\r\n\r\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\r\n            styleOverrides[\":\"] = \"before\";\r\n        }\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Gets a fixer function to fix rule issues\r\n         * @param {Token} operatorToken The operator token of an expression\r\n         * @param {string} desiredStyle The style for the rule. One of 'before', 'after', 'none'\r\n         * @returns {Function} A fixer function\r\n         */\r\n        function getFixer(operatorToken, desiredStyle) {\r\n            return fixer => {\r\n                const tokenBefore = sourceCode.getTokenBefore(operatorToken);\r\n                const tokenAfter = sourceCode.getTokenAfter(operatorToken);\r\n                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);\r\n                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);\r\n                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);\r\n                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);\r\n                let newTextBefore, newTextAfter;\r\n\r\n                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== \"none\") {\r\n\r\n                    // If there is a comment before and after the operator, don't do a fix.\r\n                    if (sourceCode.getTokenBefore(operatorToken, { includeComments: true }) !== tokenBefore &&\r\n                        sourceCode.getTokenAfter(operatorToken, { includeComments: true }) !== tokenAfter) {\r\n\r\n                        return null;\r\n                    }\r\n\r\n                    /*\r\n                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.\r\n                     * foo &&\r\n                     *           bar\r\n                     * would get fixed to\r\n                     * foo\r\n                     *        && bar\r\n                     */\r\n                    newTextBefore = textAfter;\r\n                    newTextAfter = textBefore;\r\n                } else {\r\n                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();\r\n\r\n                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.\r\n                    newTextBefore = desiredStyle === \"before\" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, \"\");\r\n                    newTextAfter = desiredStyle === \"after\" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, \"\");\r\n\r\n                    // If there was no change (due to interfering comments), don't output a fix.\r\n                    if (newTextBefore === textBefore && newTextAfter === textAfter) {\r\n                        return null;\r\n                    }\r\n                }\r\n\r\n                if (newTextAfter === \"\" && tokenAfter.type === \"Punctuator\" && \"+-\".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {\r\n\r\n                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.\r\n                    newTextAfter += \" \";\r\n                }\r\n\r\n                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Checks the operator placement\r\n         * @param {ASTNode} node The node to check\r\n         * @param {ASTNode} rightSide The node that comes after the operator in `node`\r\n         * @param {string} operator The operator\r\n         * @private\r\n         * @returns {void}\r\n         */\r\n        function validateNode(node, rightSide, operator) {\r\n\r\n            /*\r\n             * Find the operator token by searching from the right side, because between the left side and the operator\r\n             * there could be additional tokens from type annotations. Search specifically for the token which\r\n             * value equals the operator, in order to skip possible opening parentheses before the right side node.\r\n             */\r\n            const operatorToken = sourceCode.getTokenBefore(rightSide, token => token.value === operator);\r\n            const leftToken = sourceCode.getTokenBefore(operatorToken);\r\n            const rightToken = sourceCode.getTokenAfter(operatorToken);\r\n            const operatorStyleOverride = styleOverrides[operator];\r\n            const style = operatorStyleOverride || globalStyle;\r\n            const fix = getFixer(operatorToken, style);\r\n\r\n            // if single line\r\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\r\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\r\n\r\n                // do nothing.\r\n\r\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\r\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\r\n\r\n                // lone operator\r\n                context.report({\r\n                    node,\r\n                    loc: operatorToken.loc,\r\n                    messageId: \"badLinebreak\",\r\n                    data: {\r\n                        operator\r\n                    },\r\n                    fix\r\n                });\r\n\r\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\r\n\r\n                context.report({\r\n                    node,\r\n                    loc: operatorToken.loc,\r\n                    messageId: \"operatorAtBeginning\",\r\n                    data: {\r\n                        operator\r\n                    },\r\n                    fix\r\n                });\r\n\r\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\r\n\r\n                context.report({\r\n                    node,\r\n                    loc: operatorToken.loc,\r\n                    messageId: \"operatorAtEnd\",\r\n                    data: {\r\n                        operator\r\n                    },\r\n                    fix\r\n                });\r\n\r\n            } else if (style === \"none\") {\r\n\r\n                context.report({\r\n                    node,\r\n                    loc: operatorToken.loc,\r\n                    messageId: \"noLinebreak\",\r\n                    data: {\r\n                        operator\r\n                    },\r\n                    fix\r\n                });\r\n\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates a binary expression using `validateNode`\r\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\r\n         * @returns {void}\r\n         */\r\n        function validateBinaryExpression(node) {\r\n            validateNode(node, node.right, node.operator);\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            BinaryExpression: validateBinaryExpression,\r\n            LogicalExpression: validateBinaryExpression,\r\n            AssignmentExpression: validateBinaryExpression,\r\n            VariableDeclarator(node) {\r\n                if (node.init) {\r\n                    validateNode(node, node.init, \"=\");\r\n                }\r\n            },\r\n            PropertyDefinition(node) {\r\n                if (node.value) {\r\n                    validateNode(node, node.value, \"=\");\r\n                }\r\n            },\r\n            ConditionalExpression(node) {\r\n                validateNode(node, node.consequent, \"?\");\r\n                validateNode(node, node.alternate, \":\");\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}