{"ast":null,"code":"/**\r\n * @fileoverview Rule for disallowing require() outside of the top-level module context\r\n * @author Jamund Ferguson\r\n * @deprecated in ESLint v7.0.0\r\n */\n\"use strict\";\n\nconst ACCEPTABLE_PARENTS = [\"AssignmentExpression\", \"VariableDeclarator\", \"MemberExpression\", \"ExpressionStatement\", \"CallExpression\", \"ConditionalExpression\", \"Program\", \"VariableDeclaration\", \"ChainExpression\"];\n/**\r\n * Finds the eslint-scope reference in the given scope.\r\n * @param {Object} scope The scope to search.\r\n * @param {ASTNode} node The identifier node.\r\n * @returns {Reference|null} Returns the found reference or null if none were found.\r\n */\n\nfunction findReference(scope, node) {\n  const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);\n  /* istanbul ignore else: correctly returns null */\n\n  if (references.length === 1) {\n    return references[0];\n  }\n\n  return null;\n}\n/**\r\n * Checks if the given identifier node is shadowed in the given scope.\r\n * @param {Object} scope The current scope.\r\n * @param {ASTNode} node The identifier node to check.\r\n * @returns {boolean} Whether or not the name is shadowed.\r\n */\n\n\nfunction isShadowed(scope, node) {\n  const reference = findReference(scope, node);\n  return reference && reference.resolved && reference.resolved.defs.length > 0;\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `require()` calls to be placed at top-level module scope\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/global-require\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected require().\"\n    }\n  },\n\n  create(context) {\n    return {\n      CallExpression(node) {\n        const currentScope = context.getScope();\n\n        if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\n          const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\n\n          if (!isGoodRequire) {\n            context.report({\n              node,\n              messageId: \"unexpected\"\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/global-require.js"],"names":["ACCEPTABLE_PARENTS","findReference","scope","node","references","filter","reference","identifier","range","length","isShadowed","resolved","defs","module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","schema","messages","unexpected","create","context","CallExpression","currentScope","getScope","callee","name","isGoodRequire","getAncestors","every","parent","indexOf","report","messageId"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,kBAAkB,GAAG,CACvB,sBADuB,EAEvB,oBAFuB,EAGvB,kBAHuB,EAIvB,qBAJuB,EAKvB,gBALuB,EAMvB,uBANuB,EAOvB,SAPuB,EAQvB,qBARuB,EASvB,iBATuB,CAA3B;AAYA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,IAA9B,EAAoC;AAChC,QAAMC,UAAU,GAAGF,KAAK,CAACE,UAAN,CAAiBC,MAAjB,CAAwBC,SAAS,IAAIA,SAAS,CAACC,UAAV,CAAqBC,KAArB,CAA2B,CAA3B,MAAkCL,IAAI,CAACK,KAAL,CAAW,CAAX,CAAlC,IAChDF,SAAS,CAACC,UAAV,CAAqBC,KAArB,CAA2B,CAA3B,MAAkCL,IAAI,CAACK,KAAL,CAAW,CAAX,CADvB,CAAnB;AAGA;;AACA,MAAIJ,UAAU,CAACK,MAAX,KAAsB,CAA1B,EAA6B;AACzB,WAAOL,UAAU,CAAC,CAAD,CAAjB;AACH;;AACD,SAAO,IAAP;AAEH;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASM,UAAT,CAAoBR,KAApB,EAA2BC,IAA3B,EAAiC;AAC7B,QAAMG,SAAS,GAAGL,aAAa,CAACC,KAAD,EAAQC,IAAR,CAA/B;AAEA,SAAOG,SAAS,IAAIA,SAAS,CAACK,QAAvB,IAAmCL,SAAS,CAACK,QAAV,CAAmBC,IAAnB,CAAwBH,MAAxB,GAAiC,CAA3E;AACH;AAED;;;AACAI,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,UAAU,EAAE,IADV;AAGFC,IAAAA,UAAU,EAAE,EAHV;AAKFC,IAAAA,IAAI,EAAE,YALJ;AAOFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,kEADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAPJ;AAaFC,IAAAA,MAAM,EAAE,EAbN;AAcFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE;AADN;AAdR,GADO;;AAoBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,WAAO;AACHC,MAAAA,cAAc,CAACzB,IAAD,EAAO;AACjB,cAAM0B,YAAY,GAAGF,OAAO,CAACG,QAAR,EAArB;;AAEA,YAAI3B,IAAI,CAAC4B,MAAL,CAAYC,IAAZ,KAAqB,SAArB,IAAkC,CAACtB,UAAU,CAACmB,YAAD,EAAe1B,IAAI,CAAC4B,MAApB,CAAjD,EAA8E;AAC1E,gBAAME,aAAa,GAAGN,OAAO,CAACO,YAAR,GAAuBC,KAAvB,CAA6BC,MAAM,IAAIpC,kBAAkB,CAACqC,OAAnB,CAA2BD,MAAM,CAAClB,IAAlC,IAA0C,CAAC,CAAlF,CAAtB;;AAEA,cAAI,CAACe,aAAL,EAAoB;AAChBN,YAAAA,OAAO,CAACW,MAAR,CAAe;AAAEnC,cAAAA,IAAF;AAAQoC,cAAAA,SAAS,EAAE;AAAnB,aAAf;AACH;AACJ;AACJ;;AAXE,KAAP;AAaH;;AAlCY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule for disallowing require() outside of the top-level module context\r\n * @author Jamund Ferguson\r\n * @deprecated in ESLint v7.0.0\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst ACCEPTABLE_PARENTS = [\r\n    \"AssignmentExpression\",\r\n    \"VariableDeclarator\",\r\n    \"MemberExpression\",\r\n    \"ExpressionStatement\",\r\n    \"CallExpression\",\r\n    \"ConditionalExpression\",\r\n    \"Program\",\r\n    \"VariableDeclaration\",\r\n    \"ChainExpression\"\r\n];\r\n\r\n/**\r\n * Finds the eslint-scope reference in the given scope.\r\n * @param {Object} scope The scope to search.\r\n * @param {ASTNode} node The identifier node.\r\n * @returns {Reference|null} Returns the found reference or null if none were found.\r\n */\r\nfunction findReference(scope, node) {\r\n    const references = scope.references.filter(reference => reference.identifier.range[0] === node.range[0] &&\r\n            reference.identifier.range[1] === node.range[1]);\r\n\r\n    /* istanbul ignore else: correctly returns null */\r\n    if (references.length === 1) {\r\n        return references[0];\r\n    }\r\n    return null;\r\n\r\n}\r\n\r\n/**\r\n * Checks if the given identifier node is shadowed in the given scope.\r\n * @param {Object} scope The current scope.\r\n * @param {ASTNode} node The identifier node to check.\r\n * @returns {boolean} Whether or not the name is shadowed.\r\n */\r\nfunction isShadowed(scope, node) {\r\n    const reference = findReference(scope, node);\r\n\r\n    return reference && reference.resolved && reference.resolved.defs.length > 0;\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        deprecated: true,\r\n\r\n        replacedBy: [],\r\n\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require `require()` calls to be placed at top-level module scope\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/global-require\"\r\n        },\r\n\r\n        schema: [],\r\n        messages: {\r\n            unexpected: \"Unexpected require().\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        return {\r\n            CallExpression(node) {\r\n                const currentScope = context.getScope();\r\n\r\n                if (node.callee.name === \"require\" && !isShadowed(currentScope, node.callee)) {\r\n                    const isGoodRequire = context.getAncestors().every(parent => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);\r\n\r\n                    if (!isGoodRequire) {\r\n                        context.report({ node, messageId: \"unexpected\" });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}