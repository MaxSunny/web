{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst Traverser = require(\"../shared/traverser\"),\n      astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.\n\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\n/**\r\n * @typedef {Object} LoopConditionInfo\r\n * @property {eslint-scope.Reference} reference - The reference.\r\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\r\n *      that the reference is belonging to.\r\n * @property {Function} isInLoop - The predicate which checks a given reference\r\n *      is in this loop.\r\n * @property {boolean} modified - The flag that the reference is modified in\r\n *      this loop.\r\n */\n\n/**\r\n * Checks whether or not a given reference is a write reference.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is a write reference.\r\n */\n\nfunction isWriteReference(reference) {\n  if (reference.init) {\n    const def = reference.resolved && reference.resolved.defs[0];\n\n    if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n      return false;\n    }\n  }\n\n  return reference.isWrite();\n}\n/**\r\n * Checks whether or not a given loop condition info does not have the modified\r\n * flag.\r\n * @param {LoopConditionInfo} condition A loop condition info to check.\r\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\r\n */\n\n\nfunction isUnmodified(condition) {\n  return !condition.modified;\n}\n/**\r\n * Checks whether or not a given loop condition info does not have the modified\r\n * flag and does not have the group this condition belongs to.\r\n * @param {LoopConditionInfo} condition A loop condition info to check.\r\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\r\n */\n\n\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n  return !(condition.modified || condition.group);\n}\n/**\r\n * Checks whether or not a given reference is inside of a given node.\r\n * @param {ASTNode} node A node to check.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is inside of the node.\r\n */\n\n\nfunction isInRange(node, reference) {\n  const or = node.range;\n  const ir = reference.identifier.range;\n  return or[0] <= ir[0] && ir[1] <= or[1];\n}\n/**\r\n * Checks whether or not a given reference is inside of a loop node's condition.\r\n * @param {ASTNode} node A node to check.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is inside of the loop node's\r\n *      condition.\r\n */\n\n\nconst isInLoop = {\n  WhileStatement: isInRange,\n  DoWhileStatement: isInRange,\n\n  ForStatement(node, reference) {\n    return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));\n  }\n\n};\n/**\r\n * Gets the function which encloses a given reference.\r\n * This supports only FunctionDeclaration.\r\n * @param {eslint-scope.Reference} reference A reference to get.\r\n * @returns {ASTNode|null} The function node or null.\r\n */\n\nfunction getEncloseFunctionDeclaration(reference) {\n  let node = reference.identifier;\n\n  while (node) {\n    if (node.type === \"FunctionDeclaration\") {\n      return node.id ? node : null;\n    }\n\n    node = node.parent;\n  }\n\n  return null;\n}\n/**\r\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\r\n * @param {LoopConditionInfo[]} conditions The loop conditions to be updated.\r\n * @param {eslint-scope.Reference[]} modifiers The references to update.\r\n * @returns {void}\r\n */\n\n\nfunction updateModifiedFlag(conditions, modifiers) {\n  for (let i = 0; i < conditions.length; ++i) {\n    const condition = conditions[i];\n\n    for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\n      const modifier = modifiers[j];\n      let funcNode, funcVar;\n      /*\r\n       * Besides checking for the condition being in the loop, we want to\r\n       * check the function that this modifier is belonging to is called\r\n       * in the loop.\r\n       * FIXME: This should probably be extracted to a function.\r\n       */\n\n      const inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));\n      condition.modified = inLoop;\n    }\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unmodified loop conditions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unmodified-loop-condition\"\n    },\n    schema: [],\n    messages: {\n      loopConditionNotModified: \"'{{name}}' is not modified in this loop.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let groupMap = null;\n    /**\r\n     * Reports a given condition info.\r\n     * @param {LoopConditionInfo} condition A loop condition info to report.\r\n     * @returns {void}\r\n     */\n\n    function report(condition) {\n      const node = condition.reference.identifier;\n      context.report({\n        node,\n        messageId: \"loopConditionNotModified\",\n        data: node\n      });\n    }\n    /**\r\n     * Registers given conditions to the group the condition belongs to.\r\n     * @param {LoopConditionInfo[]} conditions A loop condition info to\r\n     *      register.\r\n     * @returns {void}\r\n     */\n\n\n    function registerConditionsToGroup(conditions) {\n      for (let i = 0; i < conditions.length; ++i) {\n        const condition = conditions[i];\n\n        if (condition.group) {\n          let group = groupMap.get(condition.group);\n\n          if (!group) {\n            group = [];\n            groupMap.set(condition.group, group);\n          }\n\n          group.push(condition);\n        }\n      }\n    }\n    /**\r\n     * Reports references which are inside of unmodified groups.\r\n     * @param {LoopConditionInfo[]} conditions A loop condition info to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkConditionsInGroup(conditions) {\n      if (conditions.every(isUnmodified)) {\n        conditions.forEach(report);\n      }\n    }\n    /**\r\n     * Checks whether or not a given group node has any dynamic elements.\r\n     * @param {ASTNode} root A node to check.\r\n     *      This node is one of BinaryExpression or ConditionalExpression.\r\n     * @returns {boolean} `true` if the node is dynamic.\r\n     */\n\n\n    function hasDynamicExpressions(root) {\n      let retv = false;\n      Traverser.traverse(root, {\n        visitorKeys: sourceCode.visitorKeys,\n\n        enter(node) {\n          if (DYNAMIC_PATTERN.test(node.type)) {\n            retv = true;\n            this.break();\n          } else if (SKIP_PATTERN.test(node.type)) {\n            this.skip();\n          }\n        }\n\n      });\n      return retv;\n    }\n    /**\r\n     * Creates the loop condition information from a given reference.\r\n     * @param {eslint-scope.Reference} reference A reference to create.\r\n     * @returns {LoopConditionInfo|null} Created loop condition info, or null.\r\n     */\n\n\n    function toLoopCondition(reference) {\n      if (reference.init) {\n        return null;\n      }\n\n      let group = null;\n      let child = reference.identifier;\n      let node = child.parent;\n\n      while (node) {\n        if (SENTINEL_PATTERN.test(node.type)) {\n          if (LOOP_PATTERN.test(node.type) && node.test === child) {\n            // This reference is inside of a loop condition.\n            return {\n              reference,\n              group,\n              isInLoop: isInLoop[node.type].bind(null, node),\n              modified: false\n            };\n          } // This reference is outside of a loop condition.\n\n\n          break;\n        }\n        /*\r\n         * If it's inside of a group, OK if either operand is modified.\r\n         * So stores the group this reference belongs to.\r\n         */\n\n\n        if (GROUP_PATTERN.test(node.type)) {\n          // If this expression is dynamic, no need to check.\n          if (hasDynamicExpressions(node)) {\n            break;\n          } else {\n            group = node;\n          }\n        }\n\n        child = node;\n        node = node.parent;\n      }\n\n      return null;\n    }\n    /**\r\n     * Finds unmodified references which are inside of a loop condition.\r\n     * Then reports the references which are outside of groups.\r\n     * @param {eslint-scope.Variable} variable A variable to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkReferences(variable) {\n      // Gets references that exist in loop conditions.\n      const conditions = variable.references.map(toLoopCondition).filter(Boolean);\n\n      if (conditions.length === 0) {\n        return;\n      } // Registers the conditions to belonging groups.\n\n\n      registerConditionsToGroup(conditions); // Check the conditions are modified.\n\n      const modifiers = variable.references.filter(isWriteReference);\n\n      if (modifiers.length > 0) {\n        updateModifiedFlag(conditions, modifiers);\n      }\n      /*\r\n       * Reports the conditions which are not belonging to groups.\r\n       * Others will be reported after all variables are done.\r\n       */\n\n\n      conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);\n    }\n\n    return {\n      \"Program:exit\"() {\n        const queue = [context.getScope()];\n        groupMap = new Map();\n        let scope;\n\n        while (scope = queue.pop()) {\n          queue.push(...scope.childScopes);\n          scope.variables.forEach(checkReferences);\n        }\n\n        groupMap.forEach(checkConditionsInGroup);\n        groupMap = null;\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unmodified-loop-condition.js"],"names":["Traverser","require","astUtils","SENTINEL_PATTERN","LOOP_PATTERN","GROUP_PATTERN","SKIP_PATTERN","DYNAMIC_PATTERN","isWriteReference","reference","init","def","resolved","defs","type","parent","kind","isWrite","isUnmodified","condition","modified","isUnmodifiedAndNotBelongToGroup","group","isInRange","node","or","range","ir","identifier","isInLoop","WhileStatement","DoWhileStatement","ForStatement","getEncloseFunctionDeclaration","id","updateModifiedFlag","conditions","modifiers","i","length","j","modifier","funcNode","funcVar","inLoop","Boolean","getVariableByName","from","upper","name","references","some","module","exports","meta","docs","description","recommended","url","schema","messages","loopConditionNotModified","create","context","sourceCode","getSourceCode","groupMap","report","messageId","data","registerConditionsToGroup","get","set","push","checkConditionsInGroup","every","forEach","hasDynamicExpressions","root","retv","traverse","visitorKeys","enter","test","break","skip","toLoopCondition","child","bind","checkReferences","variable","map","filter","queue","getScope","Map","scope","pop","childScopes","variables"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst Traverser = require(\"../shared/traverser\"),\r\n    astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;\r\nconst LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.\r\nconst GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;\r\nconst SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;\r\nconst DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;\r\n\r\n/**\r\n * @typedef {Object} LoopConditionInfo\r\n * @property {eslint-scope.Reference} reference - The reference.\r\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\r\n *      that the reference is belonging to.\r\n * @property {Function} isInLoop - The predicate which checks a given reference\r\n *      is in this loop.\r\n * @property {boolean} modified - The flag that the reference is modified in\r\n *      this loop.\r\n */\r\n\r\n/**\r\n * Checks whether or not a given reference is a write reference.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is a write reference.\r\n */\r\nfunction isWriteReference(reference) {\r\n    if (reference.init) {\r\n        const def = reference.resolved && reference.resolved.defs[0];\r\n\r\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\r\n            return false;\r\n        }\r\n    }\r\n    return reference.isWrite();\r\n}\r\n\r\n/**\r\n * Checks whether or not a given loop condition info does not have the modified\r\n * flag.\r\n * @param {LoopConditionInfo} condition A loop condition info to check.\r\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\r\n */\r\nfunction isUnmodified(condition) {\r\n    return !condition.modified;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given loop condition info does not have the modified\r\n * flag and does not have the group this condition belongs to.\r\n * @param {LoopConditionInfo} condition A loop condition info to check.\r\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\r\n */\r\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\r\n    return !(condition.modified || condition.group);\r\n}\r\n\r\n/**\r\n * Checks whether or not a given reference is inside of a given node.\r\n * @param {ASTNode} node A node to check.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is inside of the node.\r\n */\r\nfunction isInRange(node, reference) {\r\n    const or = node.range;\r\n    const ir = reference.identifier.range;\r\n\r\n    return or[0] <= ir[0] && ir[1] <= or[1];\r\n}\r\n\r\n/**\r\n * Checks whether or not a given reference is inside of a loop node's condition.\r\n * @param {ASTNode} node A node to check.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is inside of the loop node's\r\n *      condition.\r\n */\r\nconst isInLoop = {\r\n    WhileStatement: isInRange,\r\n    DoWhileStatement: isInRange,\r\n    ForStatement(node, reference) {\r\n        return (\r\n            isInRange(node, reference) &&\r\n            !(node.init && isInRange(node.init, reference))\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the function which encloses a given reference.\r\n * This supports only FunctionDeclaration.\r\n * @param {eslint-scope.Reference} reference A reference to get.\r\n * @returns {ASTNode|null} The function node or null.\r\n */\r\nfunction getEncloseFunctionDeclaration(reference) {\r\n    let node = reference.identifier;\r\n\r\n    while (node) {\r\n        if (node.type === \"FunctionDeclaration\") {\r\n            return node.id ? node : null;\r\n        }\r\n\r\n        node = node.parent;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\r\n * @param {LoopConditionInfo[]} conditions The loop conditions to be updated.\r\n * @param {eslint-scope.Reference[]} modifiers The references to update.\r\n * @returns {void}\r\n */\r\nfunction updateModifiedFlag(conditions, modifiers) {\r\n\r\n    for (let i = 0; i < conditions.length; ++i) {\r\n        const condition = conditions[i];\r\n\r\n        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {\r\n            const modifier = modifiers[j];\r\n            let funcNode, funcVar;\r\n\r\n            /*\r\n             * Besides checking for the condition being in the loop, we want to\r\n             * check the function that this modifier is belonging to is called\r\n             * in the loop.\r\n             * FIXME: This should probably be extracted to a function.\r\n             */\r\n            const inLoop = condition.isInLoop(modifier) || Boolean(\r\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\r\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\r\n                funcVar.references.some(condition.isInLoop)\r\n            );\r\n\r\n            condition.modified = inLoop;\r\n        }\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow unmodified loop conditions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-unmodified-loop-condition\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            loopConditionNotModified: \"'{{name}}' is not modified in this loop.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        let groupMap = null;\r\n\r\n        /**\r\n         * Reports a given condition info.\r\n         * @param {LoopConditionInfo} condition A loop condition info to report.\r\n         * @returns {void}\r\n         */\r\n        function report(condition) {\r\n            const node = condition.reference.identifier;\r\n\r\n            context.report({\r\n                node,\r\n                messageId: \"loopConditionNotModified\",\r\n                data: node\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Registers given conditions to the group the condition belongs to.\r\n         * @param {LoopConditionInfo[]} conditions A loop condition info to\r\n         *      register.\r\n         * @returns {void}\r\n         */\r\n        function registerConditionsToGroup(conditions) {\r\n            for (let i = 0; i < conditions.length; ++i) {\r\n                const condition = conditions[i];\r\n\r\n                if (condition.group) {\r\n                    let group = groupMap.get(condition.group);\r\n\r\n                    if (!group) {\r\n                        group = [];\r\n                        groupMap.set(condition.group, group);\r\n                    }\r\n                    group.push(condition);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports references which are inside of unmodified groups.\r\n         * @param {LoopConditionInfo[]} conditions A loop condition info to report.\r\n         * @returns {void}\r\n         */\r\n        function checkConditionsInGroup(conditions) {\r\n            if (conditions.every(isUnmodified)) {\r\n                conditions.forEach(report);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given group node has any dynamic elements.\r\n         * @param {ASTNode} root A node to check.\r\n         *      This node is one of BinaryExpression or ConditionalExpression.\r\n         * @returns {boolean} `true` if the node is dynamic.\r\n         */\r\n        function hasDynamicExpressions(root) {\r\n            let retv = false;\r\n\r\n            Traverser.traverse(root, {\r\n                visitorKeys: sourceCode.visitorKeys,\r\n                enter(node) {\r\n                    if (DYNAMIC_PATTERN.test(node.type)) {\r\n                        retv = true;\r\n                        this.break();\r\n                    } else if (SKIP_PATTERN.test(node.type)) {\r\n                        this.skip();\r\n                    }\r\n                }\r\n            });\r\n\r\n            return retv;\r\n        }\r\n\r\n        /**\r\n         * Creates the loop condition information from a given reference.\r\n         * @param {eslint-scope.Reference} reference A reference to create.\r\n         * @returns {LoopConditionInfo|null} Created loop condition info, or null.\r\n         */\r\n        function toLoopCondition(reference) {\r\n            if (reference.init) {\r\n                return null;\r\n            }\r\n\r\n            let group = null;\r\n            let child = reference.identifier;\r\n            let node = child.parent;\r\n\r\n            while (node) {\r\n                if (SENTINEL_PATTERN.test(node.type)) {\r\n                    if (LOOP_PATTERN.test(node.type) && node.test === child) {\r\n\r\n                        // This reference is inside of a loop condition.\r\n                        return {\r\n                            reference,\r\n                            group,\r\n                            isInLoop: isInLoop[node.type].bind(null, node),\r\n                            modified: false\r\n                        };\r\n                    }\r\n\r\n                    // This reference is outside of a loop condition.\r\n                    break;\r\n                }\r\n\r\n                /*\r\n                 * If it's inside of a group, OK if either operand is modified.\r\n                 * So stores the group this reference belongs to.\r\n                 */\r\n                if (GROUP_PATTERN.test(node.type)) {\r\n\r\n                    // If this expression is dynamic, no need to check.\r\n                    if (hasDynamicExpressions(node)) {\r\n                        break;\r\n                    } else {\r\n                        group = node;\r\n                    }\r\n                }\r\n\r\n                child = node;\r\n                node = node.parent;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Finds unmodified references which are inside of a loop condition.\r\n         * Then reports the references which are outside of groups.\r\n         * @param {eslint-scope.Variable} variable A variable to report.\r\n         * @returns {void}\r\n         */\r\n        function checkReferences(variable) {\r\n\r\n            // Gets references that exist in loop conditions.\r\n            const conditions = variable\r\n                .references\r\n                .map(toLoopCondition)\r\n                .filter(Boolean);\r\n\r\n            if (conditions.length === 0) {\r\n                return;\r\n            }\r\n\r\n            // Registers the conditions to belonging groups.\r\n            registerConditionsToGroup(conditions);\r\n\r\n            // Check the conditions are modified.\r\n            const modifiers = variable.references.filter(isWriteReference);\r\n\r\n            if (modifiers.length > 0) {\r\n                updateModifiedFlag(conditions, modifiers);\r\n            }\r\n\r\n            /*\r\n             * Reports the conditions which are not belonging to groups.\r\n             * Others will be reported after all variables are done.\r\n             */\r\n            conditions\r\n                .filter(isUnmodifiedAndNotBelongToGroup)\r\n                .forEach(report);\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\"() {\r\n                const queue = [context.getScope()];\r\n\r\n                groupMap = new Map();\r\n\r\n                let scope;\r\n\r\n                while ((scope = queue.pop())) {\r\n                    queue.push(...scope.childScopes);\r\n                    scope.variables.forEach(checkReferences);\r\n                }\r\n\r\n                groupMap.forEach(checkConditionsInGroup);\r\n                groupMap = null;\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}