{"ast":null,"code":"/**\r\n * @fileoverview Main API Class\r\n * @author Kai Cataldo\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst path = require(\"path\");\n\nconst fs = require(\"fs\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nconst {\n  CLIEngine,\n  getCLIEngineInternalSlots\n} = require(\"../cli-engine/cli-engine\");\n\nconst BuiltinRules = require(\"../rules\");\n\nconst {\n  Legacy: {\n    ConfigOps: {\n      getRuleSeverity\n    }\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst {\n  version\n} = require(\"../../package.json\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\n\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\n\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\n\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\n\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\n\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\n\n/** @typedef {import(\"../shared/types\").Rule} Rule */\n\n/**\r\n * The main formatter object.\r\n * @typedef Formatter\r\n * @property {function(LintResult[]): string | Promise<string>} format format function.\r\n */\n\n/**\r\n * The options with which to configure the ESLint instance.\r\n * @typedef {Object} ESLintOptions\r\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\r\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\r\n * @property {boolean} [cache] Enable result caching.\r\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\r\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\r\n * @property {string} [cwd] The value to use for the current working directory.\r\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\r\n * @property {string[]} [extensions] An array of file extensions to check.\r\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\r\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} [ignore] False disables use of .eslintignore.\r\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\r\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\r\n * @property {string} [overrideConfigFile] The configuration file to use.\r\n * @property {Record<string,Plugin>|null} [plugins] Preloaded plugins. This is a map-like object, keys are plugin IDs and each value is implementation.\r\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\r\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\r\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\r\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\r\n */\n\n/**\r\n * A rules metadata object.\r\n * @typedef {Object} RulesMeta\r\n * @property {string} id The plugin ID.\r\n * @property {Object} definition The plugin definition.\r\n */\n\n/**\r\n * A linting result.\r\n * @typedef {Object} LintResult\r\n * @property {string} filePath The path to the file that was linted.\r\n * @property {LintMessage[]} messages All of the messages for the result.\r\n * @property {SuppressedLintMessage[]} suppressedMessages All of the suppressed messages for the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {string} [source] The source code of the file that was linted.\r\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\r\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\r\n */\n\n/**\r\n * Private members for the `ESLint` instance.\r\n * @typedef {Object} ESLintPrivateMembers\r\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\r\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst writeFile = promisify(fs.writeFile);\n/**\r\n * The map with which to store private class members.\r\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\r\n */\n\nconst privateMembersMap = new WeakMap();\n/**\r\n * Check if a given value is a non-empty string or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is a non-empty string.\r\n */\n\nfunction isNonEmptyString(x) {\n  return typeof x === \"string\" && x.trim() !== \"\";\n}\n/**\r\n * Check if a given value is an array of non-empty stringss or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\r\n */\n\n\nfunction isArrayOfNonEmptyString(x) {\n  return Array.isArray(x) && x.every(isNonEmptyString);\n}\n/**\r\n * Check if a given value is a valid fix type or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is valid fix type.\r\n */\n\n\nfunction isFixType(x) {\n  return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\n}\n/**\r\n * Check if a given value is an array of fix types or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is an array of fix types.\r\n */\n\n\nfunction isFixTypeArray(x) {\n  return Array.isArray(x) && x.every(isFixType);\n}\n/**\r\n * The error for invalid options.\r\n */\n\n\nclass ESLintInvalidOptionsError extends Error {\n  constructor(messages) {\n    super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\n    this.code = \"ESLINT_INVALID_OPTIONS\";\n    Error.captureStackTrace(this, ESLintInvalidOptionsError);\n  }\n\n}\n/**\r\n * Validates and normalizes options for the wrapped CLIEngine instance.\r\n * @param {ESLintOptions} options The options to process.\r\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\r\n * @returns {ESLintOptions} The normalized options.\r\n */\n\n\nfunction processOptions(_ref) {\n  let {\n    allowInlineConfig = true,\n    // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\n    baseConfig = null,\n    cache = false,\n    cacheLocation = \".eslintcache\",\n    cacheStrategy = \"metadata\",\n    cwd = process.cwd(),\n    errorOnUnmatchedPattern = true,\n    extensions = null,\n    // ← should be null by default because if it's an array then it suppresses RFC20 feature.\n    fix = false,\n    fixTypes = null,\n    // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\n    globInputPaths = true,\n    ignore = true,\n    ignorePath = null,\n    // ← should be null by default because if it's a string then it may throw ENOENT.\n    overrideConfig = null,\n    overrideConfigFile = null,\n    plugins = {},\n    reportUnusedDisableDirectives = null,\n    // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\n    resolvePluginsRelativeTo = null,\n    // ← should be null by default because if it's a string then it suppresses RFC47 feature.\n    rulePaths = [],\n    useEslintrc = true,\n    ...unknownOptions\n  } = _ref;\n  const errors = [];\n  const unknownOptionKeys = Object.keys(unknownOptions);\n\n  if (unknownOptionKeys.length >= 1) {\n    errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\n\n    if (unknownOptionKeys.includes(\"cacheFile\")) {\n      errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"configFile\")) {\n      errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"envs\")) {\n      errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"globals\")) {\n      errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"ignorePattern\")) {\n      errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parser\")) {\n      errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"parserOptions\")) {\n      errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\n    }\n\n    if (unknownOptionKeys.includes(\"rules\")) {\n      errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\n    }\n  }\n\n  if (typeof allowInlineConfig !== \"boolean\") {\n    errors.push(\"'allowInlineConfig' must be a boolean.\");\n  }\n\n  if (typeof baseConfig !== \"object\") {\n    errors.push(\"'baseConfig' must be an object or null.\");\n  }\n\n  if (typeof cache !== \"boolean\") {\n    errors.push(\"'cache' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(cacheLocation)) {\n    errors.push(\"'cacheLocation' must be a non-empty string.\");\n  }\n\n  if (cacheStrategy !== \"metadata\" && cacheStrategy !== \"content\") {\n    errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\n  }\n\n  if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\n    errors.push(\"'cwd' must be an absolute path.\");\n  }\n\n  if (typeof errorOnUnmatchedPattern !== \"boolean\") {\n    errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\n  }\n\n  if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\n    errors.push(\"'extensions' must be an array of non-empty strings or null.\");\n  }\n\n  if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\n    errors.push(\"'fix' must be a boolean or a function.\");\n  }\n\n  if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\n    errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\n  }\n\n  if (typeof globInputPaths !== \"boolean\") {\n    errors.push(\"'globInputPaths' must be a boolean.\");\n  }\n\n  if (typeof ignore !== \"boolean\") {\n    errors.push(\"'ignore' must be a boolean.\");\n  }\n\n  if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\n    errors.push(\"'ignorePath' must be a non-empty string or null.\");\n  }\n\n  if (typeof overrideConfig !== \"object\") {\n    errors.push(\"'overrideConfig' must be an object or null.\");\n  }\n\n  if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\n    errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\n  }\n\n  if (typeof plugins !== \"object\") {\n    errors.push(\"'plugins' must be an object or null.\");\n  } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\n    errors.push(\"'plugins' must not include an empty string.\");\n  }\n\n  if (Array.isArray(plugins)) {\n    errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\n  }\n\n  if (reportUnusedDisableDirectives !== \"error\" && reportUnusedDisableDirectives !== \"warn\" && reportUnusedDisableDirectives !== \"off\" && reportUnusedDisableDirectives !== null) {\n    errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\n  }\n\n  if (!isNonEmptyString(resolvePluginsRelativeTo) && resolvePluginsRelativeTo !== null) {\n    errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\n  }\n\n  if (!isArrayOfNonEmptyString(rulePaths)) {\n    errors.push(\"'rulePaths' must be an array of non-empty strings.\");\n  }\n\n  if (typeof useEslintrc !== \"boolean\") {\n    errors.push(\"'useEslintrc' must be a boolean.\");\n  }\n\n  if (errors.length > 0) {\n    throw new ESLintInvalidOptionsError(errors);\n  }\n\n  return {\n    allowInlineConfig,\n    baseConfig,\n    cache,\n    cacheLocation,\n    cacheStrategy,\n    configFile: overrideConfigFile,\n    cwd,\n    errorOnUnmatchedPattern,\n    extensions,\n    fix,\n    fixTypes,\n    globInputPaths,\n    ignore,\n    ignorePath,\n    reportUnusedDisableDirectives,\n    resolvePluginsRelativeTo,\n    rulePaths,\n    useEslintrc\n  };\n}\n/**\r\n * Check if a value has one or more properties and that value is not undefined.\r\n * @param {any} obj The value to check.\r\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\r\n */\n\n\nfunction hasDefinedProperty(obj) {\n  if (typeof obj === \"object\" && obj !== null) {\n    for (const key in obj) {\n      if (typeof obj[key] !== \"undefined\") {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\r\n * Create rulesMeta object.\r\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\r\n * @returns {Object} metadata for all enabled rules.\r\n */\n\n\nfunction createRulesMeta(rules) {\n  return Array.from(rules).reduce((retVal, _ref2) => {\n    let [id, rule] = _ref2;\n    retVal[id] = rule.meta;\n    return retVal;\n  }, {});\n}\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\n\n\nconst usedDeprecatedRulesCache = new WeakMap();\n/**\r\n * Create used deprecated rule list.\r\n * @param {CLIEngine} cliEngine The CLIEngine instance.\r\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\r\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\r\n */\n\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\n  const {\n    configArrayFactory,\n    options: {\n      cwd\n    }\n  } = getCLIEngineInternalSlots(cliEngine);\n  const filePath = path.isAbsolute(maybeFilePath) ? maybeFilePath : path.join(cwd, \"__placeholder__.js\");\n  const configArray = configArrayFactory.getConfigArrayForFile(filePath);\n  const config = configArray.extractConfig(filePath); // Most files use the same config, so cache it.\n\n  if (!usedDeprecatedRulesCache.has(config)) {\n    const pluginRules = configArray.pluginRules;\n    const retv = [];\n\n    for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\n      if (getRuleSeverity(ruleConf) === 0) {\n        continue;\n      }\n\n      const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\n      const meta = rule && rule.meta;\n\n      if (meta && meta.deprecated) {\n        retv.push({\n          ruleId,\n          replacedBy: meta.replacedBy || []\n        });\n      }\n    }\n\n    usedDeprecatedRulesCache.set(config, Object.freeze(retv));\n  }\n\n  return usedDeprecatedRulesCache.get(config);\n}\n/**\r\n * Processes the linting results generated by a CLIEngine linting report to\r\n * match the ESLint class's API.\r\n * @param {CLIEngine} cliEngine The CLIEngine instance.\r\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\r\n * @returns {LintResult[]} The processed linting results.\r\n */\n\n\nfunction processCLIEngineLintReport(cliEngine, _ref3) {\n  let {\n    results\n  } = _ref3;\n  const descriptor = {\n    configurable: true,\n    enumerable: true,\n\n    get() {\n      return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\n    }\n\n  };\n\n  for (const result of results) {\n    Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\n  }\n\n  return results;\n}\n/**\r\n * An Array.prototype.sort() compatible compare function to order results by their file path.\r\n * @param {LintResult} a The first lint result.\r\n * @param {LintResult} b The second lint result.\r\n * @returns {number} An integer representing the order in which the two results should occur.\r\n */\n\n\nfunction compareResultsByFilePath(a, b) {\n  if (a.filePath < b.filePath) {\n    return -1;\n  }\n\n  if (a.filePath > b.filePath) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\r\n * Main API.\r\n */\n\n\nclass ESLint {\n  /**\r\n   * Creates a new instance of the main ESLint API.\r\n   * @param {ESLintOptions} options The options for this instance.\r\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const processedOptions = processOptions(options);\n    const cliEngine = new CLIEngine(processedOptions, {\n      preloadedPlugins: options.plugins\n    });\n    const {\n      configArrayFactory,\n      lastConfigArrays\n    } = getCLIEngineInternalSlots(cliEngine);\n    let updated = false;\n    /*\r\n     * Address `overrideConfig` to set override config.\r\n     * Operate the `configArrayFactory` internal slot directly because this\r\n     * functionality doesn't exist as the public API of CLIEngine.\r\n     */\n\n    if (hasDefinedProperty(options.overrideConfig)) {\n      configArrayFactory.setOverrideConfig(options.overrideConfig);\n      updated = true;\n    } // Update caches.\n\n\n    if (updated) {\n      configArrayFactory.clearCache();\n      lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\n    } // Initialize private properties.\n\n\n    privateMembersMap.set(this, {\n      cliEngine,\n      options: processedOptions\n    });\n  }\n  /**\r\n   * The version text.\r\n   * @type {string}\r\n   */\n\n\n  static get version() {\n    return version;\n  }\n  /**\r\n   * Outputs fixes from the given results to files.\r\n   * @param {LintResult[]} results The lint results.\r\n   * @returns {Promise<void>} Returns a promise that is used to track side effects.\r\n   */\n\n\n  static async outputFixes(results) {\n    if (!Array.isArray(results)) {\n      throw new Error(\"'results' must be an array\");\n    }\n\n    await Promise.all(results.filter(result => {\n      if (typeof result !== \"object\" || result === null) {\n        throw new Error(\"'results' must include only objects\");\n      }\n\n      return typeof result.output === \"string\" && path.isAbsolute(result.filePath);\n    }).map(r => writeFile(r.filePath, r.output)));\n  }\n  /**\r\n   * Returns results that only contains errors.\r\n   * @param {LintResult[]} results The results to filter.\r\n   * @returns {LintResult[]} The filtered results.\r\n   */\n\n\n  static getErrorResults(results) {\n    return CLIEngine.getErrorResults(results);\n  }\n  /**\r\n   * Returns meta objects for each rule represented in the lint results.\r\n   * @param {LintResult[]} results The results to fetch rules meta for.\r\n   * @returns {Object} A mapping of ruleIds to rule meta objects.\r\n   */\n\n\n  getRulesMetaForResults(results) {\n    const resultRuleIds = new Set(); // first gather all ruleIds from all results\n\n    for (const result of results) {\n      for (const {\n        ruleId\n      } of result.messages) {\n        resultRuleIds.add(ruleId);\n      }\n\n      for (const {\n        ruleId\n      } of result.suppressedMessages) {\n        resultRuleIds.add(ruleId);\n      }\n    } // create a map of all rules in the results\n\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    const rules = cliEngine.getRules();\n    const resultRules = new Map();\n\n    for (const [ruleId, rule] of rules) {\n      if (resultRuleIds.has(ruleId)) {\n        resultRules.set(ruleId, rule);\n      }\n    }\n\n    return createRulesMeta(resultRules);\n  }\n  /**\r\n   * Executes the current configuration on an array of file and directory names.\r\n   * @param {string[]} patterns An array of file and directory names.\r\n   * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\r\n   */\n\n\n  async lintFiles(patterns) {\n    if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\n      throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnFiles(patterns));\n  }\n  /**\r\n   * Executes the current configuration on text.\r\n   * @param {string} code A string of JavaScript code to lint.\r\n   * @param {Object} [options] The options.\r\n   * @param {string} [options.filePath] The path to the file of the source code.\r\n   * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\r\n   * @returns {Promise<LintResult[]>} The results of linting the string of code given.\r\n   */\n\n\n  async lintText(code) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (typeof code !== \"string\") {\n      throw new Error(\"'code' must be a string\");\n    }\n\n    if (typeof options !== \"object\") {\n      throw new Error(\"'options' must be an object, null, or undefined\");\n    }\n\n    const {\n      filePath,\n      warnIgnored = false,\n      ...unknownOptions\n    } = options || {};\n    const unknownOptionKeys = Object.keys(unknownOptions);\n\n    if (unknownOptionKeys.length > 0) {\n      throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\n    }\n\n    if (filePath !== void 0 && !isNonEmptyString(filePath)) {\n      throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\n    }\n\n    if (typeof warnIgnored !== \"boolean\") {\n      throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return processCLIEngineLintReport(cliEngine, cliEngine.executeOnText(code, filePath, warnIgnored));\n  }\n  /**\r\n   * Returns the formatter representing the given formatter name.\r\n   * @param {string} [name] The name of the formatter to load.\r\n   * The following values are allowed:\r\n   * - `undefined` ... Load `stylish` builtin formatter.\r\n   * - A builtin formatter name ... Load the builtin formatter.\r\n   * - A thirdparty formatter name:\r\n   *   - `foo` → `eslint-formatter-foo`\r\n   *   - `@foo` → `@foo/eslint-formatter`\r\n   *   - `@foo/bar` → `@foo/eslint-formatter-bar`\r\n   * - A file path ... Load the file.\r\n   * @returns {Promise<Formatter>} A promise resolving to the formatter object.\r\n   * This promise will be rejected if the given formatter was not found or not\r\n   * a function.\r\n   */\n\n\n  async loadFormatter() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"stylish\";\n\n    if (typeof name !== \"string\") {\n      throw new Error(\"'name' must be a string\");\n    }\n\n    const {\n      cliEngine,\n      options\n    } = privateMembersMap.get(this);\n    const formatter = cliEngine.getFormatter(name);\n\n    if (typeof formatter !== \"function\") {\n      throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\n    }\n\n    return {\n      /**\r\n       * The main formatter method.\r\n       * @param {LintResults[]} results The lint results to format.\r\n       * @returns {string | Promise<string>} The formatted lint results.\r\n       */\n      format(results) {\n        let rulesMeta = null;\n        results.sort(compareResultsByFilePath);\n        return formatter(results, {\n          get cwd() {\n            return options.cwd;\n          },\n\n          get rulesMeta() {\n            if (!rulesMeta) {\n              rulesMeta = createRulesMeta(cliEngine.getRules());\n            }\n\n            return rulesMeta;\n          }\n\n        });\n      }\n\n    };\n  }\n  /**\r\n   * Returns a configuration object for the given file based on the CLI options.\r\n   * This is the same logic used by the ESLint CLI executable to determine\r\n   * configuration for each file it processes.\r\n   * @param {string} filePath The path of the file to retrieve a config object for.\r\n   * @returns {Promise<ConfigData>} A configuration object for the file.\r\n   */\n\n\n  async calculateConfigForFile(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.getConfigForFile(filePath);\n  }\n  /**\r\n   * Checks if a given path is ignored by ESLint.\r\n   * @param {string} filePath The path of the file to check.\r\n   * @returns {Promise<boolean>} Whether or not the given path is ignored.\r\n   */\n\n\n  async isPathIgnored(filePath) {\n    if (!isNonEmptyString(filePath)) {\n      throw new Error(\"'filePath' must be a non-empty string\");\n    }\n\n    const {\n      cliEngine\n    } = privateMembersMap.get(this);\n    return cliEngine.isPathIgnored(filePath);\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  ESLint,\n\n  /**\r\n   * Get the private class members of a given ESLint instance for tests.\r\n   * @param {ESLint} instance The ESLint instance to get.\r\n   * @returns {ESLintPrivateMembers} The instance's private class members.\r\n   */\n  getESLintPrivateMembers(instance) {\n    return privateMembersMap.get(instance);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/eslint/eslint.js"],"names":["path","require","fs","promisify","CLIEngine","getCLIEngineInternalSlots","BuiltinRules","Legacy","ConfigOps","getRuleSeverity","version","writeFile","privateMembersMap","WeakMap","isNonEmptyString","x","trim","isArrayOfNonEmptyString","Array","isArray","every","isFixType","isFixTypeArray","ESLintInvalidOptionsError","Error","constructor","messages","join","code","captureStackTrace","processOptions","allowInlineConfig","baseConfig","cache","cacheLocation","cacheStrategy","cwd","process","errorOnUnmatchedPattern","extensions","fix","fixTypes","globInputPaths","ignore","ignorePath","overrideConfig","overrideConfigFile","plugins","reportUnusedDisableDirectives","resolvePluginsRelativeTo","rulePaths","useEslintrc","unknownOptions","errors","unknownOptionKeys","Object","keys","length","push","includes","isAbsolute","configFile","hasDefinedProperty","obj","key","createRulesMeta","rules","from","reduce","retVal","id","rule","meta","usedDeprecatedRulesCache","getOrFindUsedDeprecatedRules","cliEngine","maybeFilePath","configArrayFactory","options","filePath","configArray","getConfigArrayForFile","config","extractConfig","has","pluginRules","retv","ruleId","ruleConf","entries","get","deprecated","replacedBy","set","freeze","processCLIEngineLintReport","results","descriptor","configurable","enumerable","result","defineProperty","compareResultsByFilePath","a","b","ESLint","processedOptions","preloadedPlugins","lastConfigArrays","updated","setOverrideConfig","clearCache","outputFixes","Promise","all","filter","output","map","r","getErrorResults","getRulesMetaForResults","resultRuleIds","Set","add","suppressedMessages","getRules","resultRules","Map","lintFiles","patterns","executeOnFiles","lintText","warnIgnored","executeOnText","loadFormatter","name","formatter","getFormatter","format","rulesMeta","sort","calculateConfigForFile","getConfigForFile","isPathIgnored","module","exports","getESLintPrivateMembers","instance"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Main API Class\r\n * @author Kai Cataldo\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\nconst { promisify } = require(\"util\");\r\nconst { CLIEngine, getCLIEngineInternalSlots } = require(\"../cli-engine/cli-engine\");\r\nconst BuiltinRules = require(\"../rules\");\r\nconst {\r\n    Legacy: {\r\n        ConfigOps: {\r\n            getRuleSeverity\r\n        }\r\n    }\r\n} = require(\"@eslint/eslintrc\");\r\nconst { version } = require(\"../../package.json\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/** @typedef {import(\"../cli-engine/cli-engine\").LintReport} CLIEngineLintReport */\r\n/** @typedef {import(\"../shared/types\").DeprecatedRuleInfo} DeprecatedRuleInfo */\r\n/** @typedef {import(\"../shared/types\").ConfigData} ConfigData */\r\n/** @typedef {import(\"../shared/types\").LintMessage} LintMessage */\r\n/** @typedef {import(\"../shared/types\").SuppressedLintMessage} SuppressedLintMessage */\r\n/** @typedef {import(\"../shared/types\").Plugin} Plugin */\r\n/** @typedef {import(\"../shared/types\").Rule} Rule */\r\n\r\n/**\r\n * The main formatter object.\r\n * @typedef Formatter\r\n * @property {function(LintResult[]): string | Promise<string>} format format function.\r\n */\r\n\r\n/**\r\n * The options with which to configure the ESLint instance.\r\n * @typedef {Object} ESLintOptions\r\n * @property {boolean} [allowInlineConfig] Enable or disable inline configuration comments.\r\n * @property {ConfigData} [baseConfig] Base config object, extended by all configs used with this instance\r\n * @property {boolean} [cache] Enable result caching.\r\n * @property {string} [cacheLocation] The cache file to use instead of .eslintcache.\r\n * @property {\"metadata\" | \"content\"} [cacheStrategy] The strategy used to detect changed files.\r\n * @property {string} [cwd] The value to use for the current working directory.\r\n * @property {boolean} [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.\r\n * @property {string[]} [extensions] An array of file extensions to check.\r\n * @property {boolean|Function} [fix] Execute in autofix mode. If a function, should return a boolean.\r\n * @property {string[]} [fixTypes] Array of rule types to apply fixes for.\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} [ignore] False disables use of .eslintignore.\r\n * @property {string} [ignorePath] The ignore file to use instead of .eslintignore.\r\n * @property {ConfigData} [overrideConfig] Override config object, overrides all configs used with this instance\r\n * @property {string} [overrideConfigFile] The configuration file to use.\r\n * @property {Record<string,Plugin>|null} [plugins] Preloaded plugins. This is a map-like object, keys are plugin IDs and each value is implementation.\r\n * @property {\"error\" | \"warn\" | \"off\"} [reportUnusedDisableDirectives] the severity to report unused eslint-disable directives.\r\n * @property {string} [resolvePluginsRelativeTo] The folder where plugins should be resolved from, defaulting to the CWD.\r\n * @property {string[]} [rulePaths] An array of directories to load custom rules from.\r\n * @property {boolean} [useEslintrc] False disables looking for .eslintrc.* files.\r\n */\r\n\r\n/**\r\n * A rules metadata object.\r\n * @typedef {Object} RulesMeta\r\n * @property {string} id The plugin ID.\r\n * @property {Object} definition The plugin definition.\r\n */\r\n\r\n/**\r\n * A linting result.\r\n * @typedef {Object} LintResult\r\n * @property {string} filePath The path to the file that was linted.\r\n * @property {LintMessage[]} messages All of the messages for the result.\r\n * @property {SuppressedLintMessage[]} suppressedMessages All of the suppressed messages for the result.\r\n * @property {number} errorCount Number of errors for the result.\r\n * @property {number} fatalErrorCount Number of fatal errors for the result.\r\n * @property {number} warningCount Number of warnings for the result.\r\n * @property {number} fixableErrorCount Number of fixable errors for the result.\r\n * @property {number} fixableWarningCount Number of fixable warnings for the result.\r\n * @property {string} [source] The source code of the file that was linted.\r\n * @property {string} [output] The source code of the file that was linted, with as many fixes applied as possible.\r\n * @property {DeprecatedRuleInfo[]} usedDeprecatedRules The list of used deprecated rules.\r\n */\r\n\r\n/**\r\n * Private members for the `ESLint` instance.\r\n * @typedef {Object} ESLintPrivateMembers\r\n * @property {CLIEngine} cliEngine The wrapped CLIEngine instance.\r\n * @property {ESLintOptions} options The options used to instantiate the ESLint instance.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst writeFile = promisify(fs.writeFile);\r\n\r\n/**\r\n * The map with which to store private class members.\r\n * @type {WeakMap<ESLint, ESLintPrivateMembers>}\r\n */\r\nconst privateMembersMap = new WeakMap();\r\n\r\n/**\r\n * Check if a given value is a non-empty string or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is a non-empty string.\r\n */\r\nfunction isNonEmptyString(x) {\r\n    return typeof x === \"string\" && x.trim() !== \"\";\r\n}\r\n\r\n/**\r\n * Check if a given value is an array of non-empty stringss or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is an array of non-empty stringss.\r\n */\r\nfunction isArrayOfNonEmptyString(x) {\r\n    return Array.isArray(x) && x.every(isNonEmptyString);\r\n}\r\n\r\n/**\r\n * Check if a given value is a valid fix type or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is valid fix type.\r\n */\r\nfunction isFixType(x) {\r\n    return x === \"directive\" || x === \"problem\" || x === \"suggestion\" || x === \"layout\";\r\n}\r\n\r\n/**\r\n * Check if a given value is an array of fix types or not.\r\n * @param {any} x The value to check.\r\n * @returns {boolean} `true` if `x` is an array of fix types.\r\n */\r\nfunction isFixTypeArray(x) {\r\n    return Array.isArray(x) && x.every(isFixType);\r\n}\r\n\r\n/**\r\n * The error for invalid options.\r\n */\r\nclass ESLintInvalidOptionsError extends Error {\r\n    constructor(messages) {\r\n        super(`Invalid Options:\\n- ${messages.join(\"\\n- \")}`);\r\n        this.code = \"ESLINT_INVALID_OPTIONS\";\r\n        Error.captureStackTrace(this, ESLintInvalidOptionsError);\r\n    }\r\n}\r\n\r\n/**\r\n * Validates and normalizes options for the wrapped CLIEngine instance.\r\n * @param {ESLintOptions} options The options to process.\r\n * @throws {ESLintInvalidOptionsError} If of any of a variety of type errors.\r\n * @returns {ESLintOptions} The normalized options.\r\n */\r\nfunction processOptions({\r\n    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.\r\n    baseConfig = null,\r\n    cache = false,\r\n    cacheLocation = \".eslintcache\",\r\n    cacheStrategy = \"metadata\",\r\n    cwd = process.cwd(),\r\n    errorOnUnmatchedPattern = true,\r\n    extensions = null, // ← should be null by default because if it's an array then it suppresses RFC20 feature.\r\n    fix = false,\r\n    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.\r\n    globInputPaths = true,\r\n    ignore = true,\r\n    ignorePath = null, // ← should be null by default because if it's a string then it may throw ENOENT.\r\n    overrideConfig = null,\r\n    overrideConfigFile = null,\r\n    plugins = {},\r\n    reportUnusedDisableDirectives = null, // ← should be null by default because if it's a string then it overrides the 'reportUnusedDisableDirectives' setting in config files. And we cannot use `overrideConfig.reportUnusedDisableDirectives` instead because we cannot configure the `error` severity with that.\r\n    resolvePluginsRelativeTo = null, // ← should be null by default because if it's a string then it suppresses RFC47 feature.\r\n    rulePaths = [],\r\n    useEslintrc = true,\r\n    ...unknownOptions\r\n}) {\r\n    const errors = [];\r\n    const unknownOptionKeys = Object.keys(unknownOptions);\r\n\r\n    if (unknownOptionKeys.length >= 1) {\r\n        errors.push(`Unknown options: ${unknownOptionKeys.join(\", \")}`);\r\n        if (unknownOptionKeys.includes(\"cacheFile\")) {\r\n            errors.push(\"'cacheFile' has been removed. Please use the 'cacheLocation' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"configFile\")) {\r\n            errors.push(\"'configFile' has been removed. Please use the 'overrideConfigFile' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"envs\")) {\r\n            errors.push(\"'envs' has been removed. Please use the 'overrideConfig.env' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"globals\")) {\r\n            errors.push(\"'globals' has been removed. Please use the 'overrideConfig.globals' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"ignorePattern\")) {\r\n            errors.push(\"'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"parser\")) {\r\n            errors.push(\"'parser' has been removed. Please use the 'overrideConfig.parser' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"parserOptions\")) {\r\n            errors.push(\"'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.\");\r\n        }\r\n        if (unknownOptionKeys.includes(\"rules\")) {\r\n            errors.push(\"'rules' has been removed. Please use the 'overrideConfig.rules' option instead.\");\r\n        }\r\n    }\r\n    if (typeof allowInlineConfig !== \"boolean\") {\r\n        errors.push(\"'allowInlineConfig' must be a boolean.\");\r\n    }\r\n    if (typeof baseConfig !== \"object\") {\r\n        errors.push(\"'baseConfig' must be an object or null.\");\r\n    }\r\n    if (typeof cache !== \"boolean\") {\r\n        errors.push(\"'cache' must be a boolean.\");\r\n    }\r\n    if (!isNonEmptyString(cacheLocation)) {\r\n        errors.push(\"'cacheLocation' must be a non-empty string.\");\r\n    }\r\n    if (\r\n        cacheStrategy !== \"metadata\" &&\r\n        cacheStrategy !== \"content\"\r\n    ) {\r\n        errors.push(\"'cacheStrategy' must be any of \\\"metadata\\\", \\\"content\\\".\");\r\n    }\r\n    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {\r\n        errors.push(\"'cwd' must be an absolute path.\");\r\n    }\r\n    if (typeof errorOnUnmatchedPattern !== \"boolean\") {\r\n        errors.push(\"'errorOnUnmatchedPattern' must be a boolean.\");\r\n    }\r\n    if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {\r\n        errors.push(\"'extensions' must be an array of non-empty strings or null.\");\r\n    }\r\n    if (typeof fix !== \"boolean\" && typeof fix !== \"function\") {\r\n        errors.push(\"'fix' must be a boolean or a function.\");\r\n    }\r\n    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {\r\n        errors.push(\"'fixTypes' must be an array of any of \\\"directive\\\", \\\"problem\\\", \\\"suggestion\\\", and \\\"layout\\\".\");\r\n    }\r\n    if (typeof globInputPaths !== \"boolean\") {\r\n        errors.push(\"'globInputPaths' must be a boolean.\");\r\n    }\r\n    if (typeof ignore !== \"boolean\") {\r\n        errors.push(\"'ignore' must be a boolean.\");\r\n    }\r\n    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {\r\n        errors.push(\"'ignorePath' must be a non-empty string or null.\");\r\n    }\r\n    if (typeof overrideConfig !== \"object\") {\r\n        errors.push(\"'overrideConfig' must be an object or null.\");\r\n    }\r\n    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {\r\n        errors.push(\"'overrideConfigFile' must be a non-empty string or null.\");\r\n    }\r\n    if (typeof plugins !== \"object\") {\r\n        errors.push(\"'plugins' must be an object or null.\");\r\n    } else if (plugins !== null && Object.keys(plugins).includes(\"\")) {\r\n        errors.push(\"'plugins' must not include an empty string.\");\r\n    }\r\n    if (Array.isArray(plugins)) {\r\n        errors.push(\"'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.\");\r\n    }\r\n    if (\r\n        reportUnusedDisableDirectives !== \"error\" &&\r\n        reportUnusedDisableDirectives !== \"warn\" &&\r\n        reportUnusedDisableDirectives !== \"off\" &&\r\n        reportUnusedDisableDirectives !== null\r\n    ) {\r\n        errors.push(\"'reportUnusedDisableDirectives' must be any of \\\"error\\\", \\\"warn\\\", \\\"off\\\", and null.\");\r\n    }\r\n    if (\r\n        !isNonEmptyString(resolvePluginsRelativeTo) &&\r\n        resolvePluginsRelativeTo !== null\r\n    ) {\r\n        errors.push(\"'resolvePluginsRelativeTo' must be a non-empty string or null.\");\r\n    }\r\n    if (!isArrayOfNonEmptyString(rulePaths)) {\r\n        errors.push(\"'rulePaths' must be an array of non-empty strings.\");\r\n    }\r\n    if (typeof useEslintrc !== \"boolean\") {\r\n        errors.push(\"'useEslintrc' must be a boolean.\");\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n        throw new ESLintInvalidOptionsError(errors);\r\n    }\r\n\r\n    return {\r\n        allowInlineConfig,\r\n        baseConfig,\r\n        cache,\r\n        cacheLocation,\r\n        cacheStrategy,\r\n        configFile: overrideConfigFile,\r\n        cwd,\r\n        errorOnUnmatchedPattern,\r\n        extensions,\r\n        fix,\r\n        fixTypes,\r\n        globInputPaths,\r\n        ignore,\r\n        ignorePath,\r\n        reportUnusedDisableDirectives,\r\n        resolvePluginsRelativeTo,\r\n        rulePaths,\r\n        useEslintrc\r\n    };\r\n}\r\n\r\n/**\r\n * Check if a value has one or more properties and that value is not undefined.\r\n * @param {any} obj The value to check.\r\n * @returns {boolean} `true` if `obj` has one or more properties that that value is not undefined.\r\n */\r\nfunction hasDefinedProperty(obj) {\r\n    if (typeof obj === \"object\" && obj !== null) {\r\n        for (const key in obj) {\r\n            if (typeof obj[key] !== \"undefined\") {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create rulesMeta object.\r\n * @param {Map<string,Rule>} rules a map of rules from which to generate the object.\r\n * @returns {Object} metadata for all enabled rules.\r\n */\r\nfunction createRulesMeta(rules) {\r\n    return Array.from(rules).reduce((retVal, [id, rule]) => {\r\n        retVal[id] = rule.meta;\r\n        return retVal;\r\n    }, {});\r\n}\r\n\r\n/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>} */\r\nconst usedDeprecatedRulesCache = new WeakMap();\r\n\r\n/**\r\n * Create used deprecated rule list.\r\n * @param {CLIEngine} cliEngine The CLIEngine instance.\r\n * @param {string} maybeFilePath The absolute path to a lint target file or `\"<text>\"`.\r\n * @returns {DeprecatedRuleInfo[]} The used deprecated rule list.\r\n */\r\nfunction getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {\r\n    const {\r\n        configArrayFactory,\r\n        options: { cwd }\r\n    } = getCLIEngineInternalSlots(cliEngine);\r\n    const filePath = path.isAbsolute(maybeFilePath)\r\n        ? maybeFilePath\r\n        : path.join(cwd, \"__placeholder__.js\");\r\n    const configArray = configArrayFactory.getConfigArrayForFile(filePath);\r\n    const config = configArray.extractConfig(filePath);\r\n\r\n    // Most files use the same config, so cache it.\r\n    if (!usedDeprecatedRulesCache.has(config)) {\r\n        const pluginRules = configArray.pluginRules;\r\n        const retv = [];\r\n\r\n        for (const [ruleId, ruleConf] of Object.entries(config.rules)) {\r\n            if (getRuleSeverity(ruleConf) === 0) {\r\n                continue;\r\n            }\r\n            const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);\r\n            const meta = rule && rule.meta;\r\n\r\n            if (meta && meta.deprecated) {\r\n                retv.push({ ruleId, replacedBy: meta.replacedBy || [] });\r\n            }\r\n        }\r\n\r\n        usedDeprecatedRulesCache.set(config, Object.freeze(retv));\r\n    }\r\n\r\n    return usedDeprecatedRulesCache.get(config);\r\n}\r\n\r\n/**\r\n * Processes the linting results generated by a CLIEngine linting report to\r\n * match the ESLint class's API.\r\n * @param {CLIEngine} cliEngine The CLIEngine instance.\r\n * @param {CLIEngineLintReport} report The CLIEngine linting report to process.\r\n * @returns {LintResult[]} The processed linting results.\r\n */\r\nfunction processCLIEngineLintReport(cliEngine, { results }) {\r\n    const descriptor = {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get() {\r\n            return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);\r\n        }\r\n    };\r\n\r\n    for (const result of results) {\r\n        Object.defineProperty(result, \"usedDeprecatedRules\", descriptor);\r\n    }\r\n\r\n    return results;\r\n}\r\n\r\n/**\r\n * An Array.prototype.sort() compatible compare function to order results by their file path.\r\n * @param {LintResult} a The first lint result.\r\n * @param {LintResult} b The second lint result.\r\n * @returns {number} An integer representing the order in which the two results should occur.\r\n */\r\nfunction compareResultsByFilePath(a, b) {\r\n    if (a.filePath < b.filePath) {\r\n        return -1;\r\n    }\r\n\r\n    if (a.filePath > b.filePath) {\r\n        return 1;\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Main API.\r\n */\r\nclass ESLint {\r\n\r\n    /**\r\n     * Creates a new instance of the main ESLint API.\r\n     * @param {ESLintOptions} options The options for this instance.\r\n     */\r\n    constructor(options = {}) {\r\n        const processedOptions = processOptions(options);\r\n        const cliEngine = new CLIEngine(processedOptions, { preloadedPlugins: options.plugins });\r\n        const {\r\n            configArrayFactory,\r\n            lastConfigArrays\r\n        } = getCLIEngineInternalSlots(cliEngine);\r\n        let updated = false;\r\n\r\n        /*\r\n         * Address `overrideConfig` to set override config.\r\n         * Operate the `configArrayFactory` internal slot directly because this\r\n         * functionality doesn't exist as the public API of CLIEngine.\r\n         */\r\n        if (hasDefinedProperty(options.overrideConfig)) {\r\n            configArrayFactory.setOverrideConfig(options.overrideConfig);\r\n            updated = true;\r\n        }\r\n\r\n        // Update caches.\r\n        if (updated) {\r\n            configArrayFactory.clearCache();\r\n            lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();\r\n        }\r\n\r\n        // Initialize private properties.\r\n        privateMembersMap.set(this, {\r\n            cliEngine,\r\n            options: processedOptions\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The version text.\r\n     * @type {string}\r\n     */\r\n    static get version() {\r\n        return version;\r\n    }\r\n\r\n    /**\r\n     * Outputs fixes from the given results to files.\r\n     * @param {LintResult[]} results The lint results.\r\n     * @returns {Promise<void>} Returns a promise that is used to track side effects.\r\n     */\r\n    static async outputFixes(results) {\r\n        if (!Array.isArray(results)) {\r\n            throw new Error(\"'results' must be an array\");\r\n        }\r\n\r\n        await Promise.all(\r\n            results\r\n                .filter(result => {\r\n                    if (typeof result !== \"object\" || result === null) {\r\n                        throw new Error(\"'results' must include only objects\");\r\n                    }\r\n                    return (\r\n                        typeof result.output === \"string\" &&\r\n                        path.isAbsolute(result.filePath)\r\n                    );\r\n                })\r\n                .map(r => writeFile(r.filePath, r.output))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns results that only contains errors.\r\n     * @param {LintResult[]} results The results to filter.\r\n     * @returns {LintResult[]} The filtered results.\r\n     */\r\n    static getErrorResults(results) {\r\n        return CLIEngine.getErrorResults(results);\r\n    }\r\n\r\n    /**\r\n     * Returns meta objects for each rule represented in the lint results.\r\n     * @param {LintResult[]} results The results to fetch rules meta for.\r\n     * @returns {Object} A mapping of ruleIds to rule meta objects.\r\n     */\r\n    getRulesMetaForResults(results) {\r\n\r\n        const resultRuleIds = new Set();\r\n\r\n        // first gather all ruleIds from all results\r\n\r\n        for (const result of results) {\r\n            for (const { ruleId } of result.messages) {\r\n                resultRuleIds.add(ruleId);\r\n            }\r\n            for (const { ruleId } of result.suppressedMessages) {\r\n                resultRuleIds.add(ruleId);\r\n            }\r\n        }\r\n\r\n        // create a map of all rules in the results\r\n\r\n        const { cliEngine } = privateMembersMap.get(this);\r\n        const rules = cliEngine.getRules();\r\n        const resultRules = new Map();\r\n\r\n        for (const [ruleId, rule] of rules) {\r\n            if (resultRuleIds.has(ruleId)) {\r\n                resultRules.set(ruleId, rule);\r\n            }\r\n        }\r\n\r\n        return createRulesMeta(resultRules);\r\n\r\n    }\r\n\r\n    /**\r\n     * Executes the current configuration on an array of file and directory names.\r\n     * @param {string[]} patterns An array of file and directory names.\r\n     * @returns {Promise<LintResult[]>} The results of linting the file patterns given.\r\n     */\r\n    async lintFiles(patterns) {\r\n        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {\r\n            throw new Error(\"'patterns' must be a non-empty string or an array of non-empty strings\");\r\n        }\r\n        const { cliEngine } = privateMembersMap.get(this);\r\n\r\n        return processCLIEngineLintReport(\r\n            cliEngine,\r\n            cliEngine.executeOnFiles(patterns)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Executes the current configuration on text.\r\n     * @param {string} code A string of JavaScript code to lint.\r\n     * @param {Object} [options] The options.\r\n     * @param {string} [options.filePath] The path to the file of the source code.\r\n     * @param {boolean} [options.warnIgnored] When set to true, warn if given filePath is an ignored path.\r\n     * @returns {Promise<LintResult[]>} The results of linting the string of code given.\r\n     */\r\n    async lintText(code, options = {}) {\r\n        if (typeof code !== \"string\") {\r\n            throw new Error(\"'code' must be a string\");\r\n        }\r\n        if (typeof options !== \"object\") {\r\n            throw new Error(\"'options' must be an object, null, or undefined\");\r\n        }\r\n        const {\r\n            filePath,\r\n            warnIgnored = false,\r\n            ...unknownOptions\r\n        } = options || {};\r\n\r\n        const unknownOptionKeys = Object.keys(unknownOptions);\r\n\r\n        if (unknownOptionKeys.length > 0) {\r\n            throw new Error(`'options' must not include the unknown option(s): ${unknownOptionKeys.join(\", \")}`);\r\n        }\r\n\r\n        if (filePath !== void 0 && !isNonEmptyString(filePath)) {\r\n            throw new Error(\"'options.filePath' must be a non-empty string or undefined\");\r\n        }\r\n        if (typeof warnIgnored !== \"boolean\") {\r\n            throw new Error(\"'options.warnIgnored' must be a boolean or undefined\");\r\n        }\r\n\r\n        const { cliEngine } = privateMembersMap.get(this);\r\n\r\n        return processCLIEngineLintReport(\r\n            cliEngine,\r\n            cliEngine.executeOnText(code, filePath, warnIgnored)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns the formatter representing the given formatter name.\r\n     * @param {string} [name] The name of the formatter to load.\r\n     * The following values are allowed:\r\n     * - `undefined` ... Load `stylish` builtin formatter.\r\n     * - A builtin formatter name ... Load the builtin formatter.\r\n     * - A thirdparty formatter name:\r\n     *   - `foo` → `eslint-formatter-foo`\r\n     *   - `@foo` → `@foo/eslint-formatter`\r\n     *   - `@foo/bar` → `@foo/eslint-formatter-bar`\r\n     * - A file path ... Load the file.\r\n     * @returns {Promise<Formatter>} A promise resolving to the formatter object.\r\n     * This promise will be rejected if the given formatter was not found or not\r\n     * a function.\r\n     */\r\n    async loadFormatter(name = \"stylish\") {\r\n        if (typeof name !== \"string\") {\r\n            throw new Error(\"'name' must be a string\");\r\n        }\r\n\r\n        const { cliEngine, options } = privateMembersMap.get(this);\r\n        const formatter = cliEngine.getFormatter(name);\r\n\r\n        if (typeof formatter !== \"function\") {\r\n            throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);\r\n        }\r\n\r\n        return {\r\n\r\n            /**\r\n             * The main formatter method.\r\n             * @param {LintResults[]} results The lint results to format.\r\n             * @returns {string | Promise<string>} The formatted lint results.\r\n             */\r\n            format(results) {\r\n                let rulesMeta = null;\r\n\r\n                results.sort(compareResultsByFilePath);\r\n\r\n                return formatter(results, {\r\n                    get cwd() {\r\n                        return options.cwd;\r\n                    },\r\n                    get rulesMeta() {\r\n                        if (!rulesMeta) {\r\n                            rulesMeta = createRulesMeta(cliEngine.getRules());\r\n                        }\r\n\r\n                        return rulesMeta;\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a configuration object for the given file based on the CLI options.\r\n     * This is the same logic used by the ESLint CLI executable to determine\r\n     * configuration for each file it processes.\r\n     * @param {string} filePath The path of the file to retrieve a config object for.\r\n     * @returns {Promise<ConfigData>} A configuration object for the file.\r\n     */\r\n    async calculateConfigForFile(filePath) {\r\n        if (!isNonEmptyString(filePath)) {\r\n            throw new Error(\"'filePath' must be a non-empty string\");\r\n        }\r\n        const { cliEngine } = privateMembersMap.get(this);\r\n\r\n        return cliEngine.getConfigForFile(filePath);\r\n    }\r\n\r\n    /**\r\n     * Checks if a given path is ignored by ESLint.\r\n     * @param {string} filePath The path of the file to check.\r\n     * @returns {Promise<boolean>} Whether or not the given path is ignored.\r\n     */\r\n    async isPathIgnored(filePath) {\r\n        if (!isNonEmptyString(filePath)) {\r\n            throw new Error(\"'filePath' must be a non-empty string\");\r\n        }\r\n        const { cliEngine } = privateMembersMap.get(this);\r\n\r\n        return cliEngine.isPathIgnored(filePath);\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nmodule.exports = {\r\n    ESLint,\r\n\r\n    /**\r\n     * Get the private class members of a given ESLint instance for tests.\r\n     * @param {ESLint} instance The ESLint instance to get.\r\n     * @returns {ESLintPrivateMembers} The instance's private class members.\r\n     */\r\n    getESLintPrivateMembers(instance) {\r\n        return privateMembersMap.get(instance);\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}