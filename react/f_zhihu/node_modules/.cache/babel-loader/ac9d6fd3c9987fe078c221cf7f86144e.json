{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow mixed binary operators.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils.js\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\nconst TERNARY_OPERATOR = [\"?:\"];\nconst COALESCE_OPERATOR = [\"??\"];\nconst ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);\nconst DEFAULT_GROUPS = [ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS];\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\n/**\r\n * Normalizes options.\r\n * @param {Object|undefined} options A options object to normalize.\r\n * @returns {Object} Normalized option object.\r\n */\n\nfunction normalizeOptions() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hasGroups = options.groups && options.groups.length > 0;\n  const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\n  const allowSamePrecedence = options.allowSamePrecedence !== false;\n  return {\n    groups,\n    allowSamePrecedence\n  };\n}\n/**\r\n * Checks whether any group which includes both given operator exists or not.\r\n * @param {Array<string[]>} groups A list of groups to check.\r\n * @param {string} left An operator.\r\n * @param {string} right Another operator.\r\n * @returns {boolean} `true` if such group existed.\r\n */\n\n\nfunction includesBothInAGroup(groups, left, right) {\n  return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\n}\n/**\r\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\r\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\r\n * This parent node can be BinaryExpression, LogicalExpression\r\n *      , or a ConditionalExpression node\r\n * @returns {ASTNode} node the appropriate node(left or test).\r\n */\n\n\nfunction getChildNode(node) {\n  return node.type === \"ConditionalExpression\" ? node.test : node.left;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow mixed binary operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-mixed-operators\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        groups: {\n          type: \"array\",\n          items: {\n            type: \"array\",\n            items: {\n              enum: ALL_OPERATORS\n            },\n            minItems: 2,\n            uniqueItems: true\n          },\n          uniqueItems: true\n        },\n        allowSamePrecedence: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const options = normalizeOptions(context.options[0]);\n    /**\r\n     * Checks whether a given node should be ignored by options or not.\r\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n     *      node or a LogicalExpression node. This parent node is one of\r\n     *      them, too.\r\n     * @returns {boolean} `true` if the node should be ignored.\r\n     */\n\n    function shouldIgnore(node) {\n      const a = node;\n      const b = node.parent;\n      return !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);\n    }\n    /**\r\n     * Checks whether the operator of a given node is mixed with parent\r\n     * node's operator or not.\r\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n     *      node or a LogicalExpression node. This parent node is one of\r\n     *      them, too.\r\n     * @returns {boolean} `true` if the node was mixed.\r\n     */\n\n\n    function isMixedWithParent(node) {\n      return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);\n    }\n    /**\r\n     * Gets the operator token of a given node.\r\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n     *      node or a LogicalExpression node.\r\n     * @returns {Token} The operator token of the node.\r\n     */\n\n\n    function getOperatorToken(node) {\n      return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\n    }\n    /**\r\n     * Reports both the operator of a given node and the operator of the\r\n     * parent node.\r\n     * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n     *      node or a LogicalExpression node. This parent node is one of\r\n     *      them, too.\r\n     * @returns {void}\r\n     */\n\n\n    function reportBothOperators(node) {\n      const parent = node.parent;\n      const left = getChildNode(parent) === node ? node : parent;\n      const right = getChildNode(parent) !== node ? node : parent;\n      const data = {\n        leftOperator: left.operator || \"?:\",\n        rightOperator: right.operator || \"?:\"\n      };\n      context.report({\n        node: left,\n        loc: getOperatorToken(left).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n      context.report({\n        node: right,\n        loc: getOperatorToken(right).loc,\n        messageId: \"unexpectedMixedOperator\",\n        data\n      });\n    }\n    /**\r\n     * Checks between the operator of this node and the operator of the\r\n     * parent node.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function check(node) {\n      if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {\n        reportBothOperators(node);\n      }\n    }\n\n    return {\n      BinaryExpression: check,\n      LogicalExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-mixed-operators.js"],"names":["astUtils","require","ARITHMETIC_OPERATORS","BITWISE_OPERATORS","COMPARISON_OPERATORS","LOGICAL_OPERATORS","RELATIONAL_OPERATORS","TERNARY_OPERATOR","COALESCE_OPERATOR","ALL_OPERATORS","concat","DEFAULT_GROUPS","TARGET_NODE_TYPE","normalizeOptions","options","hasGroups","groups","length","allowSamePrecedence","includesBothInAGroup","left","right","some","group","indexOf","getChildNode","node","type","test","module","exports","meta","docs","description","recommended","url","schema","properties","items","enum","minItems","uniqueItems","default","additionalProperties","messages","unexpectedMixedOperator","create","context","sourceCode","getSourceCode","shouldIgnore","a","b","parent","operator","getPrecedence","isMixedWithParent","isParenthesised","getOperatorToken","getTokenAfter","isNotClosingParenToken","reportBothOperators","data","leftOperator","rightOperator","report","loc","messageId","check","BinaryExpression","LogicalExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow mixed binary operators.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils.js\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst ARITHMETIC_OPERATORS = [\"+\", \"-\", \"*\", \"/\", \"%\", \"**\"];\r\nconst BITWISE_OPERATORS = [\"&\", \"|\", \"^\", \"~\", \"<<\", \">>\", \">>>\"];\r\nconst COMPARISON_OPERATORS = [\"==\", \"!=\", \"===\", \"!==\", \">\", \">=\", \"<\", \"<=\"];\r\nconst LOGICAL_OPERATORS = [\"&&\", \"||\"];\r\nconst RELATIONAL_OPERATORS = [\"in\", \"instanceof\"];\r\nconst TERNARY_OPERATOR = [\"?:\"];\r\nconst COALESCE_OPERATOR = [\"??\"];\r\nconst ALL_OPERATORS = [].concat(\r\n    ARITHMETIC_OPERATORS,\r\n    BITWISE_OPERATORS,\r\n    COMPARISON_OPERATORS,\r\n    LOGICAL_OPERATORS,\r\n    RELATIONAL_OPERATORS,\r\n    TERNARY_OPERATOR,\r\n    COALESCE_OPERATOR\r\n);\r\nconst DEFAULT_GROUPS = [\r\n    ARITHMETIC_OPERATORS,\r\n    BITWISE_OPERATORS,\r\n    COMPARISON_OPERATORS,\r\n    LOGICAL_OPERATORS,\r\n    RELATIONAL_OPERATORS\r\n];\r\nconst TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;\r\n\r\n/**\r\n * Normalizes options.\r\n * @param {Object|undefined} options A options object to normalize.\r\n * @returns {Object} Normalized option object.\r\n */\r\nfunction normalizeOptions(options = {}) {\r\n    const hasGroups = options.groups && options.groups.length > 0;\r\n    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;\r\n    const allowSamePrecedence = options.allowSamePrecedence !== false;\r\n\r\n    return {\r\n        groups,\r\n        allowSamePrecedence\r\n    };\r\n}\r\n\r\n/**\r\n * Checks whether any group which includes both given operator exists or not.\r\n * @param {Array<string[]>} groups A list of groups to check.\r\n * @param {string} left An operator.\r\n * @param {string} right Another operator.\r\n * @returns {boolean} `true` if such group existed.\r\n */\r\nfunction includesBothInAGroup(groups, left, right) {\r\n    return groups.some(group => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);\r\n}\r\n\r\n/**\r\n * Checks whether the given node is a conditional expression and returns the test node else the left node.\r\n * @param {ASTNode} node A node which can be a BinaryExpression or a LogicalExpression node.\r\n * This parent node can be BinaryExpression, LogicalExpression\r\n *      , or a ConditionalExpression node\r\n * @returns {ASTNode} node the appropriate node(left or test).\r\n */\r\nfunction getChildNode(node) {\r\n    return node.type === \"ConditionalExpression\" ? node.test : node.left;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow mixed binary operators\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-mixed-operators\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    groups: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"array\",\r\n                            items: { enum: ALL_OPERATORS },\r\n                            minItems: 2,\r\n                            uniqueItems: true\r\n                        },\r\n                        uniqueItems: true\r\n                    },\r\n                    allowSamePrecedence: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedMixedOperator: \"Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const options = normalizeOptions(context.options[0]);\r\n\r\n        /**\r\n         * Checks whether a given node should be ignored by options or not.\r\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n         *      node or a LogicalExpression node. This parent node is one of\r\n         *      them, too.\r\n         * @returns {boolean} `true` if the node should be ignored.\r\n         */\r\n        function shouldIgnore(node) {\r\n            const a = node;\r\n            const b = node.parent;\r\n\r\n            return (\r\n                !includesBothInAGroup(options.groups, a.operator, b.type === \"ConditionalExpression\" ? \"?:\" : b.operator) ||\r\n                (\r\n                    options.allowSamePrecedence &&\r\n                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)\r\n                )\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks whether the operator of a given node is mixed with parent\r\n         * node's operator or not.\r\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n         *      node or a LogicalExpression node. This parent node is one of\r\n         *      them, too.\r\n         * @returns {boolean} `true` if the node was mixed.\r\n         */\r\n        function isMixedWithParent(node) {\r\n\r\n            return (\r\n                node.operator !== node.parent.operator &&\r\n                !astUtils.isParenthesised(sourceCode, node)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Gets the operator token of a given node.\r\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n         *      node or a LogicalExpression node.\r\n         * @returns {Token} The operator token of the node.\r\n         */\r\n        function getOperatorToken(node) {\r\n            return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);\r\n        }\r\n\r\n        /**\r\n         * Reports both the operator of a given node and the operator of the\r\n         * parent node.\r\n         * @param {ASTNode} node A node to check. This is a BinaryExpression\r\n         *      node or a LogicalExpression node. This parent node is one of\r\n         *      them, too.\r\n         * @returns {void}\r\n         */\r\n        function reportBothOperators(node) {\r\n            const parent = node.parent;\r\n            const left = (getChildNode(parent) === node) ? node : parent;\r\n            const right = (getChildNode(parent) !== node) ? node : parent;\r\n            const data = {\r\n                leftOperator: left.operator || \"?:\",\r\n                rightOperator: right.operator || \"?:\"\r\n            };\r\n\r\n            context.report({\r\n                node: left,\r\n                loc: getOperatorToken(left).loc,\r\n                messageId: \"unexpectedMixedOperator\",\r\n                data\r\n            });\r\n            context.report({\r\n                node: right,\r\n                loc: getOperatorToken(right).loc,\r\n                messageId: \"unexpectedMixedOperator\",\r\n                data\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks between the operator of this node and the operator of the\r\n         * parent node.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {void}\r\n         */\r\n        function check(node) {\r\n            if (\r\n                TARGET_NODE_TYPE.test(node.parent.type) &&\r\n                isMixedWithParent(node) &&\r\n                !shouldIgnore(node)\r\n            ) {\r\n                reportBothOperators(node);\r\n            }\r\n        }\r\n\r\n        return {\r\n            BinaryExpression: check,\r\n            LogicalExpression: check\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}