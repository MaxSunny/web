{"ast":null,"code":"/**\r\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given node is a constructor.\r\n * @param {ASTNode} node A node to check. This node type is one of\r\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\r\n *   `ArrowFunctionExpression`.\r\n * @returns {boolean} `true` if the node is a constructor.\r\n */\n\n\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow `this`/`super` before calling `super()` in constructors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-this-before-super\"\n    },\n    schema: [],\n    messages: {\n      noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\n    }\n  },\n\n  create(context) {\n    /*\r\n     * Information for each constructor.\r\n     * - upper:      Information of the upper constructor.\r\n     * - hasExtends: A flag which shows whether the owner class has a valid\r\n     *   `extends` part.\r\n     * - scope:      The scope of the owner class.\r\n     * - codePath:   The code path of this constructor.\r\n     */\n    let funcInfo = null;\n    /*\r\n     * Information for each code path segment.\r\n     * Each key is the id of a code path segment.\r\n     * Each value is an object:\r\n     * - superCalled:  The flag which shows `super()` called in all code paths.\r\n     * - invalidNodes: The array of invalid ThisExpression and Super nodes.\r\n     */\n\n    let segInfoMap = Object.create(null);\n    /**\r\n     * Gets whether or not `super()` is called in a given code path segment.\r\n     * @param {CodePathSegment} segment A code path segment to get.\r\n     * @returns {boolean} `true` if `super()` is called.\r\n     */\n\n    function isCalled(segment) {\n      return !segment.reachable || segInfoMap[segment.id].superCalled;\n    }\n    /**\r\n     * Checks whether or not this is in a constructor.\r\n     * @returns {boolean} `true` if this is in a constructor.\r\n     */\n\n\n    function isInConstructorOfDerivedClass() {\n      return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n    }\n    /**\r\n     * Checks whether or not this is before `super()` is called.\r\n     * @returns {boolean} `true` if this is before `super()` is called.\r\n     */\n\n\n    function isBeforeCallOfSuper() {\n      return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);\n    }\n    /**\r\n     * Sets a given node as invalid.\r\n     * @param {ASTNode} node A node to set as invalid. This is one of\r\n     *      a ThisExpression and a Super.\r\n     * @returns {void}\r\n     */\n\n\n    function setInvalid(node) {\n      const segments = funcInfo.codePath.currentSegments;\n\n      for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        if (segment.reachable) {\n          segInfoMap[segment.id].invalidNodes.push(node);\n        }\n      }\n    }\n    /**\r\n     * Sets the current segment as `super` was called.\r\n     * @returns {void}\r\n     */\n\n\n    function setSuperCalled() {\n      const segments = funcInfo.codePath.currentSegments;\n\n      for (let i = 0; i < segments.length; ++i) {\n        const segment = segments[i];\n\n        if (segment.reachable) {\n          segInfoMap[segment.id].superCalled = true;\n        }\n      }\n    }\n\n    return {\n      /**\r\n       * Adds information of a constructor into the stack.\r\n       * @param {CodePath} codePath A code path which was started.\r\n       * @param {ASTNode} node The current node.\r\n       * @returns {void}\r\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            codePath\n          };\n        }\n      },\n\n      /**\r\n       * Removes the top of stack item.\r\n       *\r\n       * And this traverses all segments of this code path then reports every\r\n       * invalid node.\r\n       * @param {CodePath} codePath A code path which was ended.\r\n       * @returns {void}\r\n       */\n      onCodePathEnd(codePath) {\n        const isDerivedClass = funcInfo.hasExtends;\n        funcInfo = funcInfo.upper;\n\n        if (!isDerivedClass) {\n          return;\n        }\n\n        codePath.traverseSegments((segment, controller) => {\n          const info = segInfoMap[segment.id];\n\n          for (let i = 0; i < info.invalidNodes.length; ++i) {\n            const invalidNode = info.invalidNodes[i];\n            context.report({\n              messageId: \"noBeforeSuper\",\n              node: invalidNode,\n              data: {\n                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n              }\n            });\n          }\n\n          if (info.superCalled) {\n            controller.skip();\n          }\n        });\n      },\n\n      /**\r\n       * Initialize information of a given code path segment.\r\n       * @param {CodePathSegment} segment A code path segment to initialize.\r\n       * @returns {void}\r\n       */\n      onCodePathSegmentStart(segment) {\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        } // Initialize info.\n\n\n        segInfoMap[segment.id] = {\n          superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),\n          invalidNodes: []\n        };\n      },\n\n      /**\r\n       * Update information of the code path segment when a code path was\r\n       * looped.\r\n       * @param {CodePathSegment} fromSegment The code path segment of the\r\n       *      end of a loop.\r\n       * @param {CodePathSegment} toSegment A code path segment of the head\r\n       *      of a loop.\r\n       * @returns {void}\r\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!isInConstructorOfDerivedClass()) {\n          return;\n        } // Update information inside of the loop.\n\n\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, (segment, controller) => {\n          const info = segInfoMap[segment.id];\n\n          if (info.superCalled) {\n            info.invalidNodes = [];\n            controller.skip();\n          } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {\n            info.superCalled = true;\n            info.invalidNodes = [];\n          }\n        });\n      },\n\n      /**\r\n       * Reports if this is before `super()`.\r\n       * @param {ASTNode} node A target node.\r\n       * @returns {void}\r\n       */\n      ThisExpression(node) {\n        if (isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n\n      /**\r\n       * Reports if this is before `super()`.\r\n       * @param {ASTNode} node A target node.\r\n       * @returns {void}\r\n       */\n      Super(node) {\n        if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n          setInvalid(node);\n        }\n      },\n\n      /**\r\n       * Marks `super()` called.\r\n       * @param {ASTNode} node A target node.\r\n       * @returns {void}\r\n       */\n      \"CallExpression:exit\"(node) {\n        if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n          setSuperCalled();\n        }\n      },\n\n      /**\r\n       * Resets state.\r\n       * @returns {void}\r\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-this-before-super.js"],"names":["astUtils","require","isConstructorFunction","node","type","parent","kind","module","exports","meta","docs","description","recommended","url","schema","messages","noBeforeSuper","create","context","funcInfo","segInfoMap","Object","isCalled","segment","reachable","id","superCalled","isInConstructorOfDerivedClass","Boolean","isConstructor","hasExtends","isBeforeCallOfSuper","codePath","currentSegments","every","setInvalid","segments","i","length","invalidNodes","push","setSuperCalled","onCodePathStart","classNode","upper","superClass","isNullOrUndefined","onCodePathEnd","isDerivedClass","traverseSegments","controller","info","invalidNode","report","messageId","data","skip","onCodePathSegmentStart","prevSegments","onCodePathSegmentLoop","fromSegment","toSegment","first","last","ThisExpression","Super","isCallee","callee"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given node is a constructor.\r\n * @param {ASTNode} node A node to check. This node type is one of\r\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\r\n *   `ArrowFunctionExpression`.\r\n * @returns {boolean} `true` if the node is a constructor.\r\n */\r\nfunction isConstructorFunction(node) {\r\n    return (\r\n        node.type === \"FunctionExpression\" &&\r\n        node.parent.type === \"MethodDefinition\" &&\r\n        node.parent.kind === \"constructor\"\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-this-before-super\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            noBeforeSuper: \"'{{kind}}' is not allowed before 'super()'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /*\r\n         * Information for each constructor.\r\n         * - upper:      Information of the upper constructor.\r\n         * - hasExtends: A flag which shows whether the owner class has a valid\r\n         *   `extends` part.\r\n         * - scope:      The scope of the owner class.\r\n         * - codePath:   The code path of this constructor.\r\n         */\r\n        let funcInfo = null;\r\n\r\n        /*\r\n         * Information for each code path segment.\r\n         * Each key is the id of a code path segment.\r\n         * Each value is an object:\r\n         * - superCalled:  The flag which shows `super()` called in all code paths.\r\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\r\n         */\r\n        let segInfoMap = Object.create(null);\r\n\r\n        /**\r\n         * Gets whether or not `super()` is called in a given code path segment.\r\n         * @param {CodePathSegment} segment A code path segment to get.\r\n         * @returns {boolean} `true` if `super()` is called.\r\n         */\r\n        function isCalled(segment) {\r\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not this is in a constructor.\r\n         * @returns {boolean} `true` if this is in a constructor.\r\n         */\r\n        function isInConstructorOfDerivedClass() {\r\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not this is before `super()` is called.\r\n         * @returns {boolean} `true` if this is before `super()` is called.\r\n         */\r\n        function isBeforeCallOfSuper() {\r\n            return (\r\n                isInConstructorOfDerivedClass() &&\r\n                !funcInfo.codePath.currentSegments.every(isCalled)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Sets a given node as invalid.\r\n         * @param {ASTNode} node A node to set as invalid. This is one of\r\n         *      a ThisExpression and a Super.\r\n         * @returns {void}\r\n         */\r\n        function setInvalid(node) {\r\n            const segments = funcInfo.codePath.currentSegments;\r\n\r\n            for (let i = 0; i < segments.length; ++i) {\r\n                const segment = segments[i];\r\n\r\n                if (segment.reachable) {\r\n                    segInfoMap[segment.id].invalidNodes.push(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Sets the current segment as `super` was called.\r\n         * @returns {void}\r\n         */\r\n        function setSuperCalled() {\r\n            const segments = funcInfo.codePath.currentSegments;\r\n\r\n            for (let i = 0; i < segments.length; ++i) {\r\n                const segment = segments[i];\r\n\r\n                if (segment.reachable) {\r\n                    segInfoMap[segment.id].superCalled = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n\r\n            /**\r\n             * Adds information of a constructor into the stack.\r\n             * @param {CodePath} codePath A code path which was started.\r\n             * @param {ASTNode} node The current node.\r\n             * @returns {void}\r\n             */\r\n            onCodePathStart(codePath, node) {\r\n                if (isConstructorFunction(node)) {\r\n\r\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\r\n                    const classNode = node.parent.parent.parent;\r\n\r\n                    funcInfo = {\r\n                        upper: funcInfo,\r\n                        isConstructor: true,\r\n                        hasExtends: Boolean(\r\n                            classNode.superClass &&\r\n                            !astUtils.isNullOrUndefined(classNode.superClass)\r\n                        ),\r\n                        codePath\r\n                    };\r\n                } else {\r\n                    funcInfo = {\r\n                        upper: funcInfo,\r\n                        isConstructor: false,\r\n                        hasExtends: false,\r\n                        codePath\r\n                    };\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Removes the top of stack item.\r\n             *\r\n             * And this traverses all segments of this code path then reports every\r\n             * invalid node.\r\n             * @param {CodePath} codePath A code path which was ended.\r\n             * @returns {void}\r\n             */\r\n            onCodePathEnd(codePath) {\r\n                const isDerivedClass = funcInfo.hasExtends;\r\n\r\n                funcInfo = funcInfo.upper;\r\n                if (!isDerivedClass) {\r\n                    return;\r\n                }\r\n\r\n                codePath.traverseSegments((segment, controller) => {\r\n                    const info = segInfoMap[segment.id];\r\n\r\n                    for (let i = 0; i < info.invalidNodes.length; ++i) {\r\n                        const invalidNode = info.invalidNodes[i];\r\n\r\n                        context.report({\r\n                            messageId: \"noBeforeSuper\",\r\n                            node: invalidNode,\r\n                            data: {\r\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    if (info.superCalled) {\r\n                        controller.skip();\r\n                    }\r\n                });\r\n            },\r\n\r\n            /**\r\n             * Initialize information of a given code path segment.\r\n             * @param {CodePathSegment} segment A code path segment to initialize.\r\n             * @returns {void}\r\n             */\r\n            onCodePathSegmentStart(segment) {\r\n                if (!isInConstructorOfDerivedClass()) {\r\n                    return;\r\n                }\r\n\r\n                // Initialize info.\r\n                segInfoMap[segment.id] = {\r\n                    superCalled: (\r\n                        segment.prevSegments.length > 0 &&\r\n                        segment.prevSegments.every(isCalled)\r\n                    ),\r\n                    invalidNodes: []\r\n                };\r\n            },\r\n\r\n            /**\r\n             * Update information of the code path segment when a code path was\r\n             * looped.\r\n             * @param {CodePathSegment} fromSegment The code path segment of the\r\n             *      end of a loop.\r\n             * @param {CodePathSegment} toSegment A code path segment of the head\r\n             *      of a loop.\r\n             * @returns {void}\r\n             */\r\n            onCodePathSegmentLoop(fromSegment, toSegment) {\r\n                if (!isInConstructorOfDerivedClass()) {\r\n                    return;\r\n                }\r\n\r\n                // Update information inside of the loop.\r\n                funcInfo.codePath.traverseSegments(\r\n                    { first: toSegment, last: fromSegment },\r\n                    (segment, controller) => {\r\n                        const info = segInfoMap[segment.id];\r\n\r\n                        if (info.superCalled) {\r\n                            info.invalidNodes = [];\r\n                            controller.skip();\r\n                        } else if (\r\n                            segment.prevSegments.length > 0 &&\r\n                            segment.prevSegments.every(isCalled)\r\n                        ) {\r\n                            info.superCalled = true;\r\n                            info.invalidNodes = [];\r\n                        }\r\n                    }\r\n                );\r\n            },\r\n\r\n            /**\r\n             * Reports if this is before `super()`.\r\n             * @param {ASTNode} node A target node.\r\n             * @returns {void}\r\n             */\r\n            ThisExpression(node) {\r\n                if (isBeforeCallOfSuper()) {\r\n                    setInvalid(node);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Reports if this is before `super()`.\r\n             * @param {ASTNode} node A target node.\r\n             * @returns {void}\r\n             */\r\n            Super(node) {\r\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\r\n                    setInvalid(node);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Marks `super()` called.\r\n             * @param {ASTNode} node A target node.\r\n             * @returns {void}\r\n             */\r\n            \"CallExpression:exit\"(node) {\r\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\r\n                    setSuperCalled();\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Resets state.\r\n             * @returns {void}\r\n             */\r\n            \"Program:exit\"() {\r\n                segInfoMap = Object.create(null);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}