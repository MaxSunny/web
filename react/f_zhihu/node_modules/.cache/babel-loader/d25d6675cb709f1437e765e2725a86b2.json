{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag unnecessary bind calls\r\n * @author Bence Dányi <bence@danyi.me>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary calls to `.bind()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extra-bind\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpected: \"The function binding is unnecessary.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\r\n     * Checks if a node is free of side effects.\r\n     *\r\n     * This check is stricter than it needs to be, in order to keep the implementation simple.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\r\n     */\n\n    function isSideEffectFree(node) {\n      return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\n    }\n    /**\r\n     * Reports a given function node.\r\n     * @param {ASTNode} node A node to report. This is a FunctionExpression or\r\n     *      an ArrowFunctionExpression.\r\n     * @returns {void}\r\n     */\n\n\n    function report(node) {\n      const memberNode = node.parent;\n      const callNode = memberNode.parent.type === \"ChainExpression\" ? memberNode.parent.parent : memberNode.parent;\n      context.report({\n        node: callNode,\n        messageId: \"unexpected\",\n        loc: memberNode.property.loc,\n\n        fix(fixer) {\n          if (!isSideEffectFree(callNode.arguments[0])) {\n            return null;\n          }\n          /*\r\n           * The list of the first/last token pair of a removal range.\r\n           * This is two parts because closing parentheses may exist between the method name and arguments.\r\n           * E.g. `(function(){}.bind ) (obj)`\r\n           *                    ^^^^^   ^^^^^ < removal ranges\r\n           * E.g. `(function(){}?.['bind'] ) ?.(obj)`\r\n           *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\r\n           */\n\n\n          const tokenPairs = [[// `.`, `?.`, or `[` token.\n          sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken), // property name or `]` token.\n          sourceCode.getLastToken(memberNode)], [// `?.` or `(` token of arguments.\n          sourceCode.getTokenAfter(memberNode, astUtils.isNotClosingParenToken), // `)` token of arguments.\n          sourceCode.getLastToken(callNode)]];\n          const firstTokenToRemove = tokenPairs[0][0];\n          const lastTokenToRemove = tokenPairs[1][1];\n\n          if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n            return null;\n          }\n\n          return tokenPairs.map(_ref => {\n            let [start, end] = _ref;\n            return fixer.removeRange([start.range[0], end.range[1]]);\n          });\n        }\n\n      });\n    }\n    /**\r\n     * Checks whether or not a given function node is the callee of `.bind()`\r\n     * method.\r\n     *\r\n     * e.g. `(function() {}.bind(foo))`\r\n     * @param {ASTNode} node A node to report. This is a FunctionExpression or\r\n     *      an ArrowFunctionExpression.\r\n     * @returns {boolean} `true` if the node is the callee of `.bind()` method.\r\n     */\n\n\n    function isCalleeOfBindMethod(node) {\n      if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\n        return false;\n      } // The node of `*.bind` member access.\n\n\n      const bindNode = node.parent.parent.type === \"ChainExpression\" ? node.parent.parent : node.parent;\n      return bindNode.parent.type === \"CallExpression\" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== \"SpreadElement\";\n    }\n    /**\r\n     * Adds a scope information object to the stack.\r\n     * @param {ASTNode} node A node to add. This node is a FunctionExpression\r\n     *      or a FunctionDeclaration node.\r\n     * @returns {void}\r\n     */\n\n\n    function enterFunction(node) {\n      scopeInfo = {\n        isBound: isCalleeOfBindMethod(node),\n        thisFound: false,\n        upper: scopeInfo\n      };\n    }\n    /**\r\n     * Removes the scope information object from the top of the stack.\r\n     * At the same time, this reports the function node if the function has\r\n     * `.bind()` and the `this` keywords found.\r\n     * @param {ASTNode} node A node to remove. This node is a\r\n     *      FunctionExpression or a FunctionDeclaration node.\r\n     * @returns {void}\r\n     */\n\n\n    function exitFunction(node) {\n      if (scopeInfo.isBound && !scopeInfo.thisFound) {\n        report(node);\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\r\n     * Reports a given arrow function if the function is callee of `.bind()`\r\n     * method.\r\n     * @param {ASTNode} node A node to report. This node is an\r\n     *      ArrowFunctionExpression.\r\n     * @returns {void}\r\n     */\n\n\n    function exitArrowFunction(node) {\n      if (isCalleeOfBindMethod(node)) {\n        report(node);\n      }\n    }\n    /**\r\n     * Set the mark as the `this` keyword was found in this scope.\r\n     * @returns {void}\r\n     */\n\n\n    function markAsThisFound() {\n      if (scopeInfo) {\n        scopeInfo.thisFound = true;\n      }\n    }\n\n    return {\n      \"ArrowFunctionExpression:exit\": exitArrowFunction,\n      FunctionDeclaration: enterFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      FunctionExpression: enterFunction,\n      \"FunctionExpression:exit\": exitFunction,\n      ThisExpression: markAsThisFound\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-extra-bind.js"],"names":["astUtils","require","SIDE_EFFECT_FREE_NODE_TYPES","Set","module","exports","meta","type","docs","description","recommended","url","schema","fixable","messages","unexpected","create","context","sourceCode","getSourceCode","scopeInfo","isSideEffectFree","node","has","report","memberNode","parent","callNode","messageId","loc","property","fix","fixer","arguments","tokenPairs","getTokenAfter","object","isNotClosingParenToken","getLastToken","firstTokenToRemove","lastTokenToRemove","commentsExistBetween","map","start","end","removeRange","range","isCalleeOfBindMethod","isSpecificMemberAccess","bindNode","callee","length","enterFunction","isBound","thisFound","upper","exitFunction","exitArrowFunction","markAsThisFound","FunctionDeclaration","FunctionExpression","ThisExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag unnecessary bind calls\r\n * @author Bence Dányi <bence@danyi.me>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst SIDE_EFFECT_FREE_NODE_TYPES = new Set([\"Literal\", \"Identifier\", \"ThisExpression\", \"FunctionExpression\"]);\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary calls to `.bind()`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-extra-bind\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpected: \"The function binding is unnecessary.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        let scopeInfo = null;\r\n\r\n        /**\r\n         * Checks if a node is free of side effects.\r\n         *\r\n         * This check is stricter than it needs to be, in order to keep the implementation simple.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} True if the node is known to be side-effect free, false otherwise.\r\n         */\r\n        function isSideEffectFree(node) {\r\n            return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);\r\n        }\r\n\r\n        /**\r\n         * Reports a given function node.\r\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\r\n         *      an ArrowFunctionExpression.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            const memberNode = node.parent;\r\n            const callNode = memberNode.parent.type === \"ChainExpression\"\r\n                ? memberNode.parent.parent\r\n                : memberNode.parent;\r\n\r\n            context.report({\r\n                node: callNode,\r\n                messageId: \"unexpected\",\r\n                loc: memberNode.property.loc,\r\n\r\n                fix(fixer) {\r\n                    if (!isSideEffectFree(callNode.arguments[0])) {\r\n                        return null;\r\n                    }\r\n\r\n                    /*\r\n                     * The list of the first/last token pair of a removal range.\r\n                     * This is two parts because closing parentheses may exist between the method name and arguments.\r\n                     * E.g. `(function(){}.bind ) (obj)`\r\n                     *                    ^^^^^   ^^^^^ < removal ranges\r\n                     * E.g. `(function(){}?.['bind'] ) ?.(obj)`\r\n                     *                    ^^^^^^^^^^   ^^^^^^^ < removal ranges\r\n                     */\r\n                    const tokenPairs = [\r\n                        [\r\n\r\n                            // `.`, `?.`, or `[` token.\r\n                            sourceCode.getTokenAfter(\r\n                                memberNode.object,\r\n                                astUtils.isNotClosingParenToken\r\n                            ),\r\n\r\n                            // property name or `]` token.\r\n                            sourceCode.getLastToken(memberNode)\r\n                        ],\r\n                        [\r\n\r\n                            // `?.` or `(` token of arguments.\r\n                            sourceCode.getTokenAfter(\r\n                                memberNode,\r\n                                astUtils.isNotClosingParenToken\r\n                            ),\r\n\r\n                            // `)` token of arguments.\r\n                            sourceCode.getLastToken(callNode)\r\n                        ]\r\n                    ];\r\n                    const firstTokenToRemove = tokenPairs[0][0];\r\n                    const lastTokenToRemove = tokenPairs[1][1];\r\n\r\n                    if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\r\n                        return null;\r\n                    }\r\n\r\n                    return tokenPairs.map(([start, end]) =>\r\n                        fixer.removeRange([start.range[0], end.range[1]]));\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given function node is the callee of `.bind()`\r\n         * method.\r\n         *\r\n         * e.g. `(function() {}.bind(foo))`\r\n         * @param {ASTNode} node A node to report. This is a FunctionExpression or\r\n         *      an ArrowFunctionExpression.\r\n         * @returns {boolean} `true` if the node is the callee of `.bind()` method.\r\n         */\r\n        function isCalleeOfBindMethod(node) {\r\n            if (!astUtils.isSpecificMemberAccess(node.parent, null, \"bind\")) {\r\n                return false;\r\n            }\r\n\r\n            // The node of `*.bind` member access.\r\n            const bindNode = node.parent.parent.type === \"ChainExpression\"\r\n                ? node.parent.parent\r\n                : node.parent;\r\n\r\n            return (\r\n                bindNode.parent.type === \"CallExpression\" &&\r\n                bindNode.parent.callee === bindNode &&\r\n                bindNode.parent.arguments.length === 1 &&\r\n                bindNode.parent.arguments[0].type !== \"SpreadElement\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Adds a scope information object to the stack.\r\n         * @param {ASTNode} node A node to add. This node is a FunctionExpression\r\n         *      or a FunctionDeclaration node.\r\n         * @returns {void}\r\n         */\r\n        function enterFunction(node) {\r\n            scopeInfo = {\r\n                isBound: isCalleeOfBindMethod(node),\r\n                thisFound: false,\r\n                upper: scopeInfo\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Removes the scope information object from the top of the stack.\r\n         * At the same time, this reports the function node if the function has\r\n         * `.bind()` and the `this` keywords found.\r\n         * @param {ASTNode} node A node to remove. This node is a\r\n         *      FunctionExpression or a FunctionDeclaration node.\r\n         * @returns {void}\r\n         */\r\n        function exitFunction(node) {\r\n            if (scopeInfo.isBound && !scopeInfo.thisFound) {\r\n                report(node);\r\n            }\r\n\r\n            scopeInfo = scopeInfo.upper;\r\n        }\r\n\r\n        /**\r\n         * Reports a given arrow function if the function is callee of `.bind()`\r\n         * method.\r\n         * @param {ASTNode} node A node to report. This node is an\r\n         *      ArrowFunctionExpression.\r\n         * @returns {void}\r\n         */\r\n        function exitArrowFunction(node) {\r\n            if (isCalleeOfBindMethod(node)) {\r\n                report(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Set the mark as the `this` keyword was found in this scope.\r\n         * @returns {void}\r\n         */\r\n        function markAsThisFound() {\r\n            if (scopeInfo) {\r\n                scopeInfo.thisFound = true;\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"ArrowFunctionExpression:exit\": exitArrowFunction,\r\n            FunctionDeclaration: enterFunction,\r\n            \"FunctionDeclaration:exit\": exitFunction,\r\n            FunctionExpression: enterFunction,\r\n            \"FunctionExpression:exit\": exitFunction,\r\n            ThisExpression: markAsThisFound\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}