{"ast":null,"code":"/**\r\n * @fileoverview Rule to count multiple spaces in regular expressions\r\n * @author Matt DuVall <http://www.mattduvall.com/>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst regexpp = require(\"regexpp\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst regExpParser = new regexpp.RegExpParser();\nconst DOUBLE_SPACE = / {2}/u;\n/**\r\n * Check if node is a string\r\n * @param {ASTNode} node node to evaluate\r\n * @returns {boolean} True if its a string\r\n * @private\r\n */\n\nfunction isString(node) {\n  return node && node.type === \"Literal\" && typeof node.value === \"string\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow multiple spaces in regular expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-regex-spaces\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Validate regular expression\r\n     * @param {ASTNode} nodeToReport Node to report.\r\n     * @param {string} pattern Regular expression pattern to validate.\r\n     * @param {string} rawPattern Raw representation of the pattern in the source code.\r\n     * @param {number} rawPatternStartRange Start range of the pattern in the source code.\r\n     * @param {string} flags Regular expression flags.\r\n     * @returns {void}\r\n     * @private\r\n     */\n    function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\n      // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\n      if (!DOUBLE_SPACE.test(rawPattern)) {\n        return;\n      }\n\n      const characterClassNodes = [];\n      let regExpAST;\n\n      try {\n        regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      regexpp.visitRegExpAST(regExpAST, {\n        onCharacterClassEnter(ccNode) {\n          characterClassNodes.push(ccNode);\n        }\n\n      });\n      const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\n      let match;\n\n      while (match = spacesPattern.exec(pattern)) {\n        const {\n          1: {\n            length\n          },\n          index\n        } = match; // Report only consecutive spaces that are not in character classes.\n\n        if (characterClassNodes.every(_ref => {\n          let {\n            start,\n            end\n          } = _ref;\n          return index < start || end <= index;\n        })) {\n          context.report({\n            node: nodeToReport,\n            messageId: \"multipleSpaces\",\n            data: {\n              length\n            },\n\n            fix(fixer) {\n              if (pattern !== rawPattern) {\n                return null;\n              }\n\n              return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], ` {${length}}`);\n            }\n\n          }); // Report only the first occurrence of consecutive spaces\n\n          return;\n        }\n      }\n    }\n    /**\r\n     * Validate regular expression literals\r\n     * @param {ASTNode} node node to validate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkLiteral(node) {\n      if (node.regex) {\n        const pattern = node.regex.pattern;\n        const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\n        const rawPatternStartRange = node.range[0] + 1;\n        const flags = node.regex.flags;\n        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n      }\n    }\n    /**\r\n     * Validate strings passed to the RegExp constructor\r\n     * @param {ASTNode} node node to validate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkFunction(node) {\n      const scope = context.getScope();\n      const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\n      const shadowed = regExpVar && regExpVar.defs.length > 0;\n      const patternNode = node.arguments[0];\n      const flagsNode = node.arguments[1];\n\n      if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\n        const pattern = patternNode.value;\n        const rawPattern = patternNode.raw.slice(1, -1);\n        const rawPatternStartRange = patternNode.range[0] + 1;\n        const flags = isString(flagsNode) ? flagsNode.value : \"\";\n        checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);\n      }\n    }\n\n    return {\n      Literal: checkLiteral,\n      CallExpression: checkFunction,\n      NewExpression: checkFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-regex-spaces.js"],"names":["astUtils","require","regexpp","regExpParser","RegExpParser","DOUBLE_SPACE","isString","node","type","value","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","multipleSpaces","create","context","checkRegex","nodeToReport","pattern","rawPattern","rawPatternStartRange","flags","test","characterClassNodes","regExpAST","parsePattern","length","includes","visitRegExpAST","onCharacterClassEnter","ccNode","push","spacesPattern","match","exec","index","every","start","end","report","messageId","data","fix","fixer","replaceTextRange","checkLiteral","regex","raw","slice","lastIndexOf","range","checkFunction","scope","getScope","regExpVar","getVariableByName","shadowed","defs","patternNode","arguments","flagsNode","callee","name","Literal","CallExpression","NewExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to count multiple spaces in regular expressions\r\n * @author Matt DuVall <http://www.mattduvall.com/>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst regexpp = require(\"regexpp\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst regExpParser = new regexpp.RegExpParser();\r\nconst DOUBLE_SPACE = / {2}/u;\r\n\r\n/**\r\n * Check if node is a string\r\n * @param {ASTNode} node node to evaluate\r\n * @returns {boolean} True if its a string\r\n * @private\r\n */\r\nfunction isString(node) {\r\n    return node && node.type === \"Literal\" && typeof node.value === \"string\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow multiple spaces in regular expressions\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-regex-spaces\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            multipleSpaces: \"Spaces are hard to count. Use {{{length}}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Validate regular expression\r\n         * @param {ASTNode} nodeToReport Node to report.\r\n         * @param {string} pattern Regular expression pattern to validate.\r\n         * @param {string} rawPattern Raw representation of the pattern in the source code.\r\n         * @param {number} rawPatternStartRange Start range of the pattern in the source code.\r\n         * @param {string} flags Regular expression flags.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {\r\n\r\n            // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \\ ').\r\n            if (!DOUBLE_SPACE.test(rawPattern)) {\r\n                return;\r\n            }\r\n\r\n            const characterClassNodes = [];\r\n            let regExpAST;\r\n\r\n            try {\r\n                regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\r\n            } catch {\r\n\r\n                // Ignore regular expressions with syntax errors\r\n                return;\r\n            }\r\n\r\n            regexpp.visitRegExpAST(regExpAST, {\r\n                onCharacterClassEnter(ccNode) {\r\n                    characterClassNodes.push(ccNode);\r\n                }\r\n            });\r\n\r\n            const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;\r\n            let match;\r\n\r\n            while ((match = spacesPattern.exec(pattern))) {\r\n                const { 1: { length }, index } = match;\r\n\r\n                // Report only consecutive spaces that are not in character classes.\r\n                if (\r\n                    characterClassNodes.every(({ start, end }) => index < start || end <= index)\r\n                ) {\r\n                    context.report({\r\n                        node: nodeToReport,\r\n                        messageId: \"multipleSpaces\",\r\n                        data: { length },\r\n                        fix(fixer) {\r\n                            if (pattern !== rawPattern) {\r\n                                return null;\r\n                            }\r\n                            return fixer.replaceTextRange(\r\n                                [rawPatternStartRange + index, rawPatternStartRange + index + length],\r\n                                ` {${length}}`\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    // Report only the first occurrence of consecutive spaces\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validate regular expression literals\r\n         * @param {ASTNode} node node to validate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkLiteral(node) {\r\n            if (node.regex) {\r\n                const pattern = node.regex.pattern;\r\n                const rawPattern = node.raw.slice(1, node.raw.lastIndexOf(\"/\"));\r\n                const rawPatternStartRange = node.range[0] + 1;\r\n                const flags = node.regex.flags;\r\n\r\n                checkRegex(\r\n                    node,\r\n                    pattern,\r\n                    rawPattern,\r\n                    rawPatternStartRange,\r\n                    flags\r\n                );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validate strings passed to the RegExp constructor\r\n         * @param {ASTNode} node node to validate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkFunction(node) {\r\n            const scope = context.getScope();\r\n            const regExpVar = astUtils.getVariableByName(scope, \"RegExp\");\r\n            const shadowed = regExpVar && regExpVar.defs.length > 0;\r\n            const patternNode = node.arguments[0];\r\n            const flagsNode = node.arguments[1];\r\n\r\n            if (node.callee.type === \"Identifier\" && node.callee.name === \"RegExp\" && isString(patternNode) && !shadowed) {\r\n                const pattern = patternNode.value;\r\n                const rawPattern = patternNode.raw.slice(1, -1);\r\n                const rawPatternStartRange = patternNode.range[0] + 1;\r\n                const flags = isString(flagsNode) ? flagsNode.value : \"\";\r\n\r\n                checkRegex(\r\n                    node,\r\n                    pattern,\r\n                    rawPattern,\r\n                    rawPatternStartRange,\r\n                    flags\r\n                );\r\n            }\r\n        }\r\n\r\n        return {\r\n            Literal: checkLiteral,\r\n            CallExpression: checkFunction,\r\n            NewExpression: checkFunction\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}