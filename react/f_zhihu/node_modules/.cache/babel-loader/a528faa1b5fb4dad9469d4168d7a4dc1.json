{"ast":null,"code":"/**\r\n * @fileoverview A class of the code path analyzer.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\"),\n      {\n  breakableTypePattern\n} = require(\"../../shared/ast-utils\"),\n      CodePath = require(\"./code-path\"),\n      CodePathSegment = require(\"./code-path-segment\"),\n      IdGenerator = require(\"./id-generator\"),\n      debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given node is a `case` node (not `default` node).\r\n * @param {ASTNode} node A `SwitchCase` node to check.\r\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\r\n */\n\n\nfunction isCaseNode(node) {\n  return Boolean(node.test);\n}\n/**\r\n * Checks if a given node appears as the value of a PropertyDefinition node.\r\n * @param {ASTNode} node THe node to check.\r\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\r\n *      false if not.\r\n */\n\n\nfunction isPropertyDefinitionValue(node) {\n  const parent = node.parent;\n  return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\n}\n/**\r\n * Checks whether the given logical operator is taken into account for the code\r\n * path analysis.\r\n * @param {string} operator The operator found in the LogicalExpression node\r\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\r\n */\n\n\nfunction isHandledLogicalOperator(operator) {\n  return operator === \"&&\" || operator === \"||\" || operator === \"??\";\n}\n/**\r\n * Checks whether the given assignment operator is a logical assignment operator.\r\n * Logical assignments are taken into account for the code path analysis\r\n * because of their short-circuiting semantics.\r\n * @param {string} operator The operator found in the AssignmentExpression node\r\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\r\n */\n\n\nfunction isLogicalAssignmentOperator(operator) {\n  return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\n}\n/**\r\n * Gets the label if the parent node of a given node is a LabeledStatement.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string|null} The label or `null`.\r\n */\n\n\nfunction getLabel(node) {\n  if (node.parent.type === \"LabeledStatement\") {\n    return node.parent.label.name;\n  }\n\n  return null;\n}\n/**\r\n * Checks whether or not a given logical expression node goes different path\r\n * between the `true` case and the `false` case.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a test of a choice statement.\r\n */\n\n\nfunction isForkingByTrueOrFalse(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n      return parent.test === node;\n\n    case \"LogicalExpression\":\n      return isHandledLogicalOperator(parent.operator);\n\n    case \"AssignmentExpression\":\n      return isLogicalAssignmentOperator(parent.operator);\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Gets the boolean value of a given literal node.\r\n *\r\n * This is used to detect infinity loops (e.g. `while (true) {}`).\r\n * Statements preceded by an infinity loop are unreachable if the loop didn't\r\n * have any `break` statement.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\r\n *   otherwise `undefined`.\r\n */\n\n\nfunction getBooleanValueIfSimpleConstant(node) {\n  if (node.type === \"Literal\") {\n    return Boolean(node.value);\n  }\n\n  return void 0;\n}\n/**\r\n * Checks that a given identifier node is a reference or not.\r\n *\r\n * This is used to detect the first throwable node in a `try` block.\r\n * @param {ASTNode} node An Identifier node to check.\r\n * @returns {boolean} `true` if the node is a reference.\r\n */\n\n\nfunction isIdentifierReference(node) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"LabeledStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n    case \"ImportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"CatchClause\":\n      return false;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    case \"Property\":\n    case \"PropertyDefinition\":\n    case \"MethodDefinition\":\n      return parent.key !== node || parent.computed || parent.shorthand;\n\n    case \"AssignmentPattern\":\n      return parent.key !== node;\n\n    default:\n      return true;\n  }\n}\n/**\r\n * Updates the current segment with the head segment.\r\n * This is similar to local branches and tracking branches of git.\r\n *\r\n * To separate the current and the head is in order to not make useless segments.\r\n *\r\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\r\n * events are fired.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction forwardCurrentToHead(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const currentSegments = state.currentSegments;\n  const headSegments = state.headSegments;\n  const end = Math.max(currentSegments.length, headSegments.length);\n  let i, currentSegment, headSegment; // Fires leaving events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && currentSegment) {\n      debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n      if (currentSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n      }\n    }\n  } // Update state.\n\n\n  state.currentSegments = headSegments; // Fires entering events.\n\n  for (i = 0; i < end; ++i) {\n    currentSegment = currentSegments[i];\n    headSegment = headSegments[i];\n\n    if (currentSegment !== headSegment && headSegment) {\n      debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\n      CodePathSegment.markUsed(headSegment);\n\n      if (headSegment.reachable) {\n        analyzer.emitter.emit(\"onCodePathSegmentStart\", headSegment, node);\n      }\n    }\n  }\n}\n/**\r\n * Updates the current segment with empty.\r\n * This is called at the last of functions or the program.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction leaveFromCurrentSegment(analyzer, node) {\n  const state = CodePath.getState(analyzer.codePath);\n  const currentSegments = state.currentSegments;\n\n  for (let i = 0; i < currentSegments.length; ++i) {\n    const currentSegment = currentSegments[i];\n    debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\n\n    if (currentSegment.reachable) {\n      analyzer.emitter.emit(\"onCodePathSegmentEnd\", currentSegment, node);\n    }\n  }\n\n  state.currentSegments = [];\n}\n/**\r\n * Updates the code path due to the position of a given node in the parent node\r\n * thereof.\r\n *\r\n * For example, if the node is `parent.consequent`, this creates a fork from the\r\n * current path.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction preprocess(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  const parent = node.parent;\n\n  switch (parent.type) {\n    // The `arguments.length == 0` case is in `postprocess` function.\n    case \"CallExpression\":\n      if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (parent.optional === true && parent.property === node) {\n        state.makeOptionalRight();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (parent.right === node && isHandledLogicalOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {\n        state.makeLogicalRight();\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      /*\r\n       * Fork if this node is at `consequent`/`alternate`.\r\n       * `popForkContext()` exists at `IfStatement:exit` and\r\n       * `ConditionalExpression:exit`.\r\n       */\n      if (parent.consequent === node) {\n        state.makeIfConsequent();\n      } else if (parent.alternate === node) {\n        state.makeIfAlternate();\n      }\n\n      break;\n\n    case \"SwitchCase\":\n      if (parent.consequent[0] === node) {\n        state.makeSwitchCaseBody(false, !parent.test);\n      }\n\n      break;\n\n    case \"TryStatement\":\n      if (parent.handler === node) {\n        state.makeCatchBlock();\n      } else if (parent.finalizer === node) {\n        state.makeFinallyBlock();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n      if (parent.test === node) {\n        state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n      } else {\n        assert(parent.body === node);\n        state.makeWhileBody();\n      }\n\n      break;\n\n    case \"DoWhileStatement\":\n      if (parent.body === node) {\n        state.makeDoWhileBody();\n      } else {\n        assert(parent.test === node);\n        state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n      }\n\n      break;\n\n    case \"ForStatement\":\n      if (parent.test === node) {\n        state.makeForTest(getBooleanValueIfSimpleConstant(node));\n      } else if (parent.update === node) {\n        state.makeForUpdate();\n      } else if (parent.body === node) {\n        state.makeForBody();\n      }\n\n      break;\n\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      if (parent.left === node) {\n        state.makeForInOfLeft();\n      } else if (parent.right === node) {\n        state.makeForInOfRight();\n      } else {\n        assert(parent.body === node);\n        state.makeForInOfBody();\n      }\n\n      break;\n\n    case \"AssignmentPattern\":\n      /*\r\n       * Fork if this node is at `right`.\r\n       * `left` is executed always, so it uses the current path.\r\n       * `popForkContext()` exists at `AssignmentPattern:exit`.\r\n       */\n      if (parent.right === node) {\n        state.pushForkContext();\n        state.forkBypassPath();\n        state.forkPath();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n}\n/**\r\n * Updates the code path due to the type of a given node in entering.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction processCodePathToEnter(analyzer, node) {\n  let codePath = analyzer.codePath;\n  let state = codePath && CodePath.getState(codePath);\n  const parent = node.parent;\n  /**\r\n   * Creates a new code path and trigger the onCodePathStart event\r\n   * based on the currently selected node.\r\n   * @param {string} origin The reason the code path was started.\r\n   * @returns {void}\r\n   */\n\n  function startCodePath(origin) {\n    if (codePath) {\n      // Emits onCodePathSegmentStart events if updated.\n      forwardCurrentToHead(analyzer, node);\n      debug.dumpState(node, state, false);\n    } // Create the code path of this scope.\n\n\n    codePath = analyzer.codePath = new CodePath({\n      id: analyzer.idGenerator.next(),\n      origin,\n      upper: codePath,\n      onLooped: analyzer.onLooped\n    });\n    state = CodePath.getState(codePath); // Emits onCodePathStart events.\n\n    debug.dump(`onCodePathStart ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n  }\n  /*\r\n   * Special case: The right side of class field initializer is considered\r\n   * to be its own function, so we need to start a new code path in this\r\n   * case.\r\n   */\n\n\n  if (isPropertyDefinitionValue(node)) {\n    startCodePath(\"class-field-initializer\");\n    /*\r\n     * Intentional fall through because `node` needs to also be\r\n     * processed by the code below. For example, if we have:\r\n     *\r\n     * class Foo {\r\n     *     a = () => {}\r\n     * }\r\n     *\r\n     * In this case, we also need start a second code path.\r\n     */\n  }\n\n  switch (node.type) {\n    case \"Program\":\n      startCodePath(\"program\");\n      break;\n\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n      startCodePath(\"function\");\n      break;\n\n    case \"StaticBlock\":\n      startCodePath(\"class-static-block\");\n      break;\n\n    case \"ChainExpression\":\n      state.pushChainContext();\n      break;\n\n    case \"CallExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"MemberExpression\":\n      if (node.optional === true) {\n        state.makeOptionalNode();\n      }\n\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.pushChoiceContext(node.operator.slice(0, -1), // removes `=` from the end\n        isForkingByTrueOrFalse(node));\n      }\n\n      break;\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      state.pushChoiceContext(\"test\", false);\n      break;\n\n    case \"SwitchStatement\":\n      state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));\n      break;\n\n    case \"TryStatement\":\n      state.pushTryContext(Boolean(node.finalizer));\n      break;\n\n    case \"SwitchCase\":\n      /*\r\n       * Fork if this node is after the 2st node in `cases`.\r\n       * It's similar to `else` blocks.\r\n       * The next `test` node is processed in this path.\r\n       */\n      if (parent.discriminant !== node && parent.cases[0] !== node) {\n        state.forkPath();\n      }\n\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.pushLoopContext(node.type, getLabel(node));\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.pushBreakContext(false, node.label.name);\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  forwardCurrentToHead(analyzer, node);\n  debug.dumpState(node, state, false);\n}\n/**\r\n * Updates the code path due to the type of a given node in leaving.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction processCodePathToExit(analyzer, node) {\n  const codePath = analyzer.codePath;\n  const state = CodePath.getState(codePath);\n  let dontForward = false;\n\n  switch (node.type) {\n    case \"ChainExpression\":\n      state.popChainContext();\n      break;\n\n    case \"IfStatement\":\n    case \"ConditionalExpression\":\n      state.popChoiceContext();\n      break;\n\n    case \"LogicalExpression\":\n      if (isHandledLogicalOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"AssignmentExpression\":\n      if (isLogicalAssignmentOperator(node.operator)) {\n        state.popChoiceContext();\n      }\n\n      break;\n\n    case \"SwitchStatement\":\n      state.popSwitchContext();\n      break;\n\n    case \"SwitchCase\":\n      /*\r\n       * This is the same as the process at the 1st `consequent` node in\r\n       * `preprocess` function.\r\n       * Must do if this `consequent` is empty.\r\n       */\n      if (node.consequent.length === 0) {\n        state.makeSwitchCaseBody(true, !node.test);\n      }\n\n      if (state.forkContext.reachable) {\n        dontForward = true;\n      }\n\n      break;\n\n    case \"TryStatement\":\n      state.popTryContext();\n      break;\n\n    case \"BreakStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeBreak(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ContinueStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeContinue(node.label && node.label.name);\n      dontForward = true;\n      break;\n\n    case \"ReturnStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeReturn();\n      dontForward = true;\n      break;\n\n    case \"ThrowStatement\":\n      forwardCurrentToHead(analyzer, node);\n      state.makeThrow();\n      dontForward = true;\n      break;\n\n    case \"Identifier\":\n      if (isIdentifierReference(node)) {\n        state.makeFirstThrowablePathInTryBlock();\n        dontForward = true;\n      }\n\n      break;\n\n    case \"CallExpression\":\n    case \"ImportExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"YieldExpression\":\n      state.makeFirstThrowablePathInTryBlock();\n      break;\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      state.popLoopContext();\n      break;\n\n    case \"AssignmentPattern\":\n      state.popForkContext();\n      break;\n\n    case \"LabeledStatement\":\n      if (!breakableTypePattern.test(node.body.type)) {\n        state.popBreakContext();\n      }\n\n      break;\n\n    default:\n      break;\n  } // Emits onCodePathSegmentStart events if updated.\n\n\n  if (!dontForward) {\n    forwardCurrentToHead(analyzer, node);\n  }\n\n  debug.dumpState(node, state, true);\n}\n/**\r\n * Updates the code path to finalize the current code path.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\n\n\nfunction postprocess(analyzer, node) {\n  /**\r\n   * Ends the code path for the current node.\r\n   * @returns {void}\r\n   */\n  function endCodePath() {\n    let codePath = analyzer.codePath; // Mark the current path as the final node.\n\n    CodePath.getState(codePath).makeFinal(); // Emits onCodePathSegmentEnd event of the current segments.\n\n    leaveFromCurrentSegment(analyzer, node); // Emits onCodePathEnd event of this code path.\n\n    debug.dump(`onCodePathEnd ${codePath.id}`);\n    analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n    debug.dumpDot(codePath);\n    codePath = analyzer.codePath = analyzer.codePath.upper;\n\n    if (codePath) {\n      debug.dumpState(node, CodePath.getState(codePath), true);\n    }\n  }\n\n  switch (node.type) {\n    case \"Program\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"StaticBlock\":\n      {\n        endCodePath();\n        break;\n      }\n    // The `arguments.length >= 1` case is in `preprocess` function.\n\n    case \"CallExpression\":\n      if (node.optional === true && node.arguments.length === 0) {\n        CodePath.getState(analyzer.codePath).makeOptionalRight();\n      }\n\n      break;\n\n    default:\n      break;\n  }\n  /*\r\n   * Special case: The right side of class field initializer is considered\r\n   * to be its own function, so we need to end a code path in this\r\n   * case.\r\n   *\r\n   * We need to check after the other checks in order to close the\r\n   * code paths in the correct order for code like this:\r\n   *\r\n   *\r\n   * class Foo {\r\n   *     a = () => {}\r\n   * }\r\n   *\r\n   * In this case, The ArrowFunctionExpression code path is closed first\r\n   * and then we need to close the code path for the PropertyDefinition\r\n   * value.\r\n   */\n\n\n  if (isPropertyDefinitionValue(node)) {\n    endCodePath();\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * The class to analyze code paths.\r\n * This class implements the EventGenerator interface.\r\n */\n\n\nclass CodePathAnalyzer {\n  /**\r\n   * @param {EventGenerator} eventGenerator An event generator to wrap.\r\n   */\n  constructor(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n  }\n  /**\r\n   * Does the process to enter a given AST node.\r\n   * This updates state of analysis and calls `enterNode` of the wrapped.\r\n   * @param {ASTNode} node A node which is entering.\r\n   * @returns {void}\r\n   */\n\n\n  enterNode(node) {\n    this.currentNode = node; // Updates the code path due to node's position in its parent node.\n\n    if (node.parent) {\n      preprocess(this, node);\n    }\n    /*\r\n     * Updates the code path.\r\n     * And emits onCodePathStart/onCodePathSegmentStart events.\r\n     */\n\n\n    processCodePathToEnter(this, node); // Emits node events.\n\n    this.original.enterNode(node);\n    this.currentNode = null;\n  }\n  /**\r\n   * Does the process to leave a given AST node.\r\n   * This updates state of analysis and calls `leaveNode` of the wrapped.\r\n   * @param {ASTNode} node A node which is leaving.\r\n   * @returns {void}\r\n   */\n\n\n  leaveNode(node) {\n    this.currentNode = node;\n    /*\r\n     * Updates the code path.\r\n     * And emits onCodePathStart/onCodePathSegmentStart events.\r\n     */\n\n    processCodePathToExit(this, node); // Emits node events.\n\n    this.original.leaveNode(node); // Emits the last onCodePathStart/onCodePathSegmentStart events.\n\n    postprocess(this, node);\n    this.currentNode = null;\n  }\n  /**\r\n   * This is called on a code path looped.\r\n   * Then this raises a looped event.\r\n   * @param {CodePathSegment} fromSegment A segment of prev.\r\n   * @param {CodePathSegment} toSegment A segment of next.\r\n   * @returns {void}\r\n   */\n\n\n  onLooped(fromSegment, toSegment) {\n    if (fromSegment.reachable && toSegment.reachable) {\n      debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\n      this.emitter.emit(\"onCodePathSegmentLoop\", fromSegment, toSegment, this.currentNode);\n    }\n  }\n\n}\n\nmodule.exports = CodePathAnalyzer;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js"],"names":["assert","require","breakableTypePattern","CodePath","CodePathSegment","IdGenerator","debug","isCaseNode","node","Boolean","test","isPropertyDefinitionValue","parent","type","value","isHandledLogicalOperator","operator","isLogicalAssignmentOperator","getLabel","label","name","isForkingByTrueOrFalse","getBooleanValueIfSimpleConstant","isIdentifierReference","id","key","computed","shorthand","forwardCurrentToHead","analyzer","codePath","state","getState","currentSegments","headSegments","end","Math","max","length","i","currentSegment","headSegment","dump","reachable","emitter","emit","markUsed","leaveFromCurrentSegment","preprocess","optional","arguments","makeOptionalRight","property","right","makeLogicalRight","consequent","makeIfConsequent","alternate","makeIfAlternate","makeSwitchCaseBody","handler","makeCatchBlock","finalizer","makeFinallyBlock","makeWhileTest","body","makeWhileBody","makeDoWhileBody","makeDoWhileTest","makeForTest","update","makeForUpdate","makeForBody","left","makeForInOfLeft","makeForInOfRight","makeForInOfBody","pushForkContext","forkBypassPath","forkPath","processCodePathToEnter","startCodePath","origin","dumpState","idGenerator","next","upper","onLooped","pushChainContext","makeOptionalNode","pushChoiceContext","slice","pushSwitchContext","cases","some","pushTryContext","discriminant","pushLoopContext","pushBreakContext","processCodePathToExit","dontForward","popChainContext","popChoiceContext","popSwitchContext","forkContext","popTryContext","makeBreak","makeContinue","makeReturn","makeThrow","makeFirstThrowablePathInTryBlock","popLoopContext","popForkContext","popBreakContext","postprocess","endCodePath","makeFinal","dumpDot","CodePathAnalyzer","constructor","eventGenerator","original","currentNode","bind","enterNode","leaveNode","fromSegment","toSegment","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A class of the code path analyzer.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst assert = require(\"assert\"),\r\n    { breakableTypePattern } = require(\"../../shared/ast-utils\"),\r\n    CodePath = require(\"./code-path\"),\r\n    CodePathSegment = require(\"./code-path-segment\"),\r\n    IdGenerator = require(\"./id-generator\"),\r\n    debug = require(\"./debug-helpers\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given node is a `case` node (not `default` node).\r\n * @param {ASTNode} node A `SwitchCase` node to check.\r\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\r\n */\r\nfunction isCaseNode(node) {\r\n    return Boolean(node.test);\r\n}\r\n\r\n/**\r\n * Checks if a given node appears as the value of a PropertyDefinition node.\r\n * @param {ASTNode} node THe node to check.\r\n * @returns {boolean} `true` if the node is a PropertyDefinition value,\r\n *      false if not.\r\n */\r\nfunction isPropertyDefinitionValue(node) {\r\n    const parent = node.parent;\r\n\r\n    return parent && parent.type === \"PropertyDefinition\" && parent.value === node;\r\n}\r\n\r\n/**\r\n * Checks whether the given logical operator is taken into account for the code\r\n * path analysis.\r\n * @param {string} operator The operator found in the LogicalExpression node\r\n * @returns {boolean} `true` if the operator is \"&&\" or \"||\" or \"??\"\r\n */\r\nfunction isHandledLogicalOperator(operator) {\r\n    return operator === \"&&\" || operator === \"||\" || operator === \"??\";\r\n}\r\n\r\n/**\r\n * Checks whether the given assignment operator is a logical assignment operator.\r\n * Logical assignments are taken into account for the code path analysis\r\n * because of their short-circuiting semantics.\r\n * @param {string} operator The operator found in the AssignmentExpression node\r\n * @returns {boolean} `true` if the operator is \"&&=\" or \"||=\" or \"??=\"\r\n */\r\nfunction isLogicalAssignmentOperator(operator) {\r\n    return operator === \"&&=\" || operator === \"||=\" || operator === \"??=\";\r\n}\r\n\r\n/**\r\n * Gets the label if the parent node of a given node is a LabeledStatement.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {string|null} The label or `null`.\r\n */\r\nfunction getLabel(node) {\r\n    if (node.parent.type === \"LabeledStatement\") {\r\n        return node.parent.label.name;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given logical expression node goes different path\r\n * between the `true` case and the `false` case.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a test of a choice statement.\r\n */\r\nfunction isForkingByTrueOrFalse(node) {\r\n    const parent = node.parent;\r\n\r\n    switch (parent.type) {\r\n        case \"ConditionalExpression\":\r\n        case \"IfStatement\":\r\n        case \"WhileStatement\":\r\n        case \"DoWhileStatement\":\r\n        case \"ForStatement\":\r\n            return parent.test === node;\r\n\r\n        case \"LogicalExpression\":\r\n            return isHandledLogicalOperator(parent.operator);\r\n\r\n        case \"AssignmentExpression\":\r\n            return isLogicalAssignmentOperator(parent.operator);\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the boolean value of a given literal node.\r\n *\r\n * This is used to detect infinity loops (e.g. `while (true) {}`).\r\n * Statements preceded by an infinity loop are unreachable if the loop didn't\r\n * have any `break` statement.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\r\n *   otherwise `undefined`.\r\n */\r\nfunction getBooleanValueIfSimpleConstant(node) {\r\n    if (node.type === \"Literal\") {\r\n        return Boolean(node.value);\r\n    }\r\n    return void 0;\r\n}\r\n\r\n/**\r\n * Checks that a given identifier node is a reference or not.\r\n *\r\n * This is used to detect the first throwable node in a `try` block.\r\n * @param {ASTNode} node An Identifier node to check.\r\n * @returns {boolean} `true` if the node is a reference.\r\n */\r\nfunction isIdentifierReference(node) {\r\n    const parent = node.parent;\r\n\r\n    switch (parent.type) {\r\n        case \"LabeledStatement\":\r\n        case \"BreakStatement\":\r\n        case \"ContinueStatement\":\r\n        case \"ArrayPattern\":\r\n        case \"RestElement\":\r\n        case \"ImportSpecifier\":\r\n        case \"ImportDefaultSpecifier\":\r\n        case \"ImportNamespaceSpecifier\":\r\n        case \"CatchClause\":\r\n            return false;\r\n\r\n        case \"FunctionDeclaration\":\r\n        case \"FunctionExpression\":\r\n        case \"ArrowFunctionExpression\":\r\n        case \"ClassDeclaration\":\r\n        case \"ClassExpression\":\r\n        case \"VariableDeclarator\":\r\n            return parent.id !== node;\r\n\r\n        case \"Property\":\r\n        case \"PropertyDefinition\":\r\n        case \"MethodDefinition\":\r\n            return (\r\n                parent.key !== node ||\r\n                parent.computed ||\r\n                parent.shorthand\r\n            );\r\n\r\n        case \"AssignmentPattern\":\r\n            return parent.key !== node;\r\n\r\n        default:\r\n            return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Updates the current segment with the head segment.\r\n * This is similar to local branches and tracking branches of git.\r\n *\r\n * To separate the current and the head is in order to not make useless segments.\r\n *\r\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\r\n * events are fired.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction forwardCurrentToHead(analyzer, node) {\r\n    const codePath = analyzer.codePath;\r\n    const state = CodePath.getState(codePath);\r\n    const currentSegments = state.currentSegments;\r\n    const headSegments = state.headSegments;\r\n    const end = Math.max(currentSegments.length, headSegments.length);\r\n    let i, currentSegment, headSegment;\r\n\r\n    // Fires leaving events.\r\n    for (i = 0; i < end; ++i) {\r\n        currentSegment = currentSegments[i];\r\n        headSegment = headSegments[i];\r\n\r\n        if (currentSegment !== headSegment && currentSegment) {\r\n            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\r\n\r\n            if (currentSegment.reachable) {\r\n                analyzer.emitter.emit(\r\n                    \"onCodePathSegmentEnd\",\r\n                    currentSegment,\r\n                    node\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    // Update state.\r\n    state.currentSegments = headSegments;\r\n\r\n    // Fires entering events.\r\n    for (i = 0; i < end; ++i) {\r\n        currentSegment = currentSegments[i];\r\n        headSegment = headSegments[i];\r\n\r\n        if (currentSegment !== headSegment && headSegment) {\r\n            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);\r\n\r\n            CodePathSegment.markUsed(headSegment);\r\n            if (headSegment.reachable) {\r\n                analyzer.emitter.emit(\r\n                    \"onCodePathSegmentStart\",\r\n                    headSegment,\r\n                    node\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Updates the current segment with empty.\r\n * This is called at the last of functions or the program.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction leaveFromCurrentSegment(analyzer, node) {\r\n    const state = CodePath.getState(analyzer.codePath);\r\n    const currentSegments = state.currentSegments;\r\n\r\n    for (let i = 0; i < currentSegments.length; ++i) {\r\n        const currentSegment = currentSegments[i];\r\n\r\n        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);\r\n        if (currentSegment.reachable) {\r\n            analyzer.emitter.emit(\r\n                \"onCodePathSegmentEnd\",\r\n                currentSegment,\r\n                node\r\n            );\r\n        }\r\n    }\r\n\r\n    state.currentSegments = [];\r\n}\r\n\r\n/**\r\n * Updates the code path due to the position of a given node in the parent node\r\n * thereof.\r\n *\r\n * For example, if the node is `parent.consequent`, this creates a fork from the\r\n * current path.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction preprocess(analyzer, node) {\r\n    const codePath = analyzer.codePath;\r\n    const state = CodePath.getState(codePath);\r\n    const parent = node.parent;\r\n\r\n    switch (parent.type) {\r\n\r\n        // The `arguments.length == 0` case is in `postprocess` function.\r\n        case \"CallExpression\":\r\n            if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {\r\n                state.makeOptionalRight();\r\n            }\r\n            break;\r\n        case \"MemberExpression\":\r\n            if (parent.optional === true && parent.property === node) {\r\n                state.makeOptionalRight();\r\n            }\r\n            break;\r\n\r\n        case \"LogicalExpression\":\r\n            if (\r\n                parent.right === node &&\r\n                isHandledLogicalOperator(parent.operator)\r\n            ) {\r\n                state.makeLogicalRight();\r\n            }\r\n            break;\r\n\r\n        case \"AssignmentExpression\":\r\n            if (\r\n                parent.right === node &&\r\n                isLogicalAssignmentOperator(parent.operator)\r\n            ) {\r\n                state.makeLogicalRight();\r\n            }\r\n            break;\r\n\r\n        case \"ConditionalExpression\":\r\n        case \"IfStatement\":\r\n\r\n            /*\r\n             * Fork if this node is at `consequent`/`alternate`.\r\n             * `popForkContext()` exists at `IfStatement:exit` and\r\n             * `ConditionalExpression:exit`.\r\n             */\r\n            if (parent.consequent === node) {\r\n                state.makeIfConsequent();\r\n            } else if (parent.alternate === node) {\r\n                state.makeIfAlternate();\r\n            }\r\n            break;\r\n\r\n        case \"SwitchCase\":\r\n            if (parent.consequent[0] === node) {\r\n                state.makeSwitchCaseBody(false, !parent.test);\r\n            }\r\n            break;\r\n\r\n        case \"TryStatement\":\r\n            if (parent.handler === node) {\r\n                state.makeCatchBlock();\r\n            } else if (parent.finalizer === node) {\r\n                state.makeFinallyBlock();\r\n            }\r\n            break;\r\n\r\n        case \"WhileStatement\":\r\n            if (parent.test === node) {\r\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\r\n            } else {\r\n                assert(parent.body === node);\r\n                state.makeWhileBody();\r\n            }\r\n            break;\r\n\r\n        case \"DoWhileStatement\":\r\n            if (parent.body === node) {\r\n                state.makeDoWhileBody();\r\n            } else {\r\n                assert(parent.test === node);\r\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\r\n            }\r\n            break;\r\n\r\n        case \"ForStatement\":\r\n            if (parent.test === node) {\r\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\r\n            } else if (parent.update === node) {\r\n                state.makeForUpdate();\r\n            } else if (parent.body === node) {\r\n                state.makeForBody();\r\n            }\r\n            break;\r\n\r\n        case \"ForInStatement\":\r\n        case \"ForOfStatement\":\r\n            if (parent.left === node) {\r\n                state.makeForInOfLeft();\r\n            } else if (parent.right === node) {\r\n                state.makeForInOfRight();\r\n            } else {\r\n                assert(parent.body === node);\r\n                state.makeForInOfBody();\r\n            }\r\n            break;\r\n\r\n        case \"AssignmentPattern\":\r\n\r\n            /*\r\n             * Fork if this node is at `right`.\r\n             * `left` is executed always, so it uses the current path.\r\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\r\n             */\r\n            if (parent.right === node) {\r\n                state.pushForkContext();\r\n                state.forkBypassPath();\r\n                state.forkPath();\r\n            }\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\n/**\r\n * Updates the code path due to the type of a given node in entering.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction processCodePathToEnter(analyzer, node) {\r\n    let codePath = analyzer.codePath;\r\n    let state = codePath && CodePath.getState(codePath);\r\n    const parent = node.parent;\r\n\r\n    /**\r\n     * Creates a new code path and trigger the onCodePathStart event\r\n     * based on the currently selected node.\r\n     * @param {string} origin The reason the code path was started.\r\n     * @returns {void}\r\n     */\r\n    function startCodePath(origin) {\r\n        if (codePath) {\r\n\r\n            // Emits onCodePathSegmentStart events if updated.\r\n            forwardCurrentToHead(analyzer, node);\r\n            debug.dumpState(node, state, false);\r\n        }\r\n\r\n        // Create the code path of this scope.\r\n        codePath = analyzer.codePath = new CodePath({\r\n            id: analyzer.idGenerator.next(),\r\n            origin,\r\n            upper: codePath,\r\n            onLooped: analyzer.onLooped\r\n        });\r\n        state = CodePath.getState(codePath);\r\n\r\n        // Emits onCodePathStart events.\r\n        debug.dump(`onCodePathStart ${codePath.id}`);\r\n        analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\r\n    }\r\n\r\n    /*\r\n     * Special case: The right side of class field initializer is considered\r\n     * to be its own function, so we need to start a new code path in this\r\n     * case.\r\n     */\r\n    if (isPropertyDefinitionValue(node)) {\r\n        startCodePath(\"class-field-initializer\");\r\n\r\n        /*\r\n         * Intentional fall through because `node` needs to also be\r\n         * processed by the code below. For example, if we have:\r\n         *\r\n         * class Foo {\r\n         *     a = () => {}\r\n         * }\r\n         *\r\n         * In this case, we also need start a second code path.\r\n         */\r\n\r\n    }\r\n\r\n    switch (node.type) {\r\n        case \"Program\":\r\n            startCodePath(\"program\");\r\n            break;\r\n\r\n        case \"FunctionDeclaration\":\r\n        case \"FunctionExpression\":\r\n        case \"ArrowFunctionExpression\":\r\n            startCodePath(\"function\");\r\n            break;\r\n\r\n        case \"StaticBlock\":\r\n            startCodePath(\"class-static-block\");\r\n            break;\r\n\r\n        case \"ChainExpression\":\r\n            state.pushChainContext();\r\n            break;\r\n        case \"CallExpression\":\r\n            if (node.optional === true) {\r\n                state.makeOptionalNode();\r\n            }\r\n            break;\r\n        case \"MemberExpression\":\r\n            if (node.optional === true) {\r\n                state.makeOptionalNode();\r\n            }\r\n            break;\r\n\r\n        case \"LogicalExpression\":\r\n            if (isHandledLogicalOperator(node.operator)) {\r\n                state.pushChoiceContext(\r\n                    node.operator,\r\n                    isForkingByTrueOrFalse(node)\r\n                );\r\n            }\r\n            break;\r\n\r\n        case \"AssignmentExpression\":\r\n            if (isLogicalAssignmentOperator(node.operator)) {\r\n                state.pushChoiceContext(\r\n                    node.operator.slice(0, -1), // removes `=` from the end\r\n                    isForkingByTrueOrFalse(node)\r\n                );\r\n            }\r\n            break;\r\n\r\n        case \"ConditionalExpression\":\r\n        case \"IfStatement\":\r\n            state.pushChoiceContext(\"test\", false);\r\n            break;\r\n\r\n        case \"SwitchStatement\":\r\n            state.pushSwitchContext(\r\n                node.cases.some(isCaseNode),\r\n                getLabel(node)\r\n            );\r\n            break;\r\n\r\n        case \"TryStatement\":\r\n            state.pushTryContext(Boolean(node.finalizer));\r\n            break;\r\n\r\n        case \"SwitchCase\":\r\n\r\n            /*\r\n             * Fork if this node is after the 2st node in `cases`.\r\n             * It's similar to `else` blocks.\r\n             * The next `test` node is processed in this path.\r\n             */\r\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\r\n                state.forkPath();\r\n            }\r\n            break;\r\n\r\n        case \"WhileStatement\":\r\n        case \"DoWhileStatement\":\r\n        case \"ForStatement\":\r\n        case \"ForInStatement\":\r\n        case \"ForOfStatement\":\r\n            state.pushLoopContext(node.type, getLabel(node));\r\n            break;\r\n\r\n        case \"LabeledStatement\":\r\n            if (!breakableTypePattern.test(node.body.type)) {\r\n                state.pushBreakContext(false, node.label.name);\r\n            }\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Emits onCodePathSegmentStart events if updated.\r\n    forwardCurrentToHead(analyzer, node);\r\n    debug.dumpState(node, state, false);\r\n}\r\n\r\n/**\r\n * Updates the code path due to the type of a given node in leaving.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction processCodePathToExit(analyzer, node) {\r\n\r\n    const codePath = analyzer.codePath;\r\n    const state = CodePath.getState(codePath);\r\n    let dontForward = false;\r\n\r\n    switch (node.type) {\r\n        case \"ChainExpression\":\r\n            state.popChainContext();\r\n            break;\r\n\r\n        case \"IfStatement\":\r\n        case \"ConditionalExpression\":\r\n            state.popChoiceContext();\r\n            break;\r\n\r\n        case \"LogicalExpression\":\r\n            if (isHandledLogicalOperator(node.operator)) {\r\n                state.popChoiceContext();\r\n            }\r\n            break;\r\n\r\n        case \"AssignmentExpression\":\r\n            if (isLogicalAssignmentOperator(node.operator)) {\r\n                state.popChoiceContext();\r\n            }\r\n            break;\r\n\r\n        case \"SwitchStatement\":\r\n            state.popSwitchContext();\r\n            break;\r\n\r\n        case \"SwitchCase\":\r\n\r\n            /*\r\n             * This is the same as the process at the 1st `consequent` node in\r\n             * `preprocess` function.\r\n             * Must do if this `consequent` is empty.\r\n             */\r\n            if (node.consequent.length === 0) {\r\n                state.makeSwitchCaseBody(true, !node.test);\r\n            }\r\n            if (state.forkContext.reachable) {\r\n                dontForward = true;\r\n            }\r\n            break;\r\n\r\n        case \"TryStatement\":\r\n            state.popTryContext();\r\n            break;\r\n\r\n        case \"BreakStatement\":\r\n            forwardCurrentToHead(analyzer, node);\r\n            state.makeBreak(node.label && node.label.name);\r\n            dontForward = true;\r\n            break;\r\n\r\n        case \"ContinueStatement\":\r\n            forwardCurrentToHead(analyzer, node);\r\n            state.makeContinue(node.label && node.label.name);\r\n            dontForward = true;\r\n            break;\r\n\r\n        case \"ReturnStatement\":\r\n            forwardCurrentToHead(analyzer, node);\r\n            state.makeReturn();\r\n            dontForward = true;\r\n            break;\r\n\r\n        case \"ThrowStatement\":\r\n            forwardCurrentToHead(analyzer, node);\r\n            state.makeThrow();\r\n            dontForward = true;\r\n            break;\r\n\r\n        case \"Identifier\":\r\n            if (isIdentifierReference(node)) {\r\n                state.makeFirstThrowablePathInTryBlock();\r\n                dontForward = true;\r\n            }\r\n            break;\r\n\r\n        case \"CallExpression\":\r\n        case \"ImportExpression\":\r\n        case \"MemberExpression\":\r\n        case \"NewExpression\":\r\n        case \"YieldExpression\":\r\n            state.makeFirstThrowablePathInTryBlock();\r\n            break;\r\n\r\n        case \"WhileStatement\":\r\n        case \"DoWhileStatement\":\r\n        case \"ForStatement\":\r\n        case \"ForInStatement\":\r\n        case \"ForOfStatement\":\r\n            state.popLoopContext();\r\n            break;\r\n\r\n        case \"AssignmentPattern\":\r\n            state.popForkContext();\r\n            break;\r\n\r\n        case \"LabeledStatement\":\r\n            if (!breakableTypePattern.test(node.body.type)) {\r\n                state.popBreakContext();\r\n            }\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    // Emits onCodePathSegmentStart events if updated.\r\n    if (!dontForward) {\r\n        forwardCurrentToHead(analyzer, node);\r\n    }\r\n    debug.dumpState(node, state, true);\r\n}\r\n\r\n/**\r\n * Updates the code path to finalize the current code path.\r\n * @param {CodePathAnalyzer} analyzer The instance.\r\n * @param {ASTNode} node The current AST node.\r\n * @returns {void}\r\n */\r\nfunction postprocess(analyzer, node) {\r\n\r\n    /**\r\n     * Ends the code path for the current node.\r\n     * @returns {void}\r\n     */\r\n    function endCodePath() {\r\n        let codePath = analyzer.codePath;\r\n\r\n        // Mark the current path as the final node.\r\n        CodePath.getState(codePath).makeFinal();\r\n\r\n        // Emits onCodePathSegmentEnd event of the current segments.\r\n        leaveFromCurrentSegment(analyzer, node);\r\n\r\n        // Emits onCodePathEnd event of this code path.\r\n        debug.dump(`onCodePathEnd ${codePath.id}`);\r\n        analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\r\n        debug.dumpDot(codePath);\r\n\r\n        codePath = analyzer.codePath = analyzer.codePath.upper;\r\n        if (codePath) {\r\n            debug.dumpState(node, CodePath.getState(codePath), true);\r\n        }\r\n\r\n    }\r\n\r\n    switch (node.type) {\r\n        case \"Program\":\r\n        case \"FunctionDeclaration\":\r\n        case \"FunctionExpression\":\r\n        case \"ArrowFunctionExpression\":\r\n        case \"StaticBlock\": {\r\n            endCodePath();\r\n            break;\r\n        }\r\n\r\n        // The `arguments.length >= 1` case is in `preprocess` function.\r\n        case \"CallExpression\":\r\n            if (node.optional === true && node.arguments.length === 0) {\r\n                CodePath.getState(analyzer.codePath).makeOptionalRight();\r\n            }\r\n            break;\r\n\r\n        default:\r\n            break;\r\n    }\r\n\r\n    /*\r\n     * Special case: The right side of class field initializer is considered\r\n     * to be its own function, so we need to end a code path in this\r\n     * case.\r\n     *\r\n     * We need to check after the other checks in order to close the\r\n     * code paths in the correct order for code like this:\r\n     *\r\n     *\r\n     * class Foo {\r\n     *     a = () => {}\r\n     * }\r\n     *\r\n     * In this case, The ArrowFunctionExpression code path is closed first\r\n     * and then we need to close the code path for the PropertyDefinition\r\n     * value.\r\n     */\r\n    if (isPropertyDefinitionValue(node)) {\r\n        endCodePath();\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * The class to analyze code paths.\r\n * This class implements the EventGenerator interface.\r\n */\r\nclass CodePathAnalyzer {\r\n\r\n    /**\r\n     * @param {EventGenerator} eventGenerator An event generator to wrap.\r\n     */\r\n    constructor(eventGenerator) {\r\n        this.original = eventGenerator;\r\n        this.emitter = eventGenerator.emitter;\r\n        this.codePath = null;\r\n        this.idGenerator = new IdGenerator(\"s\");\r\n        this.currentNode = null;\r\n        this.onLooped = this.onLooped.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Does the process to enter a given AST node.\r\n     * This updates state of analysis and calls `enterNode` of the wrapped.\r\n     * @param {ASTNode} node A node which is entering.\r\n     * @returns {void}\r\n     */\r\n    enterNode(node) {\r\n        this.currentNode = node;\r\n\r\n        // Updates the code path due to node's position in its parent node.\r\n        if (node.parent) {\r\n            preprocess(this, node);\r\n        }\r\n\r\n        /*\r\n         * Updates the code path.\r\n         * And emits onCodePathStart/onCodePathSegmentStart events.\r\n         */\r\n        processCodePathToEnter(this, node);\r\n\r\n        // Emits node events.\r\n        this.original.enterNode(node);\r\n\r\n        this.currentNode = null;\r\n    }\r\n\r\n    /**\r\n     * Does the process to leave a given AST node.\r\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\r\n     * @param {ASTNode} node A node which is leaving.\r\n     * @returns {void}\r\n     */\r\n    leaveNode(node) {\r\n        this.currentNode = node;\r\n\r\n        /*\r\n         * Updates the code path.\r\n         * And emits onCodePathStart/onCodePathSegmentStart events.\r\n         */\r\n        processCodePathToExit(this, node);\r\n\r\n        // Emits node events.\r\n        this.original.leaveNode(node);\r\n\r\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\r\n        postprocess(this, node);\r\n\r\n        this.currentNode = null;\r\n    }\r\n\r\n    /**\r\n     * This is called on a code path looped.\r\n     * Then this raises a looped event.\r\n     * @param {CodePathSegment} fromSegment A segment of prev.\r\n     * @param {CodePathSegment} toSegment A segment of next.\r\n     * @returns {void}\r\n     */\r\n    onLooped(fromSegment, toSegment) {\r\n        if (fromSegment.reachable && toSegment.reachable) {\r\n            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);\r\n            this.emitter.emit(\r\n                \"onCodePathSegmentLoop\",\r\n                fromSegment,\r\n                toSegment,\r\n                this.currentNode\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = CodePathAnalyzer;\r\n"]},"metadata":{},"sourceType":"script"}