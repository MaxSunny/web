{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\r\n * @author Jonathan Kingston\r\n * @author Christophe Porteneuve\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher(); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow irregular whitespace\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        skipComments: {\n          type: \"boolean\",\n          default: false\n        },\n        skipStrings: {\n          type: \"boolean\",\n          default: true\n        },\n        skipTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        skipRegExps: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noIrregularWhitespace: \"Irregular whitespace not allowed.\"\n    }\n  },\n\n  create(context) {\n    // Module store of errors that we have found\n    let errors = []; // Lookup the `skipComments` option, which defaults to `false`.\n\n    const options = context.options[0] || {};\n    const skipComments = !!options.skipComments;\n    const skipStrings = options.skipStrings !== false;\n    const skipRegExps = !!options.skipRegExps;\n    const skipTemplates = !!options.skipTemplates;\n    const sourceCode = context.getSourceCode();\n    const commentNodes = sourceCode.getAllComments();\n    /**\r\n     * Removes errors that occur inside the given node\r\n     * @param {ASTNode} node to check for matching errors.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function removeWhitespaceError(node) {\n      const locStart = node.loc.start;\n      const locEnd = node.loc.end;\n      errors = errors.filter(_ref => {\n        let {\n          loc: {\n            start: errorLocStart\n          }\n        } = _ref;\n        return errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line;\n      });\n    }\n    /**\r\n     * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n     * @param {ASTNode} node to check for matching errors.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n      const shouldCheckStrings = skipStrings && typeof node.value === \"string\";\n      const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n      if (shouldCheckStrings || shouldCheckRegExps) {\n        // If we have irregular characters remove them from the errors list\n        if (ALL_IRREGULARS.test(node.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n    /**\r\n     * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n     * @param {ASTNode} node to check for matching errors.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function removeInvalidNodeErrorsInTemplateLiteral(node) {\n      if (typeof node.value.raw === \"string\") {\n        if (ALL_IRREGULARS.test(node.value.raw)) {\n          removeWhitespaceError(node);\n        }\n      }\n    }\n    /**\r\n     * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n     * @param {ASTNode} node to check for matching errors.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function removeInvalidNodeErrorsInComment(node) {\n      if (ALL_IRREGULARS.test(node.value)) {\n        removeWhitespaceError(node);\n      }\n    }\n    /**\r\n     * Checks the program source for irregular whitespace\r\n     * @param {ASTNode} node The program node\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForIrregularWhitespace(node) {\n      const sourceLines = sourceCode.lines;\n      sourceLines.forEach((sourceLine, lineIndex) => {\n        const lineNumber = lineIndex + 1;\n        let match;\n\n        while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n          errors.push({\n            node,\n            messageId: \"noIrregularWhitespace\",\n            loc: {\n              start: {\n                line: lineNumber,\n                column: match.index\n              },\n              end: {\n                line: lineNumber,\n                column: match.index + match[0].length\n              }\n            }\n          });\n        }\n      });\n    }\n    /**\r\n     * Checks the program source for irregular line terminators\r\n     * @param {ASTNode} node The program node\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkForIrregularLineTerminators(node) {\n      const source = sourceCode.getText(),\n            sourceLines = sourceCode.lines,\n            linebreaks = source.match(LINE_BREAK);\n      let lastLineIndex = -1,\n          match;\n\n      while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n        const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n        errors.push({\n          node,\n          messageId: \"noIrregularWhitespace\",\n          loc: {\n            start: {\n              line: lineIndex + 1,\n              column: sourceLines[lineIndex].length\n            },\n            end: {\n              line: lineIndex + 2,\n              column: 0\n            }\n          }\n        });\n        lastLineIndex = lineIndex;\n      }\n    }\n    /**\r\n     * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function noop() {}\n\n    const nodes = {};\n\n    if (ALL_IRREGULARS.test(sourceCode.getText())) {\n      nodes.Program = function (node) {\n        /*\r\n         * As we can easily fire warnings for all white space issues with\r\n         * all the source its simpler to fire them here.\r\n         * This means we can check all the application code without having\r\n         * to worry about issues caused in the parser tokens.\r\n         * When writing this code also evaluating per node was missing out\r\n         * connecting tokens in some cases.\r\n         * We can later filter the errors when they are found to be not an\r\n         * issue in nodes we don't care about.\r\n         */\n        checkForIrregularWhitespace(node);\n        checkForIrregularLineTerminators(node);\n      };\n\n      nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n      nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n\n      nodes[\"Program:exit\"] = function () {\n        if (skipComments) {\n          // First strip errors occurring in comment nodes.\n          commentNodes.forEach(removeInvalidNodeErrorsInComment);\n        } // If we have any errors remaining report on them\n\n\n        errors.forEach(error => context.report(error));\n      };\n    } else {\n      nodes.Program = noop;\n    }\n\n    return nodes;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-irregular-whitespace.js"],"names":["astUtils","require","ALL_IRREGULARS","IRREGULAR_WHITESPACE","IRREGULAR_LINE_TERMINATORS","LINE_BREAK","createGlobalLinebreakMatcher","module","exports","meta","type","docs","description","recommended","url","schema","properties","skipComments","default","skipStrings","skipTemplates","skipRegExps","additionalProperties","messages","noIrregularWhitespace","create","context","errors","options","sourceCode","getSourceCode","commentNodes","getAllComments","removeWhitespaceError","node","locStart","loc","start","locEnd","end","filter","errorLocStart","line","column","removeInvalidNodeErrorsInIdentifierOrLiteral","shouldCheckStrings","value","shouldCheckRegExps","Boolean","regex","test","raw","removeInvalidNodeErrorsInTemplateLiteral","removeInvalidNodeErrorsInComment","checkForIrregularWhitespace","sourceLines","lines","forEach","sourceLine","lineIndex","lineNumber","match","exec","push","messageId","index","length","checkForIrregularLineTerminators","source","getText","linebreaks","lastLineIndex","indexOf","noop","nodes","Program","Identifier","Literal","TemplateElement","error","report"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\r\n * @author Jonathan Kingston\r\n * @author Christophe Porteneuve\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\r\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\r\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\r\nconst LINE_BREAK = astUtils.createGlobalLinebreakMatcher();\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow irregular whitespace\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-irregular-whitespace\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    skipComments: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    skipStrings: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    skipTemplates: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    skipRegExps: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            noIrregularWhitespace: \"Irregular whitespace not allowed.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        // Module store of errors that we have found\r\n        let errors = [];\r\n\r\n        // Lookup the `skipComments` option, which defaults to `false`.\r\n        const options = context.options[0] || {};\r\n        const skipComments = !!options.skipComments;\r\n        const skipStrings = options.skipStrings !== false;\r\n        const skipRegExps = !!options.skipRegExps;\r\n        const skipTemplates = !!options.skipTemplates;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n        const commentNodes = sourceCode.getAllComments();\r\n\r\n        /**\r\n         * Removes errors that occur inside the given node\r\n         * @param {ASTNode} node to check for matching errors.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function removeWhitespaceError(node) {\r\n            const locStart = node.loc.start;\r\n            const locEnd = node.loc.end;\r\n\r\n            errors = errors.filter(({ loc: { start: errorLocStart } }) => (\r\n                errorLocStart.line < locStart.line ||\r\n                errorLocStart.line === locStart.line && errorLocStart.column < locStart.column ||\r\n                errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column ||\r\n                errorLocStart.line > locEnd.line\r\n            ));\r\n        }\r\n\r\n        /**\r\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n         * @param {ASTNode} node to check for matching errors.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\r\n            const shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\r\n            const shouldCheckRegExps = skipRegExps && Boolean(node.regex);\r\n\r\n            if (shouldCheckStrings || shouldCheckRegExps) {\r\n\r\n                // If we have irregular characters remove them from the errors list\r\n                if (ALL_IRREGULARS.test(node.raw)) {\r\n                    removeWhitespaceError(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n         * @param {ASTNode} node to check for matching errors.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\r\n            if (typeof node.value.raw === \"string\") {\r\n                if (ALL_IRREGULARS.test(node.value.raw)) {\r\n                    removeWhitespaceError(node);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\r\n         * @param {ASTNode} node to check for matching errors.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function removeInvalidNodeErrorsInComment(node) {\r\n            if (ALL_IRREGULARS.test(node.value)) {\r\n                removeWhitespaceError(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the program source for irregular whitespace\r\n         * @param {ASTNode} node The program node\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForIrregularWhitespace(node) {\r\n            const sourceLines = sourceCode.lines;\r\n\r\n            sourceLines.forEach((sourceLine, lineIndex) => {\r\n                const lineNumber = lineIndex + 1;\r\n                let match;\r\n\r\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\r\n                    errors.push({\r\n                        node,\r\n                        messageId: \"noIrregularWhitespace\",\r\n                        loc: {\r\n                            start: {\r\n                                line: lineNumber,\r\n                                column: match.index\r\n                            },\r\n                            end: {\r\n                                line: lineNumber,\r\n                                column: match.index + match[0].length\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks the program source for irregular line terminators\r\n         * @param {ASTNode} node The program node\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkForIrregularLineTerminators(node) {\r\n            const source = sourceCode.getText(),\r\n                sourceLines = sourceCode.lines,\r\n                linebreaks = source.match(LINE_BREAK);\r\n            let lastLineIndex = -1,\r\n                match;\r\n\r\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\r\n                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\r\n\r\n                errors.push({\r\n                    node,\r\n                    messageId: \"noIrregularWhitespace\",\r\n                    loc: {\r\n                        start: {\r\n                            line: lineIndex + 1,\r\n                            column: sourceLines[lineIndex].length\r\n                        },\r\n                        end: {\r\n                            line: lineIndex + 2,\r\n                            column: 0\r\n                        }\r\n                    }\r\n                });\r\n\r\n                lastLineIndex = lineIndex;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function noop() {}\r\n\r\n        const nodes = {};\r\n\r\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\r\n            nodes.Program = function(node) {\r\n\r\n                /*\r\n                 * As we can easily fire warnings for all white space issues with\r\n                 * all the source its simpler to fire them here.\r\n                 * This means we can check all the application code without having\r\n                 * to worry about issues caused in the parser tokens.\r\n                 * When writing this code also evaluating per node was missing out\r\n                 * connecting tokens in some cases.\r\n                 * We can later filter the errors when they are found to be not an\r\n                 * issue in nodes we don't care about.\r\n                 */\r\n                checkForIrregularWhitespace(node);\r\n                checkForIrregularLineTerminators(node);\r\n            };\r\n\r\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\r\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\r\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\r\n            nodes[\"Program:exit\"] = function() {\r\n                if (skipComments) {\r\n\r\n                    // First strip errors occurring in comment nodes.\r\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\r\n                }\r\n\r\n                // If we have any errors remaining report on them\r\n                errors.forEach(error => context.report(error));\r\n            };\r\n        } else {\r\n            nodes.Program = noop;\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}