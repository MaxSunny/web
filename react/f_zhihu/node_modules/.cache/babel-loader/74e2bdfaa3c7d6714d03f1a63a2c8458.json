{"ast":null,"code":"/**\r\n * @fileoverview Ensures that the results of typeof are compared against a valid string\r\n * @author Ian Christian Myers\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce comparing `typeof` expressions against valid strings\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/valid-typeof\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      type: \"object\",\n      properties: {\n        requireStringLiterals: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      invalidValue: \"Invalid typeof comparison value.\",\n      notString: \"Typeof comparisons should be to string literals.\",\n      suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\n    }\n  },\n\n  create(context) {\n    const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\n          OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n    const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\n    let globalScope;\n    /**\r\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n     * @param {ASTNode} node `Identifier` node to check.\r\n     * @returns {boolean} `true` if the node is a reference to a global variable.\r\n     */\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\r\n     * Determines whether a node is a typeof expression.\r\n     * @param {ASTNode} node The node\r\n     * @returns {boolean} `true` if the node is a typeof expression\r\n     */\n\n\n    function isTypeofExpression(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      UnaryExpression(node) {\n        if (isTypeofExpression(node)) {\n          const parent = context.getAncestors().pop();\n\n          if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n            const sibling = parent.left === node ? parent.right : parent.left;\n\n            if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\n              const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\n\n              if (VALID_TYPES.indexOf(value) === -1) {\n                context.report({\n                  node: sibling,\n                  messageId: \"invalidValue\"\n                });\n              }\n            } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\n                suggest: [{\n                  messageId: \"suggestString\",\n                  data: {\n                    type: \"undefined\"\n                  },\n\n                  fix(fixer) {\n                    return fixer.replaceText(sibling, '\"undefined\"');\n                  }\n\n                }]\n              });\n            } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\n              context.report({\n                node: sibling,\n                messageId: \"notString\"\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/valid-typeof.js"],"names":["module","exports","meta","type","docs","description","recommended","url","hasSuggestions","schema","properties","requireStringLiterals","default","additionalProperties","messages","invalidValue","notString","suggestString","create","context","VALID_TYPES","OPERATORS","options","globalScope","isReferenceToGlobalVariable","node","variable","set","get","name","defs","length","references","some","ref","identifier","isTypeofExpression","operator","Program","getScope","UnaryExpression","parent","getAncestors","pop","indexOf","sibling","left","right","expressions","value","quasis","cooked","report","messageId","suggest","data","fix","fixer","replaceText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Ensures that the results of typeof are compared against a valid string\r\n * @author Ian Christian Myers\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"enforce comparing `typeof` expressions against valid strings\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/valid-typeof\"\r\n        },\r\n\r\n        hasSuggestions: true,\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    requireStringLiterals: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            invalidValue: \"Invalid typeof comparison value.\",\r\n            notString: \"Typeof comparisons should be to string literals.\",\r\n            suggestString: 'Use `\"{{type}}\"` instead of `{{type}}`.'\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\", \"bigint\"],\r\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\r\n\r\n        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;\r\n\r\n        let globalScope;\r\n\r\n        /**\r\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n         * @param {ASTNode} node `Identifier` node to check.\r\n         * @returns {boolean} `true` if the node is a reference to a global variable.\r\n         */\r\n        function isReferenceToGlobalVariable(node) {\r\n            const variable = globalScope.set.get(node.name);\r\n\r\n            return variable && variable.defs.length === 0 &&\r\n                variable.references.some(ref => ref.identifier === node);\r\n        }\r\n\r\n        /**\r\n         * Determines whether a node is a typeof expression.\r\n         * @param {ASTNode} node The node\r\n         * @returns {boolean} `true` if the node is a typeof expression\r\n         */\r\n        function isTypeofExpression(node) {\r\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            Program() {\r\n                globalScope = context.getScope();\r\n            },\r\n\r\n            UnaryExpression(node) {\r\n                if (isTypeofExpression(node)) {\r\n                    const parent = context.getAncestors().pop();\r\n\r\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\r\n                        const sibling = parent.left === node ? parent.right : parent.left;\r\n\r\n                        if (sibling.type === \"Literal\" || sibling.type === \"TemplateLiteral\" && !sibling.expressions.length) {\r\n                            const value = sibling.type === \"Literal\" ? sibling.value : sibling.quasis[0].value.cooked;\r\n\r\n                            if (VALID_TYPES.indexOf(value) === -1) {\r\n                                context.report({ node: sibling, messageId: \"invalidValue\" });\r\n                            }\r\n                        } else if (sibling.type === \"Identifier\" && sibling.name === \"undefined\" && isReferenceToGlobalVariable(sibling)) {\r\n                            context.report({\r\n                                node: sibling,\r\n                                messageId: requireStringLiterals ? \"notString\" : \"invalidValue\",\r\n                                suggest: [\r\n                                    {\r\n                                        messageId: \"suggestString\",\r\n                                        data: { type: \"undefined\" },\r\n                                        fix(fixer) {\r\n                                            return fixer.replaceText(sibling, '\"undefined\"');\r\n                                        }\r\n                                    }\r\n                                ]\r\n                            });\r\n                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {\r\n                            context.report({ node: sibling, messageId: \"notString\" });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}