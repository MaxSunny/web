{"ast":null,"code":"/**\r\n * @fileoverview A class of the code path.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst CodePathState = require(\"./code-path-state\");\n\nconst IdGenerator = require(\"./id-generator\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * A code path.\r\n */\n\n\nclass CodePath {\n  /**\r\n   * Creates a new instance.\r\n   * @param {Object} options Options for the function (see below).\r\n   * @param {string} options.id An identifier.\r\n   * @param {string} options.origin The type of code path origin.\r\n   * @param {CodePath|null} options.upper The code path of the upper function scope.\r\n   * @param {Function} options.onLooped A callback function to notify looping.\r\n   */\n  constructor(_ref) {\n    let {\n      id,\n      origin,\n      upper,\n      onLooped\n    } = _ref;\n\n    /**\r\n     * The identifier of this code path.\r\n     * Rules use it to store additional information of each rule.\r\n     * @type {string}\r\n     */\n    this.id = id;\n    /**\r\n     * The reason that this code path was started. May be \"program\",\r\n     * \"function\", \"class-field-initializer\", or \"class-static-block\".\r\n     * @type {string}\r\n     */\n\n    this.origin = origin;\n    /**\r\n     * The code path of the upper function scope.\r\n     * @type {CodePath|null}\r\n     */\n\n    this.upper = upper;\n    /**\r\n     * The code paths of nested function scopes.\r\n     * @type {CodePath[]}\r\n     */\n\n    this.childCodePaths = []; // Initializes internal state.\n\n    Object.defineProperty(this, \"internal\", {\n      value: new CodePathState(new IdGenerator(`${id}_`), onLooped)\n    }); // Adds this into `childCodePaths` of `upper`.\n\n    if (upper) {\n      upper.childCodePaths.push(this);\n    }\n  }\n  /**\r\n   * Gets the state of a given code path.\r\n   * @param {CodePath} codePath A code path to get.\r\n   * @returns {CodePathState} The state of the code path.\r\n   */\n\n\n  static getState(codePath) {\n    return codePath.internal;\n  }\n  /**\r\n   * The initial code path segment.\r\n   * @type {CodePathSegment}\r\n   */\n\n\n  get initialSegment() {\n    return this.internal.initialSegment;\n  }\n  /**\r\n   * Final code path segments.\r\n   * This array is a mix of `returnedSegments` and `thrownSegments`.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get finalSegments() {\n    return this.internal.finalSegments;\n  }\n  /**\r\n   * Final code path segments which is with `return` statements.\r\n   * This array contains the last path segment if it's reachable.\r\n   * Since the reachable last path returns `undefined`.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get returnedSegments() {\n    return this.internal.returnedForkContext;\n  }\n  /**\r\n   * Final code path segments which is with `throw` statements.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get thrownSegments() {\n    return this.internal.thrownForkContext;\n  }\n  /**\r\n   * Current code path segments.\r\n   * @type {CodePathSegment[]}\r\n   */\n\n\n  get currentSegments() {\n    return this.internal.currentSegments;\n  }\n  /**\r\n   * Traverses all segments in this code path.\r\n   *\r\n   *     codePath.traverseSegments(function(segment, controller) {\r\n   *         // do something.\r\n   *     });\r\n   *\r\n   * This method enumerates segments in order from the head.\r\n   *\r\n   * The `controller` object has two methods.\r\n   *\r\n   * - `controller.skip()` - Skip the following segments in this branch.\r\n   * - `controller.break()` - Skip all following segments.\r\n   * @param {Object} [options] Omittable.\r\n   * @param {CodePathSegment} [options.first] The first segment to traverse.\r\n   * @param {CodePathSegment} [options.last] The last segment to traverse.\r\n   * @param {Function} callback A callback function.\r\n   * @returns {void}\r\n   */\n\n\n  traverseSegments(options, callback) {\n    let resolvedOptions;\n    let resolvedCallback;\n\n    if (typeof options === \"function\") {\n      resolvedCallback = options;\n      resolvedOptions = {};\n    } else {\n      resolvedOptions = options || {};\n      resolvedCallback = callback;\n    }\n\n    const startSegment = resolvedOptions.first || this.internal.initialSegment;\n    const lastSegment = resolvedOptions.last;\n    let item = null;\n    let index = 0;\n    let end = 0;\n    let segment = null;\n    const visited = Object.create(null);\n    const stack = [[startSegment, 0]];\n    let skippedSegment = null;\n    let broken = false;\n    const controller = {\n      skip() {\n        if (stack.length <= 1) {\n          broken = true;\n        } else {\n          skippedSegment = stack[stack.length - 2][0];\n        }\n      },\n\n      break() {\n        broken = true;\n      }\n\n    };\n    /**\r\n     * Checks a given previous segment has been visited.\r\n     * @param {CodePathSegment} prevSegment A previous segment to check.\r\n     * @returns {boolean} `true` if the segment has been visited.\r\n     */\n\n    function isVisited(prevSegment) {\n      return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);\n    }\n\n    while (stack.length > 0) {\n      item = stack[stack.length - 1];\n      segment = item[0];\n      index = item[1];\n\n      if (index === 0) {\n        // Skip if this segment has been visited already.\n        if (visited[segment.id]) {\n          stack.pop();\n          continue;\n        } // Skip if all previous segments have not been visited.\n\n\n        if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {\n          stack.pop();\n          continue;\n        } // Reset the flag of skipping if all branches have been skipped.\n\n\n        if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n          skippedSegment = null;\n        }\n\n        visited[segment.id] = true; // Call the callback when the first time.\n\n        if (!skippedSegment) {\n          resolvedCallback.call(this, segment, controller);\n\n          if (segment === lastSegment) {\n            controller.skip();\n          }\n\n          if (broken) {\n            break;\n          }\n        }\n      } // Update the stack.\n\n\n      end = segment.nextSegments.length - 1;\n\n      if (index < end) {\n        item[1] += 1;\n        stack.push([segment.nextSegments[index], 0]);\n      } else if (index === end) {\n        item[0] = segment.nextSegments[index];\n        item[1] = 0;\n      } else {\n        stack.pop();\n      }\n    }\n  }\n\n}\n\nmodule.exports = CodePath;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/code-path.js"],"names":["CodePathState","require","IdGenerator","CodePath","constructor","id","origin","upper","onLooped","childCodePaths","Object","defineProperty","value","push","getState","codePath","internal","initialSegment","finalSegments","returnedSegments","returnedForkContext","thrownSegments","thrownForkContext","currentSegments","traverseSegments","options","callback","resolvedOptions","resolvedCallback","startSegment","first","lastSegment","last","item","index","end","segment","visited","create","stack","skippedSegment","broken","controller","skip","length","break","isVisited","prevSegment","isLoopedPrevSegment","pop","prevSegments","every","indexOf","call","nextSegments","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A class of the code path.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst CodePathState = require(\"./code-path-state\");\r\nconst IdGenerator = require(\"./id-generator\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * A code path.\r\n */\r\nclass CodePath {\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     * @param {Object} options Options for the function (see below).\r\n     * @param {string} options.id An identifier.\r\n     * @param {string} options.origin The type of code path origin.\r\n     * @param {CodePath|null} options.upper The code path of the upper function scope.\r\n     * @param {Function} options.onLooped A callback function to notify looping.\r\n     */\r\n    constructor({ id, origin, upper, onLooped }) {\r\n\r\n        /**\r\n         * The identifier of this code path.\r\n         * Rules use it to store additional information of each rule.\r\n         * @type {string}\r\n         */\r\n        this.id = id;\r\n\r\n        /**\r\n         * The reason that this code path was started. May be \"program\",\r\n         * \"function\", \"class-field-initializer\", or \"class-static-block\".\r\n         * @type {string}\r\n         */\r\n        this.origin = origin;\r\n\r\n        /**\r\n         * The code path of the upper function scope.\r\n         * @type {CodePath|null}\r\n         */\r\n        this.upper = upper;\r\n\r\n        /**\r\n         * The code paths of nested function scopes.\r\n         * @type {CodePath[]}\r\n         */\r\n        this.childCodePaths = [];\r\n\r\n        // Initializes internal state.\r\n        Object.defineProperty(\r\n            this,\r\n            \"internal\",\r\n            { value: new CodePathState(new IdGenerator(`${id}_`), onLooped) }\r\n        );\r\n\r\n        // Adds this into `childCodePaths` of `upper`.\r\n        if (upper) {\r\n            upper.childCodePaths.push(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the state of a given code path.\r\n     * @param {CodePath} codePath A code path to get.\r\n     * @returns {CodePathState} The state of the code path.\r\n     */\r\n    static getState(codePath) {\r\n        return codePath.internal;\r\n    }\r\n\r\n    /**\r\n     * The initial code path segment.\r\n     * @type {CodePathSegment}\r\n     */\r\n    get initialSegment() {\r\n        return this.internal.initialSegment;\r\n    }\r\n\r\n    /**\r\n     * Final code path segments.\r\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get finalSegments() {\r\n        return this.internal.finalSegments;\r\n    }\r\n\r\n    /**\r\n     * Final code path segments which is with `return` statements.\r\n     * This array contains the last path segment if it's reachable.\r\n     * Since the reachable last path returns `undefined`.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get returnedSegments() {\r\n        return this.internal.returnedForkContext;\r\n    }\r\n\r\n    /**\r\n     * Final code path segments which is with `throw` statements.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get thrownSegments() {\r\n        return this.internal.thrownForkContext;\r\n    }\r\n\r\n    /**\r\n     * Current code path segments.\r\n     * @type {CodePathSegment[]}\r\n     */\r\n    get currentSegments() {\r\n        return this.internal.currentSegments;\r\n    }\r\n\r\n    /**\r\n     * Traverses all segments in this code path.\r\n     *\r\n     *     codePath.traverseSegments(function(segment, controller) {\r\n     *         // do something.\r\n     *     });\r\n     *\r\n     * This method enumerates segments in order from the head.\r\n     *\r\n     * The `controller` object has two methods.\r\n     *\r\n     * - `controller.skip()` - Skip the following segments in this branch.\r\n     * - `controller.break()` - Skip all following segments.\r\n     * @param {Object} [options] Omittable.\r\n     * @param {CodePathSegment} [options.first] The first segment to traverse.\r\n     * @param {CodePathSegment} [options.last] The last segment to traverse.\r\n     * @param {Function} callback A callback function.\r\n     * @returns {void}\r\n     */\r\n    traverseSegments(options, callback) {\r\n        let resolvedOptions;\r\n        let resolvedCallback;\r\n\r\n        if (typeof options === \"function\") {\r\n            resolvedCallback = options;\r\n            resolvedOptions = {};\r\n        } else {\r\n            resolvedOptions = options || {};\r\n            resolvedCallback = callback;\r\n        }\r\n\r\n        const startSegment = resolvedOptions.first || this.internal.initialSegment;\r\n        const lastSegment = resolvedOptions.last;\r\n\r\n        let item = null;\r\n        let index = 0;\r\n        let end = 0;\r\n        let segment = null;\r\n        const visited = Object.create(null);\r\n        const stack = [[startSegment, 0]];\r\n        let skippedSegment = null;\r\n        let broken = false;\r\n        const controller = {\r\n            skip() {\r\n                if (stack.length <= 1) {\r\n                    broken = true;\r\n                } else {\r\n                    skippedSegment = stack[stack.length - 2][0];\r\n                }\r\n            },\r\n            break() {\r\n                broken = true;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Checks a given previous segment has been visited.\r\n         * @param {CodePathSegment} prevSegment A previous segment to check.\r\n         * @returns {boolean} `true` if the segment has been visited.\r\n         */\r\n        function isVisited(prevSegment) {\r\n            return (\r\n                visited[prevSegment.id] ||\r\n                segment.isLoopedPrevSegment(prevSegment)\r\n            );\r\n        }\r\n\r\n        while (stack.length > 0) {\r\n            item = stack[stack.length - 1];\r\n            segment = item[0];\r\n            index = item[1];\r\n\r\n            if (index === 0) {\r\n\r\n                // Skip if this segment has been visited already.\r\n                if (visited[segment.id]) {\r\n                    stack.pop();\r\n                    continue;\r\n                }\r\n\r\n                // Skip if all previous segments have not been visited.\r\n                if (segment !== startSegment &&\r\n                    segment.prevSegments.length > 0 &&\r\n                    !segment.prevSegments.every(isVisited)\r\n                ) {\r\n                    stack.pop();\r\n                    continue;\r\n                }\r\n\r\n                // Reset the flag of skipping if all branches have been skipped.\r\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\r\n                    skippedSegment = null;\r\n                }\r\n                visited[segment.id] = true;\r\n\r\n                // Call the callback when the first time.\r\n                if (!skippedSegment) {\r\n                    resolvedCallback.call(this, segment, controller);\r\n                    if (segment === lastSegment) {\r\n                        controller.skip();\r\n                    }\r\n                    if (broken) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update the stack.\r\n            end = segment.nextSegments.length - 1;\r\n            if (index < end) {\r\n                item[1] += 1;\r\n                stack.push([segment.nextSegments[index], 0]);\r\n            } else if (index === end) {\r\n                item[0] = segment.nextSegments[index];\r\n                item[1] = 0;\r\n            } else {\r\n                stack.pop();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = CodePath;\r\n"]},"metadata":{},"sourceType":"script"}