{"ast":null,"code":"/**\r\n * @fileoverview Rule to replace assignment expressions with operator assignment\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether an operator is commutative and has an operator assignment\r\n * shorthand form.\r\n * @param {string} operator Operator to check.\r\n * @returns {boolean} True if the operator is commutative and has a\r\n *     shorthand form.\r\n */\n\n\nfunction isCommutativeOperatorWithShorthand(operator) {\n  return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n/**\r\n * Checks whether an operator is not commutative and has an operator assignment\r\n * shorthand form.\r\n * @param {string} operator Operator to check.\r\n * @returns {boolean} True if the operator is not commutative and has\r\n *     a shorthand form.\r\n */\n\n\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n  return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\r\n * toString calls regardless of whether assignment shorthand is used)\r\n * @param {ASTNode} node The node on the left side of the expression\r\n * @returns {boolean} `true` if the node can be fixed\r\n */\n\n\nfunction canBeFixed(node) {\n  return node.type === \"Identifier\" || node.type === \"MemberExpression\" && (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") && (!node.computed || node.property.type === \"Literal\");\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow assignment operator shorthand where possible\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/operator-assignment\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }],\n    fixable: \"code\",\n    messages: {\n      replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}=).\",\n      unexpected: \"Unexpected operator assignment ({{operator}}=) shorthand.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Returns the operator token of an AssignmentExpression or BinaryExpression\r\n     * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\r\n     * @returns {Token} The operator token in the node\r\n     */\n\n    function getOperatorToken(node) {\n      return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n    }\n    /**\r\n     * Ensures that an assignment uses the shorthand form where possible.\r\n     * @param {ASTNode} node An AssignmentExpression node.\r\n     * @returns {void}\r\n     */\n\n\n    function verify(node) {\n      if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n        return;\n      }\n\n      const left = node.left;\n      const expr = node.right;\n      const operator = expr.operator;\n\n      if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\n        if (astUtils.isSameReference(left, expr.left, true)) {\n          context.report({\n            node,\n            messageId: \"replaced\",\n            data: {\n              operator\n            },\n\n            fix(fixer) {\n              if (canBeFixed(left) && canBeFixed(expr.left)) {\n                const equalsToken = getOperatorToken(node);\n                const operatorToken = getOperatorToken(expr);\n                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\n                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]); // Check for comments that would be removed.\n\n                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\n              }\n\n              return null;\n            }\n\n          });\n        } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\n          /*\r\n           * This case can't be fixed safely.\r\n           * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\r\n           * change the execution order of the valueOf() functions.\r\n           */\n          context.report({\n            node,\n            messageId: \"replaced\",\n            data: {\n              operator\n            }\n          });\n        }\n      }\n    }\n    /**\r\n     * Warns if an assignment expression uses operator assignment shorthand.\r\n     * @param {ASTNode} node An AssignmentExpression node.\r\n     * @returns {void}\r\n     */\n\n\n    function prohibit(node) {\n      if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\n        context.report({\n          node,\n          messageId: \"unexpected\",\n          data: {\n            operator: node.operator\n          },\n\n          fix(fixer) {\n            if (canBeFixed(node.left)) {\n              const firstToken = sourceCode.getFirstToken(node);\n              const operatorToken = getOperatorToken(node);\n              const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\n              const newOperator = node.operator.slice(0, -1);\n              let rightText; // Check for comments that would be duplicated.\n\n              if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\n                return null;\n              } // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\n\n\n              if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({\n                type: \"BinaryExpression\",\n                operator: newOperator\n              }) && !astUtils.isParenthesised(sourceCode, node.right)) {\n                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\n              } else {\n                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, {\n                  includeComments: true\n                });\n                let rightTextPrefix = \"\";\n\n                if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({\n                  type: \"Punctuator\",\n                  value: newOperator\n                }, tokenAfterOperator)) {\n                  rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\n                }\n\n                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\n              }\n\n              return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\n            }\n\n            return null;\n          }\n\n        });\n      }\n    }\n\n    return {\n      AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/operator-assignment.js"],"names":["astUtils","require","isCommutativeOperatorWithShorthand","operator","indexOf","isNonCommutativeOperatorWithShorthand","canBeFixed","node","type","object","computed","property","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","replaced","unexpected","create","context","sourceCode","getSourceCode","getOperatorToken","getFirstTokenBetween","left","right","token","value","verify","expr","isSameReference","report","messageId","data","fix","fixer","equalsToken","operatorToken","leftText","getText","slice","range","rightText","commentsExistBetween","replaceText","prohibit","isLogicalAssignmentOperator","firstToken","getFirstToken","newOperator","getPrecedence","isParenthesised","text","tokenAfterOperator","getTokenAfter","includeComments","rightTextPrefix","canTokensBeAdjacent","AssignmentExpression","options"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to replace assignment expressions with operator assignment\r\n * @author Brandon Mills\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether an operator is commutative and has an operator assignment\r\n * shorthand form.\r\n * @param {string} operator Operator to check.\r\n * @returns {boolean} True if the operator is commutative and has a\r\n *     shorthand form.\r\n */\r\nfunction isCommutativeOperatorWithShorthand(operator) {\r\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\r\n}\r\n\r\n/**\r\n * Checks whether an operator is not commutative and has an operator assignment\r\n * shorthand form.\r\n * @param {string} operator Operator to check.\r\n * @returns {boolean} True if the operator is not commutative and has\r\n *     a shorthand form.\r\n */\r\nfunction isNonCommutativeOperatorWithShorthand(operator) {\r\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\", \"**\"].indexOf(operator) >= 0;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)\r\n * toString calls regardless of whether assignment shorthand is used)\r\n * @param {ASTNode} node The node on the left side of the expression\r\n * @returns {boolean} `true` if the node can be fixed\r\n */\r\nfunction canBeFixed(node) {\r\n    return (\r\n        node.type === \"Identifier\" ||\r\n        (\r\n            node.type === \"MemberExpression\" &&\r\n            (node.object.type === \"Identifier\" || node.object.type === \"ThisExpression\") &&\r\n            (!node.computed || node.property.type === \"Literal\")\r\n        )\r\n    );\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require or disallow assignment operator shorthand where possible\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/operator-assignment\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\"]\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            replaced: \"Assignment (=) can be replaced with operator assignment ({{operator}}=).\",\r\n            unexpected: \"Unexpected operator assignment ({{operator}}=) shorthand.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Returns the operator token of an AssignmentExpression or BinaryExpression\r\n         * @param {ASTNode} node An AssignmentExpression or BinaryExpression node\r\n         * @returns {Token} The operator token in the node\r\n         */\r\n        function getOperatorToken(node) {\r\n            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\r\n        }\r\n\r\n        /**\r\n         * Ensures that an assignment uses the shorthand form where possible.\r\n         * @param {ASTNode} node An AssignmentExpression node.\r\n         * @returns {void}\r\n         */\r\n        function verify(node) {\r\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\r\n                return;\r\n            }\r\n\r\n            const left = node.left;\r\n            const expr = node.right;\r\n            const operator = expr.operator;\r\n\r\n            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {\r\n                if (astUtils.isSameReference(left, expr.left, true)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"replaced\",\r\n                        data: { operator },\r\n                        fix(fixer) {\r\n                            if (canBeFixed(left) && canBeFixed(expr.left)) {\r\n                                const equalsToken = getOperatorToken(node);\r\n                                const operatorToken = getOperatorToken(expr);\r\n                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);\r\n                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);\r\n\r\n                                // Check for comments that would be removed.\r\n                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {\r\n                                    return null;\r\n                                }\r\n\r\n                                return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {\r\n\r\n                    /*\r\n                     * This case can't be fixed safely.\r\n                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would\r\n                     * change the execution order of the valueOf() functions.\r\n                     */\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"replaced\",\r\n                        data: { operator }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Warns if an assignment expression uses operator assignment shorthand.\r\n         * @param {ASTNode} node An AssignmentExpression node.\r\n         * @returns {void}\r\n         */\r\n        function prohibit(node) {\r\n            if (node.operator !== \"=\" && !astUtils.isLogicalAssignmentOperator(node.operator)) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpected\",\r\n                    data: { operator: node.operator },\r\n                    fix(fixer) {\r\n                        if (canBeFixed(node.left)) {\r\n                            const firstToken = sourceCode.getFirstToken(node);\r\n                            const operatorToken = getOperatorToken(node);\r\n                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);\r\n                            const newOperator = node.operator.slice(0, -1);\r\n                            let rightText;\r\n\r\n                            // Check for comments that would be duplicated.\r\n                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {\r\n                                return null;\r\n                            }\r\n\r\n                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.\r\n                            if (\r\n                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: \"BinaryExpression\", operator: newOperator }) &&\r\n                                !astUtils.isParenthesised(sourceCode, node.right)\r\n                            ) {\r\n                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;\r\n                            } else {\r\n                                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true });\r\n                                let rightTextPrefix = \"\";\r\n\r\n                                if (\r\n                                    operatorToken.range[1] === tokenAfterOperator.range[0] &&\r\n                                    !astUtils.canTokensBeAdjacent({ type: \"Punctuator\", value: newOperator }, tokenAfterOperator)\r\n                                ) {\r\n                                    rightTextPrefix = \" \"; // foo+=+bar -> foo= foo+ +bar\r\n                                }\r\n\r\n                                rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;\r\n                            }\r\n\r\n                            return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);\r\n                        }\r\n                        return null;\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}