{"ast":null,"code":"/**\r\n * @fileoverview Rule to forbid control characters from regular expressions.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\";\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\n\nconst collector = new class {\n  constructor() {\n    this._source = \"\";\n    this._controlChars = [];\n    this._validator = new RegExpValidator(this);\n  }\n\n  onPatternEnter() {\n    this._controlChars = [];\n  }\n\n  onCharacter(start, end, cp) {\n    if (cp >= 0x00 && cp <= 0x1F && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith(\"\\\\x\") || this._source.slice(start, end).startsWith(\"\\\\u\"))) {\n      this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\n    }\n  }\n\n  collectControlChars(regexpStr) {\n    try {\n      this._source = regexpStr;\n\n      this._validator.validatePattern(regexpStr); // Call onCharacter hook\n\n    } catch {// Ignore syntax errors in RegExp.\n    }\n\n    return this._controlChars;\n  }\n\n}(); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow control characters in regular expressions\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-control-regex\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Get the regex expression\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {RegExp|null} Regex if found else null\r\n     * @private\r\n     */\n    function getRegExpPattern(node) {\n      if (node.regex) {\n        return node.regex.pattern;\n      }\n\n      if (typeof node.value === \"string\" && (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") && node.parent.callee.type === \"Identifier\" && node.parent.callee.name === \"RegExp\" && node.parent.arguments[0] === node) {\n        return node.value;\n      }\n\n      return null;\n    }\n\n    return {\n      Literal(node) {\n        const pattern = getRegExpPattern(node);\n\n        if (pattern) {\n          const controlCharacters = collector.collectControlChars(pattern);\n\n          if (controlCharacters.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpected\",\n              data: {\n                controlChars: controlCharacters.join(\", \")\n              }\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-control-regex.js"],"names":["RegExpValidator","require","collector","constructor","_source","_controlChars","_validator","onPatternEnter","onCharacter","start","end","cp","codePointAt","slice","startsWith","push","toString","collectControlChars","regexpStr","validatePattern","module","exports","meta","type","docs","description","recommended","url","schema","messages","unexpected","create","context","getRegExpPattern","node","regex","pattern","value","parent","callee","name","arguments","Literal","controlCharacters","length","report","messageId","data","controlChars","join"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to forbid control characters from regular expressions.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\r\nconst collector = new (class {\r\n    constructor() {\r\n        this._source = \"\";\r\n        this._controlChars = [];\r\n        this._validator = new RegExpValidator(this);\r\n    }\r\n\r\n    onPatternEnter() {\r\n        this._controlChars = [];\r\n    }\r\n\r\n    onCharacter(start, end, cp) {\r\n        if (cp >= 0x00 &&\r\n            cp <= 0x1F &&\r\n            (\r\n                this._source.codePointAt(start) === cp ||\r\n                this._source.slice(start, end).startsWith(\"\\\\x\") ||\r\n                this._source.slice(start, end).startsWith(\"\\\\u\")\r\n            )\r\n        ) {\r\n            this._controlChars.push(`\\\\x${`0${cp.toString(16)}`.slice(-2)}`);\r\n        }\r\n    }\r\n\r\n    collectControlChars(regexpStr) {\r\n        try {\r\n            this._source = regexpStr;\r\n            this._validator.validatePattern(regexpStr); // Call onCharacter hook\r\n        } catch {\r\n\r\n            // Ignore syntax errors in RegExp.\r\n        }\r\n        return this._controlChars;\r\n    }\r\n})();\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow control characters in regular expressions\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-control-regex\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unexpected: \"Unexpected control character(s) in regular expression: {{controlChars}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Get the regex expression\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {RegExp|null} Regex if found else null\r\n         * @private\r\n         */\r\n        function getRegExpPattern(node) {\r\n            if (node.regex) {\r\n                return node.regex.pattern;\r\n            }\r\n            if (typeof node.value === \"string\" &&\r\n                (node.parent.type === \"NewExpression\" || node.parent.type === \"CallExpression\") &&\r\n                node.parent.callee.type === \"Identifier\" &&\r\n                node.parent.callee.name === \"RegExp\" &&\r\n                node.parent.arguments[0] === node\r\n            ) {\r\n                return node.value;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            Literal(node) {\r\n                const pattern = getRegExpPattern(node);\r\n\r\n                if (pattern) {\r\n                    const controlCharacters = collector.collectControlChars(pattern);\r\n\r\n                    if (controlCharacters.length > 0) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"unexpected\",\r\n                            data: {\r\n                                controlChars: controlCharacters.join(\", \")\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}