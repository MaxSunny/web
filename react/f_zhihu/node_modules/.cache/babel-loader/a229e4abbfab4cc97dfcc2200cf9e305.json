{"ast":null,"code":"/**\r\n * @fileoverview Comma style - enforces comma styles of two types: last and first\r\n * @author Vignesh Anand aka vegetableman\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent comma style\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/comma-style\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"first\", \"last\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\n      expectedCommaFirst: \"',' should be placed first.\",\n      expectedCommaLast: \"',' should be placed last.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"last\",\n          sourceCode = context.getSourceCode();\n    const exceptions = {\n      ArrayPattern: true,\n      ArrowFunctionExpression: true,\n      CallExpression: true,\n      FunctionDeclaration: true,\n      FunctionExpression: true,\n      ImportDeclaration: true,\n      ObjectPattern: true,\n      NewExpression: true\n    };\n\n    if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\n      const keys = Object.keys(context.options[1].exceptions);\n\n      for (let i = 0; i < keys.length; i++) {\n        exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\n      }\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Modified text based on the style\r\n     * @param {string} styleType Style type\r\n     * @param {string} text Source code text\r\n     * @returns {string} modified text\r\n     * @private\r\n     */\n\n\n    function getReplacedText(styleType, text) {\n      switch (styleType) {\n        case \"between\":\n          return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\n\n        case \"first\":\n          return `${text},`;\n\n        case \"last\":\n          return `,${text}`;\n\n        default:\n          return \"\";\n      }\n    }\n    /**\r\n     * Determines the fixer function for a given style.\r\n     * @param {string} styleType comma style\r\n     * @param {ASTNode} previousItemToken The token to check.\r\n     * @param {ASTNode} commaToken The token to check.\r\n     * @param {ASTNode} currentItemToken The token to check.\r\n     * @returns {Function} Fixer function\r\n     * @private\r\n     */\n\n\n    function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\n      const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\n      const range = [previousItemToken.range[1], currentItemToken.range[0]];\n      return function (fixer) {\n        return fixer.replaceTextRange(range, getReplacedText(styleType, text));\n      };\n    }\n    /**\r\n     * Validates the spacing around single items in lists.\r\n     * @param {Token} previousItemToken The last token from the previous item.\r\n     * @param {Token} commaToken The token representing the comma.\r\n     * @param {Token} currentItemToken The first token of the current item.\r\n     * @param {Token} reportItem The item to use when reporting an error.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\n      // if single line\n      if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {// do nothing.\n      } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\n        const comment = sourceCode.getCommentsAfter(commaToken)[0];\n        const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : \"between\"; // lone comma\n\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"unexpectedLineBeforeAndAfterComma\",\n          fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaFirst\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\n        context.report({\n          node: reportItem,\n          loc: commaToken.loc,\n          messageId: \"expectedCommaLast\",\n          fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\n        });\n      }\n    }\n    /**\r\n     * Checks the comma placement with regards to a declaration/property/element\r\n     * @param {ASTNode} node The binary expression node to check\r\n     * @param {string} property The property of the node containing child nodes.\r\n     * @private\r\n     * @returns {void}\r\n     */\n\n\n    function validateComma(node, property) {\n      const items = node[property],\n            arrayLiteral = node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\";\n\n      if (items.length > 1 || arrayLiteral) {\n        // seed as opening [\n        let previousItemToken = sourceCode.getFirstToken(node);\n        items.forEach(item => {\n          const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\n                currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\n                reportItem = item || currentItemToken;\n          /*\r\n           * This works by comparing three token locations:\r\n           * - previousItemToken is the last token of the previous item\r\n           * - commaToken is the location of the comma before the current item\r\n           * - currentItemToken is the first token of the current item\r\n           *\r\n           * These values get switched around if item is undefined.\r\n           * previousItemToken will refer to the last token not belonging\r\n           * to the current item, which could be a comma or an opening\r\n           * square bracket. currentItemToken could be a comma.\r\n           *\r\n           * All comparisons are done based on these tokens directly, so\r\n           * they are always valid regardless of an undefined item.\r\n           */\n\n          if (astUtils.isCommaToken(commaToken)) {\n            validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\n          }\n\n          if (item) {\n            const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\n            previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\n          } else {\n            previousItemToken = currentItemToken;\n          }\n        });\n        /*\r\n         * Special case for array literals that have empty last items, such\r\n         * as [ 1, 2, ]. These arrays only have two items show up in the\r\n         * AST, so we need to look at the token to verify that there's no\r\n         * dangling comma.\r\n         */\n\n        if (arrayLiteral) {\n          const lastToken = sourceCode.getLastToken(node),\n                nextToLastToken = sourceCode.getTokenBefore(lastToken);\n\n          if (astUtils.isCommaToken(nextToLastToken)) {\n            validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    const nodes = {};\n\n    if (!exceptions.VariableDeclaration) {\n      nodes.VariableDeclaration = function (node) {\n        validateComma(node, \"declarations\");\n      };\n    }\n\n    if (!exceptions.ObjectExpression) {\n      nodes.ObjectExpression = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ObjectPattern) {\n      nodes.ObjectPattern = function (node) {\n        validateComma(node, \"properties\");\n      };\n    }\n\n    if (!exceptions.ArrayExpression) {\n      nodes.ArrayExpression = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.ArrayPattern) {\n      nodes.ArrayPattern = function (node) {\n        validateComma(node, \"elements\");\n      };\n    }\n\n    if (!exceptions.FunctionDeclaration) {\n      nodes.FunctionDeclaration = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.FunctionExpression) {\n      nodes.FunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.ArrowFunctionExpression) {\n      nodes.ArrowFunctionExpression = function (node) {\n        validateComma(node, \"params\");\n      };\n    }\n\n    if (!exceptions.CallExpression) {\n      nodes.CallExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    if (!exceptions.ImportDeclaration) {\n      nodes.ImportDeclaration = function (node) {\n        validateComma(node, \"specifiers\");\n      };\n    }\n\n    if (!exceptions.NewExpression) {\n      nodes.NewExpression = function (node) {\n        validateComma(node, \"arguments\");\n      };\n    }\n\n    return nodes;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/comma-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","properties","exceptions","additionalProperties","messages","unexpectedLineBeforeAndAfterComma","expectedCommaFirst","expectedCommaLast","create","context","style","options","sourceCode","getSourceCode","ArrayPattern","ArrowFunctionExpression","CallExpression","FunctionDeclaration","FunctionExpression","ImportDeclaration","ObjectPattern","NewExpression","length","Object","prototype","hasOwnProperty","call","keys","i","getReplacedText","styleType","text","replace","LINEBREAK_MATCHER","getFixerFunction","previousItemToken","commaToken","currentItemToken","slice","range","fixer","replaceTextRange","validateCommaItemSpacing","reportItem","isTokenOnSameLine","comment","getCommentsAfter","report","node","loc","messageId","fix","validateComma","property","items","arrayLiteral","getFirstToken","forEach","item","getTokenBefore","getTokenAfter","isCommaToken","tokenAfterItem","isNotClosingParenToken","ast","tokens","lastToken","getLastToken","nextToLastToken","nodes","VariableDeclaration","ObjectExpression","ArrayExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Comma style - enforces comma styles of two types: last and first\r\n * @author Vignesh Anand aka vegetableman\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent comma style\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/comma-style\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"first\", \"last\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptions: {\r\n                        type: \"object\",\r\n                        additionalProperties: {\r\n                            type: \"boolean\"\r\n                        }\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedLineBeforeAndAfterComma: \"Bad line breaking before and after ','.\",\r\n            expectedCommaFirst: \"',' should be placed first.\",\r\n            expectedCommaLast: \"',' should be placed last.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const style = context.options[0] || \"last\",\r\n            sourceCode = context.getSourceCode();\r\n        const exceptions = {\r\n            ArrayPattern: true,\r\n            ArrowFunctionExpression: true,\r\n            CallExpression: true,\r\n            FunctionDeclaration: true,\r\n            FunctionExpression: true,\r\n            ImportDeclaration: true,\r\n            ObjectPattern: true,\r\n            NewExpression: true\r\n        };\r\n\r\n        if (context.options.length === 2 && Object.prototype.hasOwnProperty.call(context.options[1], \"exceptions\")) {\r\n            const keys = Object.keys(context.options[1].exceptions);\r\n\r\n            for (let i = 0; i < keys.length; i++) {\r\n                exceptions[keys[i]] = context.options[1].exceptions[keys[i]];\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Modified text based on the style\r\n         * @param {string} styleType Style type\r\n         * @param {string} text Source code text\r\n         * @returns {string} modified text\r\n         * @private\r\n         */\r\n        function getReplacedText(styleType, text) {\r\n            switch (styleType) {\r\n                case \"between\":\r\n                    return `,${text.replace(astUtils.LINEBREAK_MATCHER, \"\")}`;\r\n\r\n                case \"first\":\r\n                    return `${text},`;\r\n\r\n                case \"last\":\r\n                    return `,${text}`;\r\n\r\n                default:\r\n                    return \"\";\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Determines the fixer function for a given style.\r\n         * @param {string} styleType comma style\r\n         * @param {ASTNode} previousItemToken The token to check.\r\n         * @param {ASTNode} commaToken The token to check.\r\n         * @param {ASTNode} currentItemToken The token to check.\r\n         * @returns {Function} Fixer function\r\n         * @private\r\n         */\r\n        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {\r\n            const text =\r\n                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +\r\n                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);\r\n            const range = [previousItemToken.range[1], currentItemToken.range[0]];\r\n\r\n            return function(fixer) {\r\n                return fixer.replaceTextRange(range, getReplacedText(styleType, text));\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Validates the spacing around single items in lists.\r\n         * @param {Token} previousItemToken The last token from the previous item.\r\n         * @param {Token} commaToken The token representing the comma.\r\n         * @param {Token} currentItemToken The first token of the current item.\r\n         * @param {Token} reportItem The item to use when reporting an error.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {\r\n\r\n            // if single line\r\n            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\r\n                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\r\n\r\n                // do nothing.\r\n\r\n            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&\r\n                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {\r\n\r\n                const comment = sourceCode.getCommentsAfter(commaToken)[0];\r\n                const styleType = comment && comment.type === \"Block\" && astUtils.isTokenOnSameLine(commaToken, comment)\r\n                    ? style\r\n                    : \"between\";\r\n\r\n                // lone comma\r\n                context.report({\r\n                    node: reportItem,\r\n                    loc: commaToken.loc,\r\n                    messageId: \"unexpectedLineBeforeAndAfterComma\",\r\n                    fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)\r\n                });\r\n\r\n            } else if (style === \"first\" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\r\n\r\n                context.report({\r\n                    node: reportItem,\r\n                    loc: commaToken.loc,\r\n                    messageId: \"expectedCommaFirst\",\r\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\r\n                });\r\n\r\n            } else if (style === \"last\" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {\r\n\r\n                context.report({\r\n                    node: reportItem,\r\n                    loc: commaToken.loc,\r\n                    messageId: \"expectedCommaLast\",\r\n                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the comma placement with regards to a declaration/property/element\r\n         * @param {ASTNode} node The binary expression node to check\r\n         * @param {string} property The property of the node containing child nodes.\r\n         * @private\r\n         * @returns {void}\r\n         */\r\n        function validateComma(node, property) {\r\n            const items = node[property],\r\n                arrayLiteral = (node.type === \"ArrayExpression\" || node.type === \"ArrayPattern\");\r\n\r\n            if (items.length > 1 || arrayLiteral) {\r\n\r\n                // seed as opening [\r\n                let previousItemToken = sourceCode.getFirstToken(node);\r\n\r\n                items.forEach(item => {\r\n                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,\r\n                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),\r\n                        reportItem = item || currentItemToken;\r\n\r\n                    /*\r\n                     * This works by comparing three token locations:\r\n                     * - previousItemToken is the last token of the previous item\r\n                     * - commaToken is the location of the comma before the current item\r\n                     * - currentItemToken is the first token of the current item\r\n                     *\r\n                     * These values get switched around if item is undefined.\r\n                     * previousItemToken will refer to the last token not belonging\r\n                     * to the current item, which could be a comma or an opening\r\n                     * square bracket. currentItemToken could be a comma.\r\n                     *\r\n                     * All comparisons are done based on these tokens directly, so\r\n                     * they are always valid regardless of an undefined item.\r\n                     */\r\n                    if (astUtils.isCommaToken(commaToken)) {\r\n                        validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);\r\n                    }\r\n\r\n                    if (item) {\r\n                        const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);\r\n\r\n                        previousItemToken = tokenAfterItem\r\n                            ? sourceCode.getTokenBefore(tokenAfterItem)\r\n                            : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];\r\n                    } else {\r\n                        previousItemToken = currentItemToken;\r\n                    }\r\n                });\r\n\r\n                /*\r\n                 * Special case for array literals that have empty last items, such\r\n                 * as [ 1, 2, ]. These arrays only have two items show up in the\r\n                 * AST, so we need to look at the token to verify that there's no\r\n                 * dangling comma.\r\n                 */\r\n                if (arrayLiteral) {\r\n\r\n                    const lastToken = sourceCode.getLastToken(node),\r\n                        nextToLastToken = sourceCode.getTokenBefore(lastToken);\r\n\r\n                    if (astUtils.isCommaToken(nextToLastToken)) {\r\n                        validateCommaItemSpacing(\r\n                            sourceCode.getTokenBefore(nextToLastToken),\r\n                            nextToLastToken,\r\n                            lastToken,\r\n                            lastToken\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        const nodes = {};\r\n\r\n        if (!exceptions.VariableDeclaration) {\r\n            nodes.VariableDeclaration = function(node) {\r\n                validateComma(node, \"declarations\");\r\n            };\r\n        }\r\n        if (!exceptions.ObjectExpression) {\r\n            nodes.ObjectExpression = function(node) {\r\n                validateComma(node, \"properties\");\r\n            };\r\n        }\r\n        if (!exceptions.ObjectPattern) {\r\n            nodes.ObjectPattern = function(node) {\r\n                validateComma(node, \"properties\");\r\n            };\r\n        }\r\n        if (!exceptions.ArrayExpression) {\r\n            nodes.ArrayExpression = function(node) {\r\n                validateComma(node, \"elements\");\r\n            };\r\n        }\r\n        if (!exceptions.ArrayPattern) {\r\n            nodes.ArrayPattern = function(node) {\r\n                validateComma(node, \"elements\");\r\n            };\r\n        }\r\n        if (!exceptions.FunctionDeclaration) {\r\n            nodes.FunctionDeclaration = function(node) {\r\n                validateComma(node, \"params\");\r\n            };\r\n        }\r\n        if (!exceptions.FunctionExpression) {\r\n            nodes.FunctionExpression = function(node) {\r\n                validateComma(node, \"params\");\r\n            };\r\n        }\r\n        if (!exceptions.ArrowFunctionExpression) {\r\n            nodes.ArrowFunctionExpression = function(node) {\r\n                validateComma(node, \"params\");\r\n            };\r\n        }\r\n        if (!exceptions.CallExpression) {\r\n            nodes.CallExpression = function(node) {\r\n                validateComma(node, \"arguments\");\r\n            };\r\n        }\r\n        if (!exceptions.ImportDeclaration) {\r\n            nodes.ImportDeclaration = function(node) {\r\n                validateComma(node, \"specifiers\");\r\n            };\r\n        }\r\n        if (!exceptions.NewExpression) {\r\n            nodes.NewExpression = function(node) {\r\n                validateComma(node, \"arguments\");\r\n            };\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}