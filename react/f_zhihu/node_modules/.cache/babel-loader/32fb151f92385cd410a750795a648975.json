{"ast":null,"code":"/**\r\n * @fileoverview Rule to require or disallow yoda comparisons\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //--------------------------------------------------------------------------\n// Requirements\n//--------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\r\n * Determines whether an operator is a comparison operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether or not it is a comparison operator.\r\n */\n\n\nfunction isComparisonOperator(operator) {\n  return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\n}\n/**\r\n * Determines whether an operator is an equality operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether or not it is an equality operator.\r\n */\n\n\nfunction isEqualityOperator(operator) {\n  return /^(==|===)$/u.test(operator);\n}\n/**\r\n * Determines whether an operator is one used in a range test.\r\n * Allowed operators are `<` and `<=`.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether the operator is used in range tests.\r\n */\n\n\nfunction isRangeTestOperator(operator) {\n  return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n/**\r\n * Determines whether a non-Literal node is a negative number that should be\r\n * treated as if it were a single Literal node.\r\n * @param {ASTNode} node Node to test.\r\n * @returns {boolean} True if the node is a negative number that looks like a\r\n *                    real literal and should be treated as such.\r\n */\n\n\nfunction isNegativeNumericLiteral(node) {\n  return node.type === \"UnaryExpression\" && node.operator === \"-\" && node.prefix && astUtils.isNumericLiteral(node.argument);\n}\n/**\r\n * Determines whether a node is a Template Literal which can be determined statically.\r\n * @param {ASTNode} node Node to test\r\n * @returns {boolean} True if the node is a Template Literal without expression.\r\n */\n\n\nfunction isStaticTemplateLiteral(node) {\n  return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\n}\n/**\r\n * Determines whether a non-Literal node should be treated as a single Literal node.\r\n * @param {ASTNode} node Node to test\r\n * @returns {boolean} True if the node should be treated as a single Literal node.\r\n */\n\n\nfunction looksLikeLiteral(node) {\n  return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\n}\n/**\r\n * Attempts to derive a Literal node from nodes that are treated like literals.\r\n * @param {ASTNode} node Node to normalize.\r\n * @returns {ASTNode} One of the following options.\r\n *  1. The original node if the node is already a Literal\r\n *  2. A normalized Literal node with the negative number as the value if the\r\n *     node represents a negative number literal.\r\n *  3. A normalized Literal node with the string as the value if the node is\r\n *     a Template Literal without expression.\r\n *  4. Otherwise `null`.\r\n */\n\n\nfunction getNormalizedLiteral(node) {\n  if (node.type === \"Literal\") {\n    return node;\n  }\n\n  if (isNegativeNumericLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: -node.argument.value,\n      raw: `-${node.argument.value}`\n    };\n  }\n\n  if (isStaticTemplateLiteral(node)) {\n    return {\n      type: \"Literal\",\n      value: node.quasis[0].value.cooked,\n      raw: node.quasis[0].value.raw\n    };\n  }\n\n  return null;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: 'require or disallow \"Yoda\" conditions',\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/yoda\"\n    },\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptRange: {\n          type: \"boolean\",\n          default: false\n        },\n        onlyEquality: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      expected: \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\n    }\n  },\n\n  create(context) {\n    // Default to \"never\" (!always) if no option\n    const always = context.options[0] === \"always\";\n    const exceptRange = context.options[1] && context.options[1].exceptRange;\n    const onlyEquality = context.options[1] && context.options[1].onlyEquality;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Determines whether node represents a range test.\r\n     * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\r\n     * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\r\n     * both operators must be `<` or `<=`. Finally, the literal on the left side\r\n     * must be less than or equal to the literal on the right side so that the\r\n     * test makes any sense.\r\n     * @param {ASTNode} node LogicalExpression node to test.\r\n     * @returns {boolean} Whether node is a range test.\r\n     */\n\n    function isRangeTest(node) {\n      const left = node.left,\n            right = node.right;\n      /**\r\n       * Determines whether node is of the form `0 <= x && x < 1`.\r\n       * @returns {boolean} Whether node is a \"between\" range test.\r\n       */\n\n      function isBetweenTest() {\n        if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\n          const leftLiteral = getNormalizedLiteral(left.left);\n          const rightLiteral = getNormalizedLiteral(right.right);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\r\n       * Determines whether node is of the form `x < 0 || 1 <= x`.\r\n       * @returns {boolean} Whether node is an \"outside\" range test.\r\n       */\n\n\n      function isOutsideTest() {\n        if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\n          const leftLiteral = getNormalizedLiteral(left.right);\n          const rightLiteral = getNormalizedLiteral(right.left);\n\n          if (leftLiteral === null && rightLiteral === null) {\n            return false;\n          }\n\n          if (rightLiteral === null || leftLiteral === null) {\n            return true;\n          }\n\n          if (leftLiteral.value <= rightLiteral.value) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n      /**\r\n       * Determines whether node is wrapped in parentheses.\r\n       * @returns {boolean} Whether node is preceded immediately by an open\r\n       *                    paren token and followed immediately by a close\r\n       *                    paren token.\r\n       */\n\n\n      function isParenWrapped() {\n        return astUtils.isParenthesised(sourceCode, node);\n      }\n\n      return node.type === \"LogicalExpression\" && left.type === \"BinaryExpression\" && right.type === \"BinaryExpression\" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();\n    }\n\n    const OPERATOR_FLIP_MAP = {\n      \"===\": \"===\",\n      \"!==\": \"!==\",\n      \"==\": \"==\",\n      \"!=\": \"!=\",\n      \"<\": \">\",\n      \">\": \"<\",\n      \"<=\": \">=\",\n      \">=\": \"<=\"\n    };\n    /**\r\n     * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\r\n     * @param {ASTNode} node The BinaryExpression node\r\n     * @returns {string} A string representation of the node with the sides and operator flipped\r\n     */\n\n    function getFlippedString(node) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\n      const firstRightToken = sourceCode.getTokenAfter(operatorToken);\n      const source = sourceCode.getText();\n      const leftText = source.slice(node.range[0], lastLeftToken.range[1]);\n      const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);\n      const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);\n      const rightText = source.slice(firstRightToken.range[0], node.range[1]);\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      const tokenAfter = sourceCode.getTokenAfter(node);\n      let prefix = \"\";\n      let suffix = \"\";\n\n      if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {\n        prefix = \" \";\n      }\n\n      if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {\n        suffix = \" \";\n      }\n\n      return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BinaryExpression(node) {\n        const expectedLiteral = always ? node.left : node.right;\n        const expectedNonLiteral = always ? node.right : node.left; // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\n\n        if ((expectedNonLiteral.type === \"Literal\" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === \"Literal\" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context.getAncestors().pop()))) {\n          context.report({\n            node,\n            messageId: \"expected\",\n            data: {\n              operator: node.operator,\n              expectedSide: always ? \"left\" : \"right\"\n            },\n            fix: fixer => fixer.replaceText(node, getFlippedString(node))\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/yoda.js"],"names":["astUtils","require","isComparisonOperator","operator","test","isEqualityOperator","isRangeTestOperator","indexOf","isNegativeNumericLiteral","node","type","prefix","isNumericLiteral","argument","isStaticTemplateLiteral","expressions","length","looksLikeLiteral","getNormalizedLiteral","value","raw","quasis","cooked","module","exports","meta","docs","description","recommended","url","schema","enum","properties","exceptRange","default","onlyEquality","additionalProperties","fixable","messages","expected","create","context","always","options","sourceCode","getSourceCode","isRangeTest","left","right","isBetweenTest","isSameReference","leftLiteral","rightLiteral","isOutsideTest","isParenWrapped","isParenthesised","OPERATOR_FLIP_MAP","getFlippedString","operatorToken","getFirstTokenBetween","token","lastLeftToken","getTokenBefore","firstRightToken","getTokenAfter","source","getText","leftText","slice","range","textBeforeOperator","textAfterOperator","rightText","tokenBefore","tokenAfter","suffix","canTokensBeAdjacent","BinaryExpression","expectedLiteral","expectedNonLiteral","getAncestors","pop","report","messageId","data","expectedSide","fix","fixer","replaceText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require or disallow yoda comparisons\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//--------------------------------------------------------------------------\r\n// Requirements\r\n//--------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//--------------------------------------------------------------------------\r\n// Helpers\r\n//--------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines whether an operator is a comparison operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether or not it is a comparison operator.\r\n */\r\nfunction isComparisonOperator(operator) {\r\n    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);\r\n}\r\n\r\n/**\r\n * Determines whether an operator is an equality operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether or not it is an equality operator.\r\n */\r\nfunction isEqualityOperator(operator) {\r\n    return /^(==|===)$/u.test(operator);\r\n}\r\n\r\n/**\r\n * Determines whether an operator is one used in a range test.\r\n * Allowed operators are `<` and `<=`.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} Whether the operator is used in range tests.\r\n */\r\nfunction isRangeTestOperator(operator) {\r\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\r\n}\r\n\r\n/**\r\n * Determines whether a non-Literal node is a negative number that should be\r\n * treated as if it were a single Literal node.\r\n * @param {ASTNode} node Node to test.\r\n * @returns {boolean} True if the node is a negative number that looks like a\r\n *                    real literal and should be treated as such.\r\n */\r\nfunction isNegativeNumericLiteral(node) {\r\n    return (\r\n        node.type === \"UnaryExpression\" &&\r\n        node.operator === \"-\" &&\r\n        node.prefix &&\r\n        astUtils.isNumericLiteral(node.argument)\r\n    );\r\n}\r\n\r\n/**\r\n * Determines whether a node is a Template Literal which can be determined statically.\r\n * @param {ASTNode} node Node to test\r\n * @returns {boolean} True if the node is a Template Literal without expression.\r\n */\r\nfunction isStaticTemplateLiteral(node) {\r\n    return node.type === \"TemplateLiteral\" && node.expressions.length === 0;\r\n}\r\n\r\n/**\r\n * Determines whether a non-Literal node should be treated as a single Literal node.\r\n * @param {ASTNode} node Node to test\r\n * @returns {boolean} True if the node should be treated as a single Literal node.\r\n */\r\nfunction looksLikeLiteral(node) {\r\n    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);\r\n}\r\n\r\n/**\r\n * Attempts to derive a Literal node from nodes that are treated like literals.\r\n * @param {ASTNode} node Node to normalize.\r\n * @returns {ASTNode} One of the following options.\r\n *  1. The original node if the node is already a Literal\r\n *  2. A normalized Literal node with the negative number as the value if the\r\n *     node represents a negative number literal.\r\n *  3. A normalized Literal node with the string as the value if the node is\r\n *     a Template Literal without expression.\r\n *  4. Otherwise `null`.\r\n */\r\nfunction getNormalizedLiteral(node) {\r\n    if (node.type === \"Literal\") {\r\n        return node;\r\n    }\r\n\r\n    if (isNegativeNumericLiteral(node)) {\r\n        return {\r\n            type: \"Literal\",\r\n            value: -node.argument.value,\r\n            raw: `-${node.argument.value}`\r\n        };\r\n    }\r\n\r\n    if (isStaticTemplateLiteral(node)) {\r\n        return {\r\n            type: \"Literal\",\r\n            value: node.quasis[0].value.cooked,\r\n            raw: node.quasis[0].value.raw\r\n        };\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: 'require or disallow \"Yoda\" conditions',\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/yoda\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptRange: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    onlyEquality: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            expected:\r\n                \"Expected literal to be on the {{expectedSide}} side of {{operator}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        // Default to \"never\" (!always) if no option\r\n        const always = context.options[0] === \"always\";\r\n        const exceptRange =\r\n            context.options[1] && context.options[1].exceptRange;\r\n        const onlyEquality =\r\n            context.options[1] && context.options[1].onlyEquality;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Determines whether node represents a range test.\r\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\r\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\r\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\r\n         * must be less than or equal to the literal on the right side so that the\r\n         * test makes any sense.\r\n         * @param {ASTNode} node LogicalExpression node to test.\r\n         * @returns {boolean} Whether node is a range test.\r\n         */\r\n        function isRangeTest(node) {\r\n            const left = node.left,\r\n                right = node.right;\r\n\r\n            /**\r\n             * Determines whether node is of the form `0 <= x && x < 1`.\r\n             * @returns {boolean} Whether node is a \"between\" range test.\r\n             */\r\n            function isBetweenTest() {\r\n                if (node.operator === \"&&\" && astUtils.isSameReference(left.right, right.left)) {\r\n                    const leftLiteral = getNormalizedLiteral(left.left);\r\n                    const rightLiteral = getNormalizedLiteral(right.right);\r\n\r\n                    if (leftLiteral === null && rightLiteral === null) {\r\n                        return false;\r\n                    }\r\n\r\n                    if (rightLiteral === null || leftLiteral === null) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (leftLiteral.value <= rightLiteral.value) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            /**\r\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\r\n             * @returns {boolean} Whether node is an \"outside\" range test.\r\n             */\r\n            function isOutsideTest() {\r\n                if (node.operator === \"||\" && astUtils.isSameReference(left.left, right.right)) {\r\n                    const leftLiteral = getNormalizedLiteral(left.right);\r\n                    const rightLiteral = getNormalizedLiteral(right.left);\r\n\r\n                    if (leftLiteral === null && rightLiteral === null) {\r\n                        return false;\r\n                    }\r\n\r\n                    if (rightLiteral === null || leftLiteral === null) {\r\n                        return true;\r\n                    }\r\n\r\n                    if (leftLiteral.value <= rightLiteral.value) {\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n            /**\r\n             * Determines whether node is wrapped in parentheses.\r\n             * @returns {boolean} Whether node is preceded immediately by an open\r\n             *                    paren token and followed immediately by a close\r\n             *                    paren token.\r\n             */\r\n            function isParenWrapped() {\r\n                return astUtils.isParenthesised(sourceCode, node);\r\n            }\r\n\r\n            return (\r\n                node.type === \"LogicalExpression\" &&\r\n                left.type === \"BinaryExpression\" &&\r\n                right.type === \"BinaryExpression\" &&\r\n                isRangeTestOperator(left.operator) &&\r\n                isRangeTestOperator(right.operator) &&\r\n                (isBetweenTest() || isOutsideTest()) &&\r\n                isParenWrapped()\r\n            );\r\n        }\r\n\r\n        const OPERATOR_FLIP_MAP = {\r\n            \"===\": \"===\",\r\n            \"!==\": \"!==\",\r\n            \"==\": \"==\",\r\n            \"!=\": \"!=\",\r\n            \"<\": \">\",\r\n            \">\": \"<\",\r\n            \"<=\": \">=\",\r\n            \">=\": \"<=\"\r\n        };\r\n\r\n        /**\r\n         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.\r\n         * @param {ASTNode} node The BinaryExpression node\r\n         * @returns {string} A string representation of the node with the sides and operator flipped\r\n         */\r\n        function getFlippedString(node) {\r\n            const operatorToken = sourceCode.getFirstTokenBetween(\r\n                node.left,\r\n                node.right,\r\n                token => token.value === node.operator\r\n            );\r\n            const lastLeftToken = sourceCode.getTokenBefore(operatorToken);\r\n            const firstRightToken = sourceCode.getTokenAfter(operatorToken);\r\n\r\n            const source = sourceCode.getText();\r\n\r\n            const leftText = source.slice(\r\n                node.range[0],\r\n                lastLeftToken.range[1]\r\n            );\r\n            const textBeforeOperator = source.slice(\r\n                lastLeftToken.range[1],\r\n                operatorToken.range[0]\r\n            );\r\n            const textAfterOperator = source.slice(\r\n                operatorToken.range[1],\r\n                firstRightToken.range[0]\r\n            );\r\n            const rightText = source.slice(\r\n                firstRightToken.range[0],\r\n                node.range[1]\r\n            );\r\n\r\n            const tokenBefore = sourceCode.getTokenBefore(node);\r\n            const tokenAfter = sourceCode.getTokenAfter(node);\r\n            let prefix = \"\";\r\n            let suffix = \"\";\r\n\r\n            if (\r\n                tokenBefore &&\r\n                tokenBefore.range[1] === node.range[0] &&\r\n                !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)\r\n            ) {\r\n                prefix = \" \";\r\n            }\r\n\r\n            if (\r\n                tokenAfter &&\r\n                node.range[1] === tokenAfter.range[0] &&\r\n                !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)\r\n            ) {\r\n                suffix = \" \";\r\n            }\r\n\r\n            return (\r\n                prefix +\r\n                rightText +\r\n                textBeforeOperator +\r\n                OPERATOR_FLIP_MAP[operatorToken.value] +\r\n                textAfterOperator +\r\n                leftText +\r\n                suffix\r\n            );\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            BinaryExpression(node) {\r\n                const expectedLiteral = always ? node.left : node.right;\r\n                const expectedNonLiteral = always ? node.right : node.left;\r\n\r\n                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.\r\n                if (\r\n                    (expectedNonLiteral.type === \"Literal\" ||\r\n                        looksLikeLiteral(expectedNonLiteral)) &&\r\n                    !(\r\n                        expectedLiteral.type === \"Literal\" ||\r\n                        looksLikeLiteral(expectedLiteral)\r\n                    ) &&\r\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\r\n                    isComparisonOperator(node.operator) &&\r\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\r\n                ) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"expected\",\r\n                        data: {\r\n                            operator: node.operator,\r\n                            expectedSide: always ? \"left\" : \"right\"\r\n                        },\r\n                        fix: fixer =>\r\n                            fixer.replaceText(node, getFlippedString(node))\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}