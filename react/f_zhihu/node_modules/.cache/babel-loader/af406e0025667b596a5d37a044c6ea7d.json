{"ast":null,"code":"/**\r\n * @fileoverview Flag expressions in statement position that do not side effect\r\n * @author Michael Ficarra\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\r\n * Returns `true`.\r\n * @returns {boolean} `true`.\r\n */\n\nfunction alwaysTrue() {\n  return true;\n}\n/**\r\n * Returns `false`.\r\n * @returns {boolean} `false`.\r\n */\n\n\nfunction alwaysFalse() {\n  return false;\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused expressions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-expressions\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowShortCircuit: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTernary: {\n          type: \"boolean\",\n          default: false\n        },\n        allowTaggedTemplates: {\n          type: \"boolean\",\n          default: false\n        },\n        enforceForJSX: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {},\n          allowShortCircuit = config.allowShortCircuit || false,\n          allowTernary = config.allowTernary || false,\n          allowTaggedTemplates = config.allowTaggedTemplates || false,\n          enforceForJSX = config.enforceForJSX || false;\n    /**\r\n     * Has AST suggesting a directive.\r\n     * @param {ASTNode} node any node\r\n     * @returns {boolean} whether the given node structurally represents a directive\r\n     */\n\n    function looksLikeDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n    /**\r\n     * Gets the leading sequence of members in a list that pass the predicate.\r\n     * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\r\n     * @param {a[]} list the input list\r\n     * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\r\n     */\n\n\n    function takeWhile(predicate, list) {\n      for (let i = 0; i < list.length; ++i) {\n        if (!predicate(list[i])) {\n          return list.slice(0, i);\n        }\n      }\n\n      return list.slice();\n    }\n    /**\r\n     * Gets leading directives nodes in a Node body.\r\n     * @param {ASTNode} node a Program or BlockStatement node\r\n     * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\r\n     */\n\n\n    function directives(node) {\n      return takeWhile(looksLikeDirective, node.body);\n    }\n    /**\r\n     * Detect if a Node is a directive.\r\n     * @param {ASTNode} node any node\r\n     * @param {ASTNode[]} ancestors the given node's ancestors\r\n     * @returns {boolean} whether the given node is considered a directive in its current position\r\n     */\n\n\n    function isDirective(node, ancestors) {\n      const parent = ancestors[ancestors.length - 1],\n            grandparent = ancestors[ancestors.length - 2];\n      /**\r\n       * https://tc39.es/ecma262/#directive-prologue\r\n       *\r\n       * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\r\n       * Class static blocks do not have directive prologue.\r\n       */\n\n      return (parent.type === \"Program\" || parent.type === \"BlockStatement\" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;\n    }\n    /**\r\n     * The member functions return `true` if the type has no side-effects.\r\n     * Unknown nodes are handled as `false`, then this rule ignores those.\r\n     */\n\n\n    const Checker = Object.assign(Object.create(null), {\n      isDisallowed(node) {\n        return (Checker[node.type] || alwaysFalse)(node);\n      },\n\n      ArrayExpression: alwaysTrue,\n      ArrowFunctionExpression: alwaysTrue,\n      BinaryExpression: alwaysTrue,\n\n      ChainExpression(node) {\n        return Checker.isDisallowed(node.expression);\n      },\n\n      ClassExpression: alwaysTrue,\n\n      ConditionalExpression(node) {\n        if (allowTernary) {\n          return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\n        }\n\n        return true;\n      },\n\n      FunctionExpression: alwaysTrue,\n      Identifier: alwaysTrue,\n\n      JSXElement() {\n        return enforceForJSX;\n      },\n\n      JSXFragment() {\n        return enforceForJSX;\n      },\n\n      Literal: alwaysTrue,\n\n      LogicalExpression(node) {\n        if (allowShortCircuit) {\n          return Checker.isDisallowed(node.right);\n        }\n\n        return true;\n      },\n\n      MemberExpression: alwaysTrue,\n      MetaProperty: alwaysTrue,\n      ObjectExpression: alwaysTrue,\n      SequenceExpression: alwaysTrue,\n\n      TaggedTemplateExpression() {\n        return !allowTaggedTemplates;\n      },\n\n      TemplateLiteral: alwaysTrue,\n      ThisExpression: alwaysTrue,\n\n      UnaryExpression(node) {\n        return node.operator !== \"void\" && node.operator !== \"delete\";\n      }\n\n    });\n    return {\n      ExpressionStatement(node) {\n        if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\n          context.report({\n            node,\n            messageId: \"unusedExpression\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unused-expressions.js"],"names":["alwaysTrue","alwaysFalse","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowShortCircuit","default","allowTernary","allowTaggedTemplates","enforceForJSX","additionalProperties","messages","unusedExpression","create","context","config","options","looksLikeDirective","node","expression","value","takeWhile","predicate","list","i","length","slice","directives","body","isDirective","ancestors","parent","grandparent","test","indexOf","Checker","Object","assign","isDisallowed","ArrayExpression","ArrowFunctionExpression","BinaryExpression","ChainExpression","ClassExpression","ConditionalExpression","consequent","alternate","FunctionExpression","Identifier","JSXElement","JSXFragment","Literal","LogicalExpression","right","MemberExpression","MetaProperty","ObjectExpression","SequenceExpression","TaggedTemplateExpression","TemplateLiteral","ThisExpression","UnaryExpression","operator","ExpressionStatement","getAncestors","report","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Flag expressions in statement position that do not side effect\r\n * @author Michael Ficarra\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Returns `true`.\r\n * @returns {boolean} `true`.\r\n */\r\nfunction alwaysTrue() {\r\n    return true;\r\n}\r\n\r\n/**\r\n * Returns `false`.\r\n * @returns {boolean} `false`.\r\n */\r\nfunction alwaysFalse() {\r\n    return false;\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unused expressions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-unused-expressions\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowShortCircuit: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowTernary: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowTaggedTemplates: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    enforceForJSX: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unusedExpression: \"Expected an assignment or function call and instead saw an expression.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const config = context.options[0] || {},\r\n            allowShortCircuit = config.allowShortCircuit || false,\r\n            allowTernary = config.allowTernary || false,\r\n            allowTaggedTemplates = config.allowTaggedTemplates || false,\r\n            enforceForJSX = config.enforceForJSX || false;\r\n\r\n        /**\r\n         * Has AST suggesting a directive.\r\n         * @param {ASTNode} node any node\r\n         * @returns {boolean} whether the given node structurally represents a directive\r\n         */\r\n        function looksLikeDirective(node) {\r\n            return node.type === \"ExpressionStatement\" &&\r\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\r\n        }\r\n\r\n        /**\r\n         * Gets the leading sequence of members in a list that pass the predicate.\r\n         * @param {Function} predicate ([a] -> Boolean) the function used to make the determination\r\n         * @param {a[]} list the input list\r\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\r\n         */\r\n        function takeWhile(predicate, list) {\r\n            for (let i = 0; i < list.length; ++i) {\r\n                if (!predicate(list[i])) {\r\n                    return list.slice(0, i);\r\n                }\r\n            }\r\n            return list.slice();\r\n        }\r\n\r\n        /**\r\n         * Gets leading directives nodes in a Node body.\r\n         * @param {ASTNode} node a Program or BlockStatement node\r\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\r\n         */\r\n        function directives(node) {\r\n            return takeWhile(looksLikeDirective, node.body);\r\n        }\r\n\r\n        /**\r\n         * Detect if a Node is a directive.\r\n         * @param {ASTNode} node any node\r\n         * @param {ASTNode[]} ancestors the given node's ancestors\r\n         * @returns {boolean} whether the given node is considered a directive in its current position\r\n         */\r\n        function isDirective(node, ancestors) {\r\n            const parent = ancestors[ancestors.length - 1],\r\n                grandparent = ancestors[ancestors.length - 2];\r\n\r\n            /**\r\n             * https://tc39.es/ecma262/#directive-prologue\r\n             *\r\n             * Only `FunctionBody`, `ScriptBody` and `ModuleBody` can have directive prologue.\r\n             * Class static blocks do not have directive prologue.\r\n             */\r\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\r\n                    (/Function/u.test(grandparent.type))) &&\r\n                    directives(parent).indexOf(node) >= 0;\r\n        }\r\n\r\n        /**\r\n         * The member functions return `true` if the type has no side-effects.\r\n         * Unknown nodes are handled as `false`, then this rule ignores those.\r\n         */\r\n        const Checker = Object.assign(Object.create(null), {\r\n            isDisallowed(node) {\r\n                return (Checker[node.type] || alwaysFalse)(node);\r\n            },\r\n\r\n            ArrayExpression: alwaysTrue,\r\n            ArrowFunctionExpression: alwaysTrue,\r\n            BinaryExpression: alwaysTrue,\r\n            ChainExpression(node) {\r\n                return Checker.isDisallowed(node.expression);\r\n            },\r\n            ClassExpression: alwaysTrue,\r\n            ConditionalExpression(node) {\r\n                if (allowTernary) {\r\n                    return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);\r\n                }\r\n                return true;\r\n            },\r\n            FunctionExpression: alwaysTrue,\r\n            Identifier: alwaysTrue,\r\n            JSXElement() {\r\n                return enforceForJSX;\r\n            },\r\n            JSXFragment() {\r\n                return enforceForJSX;\r\n            },\r\n            Literal: alwaysTrue,\r\n            LogicalExpression(node) {\r\n                if (allowShortCircuit) {\r\n                    return Checker.isDisallowed(node.right);\r\n                }\r\n                return true;\r\n            },\r\n            MemberExpression: alwaysTrue,\r\n            MetaProperty: alwaysTrue,\r\n            ObjectExpression: alwaysTrue,\r\n            SequenceExpression: alwaysTrue,\r\n            TaggedTemplateExpression() {\r\n                return !allowTaggedTemplates;\r\n            },\r\n            TemplateLiteral: alwaysTrue,\r\n            ThisExpression: alwaysTrue,\r\n            UnaryExpression(node) {\r\n                return node.operator !== \"void\" && node.operator !== \"delete\";\r\n            }\r\n        });\r\n\r\n        return {\r\n            ExpressionStatement(node) {\r\n                if (Checker.isDisallowed(node.expression) && !isDirective(node, context.getAncestors())) {\r\n                    context.report({ node, messageId: \"unusedExpression\" });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}