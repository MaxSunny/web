{"ast":null,"code":"/**\r\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines if the given code path is a code path with lexical `this` binding.\r\n * That is, if `this` within the code path refers to `this` of surrounding code path.\r\n * @param {CodePath} codePath Code path.\r\n * @param {ASTNode} node Node that started the code path.\r\n * @returns {boolean} `true` if it is a code path with lexical `this` binding.\r\n */\n\n\nfunction isCodePathWithLexicalThis(codePath, node) {\n  return codePath.origin === \"function\" && node.type === \"ArrowFunctionExpression\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow `this` keywords outside of classes or class-like objects\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-invalid-this\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        capIsConstructor: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedThis: \"Unexpected 'this'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const capIsConstructor = options.capIsConstructor !== false;\n    const stack = [],\n          sourceCode = context.getSourceCode();\n    /**\r\n     * Gets the current checking context.\r\n     *\r\n     * The return value has a flag that whether or not `this` keyword is valid.\r\n     * The flag is initialized when got at the first time.\r\n     * @returns {{valid: boolean}}\r\n     *   an object which has a flag that whether or not `this` keyword is valid.\r\n     */\n\n    stack.getCurrent = function () {\n      const current = this[this.length - 1];\n\n      if (!current.init) {\n        current.init = true;\n        current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode, {\n          capIsConstructor\n        });\n      }\n\n      return current;\n    };\n\n    return {\n      onCodePathStart(codePath, node) {\n        if (isCodePathWithLexicalThis(codePath, node)) {\n          return;\n        }\n\n        if (codePath.origin === \"program\") {\n          const scope = context.getScope();\n          const features = context.parserOptions.ecmaFeatures || {};\n          stack.push({\n            init: true,\n            node,\n            valid: !(scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict)\n          });\n          return;\n        }\n        /*\r\n         * `init: false` means that `valid` isn't determined yet.\r\n         * Most functions don't use `this`, and the calculation for `valid`\r\n         * is relatively costly, so we'll calculate it lazily when the first\r\n         * `this` within the function is traversed. A special case are non-strict\r\n         * functions, because `this` refers to the global object and therefore is\r\n         * always valid, so we can set `init: true` right away.\r\n         */\n\n\n        stack.push({\n          init: !context.getScope().isStrict,\n          node,\n          valid: true\n        });\n      },\n\n      onCodePathEnd(codePath, node) {\n        if (isCodePathWithLexicalThis(codePath, node)) {\n          return;\n        }\n\n        stack.pop();\n      },\n\n      // Reports if `this` of the current context is invalid.\n      ThisExpression(node) {\n        const current = stack.getCurrent();\n\n        if (current && !current.valid) {\n          context.report({\n            node,\n            messageId: \"unexpectedThis\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-invalid-this.js"],"names":["astUtils","require","isCodePathWithLexicalThis","codePath","node","origin","type","module","exports","meta","docs","description","recommended","url","schema","properties","capIsConstructor","default","additionalProperties","messages","unexpectedThis","create","context","options","stack","sourceCode","getSourceCode","getCurrent","current","length","init","valid","isDefaultThisBinding","onCodePathStart","scope","getScope","features","parserOptions","ecmaFeatures","push","isStrict","sourceType","globalReturn","childScopes","onCodePathEnd","pop","ThisExpression","report","messageId"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,yBAAT,CAAmCC,QAAnC,EAA6CC,IAA7C,EAAmD;AAC/C,SAAOD,QAAQ,CAACE,MAAT,KAAoB,UAApB,IAAkCD,IAAI,CAACE,IAAL,KAAc,yBAAvD;AACH,C,CAED;AACA;AACA;;AAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFH,IAAAA,IAAI,EAAE,YADJ;AAGFI,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,mEADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CACJ;AACIR,MAAAA,IAAI,EAAE,QADV;AAEIS,MAAAA,UAAU,EAAE;AACRC,QAAAA,gBAAgB,EAAE;AACdV,UAAAA,IAAI,EAAE,SADQ;AAEdW,UAAAA,OAAO,EAAE;AAFK;AADV,OAFhB;AAQIC,MAAAA,oBAAoB,EAAE;AAR1B,KADI,CATN;AAsBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,cAAc,EAAE;AADV;AAtBR,GADO;;AA4BbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,OAAO,GAAGD,OAAO,CAACC,OAAR,CAAgB,CAAhB,KAAsB,EAAtC;AACA,UAAMP,gBAAgB,GAAGO,OAAO,CAACP,gBAAR,KAA6B,KAAtD;AACA,UAAMQ,KAAK,GAAG,EAAd;AAAA,UACIC,UAAU,GAAGH,OAAO,CAACI,aAAR,EADjB;AAGA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AACQF,IAAAA,KAAK,CAACG,UAAN,GAAmB,YAAW;AAC1B,YAAMC,OAAO,GAAG,KAAK,KAAKC,MAAL,GAAc,CAAnB,CAAhB;;AAEA,UAAI,CAACD,OAAO,CAACE,IAAb,EAAmB;AACfF,QAAAA,OAAO,CAACE,IAAR,GAAe,IAAf;AACAF,QAAAA,OAAO,CAACG,KAAR,GAAgB,CAAC/B,QAAQ,CAACgC,oBAAT,CACbJ,OAAO,CAACxB,IADK,EAEbqB,UAFa,EAGb;AAAET,UAAAA;AAAF,SAHa,CAAjB;AAKH;;AACD,aAAOY,OAAP;AACH,KAZD;;AAcA,WAAO;AAEHK,MAAAA,eAAe,CAAC9B,QAAD,EAAWC,IAAX,EAAiB;AAC5B,YAAIF,yBAAyB,CAACC,QAAD,EAAWC,IAAX,CAA7B,EAA+C;AAC3C;AACH;;AAED,YAAID,QAAQ,CAACE,MAAT,KAAoB,SAAxB,EAAmC;AAC/B,gBAAM6B,KAAK,GAAGZ,OAAO,CAACa,QAAR,EAAd;AACA,gBAAMC,QAAQ,GAAGd,OAAO,CAACe,aAAR,CAAsBC,YAAtB,IAAsC,EAAvD;AAEAd,UAAAA,KAAK,CAACe,IAAN,CAAW;AACPT,YAAAA,IAAI,EAAE,IADC;AAEP1B,YAAAA,IAFO;AAGP2B,YAAAA,KAAK,EAAE,EACHG,KAAK,CAACM,QAAN,IACApC,IAAI,CAACqC,UAAL,KAAoB,QADpB,IAECL,QAAQ,CAACM,YAAT,IAAyBR,KAAK,CAACS,WAAN,CAAkB,CAAlB,EAAqBH,QAH5C;AAHA,WAAX;AAUA;AACH;AAED;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;;AACgBhB,QAAAA,KAAK,CAACe,IAAN,CAAW;AACPT,UAAAA,IAAI,EAAE,CAACR,OAAO,CAACa,QAAR,GAAmBK,QADnB;AAEPpC,UAAAA,IAFO;AAGP2B,UAAAA,KAAK,EAAE;AAHA,SAAX;AAKH,OArCE;;AAuCHa,MAAAA,aAAa,CAACzC,QAAD,EAAWC,IAAX,EAAiB;AAC1B,YAAIF,yBAAyB,CAACC,QAAD,EAAWC,IAAX,CAA7B,EAA+C;AAC3C;AACH;;AAEDoB,QAAAA,KAAK,CAACqB,GAAN;AACH,OA7CE;;AA+CH;AACAC,MAAAA,cAAc,CAAC1C,IAAD,EAAO;AACjB,cAAMwB,OAAO,GAAGJ,KAAK,CAACG,UAAN,EAAhB;;AAEA,YAAIC,OAAO,IAAI,CAACA,OAAO,CAACG,KAAxB,EAA+B;AAC3BT,UAAAA,OAAO,CAACyB,MAAR,CAAe;AACX3C,YAAAA,IADW;AAEX4C,YAAAA,SAAS,EAAE;AAFA,WAAf;AAIH;AACJ;;AAzDE,KAAP;AA2DH;;AAnHY,CAAjB","sourcesContent":["/**\r\n * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if the given code path is a code path with lexical `this` binding.\r\n * That is, if `this` within the code path refers to `this` of surrounding code path.\r\n * @param {CodePath} codePath Code path.\r\n * @param {ASTNode} node Node that started the code path.\r\n * @returns {boolean} `true` if it is a code path with lexical `this` binding.\r\n */\r\nfunction isCodePathWithLexicalThis(codePath, node) {\r\n    return codePath.origin === \"function\" && node.type === \"ArrowFunctionExpression\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow `this` keywords outside of classes or class-like objects\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-invalid-this\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    capIsConstructor: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedThis: \"Unexpected 'this'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const capIsConstructor = options.capIsConstructor !== false;\r\n        const stack = [],\r\n            sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Gets the current checking context.\r\n         *\r\n         * The return value has a flag that whether or not `this` keyword is valid.\r\n         * The flag is initialized when got at the first time.\r\n         * @returns {{valid: boolean}}\r\n         *   an object which has a flag that whether or not `this` keyword is valid.\r\n         */\r\n        stack.getCurrent = function() {\r\n            const current = this[this.length - 1];\r\n\r\n            if (!current.init) {\r\n                current.init = true;\r\n                current.valid = !astUtils.isDefaultThisBinding(\r\n                    current.node,\r\n                    sourceCode,\r\n                    { capIsConstructor }\r\n                );\r\n            }\r\n            return current;\r\n        };\r\n\r\n        return {\r\n\r\n            onCodePathStart(codePath, node) {\r\n                if (isCodePathWithLexicalThis(codePath, node)) {\r\n                    return;\r\n                }\r\n\r\n                if (codePath.origin === \"program\") {\r\n                    const scope = context.getScope();\r\n                    const features = context.parserOptions.ecmaFeatures || {};\r\n\r\n                    stack.push({\r\n                        init: true,\r\n                        node,\r\n                        valid: !(\r\n                            scope.isStrict ||\r\n                            node.sourceType === \"module\" ||\r\n                            (features.globalReturn && scope.childScopes[0].isStrict)\r\n                        )\r\n                    });\r\n\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * `init: false` means that `valid` isn't determined yet.\r\n                 * Most functions don't use `this`, and the calculation for `valid`\r\n                 * is relatively costly, so we'll calculate it lazily when the first\r\n                 * `this` within the function is traversed. A special case are non-strict\r\n                 * functions, because `this` refers to the global object and therefore is\r\n                 * always valid, so we can set `init: true` right away.\r\n                 */\r\n                stack.push({\r\n                    init: !context.getScope().isStrict,\r\n                    node,\r\n                    valid: true\r\n                });\r\n            },\r\n\r\n            onCodePathEnd(codePath, node) {\r\n                if (isCodePathWithLexicalThis(codePath, node)) {\r\n                    return;\r\n                }\r\n\r\n                stack.pop();\r\n            },\r\n\r\n            // Reports if `this` of the current context is invalid.\r\n            ThisExpression(node) {\r\n                const current = stack.getCurrent();\r\n\r\n                if (current && !current.valid) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedThis\"\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}