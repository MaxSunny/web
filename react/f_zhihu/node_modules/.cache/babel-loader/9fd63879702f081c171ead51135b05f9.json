{"ast":null,"code":"/**\r\n * @fileoverview Rule to require grouped accessor pairs in object literals and classes\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\r\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\r\n * @typedef {string|Token[]} Key\r\n */\n\n/**\r\n * Accessor nodes with the same key.\r\n * @typedef {Object} AccessorData\r\n * @property {Key} key Accessor's key\r\n * @property {ASTNode[]} getters List of getter nodes.\r\n * @property {ASTNode[]} setters List of setter nodes.\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not the given lists represent the equal tokens in the same order.\r\n * Tokens are compared by their properties, not by instance.\r\n * @param {Token[]} left First list of tokens.\r\n * @param {Token[]} right Second list of tokens.\r\n * @returns {boolean} `true` if the lists have same tokens.\r\n */\n\n\nfunction areEqualTokenLists(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n          rightToken = right[i];\n\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks whether or not the given keys are equal.\r\n * @param {Key} left First key.\r\n * @param {Key} right Second key.\r\n * @returns {boolean} `true` if the keys are equal.\r\n */\n\n\nfunction areEqualKeys(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    // Statically computed names.\n    return left === right;\n  }\n\n  if (Array.isArray(left) && Array.isArray(right)) {\n    // Token lists.\n    return areEqualTokenLists(left, right);\n  }\n\n  return false;\n}\n/**\r\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is of an accessor kind.\r\n */\n\n\nfunction isAccessorKind(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require grouped accessor pairs in object literals and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/grouped-accessor-pairs\"\n    },\n    schema: [{\n      enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\n    }],\n    messages: {\n      notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\n      invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\n    }\n  },\n\n  create(context) {\n    const order = context.options[0] || \"anyOrder\";\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports the given accessor pair.\r\n     * @param {string} messageId messageId to report.\r\n     * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.\r\n     * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function report(messageId, formerNode, latterNode) {\n      context.report({\n        node: latterNode,\n        messageId,\n        loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\n        data: {\n          formerName: astUtils.getFunctionNameWithKind(formerNode.value),\n          latterName: astUtils.getFunctionNameWithKind(latterNode.value)\n        }\n      });\n    }\n    /**\r\n     * Creates a new `AccessorData` object for the given getter or setter node.\r\n     * @param {ASTNode} node A getter or setter node.\r\n     * @returns {AccessorData} New `AccessorData` object that contains the given node.\r\n     * @private\r\n     */\n\n\n    function createAccessorData(node) {\n      const name = astUtils.getStaticPropertyName(node);\n      const key = name !== null ? name : sourceCode.getTokens(node.key);\n      return {\n        key,\n        getters: node.kind === \"get\" ? [node] : [],\n        setters: node.kind === \"set\" ? [node] : []\n      };\n    }\n    /**\r\n     * Merges the given `AccessorData` object into the given accessors list.\r\n     * @param {AccessorData[]} accessors The list to merge into.\r\n     * @param {AccessorData} accessorData The object to merge.\r\n     * @returns {AccessorData[]} The same instance with the merged object.\r\n     * @private\r\n     */\n\n\n    function mergeAccessorData(accessors, accessorData) {\n      const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\n\n      if (equalKeyElement) {\n        equalKeyElement.getters.push(...accessorData.getters);\n        equalKeyElement.setters.push(...accessorData.setters);\n      } else {\n        accessors.push(accessorData);\n      }\n\n      return accessors;\n    }\n    /**\r\n     * Checks accessor pairs in the given list of nodes.\r\n     * @param {ASTNode[]} nodes The list to check.\r\n     * @param {Function} shouldCheck – Predicate that returns `true` if the node should be checked.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkList(nodes, shouldCheck) {\n      const accessors = nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);\n\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        // Don't report accessor properties that have duplicate getters or setters.\n        if (getters.length === 1 && setters.length === 1) {\n          const [getter] = getters,\n                [setter] = setters,\n                getterIndex = nodes.indexOf(getter),\n                setterIndex = nodes.indexOf(setter),\n                formerNode = getterIndex < setterIndex ? getter : setter,\n                latterNode = getterIndex < setterIndex ? setter : getter;\n\n          if (Math.abs(getterIndex - setterIndex) > 1) {\n            report(\"notGrouped\", formerNode, latterNode);\n          } else if (order === \"getBeforeSet\" && getterIndex > setterIndex || order === \"setBeforeGet\" && getterIndex < setterIndex) {\n            report(\"invalidOrder\", formerNode, latterNode);\n          }\n        }\n      }\n    }\n\n    return {\n      ObjectExpression(node) {\n        checkList(node.properties, n => n.type === \"Property\");\n      },\n\n      ClassBody(node) {\n        checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\n        checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/grouped-accessor-pairs.js"],"names":["astUtils","require","areEqualTokenLists","left","right","length","i","leftToken","rightToken","type","value","areEqualKeys","Array","isArray","isAccessorKind","node","kind","module","exports","meta","docs","description","recommended","url","schema","enum","messages","notGrouped","invalidOrder","create","context","order","options","sourceCode","getSourceCode","report","messageId","formerNode","latterNode","loc","getFunctionHeadLoc","data","formerName","getFunctionNameWithKind","latterName","createAccessorData","name","getStaticPropertyName","key","getTokens","getters","setters","mergeAccessorData","accessors","accessorData","equalKeyElement","find","a","push","checkList","nodes","shouldCheck","filter","map","reduce","getter","setter","getterIndex","indexOf","setterIndex","Math","abs","ObjectExpression","properties","n","ClassBody","body","static"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require grouped accessor pairs in object literals and classes\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\r\n * @typedef {string|Token[]} Key\r\n */\r\n\r\n/**\r\n * Accessor nodes with the same key.\r\n * @typedef {Object} AccessorData\r\n * @property {Key} key Accessor's key\r\n * @property {ASTNode[]} getters List of getter nodes.\r\n * @property {ASTNode[]} setters List of setter nodes.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not the given lists represent the equal tokens in the same order.\r\n * Tokens are compared by their properties, not by instance.\r\n * @param {Token[]} left First list of tokens.\r\n * @param {Token[]} right Second list of tokens.\r\n * @returns {boolean} `true` if the lists have same tokens.\r\n */\r\nfunction areEqualTokenLists(left, right) {\r\n    if (left.length !== right.length) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < left.length; i++) {\r\n        const leftToken = left[i],\r\n            rightToken = right[i];\r\n\r\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Checks whether or not the given keys are equal.\r\n * @param {Key} left First key.\r\n * @param {Key} right Second key.\r\n * @returns {boolean} `true` if the keys are equal.\r\n */\r\nfunction areEqualKeys(left, right) {\r\n    if (typeof left === \"string\" && typeof right === \"string\") {\r\n\r\n        // Statically computed names.\r\n        return left === right;\r\n    }\r\n    if (Array.isArray(left) && Array.isArray(right)) {\r\n\r\n        // Token lists.\r\n        return areEqualTokenLists(left, right);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is of an accessor kind.\r\n */\r\nfunction isAccessorKind(node) {\r\n    return node.kind === \"get\" || node.kind === \"set\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require grouped accessor pairs in object literals and classes\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/grouped-accessor-pairs\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"anyOrder\", \"getBeforeSet\", \"setBeforeGet\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            notGrouped: \"Accessor pair {{ formerName }} and {{ latterName }} should be grouped.\",\r\n            invalidOrder: \"Expected {{ latterName }} to be before {{ formerName }}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const order = context.options[0] || \"anyOrder\";\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports the given accessor pair.\r\n         * @param {string} messageId messageId to report.\r\n         * @param {ASTNode} formerNode getter/setter node that is defined before `latterNode`.\r\n         * @param {ASTNode} latterNode getter/setter node that is defined after `formerNode`.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(messageId, formerNode, latterNode) {\r\n            context.report({\r\n                node: latterNode,\r\n                messageId,\r\n                loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),\r\n                data: {\r\n                    formerName: astUtils.getFunctionNameWithKind(formerNode.value),\r\n                    latterName: astUtils.getFunctionNameWithKind(latterNode.value)\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Creates a new `AccessorData` object for the given getter or setter node.\r\n         * @param {ASTNode} node A getter or setter node.\r\n         * @returns {AccessorData} New `AccessorData` object that contains the given node.\r\n         * @private\r\n         */\r\n        function createAccessorData(node) {\r\n            const name = astUtils.getStaticPropertyName(node);\r\n            const key = (name !== null) ? name : sourceCode.getTokens(node.key);\r\n\r\n            return {\r\n                key,\r\n                getters: node.kind === \"get\" ? [node] : [],\r\n                setters: node.kind === \"set\" ? [node] : []\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Merges the given `AccessorData` object into the given accessors list.\r\n         * @param {AccessorData[]} accessors The list to merge into.\r\n         * @param {AccessorData} accessorData The object to merge.\r\n         * @returns {AccessorData[]} The same instance with the merged object.\r\n         * @private\r\n         */\r\n        function mergeAccessorData(accessors, accessorData) {\r\n            const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\r\n\r\n            if (equalKeyElement) {\r\n                equalKeyElement.getters.push(...accessorData.getters);\r\n                equalKeyElement.setters.push(...accessorData.setters);\r\n            } else {\r\n                accessors.push(accessorData);\r\n            }\r\n\r\n            return accessors;\r\n        }\r\n\r\n        /**\r\n         * Checks accessor pairs in the given list of nodes.\r\n         * @param {ASTNode[]} nodes The list to check.\r\n         * @param {Function} shouldCheck – Predicate that returns `true` if the node should be checked.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkList(nodes, shouldCheck) {\r\n            const accessors = nodes\r\n                .filter(shouldCheck)\r\n                .filter(isAccessorKind)\r\n                .map(createAccessorData)\r\n                .reduce(mergeAccessorData, []);\r\n\r\n            for (const { getters, setters } of accessors) {\r\n\r\n                // Don't report accessor properties that have duplicate getters or setters.\r\n                if (getters.length === 1 && setters.length === 1) {\r\n                    const [getter] = getters,\r\n                        [setter] = setters,\r\n                        getterIndex = nodes.indexOf(getter),\r\n                        setterIndex = nodes.indexOf(setter),\r\n                        formerNode = getterIndex < setterIndex ? getter : setter,\r\n                        latterNode = getterIndex < setterIndex ? setter : getter;\r\n\r\n                    if (Math.abs(getterIndex - setterIndex) > 1) {\r\n                        report(\"notGrouped\", formerNode, latterNode);\r\n                    } else if (\r\n                        (order === \"getBeforeSet\" && getterIndex > setterIndex) ||\r\n                        (order === \"setBeforeGet\" && getterIndex < setterIndex)\r\n                    ) {\r\n                        report(\"invalidOrder\", formerNode, latterNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            ObjectExpression(node) {\r\n                checkList(node.properties, n => n.type === \"Property\");\r\n            },\r\n            ClassBody(node) {\r\n                checkList(node.body, n => n.type === \"MethodDefinition\" && !n.static);\r\n                checkList(node.body, n => n.type === \"MethodDefinition\" && n.static);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}