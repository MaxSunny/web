{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\r\n * @author James Allardice\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  getStaticValue\n} = require(\"eslint-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`-like methods\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-implied-eval\"\n    },\n    schema: [],\n    messages: {\n      impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\n    }\n  },\n\n  create(context) {\n    const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n    const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\n    /**\r\n     * Checks whether a node is evaluated as a string or not.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} True if the node is evaluated as a string.\r\n     */\n\n    function isEvaluatedString(node) {\n      if (node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\") {\n        return true;\n      }\n\n      if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\n        return isEvaluatedString(node.left) || isEvaluatedString(node.right);\n      }\n\n      return false;\n    }\n    /**\r\n     * Reports if the `CallExpression` node has evaluated argument.\r\n     * @param {ASTNode} node A CallExpression to check.\r\n     * @returns {void}\r\n     */\n\n\n    function reportImpliedEvalCallExpression(node) {\n      const [firstArgument] = node.arguments;\n\n      if (firstArgument) {\n        const staticValue = getStaticValue(firstArgument, context.getScope());\n        const isStaticString = staticValue && typeof staticValue.value === \"string\";\n        const isString = isStaticString || isEvaluatedString(firstArgument);\n\n        if (isString) {\n          context.report({\n            node,\n            messageId: \"impliedEval\"\n          });\n        }\n      }\n    }\n    /**\r\n     * Reports calls of `implied eval` via the global references.\r\n     * @param {Variable} globalVar A global variable to check.\r\n     * @returns {void}\r\n     */\n\n\n    function reportImpliedEvalViaGlobal(globalVar) {\n      const {\n        references,\n        name\n      } = globalVar;\n      references.forEach(ref => {\n        const identifier = ref.identifier;\n        let node = identifier.parent;\n\n        while (astUtils.isSpecificMemberAccess(node, null, name)) {\n          node = node.parent;\n        }\n\n        if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\n          const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n          const parent = calleeNode.parent;\n\n          if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\n            reportImpliedEvalCallExpression(parent);\n          }\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\n          reportImpliedEvalCallExpression(node);\n        }\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        GLOBAL_CANDIDATES.map(candidate => astUtils.getVariableByName(globalScope, candidate)).filter(globalVar => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-implied-eval.js"],"names":["astUtils","require","getStaticValue","module","exports","meta","type","docs","description","recommended","url","schema","messages","impliedEval","create","context","GLOBAL_CANDIDATES","Object","freeze","EVAL_LIKE_FUNC_PATTERN","isEvaluatedString","node","value","operator","left","right","reportImpliedEvalCallExpression","firstArgument","arguments","staticValue","getScope","isStaticString","isString","report","messageId","reportImpliedEvalViaGlobal","globalVar","references","name","forEach","ref","identifier","parent","isSpecificMemberAccess","calleeNode","callee","CallExpression","isSpecificId","globalScope","map","candidate","getVariableByName","filter","defs","length"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\r\n * @author James Allardice\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { getStaticValue } = require(\"eslint-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow the use of `eval()`-like methods\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-implied-eval\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            impliedEval: \"Implied eval. Consider passing a function instead of a string.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const GLOBAL_CANDIDATES = Object.freeze([\"global\", \"window\", \"globalThis\"]);\r\n        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;\r\n\r\n        /**\r\n         * Checks whether a node is evaluated as a string or not.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} True if the node is evaluated as a string.\r\n         */\r\n        function isEvaluatedString(node) {\r\n            if (\r\n                (node.type === \"Literal\" && typeof node.value === \"string\") ||\r\n                node.type === \"TemplateLiteral\"\r\n            ) {\r\n                return true;\r\n            }\r\n            if (node.type === \"BinaryExpression\" && node.operator === \"+\") {\r\n                return isEvaluatedString(node.left) || isEvaluatedString(node.right);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Reports if the `CallExpression` node has evaluated argument.\r\n         * @param {ASTNode} node A CallExpression to check.\r\n         * @returns {void}\r\n         */\r\n        function reportImpliedEvalCallExpression(node) {\r\n            const [firstArgument] = node.arguments;\r\n\r\n            if (firstArgument) {\r\n\r\n                const staticValue = getStaticValue(firstArgument, context.getScope());\r\n                const isStaticString = staticValue && typeof staticValue.value === \"string\";\r\n                const isString = isStaticString || isEvaluatedString(firstArgument);\r\n\r\n                if (isString) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"impliedEval\"\r\n                    });\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Reports calls of `implied eval` via the global references.\r\n         * @param {Variable} globalVar A global variable to check.\r\n         * @returns {void}\r\n         */\r\n        function reportImpliedEvalViaGlobal(globalVar) {\r\n            const { references, name } = globalVar;\r\n\r\n            references.forEach(ref => {\r\n                const identifier = ref.identifier;\r\n                let node = identifier.parent;\r\n\r\n                while (astUtils.isSpecificMemberAccess(node, null, name)) {\r\n                    node = node.parent;\r\n                }\r\n\r\n                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {\r\n                    const calleeNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\r\n                    const parent = calleeNode.parent;\r\n\r\n                    if (parent.type === \"CallExpression\" && parent.callee === calleeNode) {\r\n                        reportImpliedEvalCallExpression(parent);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            CallExpression(node) {\r\n                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {\r\n                    reportImpliedEvalCallExpression(node);\r\n                }\r\n            },\r\n            \"Program:exit\"() {\r\n                const globalScope = context.getScope();\r\n\r\n                GLOBAL_CANDIDATES\r\n                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))\r\n                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)\r\n                    .forEach(reportImpliedEvalViaGlobal);\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}