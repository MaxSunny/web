{"ast":null,"code":"/**\r\n * @fileoverview Object to handle access and retrieval of tokens.\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst assert = require(\"assert\");\n\nconst {\n  isCommentToken\n} = require(\"eslint-utils\");\n\nconst cursors = require(\"./cursors\");\n\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\n\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\n\nconst utils = require(\"./utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TOKENS = Symbol(\"tokens\");\nconst COMMENTS = Symbol(\"comments\");\nconst INDEX_MAP = Symbol(\"indexMap\");\n/**\r\n * Creates the map from locations to indices in `tokens`.\r\n *\r\n * The first/last location of tokens is mapped to the index of the token.\r\n * The first/last location of comments is mapped to the index of the next token of each comment.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @returns {Object} The map from locations to indices in `tokens`.\r\n * @private\r\n */\n\nfunction createIndexMap(tokens, comments) {\n  const map = Object.create(null);\n  let tokenIndex = 0;\n  let commentIndex = 0;\n  let nextStart = 0;\n  let range = null;\n\n  while (tokenIndex < tokens.length || commentIndex < comments.length) {\n    nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      tokenIndex += 1;\n    }\n\n    nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\n\n    while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\n      map[range[0]] = tokenIndex;\n      map[range[1] - 1] = tokenIndex;\n      commentIndex += 1;\n    }\n  }\n\n  return map;\n}\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\n\n\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let skip = 0;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    skip = opts | 0;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    skip = opts.skip | 0;\n    filter = opts.filter || null;\n  }\n\n  assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\n}\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\n\n\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\n  let includeComments = false;\n  let count = 0;\n  let countExists = false;\n  let filter = null;\n\n  if (typeof opts === \"number\") {\n    count = opts | 0;\n    countExists = true;\n  } else if (typeof opts === \"function\") {\n    filter = opts;\n  } else if (opts) {\n    includeComments = !!opts.includeComments;\n    count = opts.count | 0;\n    countExists = typeof opts.count === \"number\";\n    filter = opts.filter || null;\n  }\n\n  assert(count >= 0, \"options.count should be zero or a positive integer.\");\n  assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\n  return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\n}\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * This is overload function of the below.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\n\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\r\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\n\n\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\n  if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\n    return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\n  }\n\n  if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\n    return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\n  }\n\n  return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\n}\n/**\r\n * Gets comment tokens that are adjacent to the current cursor position.\r\n * @param {Cursor} cursor A cursor instance.\r\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\r\n * @private\r\n */\n\n\nfunction getAdjacentCommentTokensFromCursor(cursor) {\n  const tokens = [];\n  let currentToken = cursor.getOneToken();\n\n  while (currentToken && isCommentToken(currentToken)) {\n    tokens.push(currentToken);\n    currentToken = cursor.getOneToken();\n  }\n\n  return tokens;\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\r\n * The token store.\r\n *\r\n * This class provides methods to get tokens by locations as fast as possible.\r\n * The methods are a part of public API, so we should be careful if it changes this class.\r\n *\r\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\r\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\r\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\r\n * This uses binary-searching instead for comments.\r\n */\n\n\nmodule.exports = class TokenStore {\n  /**\r\n   * Initializes this token store.\r\n   * @param {Token[]} tokens The array of tokens.\r\n   * @param {Comment[]} comments The array of comments.\r\n   */\n  constructor(tokens, comments) {\n    this[TOKENS] = tokens;\n    this[COMMENTS] = comments;\n    this[INDEX_MAP] = createIndexMap(tokens, comments);\n  } //--------------------------------------------------------------------------\n  // Gets single token.\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Gets the token starting at the specified index.\r\n   * @param {number} offset Index of the start of the token's range.\r\n   * @param {Object} [options=0] The option object.\r\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n   * @returns {Token|null} The token starting at index, or null if no such token.\r\n   */\n\n\n  getTokenByRangeStart(offset, options) {\n    const includeComments = options && options.includeComments;\n    const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();\n\n    if (token && token.range[0] === offset) {\n      return token;\n    }\n\n    return null;\n  }\n  /**\r\n   * Gets the first token of the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\r\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n   * @param {number} [options.skip=0] The count of tokens the cursor skips.\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getFirstToken(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n  /**\r\n   * Gets the last token of the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getLastToken(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();\n  }\n  /**\r\n   * Gets the token that precedes a given node or token.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getTokenBefore(node, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();\n  }\n  /**\r\n   * Gets the token that follows a given node or token.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getTokenAfter(node, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();\n  }\n  /**\r\n   * Gets the first token between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getFirstTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n  /**\r\n   * Gets the last token between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n   * @returns {Token|null} An object representing the token.\r\n   */\n\n\n  getLastTokenBetween(left, right, options) {\n    return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();\n  }\n  /**\r\n   * Gets the token that precedes a given node or token in the token stream.\r\n   * This is defined for backward compatibility. Use `includeComments` option instead.\r\n   * TODO: We have a plan to remove this in a future major version.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number} [skip=0] A number of tokens to skip.\r\n   * @returns {Token|null} An object representing the token.\r\n   * @deprecated\r\n   */\n\n\n  getTokenOrCommentBefore(node, skip) {\n    return this.getTokenBefore(node, {\n      includeComments: true,\n      skip\n    });\n  }\n  /**\r\n   * Gets the token that follows a given node or token in the token stream.\r\n   * This is defined for backward compatibility. Use `includeComments` option instead.\r\n   * TODO: We have a plan to remove this in a future major version.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number} [skip=0] A number of tokens to skip.\r\n   * @returns {Token|null} An object representing the token.\r\n   * @deprecated\r\n   */\n\n\n  getTokenOrCommentAfter(node, skip) {\n    return this.getTokenAfter(node, {\n      includeComments: true,\n      skip\n    });\n  } //--------------------------------------------------------------------------\n  // Gets multiple tokens.\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Gets the first `count` tokens of the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\r\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n   * @returns {Token[]} Tokens.\r\n   */\n\n\n  getFirstTokens(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();\n  }\n  /**\r\n   * Gets the last `count` tokens of the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n   * @returns {Token[]} Tokens.\r\n   */\n\n\n  getLastTokens(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();\n  }\n  /**\r\n   * Gets the `count` tokens that precedes a given node or token.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n   * @returns {Token[]} Tokens.\r\n   */\n\n\n  getTokensBefore(node, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();\n  }\n  /**\r\n   * Gets the `count` tokens that follows a given node or token.\r\n   * @param {ASTNode|Token|Comment} node The AST node or token.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n   * @returns {Token[]} Tokens.\r\n   */\n\n\n  getTokensAfter(node, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();\n  }\n  /**\r\n   * Gets the first `count` tokens between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n   * @returns {Token[]} Tokens between left and right.\r\n   */\n\n\n  getFirstTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();\n  }\n  /**\r\n   * Gets the last `count` tokens between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n   * @returns {Token[]} Tokens between left and right.\r\n   */\n\n\n  getLastTokensBetween(left, right, options) {\n    return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();\n  }\n  /**\r\n   * Gets all tokens that are related to the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\r\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n   * @returns {Token[]} Array of objects representing tokens.\r\n   */\n\n  /**\r\n   * Gets all tokens that are related to the given node.\r\n   * @param {ASTNode} node The AST node.\r\n   * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\r\n   * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\r\n   * @returns {Token[]} Array of objects representing tokens.\r\n   */\n\n\n  getTokens(node, beforeCount, afterCount) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();\n  }\n  /**\r\n   * Gets all of the tokens between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\r\n   * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n   * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n   * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n   * @returns {Token[]} Tokens between left and right.\r\n   */\n\n  /**\r\n   * Gets all of the tokens between two non-overlapping nodes.\r\n   * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n   * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n   * @param {int} [padding=0] Number of extra tokens on either side of center.\r\n   * @returns {Token[]} Tokens between left and right.\r\n   */\n\n\n  getTokensBetween(left, right, padding) {\n    return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();\n  } //--------------------------------------------------------------------------\n  // Others.\n  //--------------------------------------------------------------------------\n\n  /**\r\n   * Checks whether any comments exist or not between the given 2 nodes.\r\n   * @param {ASTNode} left The node to check.\r\n   * @param {ASTNode} right The node to check.\r\n   * @returns {boolean} `true` if one or more comments exist.\r\n   */\n\n\n  commentsExistBetween(left, right) {\n    const index = utils.search(this[COMMENTS], left.range[1]);\n    return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];\n  }\n  /**\r\n   * Gets all comment tokens directly before the given node or token.\r\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\r\n   * @returns {Array} An array of comments in occurrence order.\r\n   */\n\n\n  getCommentsBefore(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor).reverse();\n  }\n  /**\r\n   * Gets all comment tokens directly after the given node or token.\r\n   * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\r\n   * @returns {Array} An array of comments in occurrence order.\r\n   */\n\n\n  getCommentsAfter(nodeOrToken) {\n    const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {\n      includeComments: true\n    });\n    return getAdjacentCommentTokensFromCursor(cursor);\n  }\n  /**\r\n   * Gets all comment tokens inside the given node.\r\n   * @param {ASTNode} node The AST node to get the comments for.\r\n   * @returns {Array} An array of comments in occurrence order.\r\n   */\n\n\n  getCommentsInside(node) {\n    return this.getTokens(node, {\n      includeComments: true,\n      filter: isCommentToken\n    });\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/source-code/token-store/index.js"],"names":["assert","require","isCommentToken","cursors","ForwardTokenCursor","PaddedTokenCursor","utils","TOKENS","Symbol","COMMENTS","INDEX_MAP","createIndexMap","tokens","comments","map","Object","create","tokenIndex","commentIndex","nextStart","range","length","Number","MAX_SAFE_INTEGER","createCursorWithSkip","factory","indexMap","startLoc","endLoc","opts","includeComments","skip","filter","createCursor","createCursorWithCount","count","countExists","createCursorWithPadding","beforeCount","afterCount","forward","getAdjacentCommentTokensFromCursor","cursor","currentToken","getOneToken","push","module","exports","TokenStore","constructor","getTokenByRangeStart","offset","options","token","createBaseCursor","getFirstToken","node","getLastToken","backward","getTokenBefore","getTokenAfter","getFirstTokenBetween","left","right","getLastTokenBetween","getTokenOrCommentBefore","getTokenOrCommentAfter","getFirstTokens","getAllTokens","getLastTokens","reverse","getTokensBefore","getTokensAfter","getFirstTokensBetween","getLastTokensBetween","getTokens","getTokensBetween","padding","commentsExistBetween","index","search","getCommentsBefore","nodeOrToken","getCommentsAfter","getCommentsInside"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Object to handle access and retrieval of tokens.\r\n * @author Brandon Mills\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst assert = require(\"assert\");\r\nconst { isCommentToken } = require(\"eslint-utils\");\r\nconst cursors = require(\"./cursors\");\r\nconst ForwardTokenCursor = require(\"./forward-token-cursor\");\r\nconst PaddedTokenCursor = require(\"./padded-token-cursor\");\r\nconst utils = require(\"./utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst TOKENS = Symbol(\"tokens\");\r\nconst COMMENTS = Symbol(\"comments\");\r\nconst INDEX_MAP = Symbol(\"indexMap\");\r\n\r\n/**\r\n * Creates the map from locations to indices in `tokens`.\r\n *\r\n * The first/last location of tokens is mapped to the index of the token.\r\n * The first/last location of comments is mapped to the index of the next token of each comment.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @returns {Object} The map from locations to indices in `tokens`.\r\n * @private\r\n */\r\nfunction createIndexMap(tokens, comments) {\r\n    const map = Object.create(null);\r\n    let tokenIndex = 0;\r\n    let commentIndex = 0;\r\n    let nextStart = 0;\r\n    let range = null;\r\n\r\n    while (tokenIndex < tokens.length || commentIndex < comments.length) {\r\n        nextStart = (commentIndex < comments.length) ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;\r\n        while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {\r\n            map[range[0]] = tokenIndex;\r\n            map[range[1] - 1] = tokenIndex;\r\n            tokenIndex += 1;\r\n        }\r\n\r\n        nextStart = (tokenIndex < tokens.length) ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;\r\n        while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {\r\n            map[range[0]] = tokenIndex;\r\n            map[range[1] - 1] = tokenIndex;\r\n            commentIndex += 1;\r\n        }\r\n    }\r\n\r\n    return map;\r\n}\r\n\r\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.skip`. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments=false] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.skip=0] The count of tokens the cursor skips.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\r\nfunction createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\r\n    let includeComments = false;\r\n    let skip = 0;\r\n    let filter = null;\r\n\r\n    if (typeof opts === \"number\") {\r\n        skip = opts | 0;\r\n    } else if (typeof opts === \"function\") {\r\n        filter = opts;\r\n    } else if (opts) {\r\n        includeComments = !!opts.includeComments;\r\n        skip = opts.skip | 0;\r\n        filter = opts.filter || null;\r\n    }\r\n    assert(skip >= 0, \"options.skip should be zero or a positive integer.\");\r\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\r\n\r\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);\r\n}\r\n\r\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {CursorFactory} factory The cursor factory to initialize cursor.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number|Function|Object} [opts=0] The option object. If this is a number then it's `opts.count`. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\r\nfunction createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {\r\n    let includeComments = false;\r\n    let count = 0;\r\n    let countExists = false;\r\n    let filter = null;\r\n\r\n    if (typeof opts === \"number\") {\r\n        count = opts | 0;\r\n        countExists = true;\r\n    } else if (typeof opts === \"function\") {\r\n        filter = opts;\r\n    } else if (opts) {\r\n        includeComments = !!opts.includeComments;\r\n        count = opts.count | 0;\r\n        countExists = typeof opts.count === \"number\";\r\n        filter = opts.filter || null;\r\n    }\r\n    assert(count >= 0, \"options.count should be zero or a positive integer.\");\r\n    assert(!filter || typeof filter === \"function\", \"options.filter should be a function.\");\r\n\r\n    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);\r\n}\r\n\r\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * This is overload function of the below.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {Function|Object} opts The option object. If this is a function then it's `opts.filter`.\r\n * @param {boolean} [opts.includeComments] The flag to iterate comments as well.\r\n * @param {Function|null} [opts.filter=null] The predicate function to choose tokens.\r\n * @param {number} [opts.count=0] The maximum count of tokens the cursor iterates. Zero is no iteration for backward compatibility.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\r\n/**\r\n * Creates the cursor iterates tokens with options.\r\n * @param {Token[]} tokens The array of tokens.\r\n * @param {Comment[]} comments The array of comments.\r\n * @param {Object} indexMap The map from locations to indices in `tokens`.\r\n * @param {number} startLoc The start location of the iteration range.\r\n * @param {number} endLoc The end location of the iteration range.\r\n * @param {number} [beforeCount=0] The number of tokens before the node to retrieve.\r\n * @param {boolean} [afterCount=0] The number of tokens after the node to retrieve.\r\n * @returns {Cursor} The created cursor.\r\n * @private\r\n */\r\nfunction createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {\r\n    if (typeof beforeCount === \"undefined\" && typeof afterCount === \"undefined\") {\r\n        return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);\r\n    }\r\n    if (typeof beforeCount === \"number\" || typeof beforeCount === \"undefined\") {\r\n        return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);\r\n    }\r\n    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);\r\n}\r\n\r\n/**\r\n * Gets comment tokens that are adjacent to the current cursor position.\r\n * @param {Cursor} cursor A cursor instance.\r\n * @returns {Array} An array of comment tokens adjacent to the current cursor position.\r\n * @private\r\n */\r\nfunction getAdjacentCommentTokensFromCursor(cursor) {\r\n    const tokens = [];\r\n    let currentToken = cursor.getOneToken();\r\n\r\n    while (currentToken && isCommentToken(currentToken)) {\r\n        tokens.push(currentToken);\r\n        currentToken = cursor.getOneToken();\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Exports\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * The token store.\r\n *\r\n * This class provides methods to get tokens by locations as fast as possible.\r\n * The methods are a part of public API, so we should be careful if it changes this class.\r\n *\r\n * People can get tokens in O(1) by the hash map which is mapping from the location of tokens/comments to tokens.\r\n * Also people can get a mix of tokens and comments in O(log k), the k is the number of comments.\r\n * Assuming that comments to be much fewer than tokens, this does not make hash map from token's locations to comments to reduce memory cost.\r\n * This uses binary-searching instead for comments.\r\n */\r\nmodule.exports = class TokenStore {\r\n\r\n    /**\r\n     * Initializes this token store.\r\n     * @param {Token[]} tokens The array of tokens.\r\n     * @param {Comment[]} comments The array of comments.\r\n     */\r\n    constructor(tokens, comments) {\r\n        this[TOKENS] = tokens;\r\n        this[COMMENTS] = comments;\r\n        this[INDEX_MAP] = createIndexMap(tokens, comments);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Gets single token.\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the token starting at the specified index.\r\n     * @param {number} offset Index of the start of the token's range.\r\n     * @param {Object} [options=0] The option object.\r\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n     * @returns {Token|null} The token starting at index, or null if no such token.\r\n     */\r\n    getTokenByRangeStart(offset, options) {\r\n        const includeComments = options && options.includeComments;\r\n        const token = cursors.forward.createBaseCursor(\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            offset,\r\n            -1,\r\n            includeComments\r\n        ).getOneToken();\r\n\r\n        if (token && token.range[0] === offset) {\r\n            return token;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the first token of the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.skip`. If this is a function then it's `options.filter`.\r\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n     * @param {number} [options.skip=0] The count of tokens the cursor skips.\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getFirstToken(node, options) {\r\n        return createCursorWithSkip(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[0],\r\n            node.range[1],\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the last token of the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getLastToken(node, options) {\r\n        return createCursorWithSkip(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[0],\r\n            node.range[1],\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the token that precedes a given node or token.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getTokenBefore(node, options) {\r\n        return createCursorWithSkip(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            -1,\r\n            node.range[0],\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the token that follows a given node or token.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getTokenAfter(node, options) {\r\n        return createCursorWithSkip(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[1],\r\n            -1,\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the first token between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getFirstTokenBetween(left, right, options) {\r\n        return createCursorWithSkip(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            left.range[1],\r\n            right.range[0],\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the last token between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstToken()\r\n     * @returns {Token|null} An object representing the token.\r\n     */\r\n    getLastTokenBetween(left, right, options) {\r\n        return createCursorWithSkip(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            left.range[1],\r\n            right.range[0],\r\n            options\r\n        ).getOneToken();\r\n    }\r\n\r\n    /**\r\n     * Gets the token that precedes a given node or token in the token stream.\r\n     * This is defined for backward compatibility. Use `includeComments` option instead.\r\n     * TODO: We have a plan to remove this in a future major version.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number} [skip=0] A number of tokens to skip.\r\n     * @returns {Token|null} An object representing the token.\r\n     * @deprecated\r\n     */\r\n    getTokenOrCommentBefore(node, skip) {\r\n        return this.getTokenBefore(node, { includeComments: true, skip });\r\n    }\r\n\r\n    /**\r\n     * Gets the token that follows a given node or token in the token stream.\r\n     * This is defined for backward compatibility. Use `includeComments` option instead.\r\n     * TODO: We have a plan to remove this in a future major version.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number} [skip=0] A number of tokens to skip.\r\n     * @returns {Token|null} An object representing the token.\r\n     * @deprecated\r\n     */\r\n    getTokenOrCommentAfter(node, skip) {\r\n        return this.getTokenAfter(node, { includeComments: true, skip });\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Gets multiple tokens.\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the first `count` tokens of the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {number|Function|Object} [options=0] The option object. If this is a number then it's `options.count`. If this is a function then it's `options.filter`.\r\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n     * @returns {Token[]} Tokens.\r\n     */\r\n    getFirstTokens(node, options) {\r\n        return createCursorWithCount(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[0],\r\n            node.range[1],\r\n            options\r\n        ).getAllTokens();\r\n    }\r\n\r\n    /**\r\n     * Gets the last `count` tokens of the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n     * @returns {Token[]} Tokens.\r\n     */\r\n    getLastTokens(node, options) {\r\n        return createCursorWithCount(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[0],\r\n            node.range[1],\r\n            options\r\n        ).getAllTokens().reverse();\r\n    }\r\n\r\n    /**\r\n     * Gets the `count` tokens that precedes a given node or token.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n     * @returns {Token[]} Tokens.\r\n     */\r\n    getTokensBefore(node, options) {\r\n        return createCursorWithCount(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            -1,\r\n            node.range[0],\r\n            options\r\n        ).getAllTokens().reverse();\r\n    }\r\n\r\n    /**\r\n     * Gets the `count` tokens that follows a given node or token.\r\n     * @param {ASTNode|Token|Comment} node The AST node or token.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n     * @returns {Token[]} Tokens.\r\n     */\r\n    getTokensAfter(node, options) {\r\n        return createCursorWithCount(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[1],\r\n            -1,\r\n            options\r\n        ).getAllTokens();\r\n    }\r\n\r\n    /**\r\n     * Gets the first `count` tokens between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n     * @returns {Token[]} Tokens between left and right.\r\n     */\r\n    getFirstTokensBetween(left, right, options) {\r\n        return createCursorWithCount(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            left.range[1],\r\n            right.range[0],\r\n            options\r\n        ).getAllTokens();\r\n    }\r\n\r\n    /**\r\n     * Gets the last `count` tokens between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {number|Function|Object} [options=0] The option object. Same options as getFirstTokens()\r\n     * @returns {Token[]} Tokens between left and right.\r\n     */\r\n    getLastTokensBetween(left, right, options) {\r\n        return createCursorWithCount(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            left.range[1],\r\n            right.range[0],\r\n            options\r\n        ).getAllTokens().reverse();\r\n    }\r\n\r\n    /**\r\n     * Gets all tokens that are related to the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\r\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n     * @returns {Token[]} Array of objects representing tokens.\r\n     */\r\n    /**\r\n     * Gets all tokens that are related to the given node.\r\n     * @param {ASTNode} node The AST node.\r\n     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.\r\n     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.\r\n     * @returns {Token[]} Array of objects representing tokens.\r\n     */\r\n    getTokens(node, beforeCount, afterCount) {\r\n        return createCursorWithPadding(\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            node.range[0],\r\n            node.range[1],\r\n            beforeCount,\r\n            afterCount\r\n        ).getAllTokens();\r\n    }\r\n\r\n    /**\r\n     * Gets all of the tokens between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {Function|Object} options The option object. If this is a function then it's `options.filter`.\r\n     * @param {boolean} [options.includeComments=false] The flag to iterate comments as well.\r\n     * @param {Function|null} [options.filter=null] The predicate function to choose tokens.\r\n     * @param {number} [options.count=0] The maximum count of tokens the cursor iterates.\r\n     * @returns {Token[]} Tokens between left and right.\r\n     */\r\n    /**\r\n     * Gets all of the tokens between two non-overlapping nodes.\r\n     * @param {ASTNode|Token|Comment} left Node before the desired token range.\r\n     * @param {ASTNode|Token|Comment} right Node after the desired token range.\r\n     * @param {int} [padding=0] Number of extra tokens on either side of center.\r\n     * @returns {Token[]} Tokens between left and right.\r\n     */\r\n    getTokensBetween(left, right, padding) {\r\n        return createCursorWithPadding(\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            left.range[1],\r\n            right.range[0],\r\n            padding,\r\n            padding\r\n        ).getAllTokens();\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Others.\r\n    //--------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Checks whether any comments exist or not between the given 2 nodes.\r\n     * @param {ASTNode} left The node to check.\r\n     * @param {ASTNode} right The node to check.\r\n     * @returns {boolean} `true` if one or more comments exist.\r\n     */\r\n    commentsExistBetween(left, right) {\r\n        const index = utils.search(this[COMMENTS], left.range[1]);\r\n\r\n        return (\r\n            index < this[COMMENTS].length &&\r\n            this[COMMENTS][index].range[1] <= right.range[0]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets all comment tokens directly before the given node or token.\r\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\r\n     * @returns {Array} An array of comments in occurrence order.\r\n     */\r\n    getCommentsBefore(nodeOrToken) {\r\n        const cursor = createCursorWithCount(\r\n            cursors.backward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            -1,\r\n            nodeOrToken.range[0],\r\n            { includeComments: true }\r\n        );\r\n\r\n        return getAdjacentCommentTokensFromCursor(cursor).reverse();\r\n    }\r\n\r\n    /**\r\n     * Gets all comment tokens directly after the given node or token.\r\n     * @param {ASTNode|token} nodeOrToken The AST node or token to check for adjacent comment tokens.\r\n     * @returns {Array} An array of comments in occurrence order.\r\n     */\r\n    getCommentsAfter(nodeOrToken) {\r\n        const cursor = createCursorWithCount(\r\n            cursors.forward,\r\n            this[TOKENS],\r\n            this[COMMENTS],\r\n            this[INDEX_MAP],\r\n            nodeOrToken.range[1],\r\n            -1,\r\n            { includeComments: true }\r\n        );\r\n\r\n        return getAdjacentCommentTokensFromCursor(cursor);\r\n    }\r\n\r\n    /**\r\n     * Gets all comment tokens inside the given node.\r\n     * @param {ASTNode} node The AST node to get the comments for.\r\n     * @returns {Array} An array of comments in occurrence order.\r\n     */\r\n    getCommentsInside(node) {\r\n        return this.getTokens(node, {\r\n            includeComments: true,\r\n            filter: isCommentToken\r\n        });\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}