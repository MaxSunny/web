{"ast":null,"code":"// A simple implementation of make-array\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\n\nconst EMPTY = '';\nconst SPACE = ' ';\nconst ESCAPE = '\\\\';\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/;\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g; // /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\n\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nconst SLASH = '/';\nconst KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')\n/* istanbul ignore next */\n: 'node-ignore';\n\nconst define = (object, key, value) => Object.defineProperty(object, key, {\n  value\n});\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;\n\nconst RETURN_FALSE = () => false; // Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\n\n\nconst sanitizeRange = range => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but\n//   fatal for JavaScript regular expression, so eliminate it.\n: EMPTY); // See fixtures #59\n\n\nconst cleanRangeBackSlash = slashes => {\n  const {\n    length\n  } = slashes;\n  return slashes.slice(0, length - length % 2);\n}; // > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\n\n\nconst REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, match => match.indexOf('\\\\') === 0 ? SPACE : EMPTY], // replace (\\ ) with ' '\n[/\\\\\\s/g, () => SPACE], // Escape metacharacters\n// which is written down by users but means special for regular expressions.\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, match => `\\\\${match}`], [// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, () => '[^/]'], // leading slash\n[// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, () => '^'], // replace special metacharacter slash after the leading slash\n[/\\//g, () => '\\\\/'], [// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//, // '**/foo' <-> 'foo'\n() => '^(?:.*\\\\/)?'], // starting\n[// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this) // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}], // two globstars\n[// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g, // Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n// Check if it is not the last `'/**'`\n(_, index, str) => index + 6 < str.length // case: /**/\n// > A slash followed by two consecutive asterisks then a slash matches\n// >   zero or more directories.\n// > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n// '/**/'\n? '(?:\\\\/[^\\\\/]+)*' // case: /**\n// > A trailing `\"/**\"` matches everything inside.\n// #21: everything inside but it should not include the current folder\n: '\\\\/.+'], // intermediate wildcards\n[// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g, // '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\n(_, p1) => `${p1}[^\\\\/]*`], [// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, () => ESCAPE], [// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, () => ESCAPE], [// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation\n// '[bar]'\n// '[bar\\\\\\\\]'\n? `[${sanitizeRange(range)}${endEscape}]` // Invalid range notaton\n// '[bar\\\\]' -> '[bar\\\\\\\\]'\n: '[]' : '[]'], // ending\n[// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/, // WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nmatch => /\\/$/.test(match) // foo/ will not match 'foo'\n? `${match}$` // foo matches 'foo' and 'foo/'\n: `${match}(?=$|\\\\/$)`], // trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, (_, p1) => {\n  const prefix = p1 // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? `${p1}[^/]+` // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return `${prefix}(?=$|\\\\/$)`;\n}]]; // A simple cache, because an ignore rule only has only one certain meaning\n\nconst regexCache = Object.create(null); // @param {pattern}\n\nconst makeRegex = (pattern, ignoreCase) => {\n  let source = regexCache[pattern];\n\n  if (!source) {\n    source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);\n    regexCache[pattern] = source;\n  }\n\n  return ignoreCase ? new RegExp(source, 'i') : new RegExp(source);\n};\n\nconst isString = subject => typeof subject === 'string'; // > A blank line matches no files, so it can serve as a separator for readability.\n\n\nconst checkPattern = pattern => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.\n&& pattern.indexOf('#') !== 0;\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF);\n\nclass IgnoreRule {\n  constructor(origin, pattern, negative, regex) {\n    this.origin = origin;\n    this.pattern = pattern;\n    this.negative = negative;\n    this.regex = regex;\n  }\n\n}\n\nconst createRule = (pattern, ignoreCase) => {\n  const origin = pattern;\n  let negative = false; // > An optional prefix \"!\" which negates the pattern;\n\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n\n  pattern = pattern // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  const regex = makeRegex(pattern, ignoreCase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message);\n};\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(`path must be a string, but got \\`${originalPath}\\``, TypeError);\n  } // We don't know if we should ignore EMPTY, so throw\n\n\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError);\n  } // Check if it is a relative path\n\n\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d';\n    return doThrow(`path should be a ${r} string, but got \"${originalPath}\"`, RangeError);\n  }\n\n  return true;\n};\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path);\n\ncheckPath.isNotRelative = isNotRelative;\n\ncheckPath.convert = p => p;\n\nclass Ignore {\n  constructor() {\n    let {\n      ignorecase = true,\n      ignoreCase = ignorecase,\n      allowRelativePaths = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    define(this, KEY_IGNORE, true);\n    this._rules = [];\n    this._ignoreCase = ignoreCase;\n    this._allowRelativePaths = allowRelativePaths;\n\n    this._initCache();\n  }\n\n  _initCache() {\n    this._ignoreCache = Object.create(null);\n    this._testCache = Object.create(null);\n  }\n\n  _addPattern(pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules);\n      this._added = true;\n      return;\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignoreCase);\n      this._added = true;\n\n      this._rules.push(rule);\n    }\n  } // @param {Array<string> | string | Ignore} pattern\n\n\n  add(pattern) {\n    this._added = false;\n    makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,\n    // making the behavior changed.\n\n    if (this._added) {\n      this._initCache();\n    }\n\n    return this;\n  } // legacy\n\n\n  addPattern(pattern) {\n    return this.add(pattern);\n  } //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n  // @returns {TestResult} true if a file is ignored\n\n\n  _testOne(path, checkUnignored) {\n    let ignored = false;\n    let unignored = false;\n\n    this._rules.forEach(rule => {\n      const {\n        negative\n      } = rule;\n\n      if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n        return;\n      }\n\n      const matched = rule.regex.test(path);\n\n      if (matched) {\n        ignored = !negative;\n        unignored = negative;\n      }\n    });\n\n    return {\n      ignored,\n      unignored\n    };\n  } // @returns {TestResult}\n\n\n  _test(originalPath, cache, checkUnignored, slices) {\n    const path = originalPath // Supports nullable path\n    && checkPath.convert(originalPath);\n    checkPath(path, originalPath, this._allowRelativePaths ? RETURN_FALSE : throwError);\n    return this._t(path, cache, checkUnignored, slices);\n  }\n\n  _t(path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path];\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH);\n    }\n\n    slices.pop(); // If the path has no parent directory, just test it\n\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored);\n    }\n\n    const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first\n\n\n    return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of\n    // >   that file is excluded.\n    ? parent : this._testOne(path, checkUnignored);\n  }\n\n  ignores(path) {\n    return this._test(path, this._ignoreCache, false).ignored;\n  }\n\n  createFilter() {\n    return path => !this.ignores(path);\n  }\n\n  filter(paths) {\n    return makeArray(paths).filter(this.createFilter());\n  } // @returns {TestResult}\n\n\n  test(path) {\n    return this._test(path, this._testCache, true);\n  }\n\n}\n\nconst factory = options => new Ignore(options);\n\nconst isPathValid = path => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);\n\nfactory.isPathValid = isPathValid; // Fixes typescript\n\nfactory.default = factory;\nmodule.exports = factory; // Windows\n// --------------------------------------------------------------\n\n/* istanbul ignore if  */\n\nif ( // Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str) || /[\"<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, '/');\n\n  checkPath.convert = makePosix; // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n\n  checkPath.isNotRelative = path => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n}","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/ignore/index.js"],"names":["makeArray","subject","Array","isArray","EMPTY","SPACE","ESCAPE","REGEX_TEST_BLANK_LINE","REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION","REGEX_REPLACE_LEADING_EXCAPED_HASH","REGEX_SPLITALL_CRLF","REGEX_TEST_INVALID_PATH","SLASH","KEY_IGNORE","Symbol","for","define","object","key","value","Object","defineProperty","REGEX_REGEXP_RANGE","RETURN_FALSE","sanitizeRange","range","replace","match","from","to","charCodeAt","cleanRangeBackSlash","slashes","length","slice","REPLACERS","indexOf","startingReplacer","test","_","index","str","p1","leadEscape","endEscape","close","prefix","regexCache","create","makeRegex","pattern","ignoreCase","source","reduce","prev","current","bind","RegExp","isString","checkPattern","splitPattern","split","IgnoreRule","constructor","origin","negative","regex","createRule","substr","throwError","message","Ctor","checkPath","path","originalPath","doThrow","TypeError","isNotRelative","r","RangeError","convert","p","Ignore","ignorecase","allowRelativePaths","_rules","_ignoreCase","_allowRelativePaths","_initCache","_ignoreCache","_testCache","_addPattern","concat","_added","rule","push","add","forEach","addPattern","_testOne","checkUnignored","ignored","unignored","matched","_test","cache","slices","_t","pop","parent","join","ignores","createFilter","filter","paths","factory","options","isPathValid","default","module","exports","process","env","IGNORE_TEST_WIN32","platform","makePosix","REGIX_IS_WINDOWS_PATH_ABSOLUTE"],"mappings":"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","sourcesContent":["// A simple implementation of make-array\r\nfunction makeArray (subject) {\r\n  return Array.isArray(subject)\r\n    ? subject\r\n    : [subject]\r\n}\r\n\r\nconst EMPTY = ''\r\nconst SPACE = ' '\r\nconst ESCAPE = '\\\\'\r\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\r\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\r\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\r\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\r\n// /foo,\r\n// ./foo,\r\n// ../foo,\r\n// .\r\n// ..\r\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\r\n\r\nconst SLASH = '/'\r\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\r\n  ? Symbol.for('node-ignore')\r\n  /* istanbul ignore next */\r\n  : 'node-ignore'\r\n\r\nconst define = (object, key, value) =>\r\n  Object.defineProperty(object, key, {value})\r\n\r\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\r\n\r\nconst RETURN_FALSE = () => false\r\n\r\n// Sanitize the range of a regular expression\r\n// The cases are complicated, see test cases for details\r\nconst sanitizeRange = range => range.replace(\r\n  REGEX_REGEXP_RANGE,\r\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\r\n    ? match\r\n    // Invalid range (out of order) which is ok for gitignore rules but\r\n    //   fatal for JavaScript regular expression, so eliminate it.\r\n    : EMPTY\r\n)\r\n\r\n// See fixtures #59\r\nconst cleanRangeBackSlash = slashes => {\r\n  const {length} = slashes\r\n  return slashes.slice(0, length - length % 2)\r\n}\r\n\r\n// > If the pattern ends with a slash,\r\n// > it is removed for the purpose of the following description,\r\n// > but it would only find a match with a directory.\r\n// > In other words, foo/ will match a directory foo and paths underneath it,\r\n// > but will not match a regular file or a symbolic link foo\r\n// >  (this is consistent with the way how pathspec works in general in Git).\r\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\r\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\r\n//      you could use option `mark: true` with `glob`\r\n\r\n// '`foo/`' should not continue with the '`..`'\r\nconst REPLACERS = [\r\n\r\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\r\n  [\r\n    // (a\\ ) -> (a )\r\n    // (a  ) -> (a)\r\n    // (a \\ ) -> (a  )\r\n    /\\\\?\\s+$/,\r\n    match => match.indexOf('\\\\') === 0\r\n      ? SPACE\r\n      : EMPTY\r\n  ],\r\n\r\n  // replace (\\ ) with ' '\r\n  [\r\n    /\\\\\\s/g,\r\n    () => SPACE\r\n  ],\r\n\r\n  // Escape metacharacters\r\n  // which is written down by users but means special for regular expressions.\r\n\r\n  // > There are 12 characters with special meanings:\r\n  // > - the backslash \\,\r\n  // > - the caret ^,\r\n  // > - the dollar sign $,\r\n  // > - the period or dot .,\r\n  // > - the vertical bar or pipe symbol |,\r\n  // > - the question mark ?,\r\n  // > - the asterisk or star *,\r\n  // > - the plus sign +,\r\n  // > - the opening parenthesis (,\r\n  // > - the closing parenthesis ),\r\n  // > - and the opening square bracket [,\r\n  // > - the opening curly brace {,\r\n  // > These special characters are often called \"metacharacters\".\r\n  [\r\n    /[\\\\$.|*+(){^]/g,\r\n    match => `\\\\${match}`\r\n  ],\r\n\r\n  [\r\n    // > a question mark (?) matches a single character\r\n    /(?!\\\\)\\?/g,\r\n    () => '[^/]'\r\n  ],\r\n\r\n  // leading slash\r\n  [\r\n\r\n    // > A leading slash matches the beginning of the pathname.\r\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\r\n    // A leading slash matches the beginning of the pathname\r\n    /^\\//,\r\n    () => '^'\r\n  ],\r\n\r\n  // replace special metacharacter slash after the leading slash\r\n  [\r\n    /\\//g,\r\n    () => '\\\\/'\r\n  ],\r\n\r\n  [\r\n    // > A leading \"**\" followed by a slash means match in all directories.\r\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\r\n    // > the same as pattern \"foo\".\r\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\r\n    // >   under directory \"foo\".\r\n    // Notice that the '*'s have been replaced as '\\\\*'\r\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\r\n\r\n    // '**/foo' <-> 'foo'\r\n    () => '^(?:.*\\\\/)?'\r\n  ],\r\n\r\n  // starting\r\n  [\r\n    // there will be no leading '/'\r\n    //   (which has been replaced by section \"leading slash\")\r\n    // If starts with '**', adding a '^' to the regular expression also works\r\n    /^(?=[^^])/,\r\n    function startingReplacer () {\r\n      // If has a slash `/` at the beginning or middle\r\n      return !/\\/(?!$)/.test(this)\r\n        // > Prior to 2.22.1\r\n        // > If the pattern does not contain a slash /,\r\n        // >   Git treats it as a shell glob pattern\r\n        // Actually, if there is only a trailing slash,\r\n        //   git also treats it as a shell glob pattern\r\n\r\n        // After 2.22.1 (compatible but clearer)\r\n        // > If there is a separator at the beginning or middle (or both)\r\n        // > of the pattern, then the pattern is relative to the directory\r\n        // > level of the particular .gitignore file itself.\r\n        // > Otherwise the pattern may also match at any level below\r\n        // > the .gitignore level.\r\n        ? '(?:^|\\\\/)'\r\n\r\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\r\n        // >   consumption by fnmatch(3)\r\n        : '^'\r\n    }\r\n  ],\r\n\r\n  // two globstars\r\n  [\r\n    // Use lookahead assertions so that we could match more than one `'/**'`\r\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\r\n\r\n    // Zero, one or several directories\r\n    // should not use '*', or it will be replaced by the next replacer\r\n\r\n    // Check if it is not the last `'/**'`\r\n    (_, index, str) => index + 6 < str.length\r\n\r\n      // case: /**/\r\n      // > A slash followed by two consecutive asterisks then a slash matches\r\n      // >   zero or more directories.\r\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\r\n      // '/**/'\r\n      ? '(?:\\\\/[^\\\\/]+)*'\r\n\r\n      // case: /**\r\n      // > A trailing `\"/**\"` matches everything inside.\r\n\r\n      // #21: everything inside but it should not include the current folder\r\n      : '\\\\/.+'\r\n  ],\r\n\r\n  // intermediate wildcards\r\n  [\r\n    // Never replace escaped '*'\r\n    // ignore rule '\\*' will match the path '*'\r\n\r\n    // 'abc.*/' -> go\r\n    // 'abc.*'  -> skip this rule\r\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\r\n\r\n    // '*.js' matches '.js'\r\n    // '*.js' doesn't match 'abc'\r\n    (_, p1) => `${p1}[^\\\\/]*`\r\n  ],\r\n\r\n  [\r\n    // unescape, revert step 3 except for back slash\r\n    // For example, if a user escape a '\\\\*',\r\n    // after step 3, the result will be '\\\\\\\\\\\\*'\r\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\r\n    () => ESCAPE\r\n  ],\r\n\r\n  [\r\n    // '\\\\\\\\' -> '\\\\'\r\n    /\\\\\\\\/g,\r\n    () => ESCAPE\r\n  ],\r\n\r\n  [\r\n    // > The range notation, e.g. [a-zA-Z],\r\n    // > can be used to match one of the characters in a range.\r\n\r\n    // `\\` is escaped by step 3\r\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\r\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\r\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\r\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\r\n      : close === ']'\r\n        ? endEscape.length % 2 === 0\r\n          // A normal case, and it is a range notation\r\n          // '[bar]'\r\n          // '[bar\\\\\\\\]'\r\n          ? `[${sanitizeRange(range)}${endEscape}]`\r\n          // Invalid range notaton\r\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\r\n          : '[]'\r\n        : '[]'\r\n  ],\r\n\r\n  // ending\r\n  [\r\n    // 'js' will not match 'js.'\r\n    // 'ab' will not match 'abc'\r\n    /(?:[^*])$/,\r\n\r\n    // WTF!\r\n    // https://git-scm.com/docs/gitignore\r\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\r\n    // which re-fixes #24, #38\r\n\r\n    // > If there is a separator at the end of the pattern then the pattern\r\n    // > will only match directories, otherwise the pattern can match both\r\n    // > files and directories.\r\n\r\n    // 'js*' will not match 'a.js'\r\n    // 'js/' will not match 'a.js'\r\n    // 'js' will match 'a.js' and 'a.js/'\r\n    match => /\\/$/.test(match)\r\n      // foo/ will not match 'foo'\r\n      ? `${match}$`\r\n      // foo matches 'foo' and 'foo/'\r\n      : `${match}(?=$|\\\\/$)`\r\n  ],\r\n\r\n  // trailing wildcard\r\n  [\r\n    /(\\^|\\\\\\/)?\\\\\\*$/,\r\n    (_, p1) => {\r\n      const prefix = p1\r\n        // '\\^':\r\n        // '/*' does not match EMPTY\r\n        // '/*' does not match everything\r\n\r\n        // '\\\\\\/':\r\n        // 'abc/*' does not match 'abc/'\r\n        ? `${p1}[^/]+`\r\n\r\n        // 'a*' matches 'a'\r\n        // 'a*' matches 'aa'\r\n        : '[^/]*'\r\n\r\n      return `${prefix}(?=$|\\\\/$)`\r\n    }\r\n  ],\r\n]\r\n\r\n// A simple cache, because an ignore rule only has only one certain meaning\r\nconst regexCache = Object.create(null)\r\n\r\n// @param {pattern}\r\nconst makeRegex = (pattern, ignoreCase) => {\r\n  let source = regexCache[pattern]\r\n\r\n  if (!source) {\r\n    source = REPLACERS.reduce(\r\n      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\r\n      pattern\r\n    )\r\n    regexCache[pattern] = source\r\n  }\r\n\r\n  return ignoreCase\r\n    ? new RegExp(source, 'i')\r\n    : new RegExp(source)\r\n}\r\n\r\nconst isString = subject => typeof subject === 'string'\r\n\r\n// > A blank line matches no files, so it can serve as a separator for readability.\r\nconst checkPattern = pattern => pattern\r\n  && isString(pattern)\r\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\r\n\r\n  // > A line starting with # serves as a comment.\r\n  && pattern.indexOf('#') !== 0\r\n\r\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\r\n\r\nclass IgnoreRule {\r\n  constructor (\r\n    origin,\r\n    pattern,\r\n    negative,\r\n    regex\r\n  ) {\r\n    this.origin = origin\r\n    this.pattern = pattern\r\n    this.negative = negative\r\n    this.regex = regex\r\n  }\r\n}\r\n\r\nconst createRule = (pattern, ignoreCase) => {\r\n  const origin = pattern\r\n  let negative = false\r\n\r\n  // > An optional prefix \"!\" which negates the pattern;\r\n  if (pattern.indexOf('!') === 0) {\r\n    negative = true\r\n    pattern = pattern.substr(1)\r\n  }\r\n\r\n  pattern = pattern\r\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\r\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\r\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\r\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\r\n  // >   begin with a hash.\r\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\r\n\r\n  const regex = makeRegex(pattern, ignoreCase)\r\n\r\n  return new IgnoreRule(\r\n    origin,\r\n    pattern,\r\n    negative,\r\n    regex\r\n  )\r\n}\r\n\r\nconst throwError = (message, Ctor) => {\r\n  throw new Ctor(message)\r\n}\r\n\r\nconst checkPath = (path, originalPath, doThrow) => {\r\n  if (!isString(path)) {\r\n    return doThrow(\r\n      `path must be a string, but got \\`${originalPath}\\``,\r\n      TypeError\r\n    )\r\n  }\r\n\r\n  // We don't know if we should ignore EMPTY, so throw\r\n  if (!path) {\r\n    return doThrow(`path must not be empty`, TypeError)\r\n  }\r\n\r\n  // Check if it is a relative path\r\n  if (checkPath.isNotRelative(path)) {\r\n    const r = '`path.relative()`d'\r\n    return doThrow(\r\n      `path should be a ${r} string, but got \"${originalPath}\"`,\r\n      RangeError\r\n    )\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\r\n\r\ncheckPath.isNotRelative = isNotRelative\r\ncheckPath.convert = p => p\r\n\r\nclass Ignore {\r\n  constructor ({\r\n    ignorecase = true,\r\n    ignoreCase = ignorecase,\r\n    allowRelativePaths = false\r\n  } = {}) {\r\n    define(this, KEY_IGNORE, true)\r\n\r\n    this._rules = []\r\n    this._ignoreCase = ignoreCase\r\n    this._allowRelativePaths = allowRelativePaths\r\n    this._initCache()\r\n  }\r\n\r\n  _initCache () {\r\n    this._ignoreCache = Object.create(null)\r\n    this._testCache = Object.create(null)\r\n  }\r\n\r\n  _addPattern (pattern) {\r\n    // #32\r\n    if (pattern && pattern[KEY_IGNORE]) {\r\n      this._rules = this._rules.concat(pattern._rules)\r\n      this._added = true\r\n      return\r\n    }\r\n\r\n    if (checkPattern(pattern)) {\r\n      const rule = createRule(pattern, this._ignoreCase)\r\n      this._added = true\r\n      this._rules.push(rule)\r\n    }\r\n  }\r\n\r\n  // @param {Array<string> | string | Ignore} pattern\r\n  add (pattern) {\r\n    this._added = false\r\n\r\n    makeArray(\r\n      isString(pattern)\r\n        ? splitPattern(pattern)\r\n        : pattern\r\n    ).forEach(this._addPattern, this)\r\n\r\n    // Some rules have just added to the ignore,\r\n    // making the behavior changed.\r\n    if (this._added) {\r\n      this._initCache()\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // legacy\r\n  addPattern (pattern) {\r\n    return this.add(pattern)\r\n  }\r\n\r\n  //          |           ignored : unignored\r\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\r\n  // -------- | ------- | ------- | ------- | --------\r\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\r\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\r\n\r\n  // - SKIP: always skip\r\n  // - TEST: always test\r\n  // - TESTIF: only test if checkUnignored\r\n  // - X: that never happen\r\n\r\n  // @param {boolean} whether should check if the path is unignored,\r\n  //   setting `checkUnignored` to `false` could reduce additional\r\n  //   path matching.\r\n\r\n  // @returns {TestResult} true if a file is ignored\r\n  _testOne (path, checkUnignored) {\r\n    let ignored = false\r\n    let unignored = false\r\n\r\n    this._rules.forEach(rule => {\r\n      const {negative} = rule\r\n      if (\r\n        unignored === negative && ignored !== unignored\r\n        || negative && !ignored && !unignored && !checkUnignored\r\n      ) {\r\n        return\r\n      }\r\n\r\n      const matched = rule.regex.test(path)\r\n\r\n      if (matched) {\r\n        ignored = !negative\r\n        unignored = negative\r\n      }\r\n    })\r\n\r\n    return {\r\n      ignored,\r\n      unignored\r\n    }\r\n  }\r\n\r\n  // @returns {TestResult}\r\n  _test (originalPath, cache, checkUnignored, slices) {\r\n    const path = originalPath\r\n      // Supports nullable path\r\n      && checkPath.convert(originalPath)\r\n\r\n    checkPath(\r\n      path,\r\n      originalPath,\r\n      this._allowRelativePaths\r\n        ? RETURN_FALSE\r\n        : throwError\r\n    )\r\n\r\n    return this._t(path, cache, checkUnignored, slices)\r\n  }\r\n\r\n  _t (path, cache, checkUnignored, slices) {\r\n    if (path in cache) {\r\n      return cache[path]\r\n    }\r\n\r\n    if (!slices) {\r\n      // path/to/a.js\r\n      // ['path', 'to', 'a.js']\r\n      slices = path.split(SLASH)\r\n    }\r\n\r\n    slices.pop()\r\n\r\n    // If the path has no parent directory, just test it\r\n    if (!slices.length) {\r\n      return cache[path] = this._testOne(path, checkUnignored)\r\n    }\r\n\r\n    const parent = this._t(\r\n      slices.join(SLASH) + SLASH,\r\n      cache,\r\n      checkUnignored,\r\n      slices\r\n    )\r\n\r\n    // If the path contains a parent directory, check the parent first\r\n    return cache[path] = parent.ignored\r\n      // > It is not possible to re-include a file if a parent directory of\r\n      // >   that file is excluded.\r\n      ? parent\r\n      : this._testOne(path, checkUnignored)\r\n  }\r\n\r\n  ignores (path) {\r\n    return this._test(path, this._ignoreCache, false).ignored\r\n  }\r\n\r\n  createFilter () {\r\n    return path => !this.ignores(path)\r\n  }\r\n\r\n  filter (paths) {\r\n    return makeArray(paths).filter(this.createFilter())\r\n  }\r\n\r\n  // @returns {TestResult}\r\n  test (path) {\r\n    return this._test(path, this._testCache, true)\r\n  }\r\n}\r\n\r\nconst factory = options => new Ignore(options)\r\n\r\nconst isPathValid = path =>\r\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\r\n\r\nfactory.isPathValid = isPathValid\r\n\r\n// Fixes typescript\r\nfactory.default = factory\r\n\r\nmodule.exports = factory\r\n\r\n// Windows\r\n// --------------------------------------------------------------\r\n/* istanbul ignore if  */\r\nif (\r\n  // Detect `process` so that it can run in browsers.\r\n  typeof process !== 'undefined'\r\n  && (\r\n    process.env && process.env.IGNORE_TEST_WIN32\r\n    || process.platform === 'win32'\r\n  )\r\n) {\r\n  /* eslint no-control-regex: \"off\" */\r\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\r\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\r\n    ? str\r\n    : str.replace(/\\\\/g, '/')\r\n\r\n  checkPath.convert = makePosix\r\n\r\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\r\n  // 'd:\\\\foo'\r\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\r\n  checkPath.isNotRelative = path =>\r\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\r\n    || isNotRelative(path)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}