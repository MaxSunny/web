{"ast":null,"code":"/**\r\n * @fileoverview enforce consistent line breaks inside function parentheses\r\n * @author Teddy Katz\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent line breaks inside function parentheses\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-paren-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\n      }, {\n        type: \"object\",\n        properties: {\n          minItems: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      expectedBefore: \"Expected newline before ')'.\",\n      expectedAfter: \"Expected newline after '('.\",\n      expectedBetween: \"Expected newline between arguments/params.\",\n      unexpectedBefore: \"Unexpected newline before ')'.\",\n      unexpectedAfter: \"Unexpected newline after '('.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const rawOption = context.options[0] || \"multiline\";\n    const multilineOption = rawOption === \"multiline\";\n    const multilineArgumentsOption = rawOption === \"multiline-arguments\";\n    const consistentOption = rawOption === \"consistent\";\n    let minItems;\n\n    if (typeof rawOption === \"object\") {\n      minItems = rawOption.minItems;\n    } else if (rawOption === \"always\") {\n      minItems = 0;\n    } else if (rawOption === \"never\") {\n      minItems = Infinity;\n    } else {\n      minItems = null;\n    } //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\r\n     * Determines whether there should be newlines inside function parens\r\n     * @param {ASTNode[]} elements The arguments or parameters in the list\r\n     * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\r\n     * @returns {boolean} `true` if there should be newlines inside the function parens\r\n     */\n\n\n    function shouldHaveNewlines(elements, hasLeftNewline) {\n      if (multilineArgumentsOption && elements.length === 1) {\n        return hasLeftNewline;\n      }\n\n      if (multilineOption || multilineArgumentsOption) {\n        return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\n      }\n\n      if (consistentOption) {\n        return hasLeftNewline;\n      }\n\n      return elements.length >= minItems;\n    }\n    /**\r\n     * Validates parens\r\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\r\n     * @param {ASTNode[]} elements The arguments or parameters in the list\r\n     * @returns {void}\r\n     */\n\n\n    function validateParens(parens, elements) {\n      const leftParen = parens.leftParen;\n      const rightParen = parens.rightParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      if (hasLeftNewline && !needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"unexpectedAfter\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() // If there is a comment between the ( and the first element, don't do a fix.\n            ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\n          }\n\n        });\n      } else if (!hasLeftNewline && needsNewlines) {\n        context.report({\n          node: leftParen,\n          messageId: \"expectedAfter\",\n          fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\n        });\n      }\n\n      if (hasRightNewline && !needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"unexpectedBefore\",\n\n          fix(fixer) {\n            return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() // If there is a comment between the last element and the ), don't do a fix.\n            ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\n          }\n\n        });\n      } else if (!hasRightNewline && needsNewlines) {\n        context.report({\n          node: rightParen,\n          messageId: \"expectedBefore\",\n          fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\n        });\n      }\n    }\n    /**\r\n     * Validates a list of arguments or parameters\r\n     * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\r\n     * @param {ASTNode[]} elements The arguments or parameters in the list\r\n     * @returns {void}\r\n     */\n\n\n    function validateArguments(parens, elements) {\n      const leftParen = parens.leftParen;\n      const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\n      const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\n      const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\n\n      for (let i = 0; i <= elements.length - 2; i++) {\n        const currentElement = elements[i];\n        const nextElement = elements[i + 1];\n        const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\n\n        if (!hasNewLine && needsNewlines) {\n          context.report({\n            node: currentElement,\n            messageId: \"expectedBetween\",\n            fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\n          });\n        }\n      }\n    }\n    /**\r\n     * Gets the left paren and right paren tokens of a node.\r\n     * @param {ASTNode} node The node with parens\r\n     * @throws {TypeError} Unexecpted node type.\r\n     * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\r\n     * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\r\n     * with a single parameter)\r\n     */\n\n\n    function getParenTokens(node) {\n      switch (node.type) {\n        case \"NewExpression\":\n          if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {\n            skip: 1\n          })) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {\n            // If the NewExpression does not have parens (e.g. `new Foo`), return null.\n            return null;\n          }\n\n        // falls through\n\n        case \"CallExpression\":\n          return {\n            leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\n            rightParen: sourceCode.getLastToken(node)\n          };\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        case \"ArrowFunctionExpression\":\n          {\n            const firstToken = sourceCode.getFirstToken(node, {\n              skip: node.async ? 1 : 0\n            });\n\n            if (!astUtils.isOpeningParenToken(firstToken)) {\n              // If the ArrowFunctionExpression has a single param without parens, return null.\n              return null;\n            }\n\n            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(firstToken);\n            return {\n              leftParen: firstToken,\n              rightParen\n            };\n          }\n\n        case \"ImportExpression\":\n          {\n            const leftParen = sourceCode.getFirstToken(node, 1);\n            const rightParen = sourceCode.getLastToken(node);\n            return {\n              leftParen,\n              rightParen\n            };\n          }\n\n        default:\n          throw new TypeError(`unexpected node with type ${node.type}`);\n      }\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      [[\"ArrowFunctionExpression\", \"CallExpression\", \"FunctionDeclaration\", \"FunctionExpression\", \"ImportExpression\", \"NewExpression\"]](node) {\n        const parens = getParenTokens(node);\n        let params;\n\n        if (node.type === \"ImportExpression\") {\n          params = [node.source];\n        } else if (astUtils.isFunction(node)) {\n          params = node.params;\n        } else {\n          params = node.arguments;\n        }\n\n        if (parens) {\n          validateParens(parens, params);\n\n          if (multilineArgumentsOption) {\n            validateArguments(parens, params);\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/function-paren-newline.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","minItems","minimum","additionalProperties","messages","expectedBefore","expectedAfter","expectedBetween","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","rawOption","options","multilineOption","multilineArgumentsOption","consistentOption","Infinity","shouldHaveNewlines","elements","hasLeftNewline","length","some","element","index","loc","end","line","start","validateParens","parens","leftParen","rightParen","tokenAfterLeftParen","getTokenAfter","tokenBeforeRightParen","getTokenBefore","isTokenOnSameLine","hasRightNewline","needsNewlines","report","node","messageId","fix","fixer","getText","slice","range","trim","removeRange","insertTextAfter","insertTextBefore","validateArguments","i","currentElement","nextElement","hasNewLine","getParenTokens","arguments","isOpeningParenToken","getLastToken","skip","isClosingParenToken","callee","getFirstToken","params","firstToken","async","TypeError","source","isFunction"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview enforce consistent line breaks inside function parentheses\r\n * @author Teddy Katz\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent line breaks inside function parentheses\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/function-paren-newline\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"always\", \"never\", \"consistent\", \"multiline\", \"multiline-arguments\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            minItems: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            expectedBefore: \"Expected newline before ')'.\",\r\n            expectedAfter: \"Expected newline after '('.\",\r\n            expectedBetween: \"Expected newline between arguments/params.\",\r\n            unexpectedBefore: \"Unexpected newline before ')'.\",\r\n            unexpectedAfter: \"Unexpected newline after '('.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const rawOption = context.options[0] || \"multiline\";\r\n        const multilineOption = rawOption === \"multiline\";\r\n        const multilineArgumentsOption = rawOption === \"multiline-arguments\";\r\n        const consistentOption = rawOption === \"consistent\";\r\n        let minItems;\r\n\r\n        if (typeof rawOption === \"object\") {\r\n            minItems = rawOption.minItems;\r\n        } else if (rawOption === \"always\") {\r\n            minItems = 0;\r\n        } else if (rawOption === \"never\") {\r\n            minItems = Infinity;\r\n        } else {\r\n            minItems = null;\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Helpers\r\n        //----------------------------------------------------------------------\r\n\r\n        /**\r\n         * Determines whether there should be newlines inside function parens\r\n         * @param {ASTNode[]} elements The arguments or parameters in the list\r\n         * @param {boolean} hasLeftNewline `true` if the left paren has a newline in the current code.\r\n         * @returns {boolean} `true` if there should be newlines inside the function parens\r\n         */\r\n        function shouldHaveNewlines(elements, hasLeftNewline) {\r\n            if (multilineArgumentsOption && elements.length === 1) {\r\n                return hasLeftNewline;\r\n            }\r\n            if (multilineOption || multilineArgumentsOption) {\r\n                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);\r\n            }\r\n            if (consistentOption) {\r\n                return hasLeftNewline;\r\n            }\r\n            return elements.length >= minItems;\r\n        }\r\n\r\n        /**\r\n         * Validates parens\r\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\r\n         * @param {ASTNode[]} elements The arguments or parameters in the list\r\n         * @returns {void}\r\n         */\r\n        function validateParens(parens, elements) {\r\n            const leftParen = parens.leftParen;\r\n            const rightParen = parens.rightParen;\r\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\r\n            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);\r\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\r\n            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);\r\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\r\n\r\n            if (hasLeftNewline && !needsNewlines) {\r\n                context.report({\r\n                    node: leftParen,\r\n                    messageId: \"unexpectedAfter\",\r\n                    fix(fixer) {\r\n                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()\r\n\r\n                            // If there is a comment between the ( and the first element, don't do a fix.\r\n                            ? null\r\n                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);\r\n                    }\r\n                });\r\n            } else if (!hasLeftNewline && needsNewlines) {\r\n                context.report({\r\n                    node: leftParen,\r\n                    messageId: \"expectedAfter\",\r\n                    fix: fixer => fixer.insertTextAfter(leftParen, \"\\n\")\r\n                });\r\n            }\r\n\r\n            if (hasRightNewline && !needsNewlines) {\r\n                context.report({\r\n                    node: rightParen,\r\n                    messageId: \"unexpectedBefore\",\r\n                    fix(fixer) {\r\n                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()\r\n\r\n                            // If there is a comment between the last element and the ), don't do a fix.\r\n                            ? null\r\n                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);\r\n                    }\r\n                });\r\n            } else if (!hasRightNewline && needsNewlines) {\r\n                context.report({\r\n                    node: rightParen,\r\n                    messageId: \"expectedBefore\",\r\n                    fix: fixer => fixer.insertTextBefore(rightParen, \"\\n\")\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates a list of arguments or parameters\r\n         * @param {Object} parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token\r\n         * @param {ASTNode[]} elements The arguments or parameters in the list\r\n         * @returns {void}\r\n         */\r\n        function validateArguments(parens, elements) {\r\n            const leftParen = parens.leftParen;\r\n            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);\r\n            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);\r\n            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);\r\n\r\n            for (let i = 0; i <= elements.length - 2; i++) {\r\n                const currentElement = elements[i];\r\n                const nextElement = elements[i + 1];\r\n                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;\r\n\r\n                if (!hasNewLine && needsNewlines) {\r\n                    context.report({\r\n                        node: currentElement,\r\n                        messageId: \"expectedBetween\",\r\n                        fix: fixer => fixer.insertTextBefore(nextElement, \"\\n\")\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the left paren and right paren tokens of a node.\r\n         * @param {ASTNode} node The node with parens\r\n         * @throws {TypeError} Unexecpted node type.\r\n         * @returns {Object} An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.\r\n         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression\r\n         * with a single parameter)\r\n         */\r\n        function getParenTokens(node) {\r\n            switch (node.type) {\r\n                case \"NewExpression\":\r\n                    if (!node.arguments.length && !(\r\n                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, { skip: 1 })) &&\r\n                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))\r\n                    )) {\r\n\r\n                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.\r\n                        return null;\r\n                    }\r\n\r\n                    // falls through\r\n\r\n                case \"CallExpression\":\r\n                    return {\r\n                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),\r\n                        rightParen: sourceCode.getLastToken(node)\r\n                    };\r\n\r\n                case \"FunctionDeclaration\":\r\n                case \"FunctionExpression\": {\r\n                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);\r\n                    const rightParen = node.params.length\r\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\r\n                        : sourceCode.getTokenAfter(leftParen);\r\n\r\n                    return { leftParen, rightParen };\r\n                }\r\n\r\n                case \"ArrowFunctionExpression\": {\r\n                    const firstToken = sourceCode.getFirstToken(node, { skip: (node.async ? 1 : 0) });\r\n\r\n                    if (!astUtils.isOpeningParenToken(firstToken)) {\r\n\r\n                        // If the ArrowFunctionExpression has a single param without parens, return null.\r\n                        return null;\r\n                    }\r\n\r\n                    const rightParen = node.params.length\r\n                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)\r\n                        : sourceCode.getTokenAfter(firstToken);\r\n\r\n                    return {\r\n                        leftParen: firstToken,\r\n                        rightParen\r\n                    };\r\n                }\r\n\r\n                case \"ImportExpression\": {\r\n                    const leftParen = sourceCode.getFirstToken(node, 1);\r\n                    const rightParen = sourceCode.getLastToken(node);\r\n\r\n                    return { leftParen, rightParen };\r\n                }\r\n\r\n                default:\r\n                    throw new TypeError(`unexpected node with type ${node.type}`);\r\n            }\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n\r\n        return {\r\n            [[\r\n                \"ArrowFunctionExpression\",\r\n                \"CallExpression\",\r\n                \"FunctionDeclaration\",\r\n                \"FunctionExpression\",\r\n                \"ImportExpression\",\r\n                \"NewExpression\"\r\n            ]](node) {\r\n                const parens = getParenTokens(node);\r\n                let params;\r\n\r\n                if (node.type === \"ImportExpression\") {\r\n                    params = [node.source];\r\n                } else if (astUtils.isFunction(node)) {\r\n                    params = node.params;\r\n                } else {\r\n                    params = node.arguments;\r\n                }\r\n\r\n                if (parens) {\r\n                    validateParens(parens, params);\r\n\r\n                    if (multilineArgumentsOption) {\r\n                        validateArguments(parens, params);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}