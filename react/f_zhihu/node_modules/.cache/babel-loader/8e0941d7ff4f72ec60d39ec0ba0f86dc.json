{"ast":null,"code":"/**\r\n * @fileoverview Disallow reassignment of function parameters.\r\n * @author Nat Burns\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow reassigning `function` parameters\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-param-reassign\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [false]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          props: {\n            enum: [true]\n          },\n          ignorePropertyModificationsFor: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          },\n          ignorePropertyModificationsForRegex: {\n            type: \"array\",\n            items: {\n              type: \"string\"\n            },\n            uniqueItems: true\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\n      assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\n    }\n  },\n\n  create(context) {\n    const props = context.options[0] && context.options[0].props;\n    const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\n    const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\n    /**\r\n     * Checks whether or not the reference modifies properties of its variable.\r\n     * @param {Reference} reference A reference to check.\r\n     * @returns {boolean} Whether or not the reference modifies properties of its variable.\r\n     */\n\n    function isModifyingProp(reference) {\n      let node = reference.identifier;\n      let parent = node.parent;\n\n      while (parent && (!stopNodePattern.test(parent.type) || parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\n        switch (parent.type) {\n          // e.g. foo.a = 0;\n          case \"AssignmentExpression\":\n            return parent.left === node;\n          // e.g. ++foo.a;\n\n          case \"UpdateExpression\":\n            return true;\n          // e.g. delete foo.a;\n\n          case \"UnaryExpression\":\n            if (parent.operator === \"delete\") {\n              return true;\n            }\n\n            break;\n          // e.g. for (foo.a in b) {}\n\n          case \"ForInStatement\":\n          case \"ForOfStatement\":\n            if (parent.left === node) {\n              return true;\n            } // this is a stop node for parent.right and parent.body\n\n\n            return false;\n          // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n\n          case \"CallExpression\":\n            if (parent.callee !== node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. cache[foo.a] = 0;\n\n          case \"MemberExpression\":\n            if (parent.property === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. ({ [foo]: a }) = bar;\n\n          case \"Property\":\n            if (parent.key === node) {\n              return false;\n            }\n\n            break;\n          // EXCLUDES: e.g. (foo ? a : b).c = bar;\n\n          case \"ConditionalExpression\":\n            if (parent.test === node) {\n              return false;\n            }\n\n            break;\n          // no default\n        }\n\n        node = parent;\n        parent = node.parent;\n      }\n\n      return false;\n    }\n    /**\r\n     * Tests that an identifier name matches any of the ignored property assignments.\r\n     * First we test strings in ignoredPropertyAssignmentsFor.\r\n     * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\r\n     * @param {string} identifierName A string that describes the name of an identifier to\r\n     * ignore property assignments for.\r\n     * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\r\n     */\n\n\n    function isIgnoredPropertyAssignment(identifierName) {\n      return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\n    }\n    /**\r\n     * Reports a reference if is non initializer and writable.\r\n     * @param {Reference} reference A reference to check.\r\n     * @param {int} index The index of the reference in the references.\r\n     * @param {Reference[]} references The array that the reference belongs to.\r\n     * @returns {void}\r\n     */\n\n\n    function checkReference(reference, index, references) {\n      const identifier = reference.identifier;\n\n      if (identifier && !reference.init && (\n      /*\r\n       * Destructuring assignments can have multiple default value,\r\n       * so possibly there are multiple writeable references for the same identifier.\r\n       */\n      index === 0 || references[index - 1].identifier !== identifier)) {\n        if (reference.isWrite()) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParam\",\n            data: {\n              name: identifier.name\n            }\n          });\n        } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\n          context.report({\n            node: identifier,\n            messageId: \"assignmentToFunctionParamProp\",\n            data: {\n              name: identifier.name\n            }\n          });\n        }\n      }\n    }\n    /**\r\n     * Finds and reports references that are non initializer and writable.\r\n     * @param {Variable} variable A variable to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkVariable(variable) {\n      if (variable.defs[0].type === \"Parameter\") {\n        variable.references.forEach(checkReference);\n      }\n    }\n    /**\r\n     * Checks parameters of a given function node.\r\n     * @param {ASTNode} node A function node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForFunction(node) {\n      context.getDeclaredVariables(node).forEach(checkVariable);\n    }\n\n    return {\n      // `:exit` is needed for the `node.parent` property of identifier nodes.\n      \"FunctionDeclaration:exit\": checkForFunction,\n      \"FunctionExpression:exit\": checkForFunction,\n      \"ArrowFunctionExpression:exit\": checkForFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-param-reassign.js"],"names":["stopNodePattern","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","properties","props","enum","additionalProperties","ignorePropertyModificationsFor","items","uniqueItems","ignorePropertyModificationsForRegex","messages","assignmentToFunctionParam","assignmentToFunctionParamProp","create","context","options","ignoredPropertyAssignmentsFor","ignoredPropertyAssignmentsForRegex","isModifyingProp","reference","node","identifier","parent","test","left","operator","callee","property","key","isIgnoredPropertyAssignment","identifierName","includes","some","ignored","RegExp","checkReference","index","references","init","isWrite","report","messageId","data","name","checkVariable","variable","defs","forEach","checkForFunction","getDeclaredVariables"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallow reassignment of function parameters.\r\n * @author Nat Burns\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow reassigning `function` parameters\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-param-reassign\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            props: {\r\n                                enum: [false]\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            props: {\r\n                                enum: [true]\r\n                            },\r\n                            ignorePropertyModificationsFor: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                },\r\n                                uniqueItems: true\r\n                            },\r\n                            ignorePropertyModificationsForRegex: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                },\r\n                                uniqueItems: true\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            assignmentToFunctionParam: \"Assignment to function parameter '{{name}}'.\",\r\n            assignmentToFunctionParamProp: \"Assignment to property of function parameter '{{name}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const props = context.options[0] && context.options[0].props;\r\n        const ignoredPropertyAssignmentsFor = context.options[0] && context.options[0].ignorePropertyModificationsFor || [];\r\n        const ignoredPropertyAssignmentsForRegex = context.options[0] && context.options[0].ignorePropertyModificationsForRegex || [];\r\n\r\n        /**\r\n         * Checks whether or not the reference modifies properties of its variable.\r\n         * @param {Reference} reference A reference to check.\r\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\r\n         */\r\n        function isModifyingProp(reference) {\r\n            let node = reference.identifier;\r\n            let parent = node.parent;\r\n\r\n            while (parent && (!stopNodePattern.test(parent.type) ||\r\n                    parent.type === \"ForInStatement\" || parent.type === \"ForOfStatement\")) {\r\n                switch (parent.type) {\r\n\r\n                    // e.g. foo.a = 0;\r\n                    case \"AssignmentExpression\":\r\n                        return parent.left === node;\r\n\r\n                    // e.g. ++foo.a;\r\n                    case \"UpdateExpression\":\r\n                        return true;\r\n\r\n                    // e.g. delete foo.a;\r\n                    case \"UnaryExpression\":\r\n                        if (parent.operator === \"delete\") {\r\n                            return true;\r\n                        }\r\n                        break;\r\n\r\n                    // e.g. for (foo.a in b) {}\r\n                    case \"ForInStatement\":\r\n                    case \"ForOfStatement\":\r\n                        if (parent.left === node) {\r\n                            return true;\r\n                        }\r\n\r\n                        // this is a stop node for parent.right and parent.body\r\n                        return false;\r\n\r\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\r\n                    case \"CallExpression\":\r\n                        if (parent.callee !== node) {\r\n                            return false;\r\n                        }\r\n                        break;\r\n\r\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\r\n                    case \"MemberExpression\":\r\n                        if (parent.property === node) {\r\n                            return false;\r\n                        }\r\n                        break;\r\n\r\n                    // EXCLUDES: e.g. ({ [foo]: a }) = bar;\r\n                    case \"Property\":\r\n                        if (parent.key === node) {\r\n                            return false;\r\n                        }\r\n\r\n                        break;\r\n\r\n                    // EXCLUDES: e.g. (foo ? a : b).c = bar;\r\n                    case \"ConditionalExpression\":\r\n                        if (parent.test === node) {\r\n                            return false;\r\n                        }\r\n\r\n                        break;\r\n\r\n                    // no default\r\n                }\r\n\r\n                node = parent;\r\n                parent = node.parent;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Tests that an identifier name matches any of the ignored property assignments.\r\n         * First we test strings in ignoredPropertyAssignmentsFor.\r\n         * Then we instantiate and test RegExp objects from ignoredPropertyAssignmentsForRegex strings.\r\n         * @param {string} identifierName A string that describes the name of an identifier to\r\n         * ignore property assignments for.\r\n         * @returns {boolean} Whether the string matches an ignored property assignment regular expression or not.\r\n         */\r\n        function isIgnoredPropertyAssignment(identifierName) {\r\n            return ignoredPropertyAssignmentsFor.includes(identifierName) ||\r\n                ignoredPropertyAssignmentsForRegex.some(ignored => new RegExp(ignored, \"u\").test(identifierName));\r\n        }\r\n\r\n        /**\r\n         * Reports a reference if is non initializer and writable.\r\n         * @param {Reference} reference A reference to check.\r\n         * @param {int} index The index of the reference in the references.\r\n         * @param {Reference[]} references The array that the reference belongs to.\r\n         * @returns {void}\r\n         */\r\n        function checkReference(reference, index, references) {\r\n            const identifier = reference.identifier;\r\n\r\n            if (identifier &&\r\n                !reference.init &&\r\n\r\n                /*\r\n                 * Destructuring assignments can have multiple default value,\r\n                 * so possibly there are multiple writeable references for the same identifier.\r\n                 */\r\n                (index === 0 || references[index - 1].identifier !== identifier)\r\n            ) {\r\n                if (reference.isWrite()) {\r\n                    context.report({\r\n                        node: identifier,\r\n                        messageId: \"assignmentToFunctionParam\",\r\n                        data: { name: identifier.name }\r\n                    });\r\n                } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {\r\n                    context.report({\r\n                        node: identifier,\r\n                        messageId: \"assignmentToFunctionParamProp\",\r\n                        data: { name: identifier.name }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Finds and reports references that are non initializer and writable.\r\n         * @param {Variable} variable A variable to check.\r\n         * @returns {void}\r\n         */\r\n        function checkVariable(variable) {\r\n            if (variable.defs[0].type === \"Parameter\") {\r\n                variable.references.forEach(checkReference);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks parameters of a given function node.\r\n         * @param {ASTNode} node A function node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkForFunction(node) {\r\n            context.getDeclaredVariables(node).forEach(checkVariable);\r\n        }\r\n\r\n        return {\r\n\r\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\r\n            \"FunctionDeclaration:exit\": checkForFunction,\r\n            \"FunctionExpression:exit\": checkForFunction,\r\n            \"ArrowFunctionExpression:exit\": checkForFunction\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}