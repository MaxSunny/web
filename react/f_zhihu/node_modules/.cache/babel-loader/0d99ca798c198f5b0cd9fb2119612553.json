{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce concise object methods and properties.\r\n * @author Jamund Ferguson\r\n */\n\"use strict\";\n\nconst OPTIONS = {\n  always: \"always\",\n  never: \"never\",\n  methods: \"methods\",\n  properties: \"properties\",\n  consistent: \"consistent\",\n  consistentAsNeeded: \"consistent-as-needed\"\n}; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require or disallow method and property shorthand syntax for object literals\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/object-shorthand\"\n    },\n    fixable: \"code\",\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\n        }],\n        minItems: 0,\n        maxItems: 1\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\", \"properties\"]\n        }, {\n          type: \"object\",\n          properties: {\n            avoidQuotes: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"always\", \"methods\"]\n        }, {\n          type: \"object\",\n          properties: {\n            ignoreConstructors: {\n              type: \"boolean\"\n            },\n            avoidQuotes: {\n              type: \"boolean\"\n            },\n            avoidExplicitReturnArrows: {\n              type: \"boolean\"\n            }\n          },\n          additionalProperties: false\n        }],\n        minItems: 0,\n        maxItems: 2\n      }]\n    },\n    messages: {\n      expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\n      expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\n      expectedPropertyShorthand: \"Expected property shorthand.\",\n      expectedPropertyLongform: \"Expected longform property syntax.\",\n      expectedMethodShorthand: \"Expected method shorthand.\",\n      expectedMethodLongform: \"Expected longform method syntax.\",\n      unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\n    }\n  },\n\n  create(context) {\n    const APPLY = context.options[0] || OPTIONS.always;\n    const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\n    const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\n    const APPLY_NEVER = APPLY === OPTIONS.never;\n    const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\n    const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\n    const PARAMS = context.options[1] || {};\n    const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\n    const AVOID_QUOTES = PARAMS.avoidQuotes;\n    const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\n    /**\r\n     * Determines if the first character of the name is a capital letter.\r\n     * @param {string} name The name of the node to evaluate.\r\n     * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\r\n     * @private\r\n     */\n\n    function isConstructor(name) {\n      const match = CTOR_PREFIX_REGEX.exec(name); // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\n\n      if (!match) {\n        return false;\n      }\n\n      const firstChar = name.charAt(match.index);\n      return firstChar === firstChar.toUpperCase();\n    }\n    /**\r\n     * Determines if the property can have a shorthand form.\r\n     * @param {ASTNode} property Property AST node\r\n     * @returns {boolean} True if the property can have a shorthand form\r\n     * @private\r\n     */\n\n\n    function canHaveShorthand(property) {\n      return property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\";\n    }\n    /**\r\n     * Checks whether a node is a string literal.\r\n     * @param {ASTNode} node Any AST node.\r\n     * @returns {boolean} `true` if it is a string literal.\r\n     */\n\n\n    function isStringLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\r\n     * Determines if the property is a shorthand or not.\r\n     * @param {ASTNode} property Property AST node\r\n     * @returns {boolean} True if the property is considered shorthand, false if not.\r\n     * @private\r\n     */\n\n\n    function isShorthand(property) {\n      // property.method is true when `{a(){}}`.\n      return property.shorthand || property.method;\n    }\n    /**\r\n     * Determines if the property's key and method or value are named equally.\r\n     * @param {ASTNode} property Property AST node\r\n     * @returns {boolean} True if the key and value are named equally, false if not.\r\n     * @private\r\n     */\n\n\n    function isRedundant(property) {\n      const value = property.value;\n\n      if (value.type === \"FunctionExpression\") {\n        return !value.id; // Only anonymous should be shorthand method.\n      }\n\n      if (value.type === \"Identifier\") {\n        return astUtils.getStaticPropertyName(property) === value.name;\n      }\n\n      return false;\n    }\n    /**\r\n     * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\r\n     * @param {ASTNode} node Property AST node\r\n     * @param {boolean} checkRedundancy Whether to check longform redundancy\r\n     * @returns {void}\r\n     */\n\n\n    function checkConsistency(node, checkRedundancy) {\n      // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\n      const properties = node.properties.filter(canHaveShorthand); // Do we still have properties left after filtering the getters and setters?\n\n      if (properties.length > 0) {\n        const shorthandProperties = properties.filter(isShorthand);\n        /*\r\n         * If we do not have an equal number of longform properties as\r\n         * shorthand properties, we are using the annotations inconsistently\r\n         */\n\n        if (shorthandProperties.length !== properties.length) {\n          // We have at least 1 shorthand property\n          if (shorthandProperties.length > 0) {\n            context.report({\n              node,\n              messageId: \"unexpectedMix\"\n            });\n          } else if (checkRedundancy) {\n            /*\r\n             * If all properties of the object contain a method or value with a name matching it's key,\r\n             * all the keys are redundant.\r\n             */\n            const canAlwaysUseShorthand = properties.every(isRedundant);\n\n            if (canAlwaysUseShorthand) {\n              context.report({\n                node,\n                messageId: \"expectedAllPropertiesShorthanded\"\n              });\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Fixes a FunctionExpression node by making it into a shorthand property.\r\n     * @param {SourceCodeFixer} fixer The fixer object\r\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\r\n     * @returns {Object} A fix for this node\r\n     */\n\n\n    function makeFunctionShorthand(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let keyPrefix = \"\"; // key: /* */ () => {}\n\n      if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\n        return null;\n      }\n\n      if (node.value.async) {\n        keyPrefix += \"async \";\n      }\n\n      if (node.value.generator) {\n        keyPrefix += \"*\";\n      }\n\n      const fixRange = [firstKeyToken.range[0], node.range[1]];\n      const methodPrefix = keyPrefix + keyText;\n\n      if (node.value.type === \"FunctionExpression\") {\n        const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\n        const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\n        return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1]));\n      }\n\n      const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\n      const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\n      let shouldAddParensAroundParameters = false;\n      let tokenBeforeParams;\n\n      if (node.value.params.length === 0) {\n        tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\n      } else {\n        tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\n      }\n\n      if (node.value.params.length === 1) {\n        const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\n        const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\n        shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\n      }\n\n      const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];\n      const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\n      const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\n      const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\n      return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);\n    }\n    /**\r\n     * Fixes a FunctionExpression node by making it into a longform property.\r\n     * @param {SourceCodeFixer} fixer The fixer object\r\n     * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\r\n     * @returns {Object} A fix for this node\r\n     */\n\n\n    function makeFunctionLongform(fixer, node) {\n      const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\n      const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\n      const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\n      let functionHeader = \"function\";\n\n      if (node.value.async) {\n        functionHeader = `async ${functionHeader}`;\n      }\n\n      if (node.value.generator) {\n        functionHeader = `${functionHeader}*`;\n      }\n\n      return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\n    }\n    /*\r\n     * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\r\n     * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\r\n     * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\r\n     * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\r\n     * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\r\n     * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\r\n     * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\r\n     * because converting it into a method would change the value of one of the lexical identifiers.\r\n     */\n\n\n    const lexicalScopeStack = [];\n    const arrowsWithLexicalIdentifiers = new WeakSet();\n    const argumentsIdentifiers = new WeakSet();\n    /**\r\n     * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\r\n     * Also, this marks all `arguments` identifiers so that they can be detected later.\r\n     * @returns {void}\r\n     */\n\n    function enterFunction() {\n      lexicalScopeStack.unshift(new Set());\n      context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\n        variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\n      });\n    }\n    /**\r\n     * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\r\n     * @returns {void}\r\n     */\n\n\n    function exitFunction() {\n      lexicalScopeStack.shift();\n    }\n    /**\r\n     * Marks the current function as having a lexical keyword. This implies that all arrow functions\r\n     * in the current lexical scope contain a reference to this lexical keyword.\r\n     * @returns {void}\r\n     */\n\n\n    function reportLexicalIdentifier() {\n      lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: enterFunction,\n      FunctionDeclaration: enterFunction,\n      FunctionExpression: enterFunction,\n      \"Program:exit\": exitFunction,\n      \"FunctionDeclaration:exit\": exitFunction,\n      \"FunctionExpression:exit\": exitFunction,\n\n      ArrowFunctionExpression(node) {\n        lexicalScopeStack[0].add(node);\n      },\n\n      \"ArrowFunctionExpression:exit\"(node) {\n        lexicalScopeStack[0].delete(node);\n      },\n\n      ThisExpression: reportLexicalIdentifier,\n      Super: reportLexicalIdentifier,\n\n      MetaProperty(node) {\n        if (node.meta.name === \"new\" && node.property.name === \"target\") {\n          reportLexicalIdentifier();\n        }\n      },\n\n      Identifier(node) {\n        if (argumentsIdentifiers.has(node)) {\n          reportLexicalIdentifier();\n        }\n      },\n\n      ObjectExpression(node) {\n        if (APPLY_CONSISTENT) {\n          checkConsistency(node, false);\n        } else if (APPLY_CONSISTENT_AS_NEEDED) {\n          checkConsistency(node, true);\n        }\n      },\n\n      \"Property:exit\"(node) {\n        const isConciseProperty = node.method || node.shorthand; // Ignore destructuring assignment\n\n        if (node.parent.type === \"ObjectPattern\") {\n          return;\n        } // getters and setters are ignored\n\n\n        if (node.kind === \"get\" || node.kind === \"set\") {\n          return;\n        } // only computed methods can fail the following checks\n\n\n        if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\n          return;\n        } //--------------------------------------------------------------\n        // Checks for property/method shorthand.\n\n\n        if (isConciseProperty) {\n          if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\n            const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\"; // { x() {} } should be written as { x: function() {} }\n\n            context.report({\n              node,\n              messageId,\n              fix: fixer => makeFunctionLongform(fixer, node)\n            });\n          } else if (APPLY_NEVER) {\n            // { x } should be written as { x: x }\n            context.report({\n              node,\n              messageId: \"expectedPropertyLongform\",\n              fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\n            });\n          }\n        } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\n          if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\n            return;\n          }\n\n          if (AVOID_QUOTES && isStringLiteral(node.key)) {\n            return;\n          } // {[x]: function(){}} should be written as {[x]() {}}\n\n\n          if (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\" && node.value.body.type === \"BlockStatement\" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {\n            context.report({\n              node,\n              messageId: \"expectedMethodShorthand\",\n              fix: fixer => makeFunctionShorthand(fixer, node)\n            });\n          }\n        } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\n          // {x: x} should be written as {x}\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\n          if (AVOID_QUOTES) {\n            return;\n          } // {\"x\": x} should be written as {x}\n\n\n          context.report({\n            node,\n            messageId: \"expectedPropertyShorthand\",\n\n            fix(fixer) {\n              return fixer.replaceText(node, node.value.name);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/object-shorthand.js"],"names":["OPTIONS","always","never","methods","properties","consistent","consistentAsNeeded","astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","anyOf","items","enum","minItems","maxItems","avoidQuotes","additionalProperties","ignoreConstructors","avoidExplicitReturnArrows","messages","expectedAllPropertiesShorthanded","expectedLiteralMethodLongform","expectedPropertyShorthand","expectedPropertyLongform","expectedMethodShorthand","expectedMethodLongform","unexpectedMix","create","context","APPLY","options","APPLY_TO_METHODS","APPLY_TO_PROPS","APPLY_NEVER","APPLY_CONSISTENT","APPLY_CONSISTENT_AS_NEEDED","PARAMS","IGNORE_CONSTRUCTORS","AVOID_QUOTES","AVOID_EXPLICIT_RETURN_ARROWS","sourceCode","getSourceCode","CTOR_PREFIX_REGEX","isConstructor","name","match","exec","firstChar","charAt","index","toUpperCase","canHaveShorthand","property","kind","isStringLiteral","node","value","isShorthand","shorthand","method","isRedundant","id","getStaticPropertyName","checkConsistency","checkRedundancy","filter","length","shorthandProperties","report","messageId","canAlwaysUseShorthand","every","makeFunctionShorthand","fixer","firstKeyToken","computed","getFirstToken","isOpeningBracketToken","key","lastKeyToken","getFirstTokenBetween","isClosingBracketToken","getLastToken","keyText","text","slice","range","keyPrefix","commentsExistBetween","async","generator","fixRange","methodPrefix","functionToken","getTokens","find","token","tokenBeforeParams","getTokenAfter","replaceTextRange","arrowToken","getTokenBefore","body","isArrowToken","fnBody","shouldAddParensAroundParameters","params","isOpeningParenToken","hasParen","isTokenOutsideNode","sliceStart","sliceEnd","oldParamText","newParamText","makeFunctionLongform","getTokensBetween","functionHeader","lexicalScopeStack","arrowsWithLexicalIdentifiers","WeakSet","argumentsIdentifiers","enterFunction","unshift","Set","getScope","variables","variable","forEach","references","map","ref","identifier","add","exitFunction","shift","reportLexicalIdentifier","arrowFunction","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","delete","ThisExpression","Super","MetaProperty","Identifier","has","ObjectExpression","isConciseProperty","parent","fix","insertTextAfter","replaceText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce concise object methods and properties.\r\n * @author Jamund Ferguson\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst OPTIONS = {\r\n    always: \"always\",\r\n    never: \"never\",\r\n    methods: \"methods\",\r\n    properties: \"properties\",\r\n    consistent: \"consistent\",\r\n    consistentAsNeeded: \"consistent-as-needed\"\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require or disallow method and property shorthand syntax for object literals\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/object-shorthand\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"methods\", \"properties\", \"never\", \"consistent\", \"consistent-as-needed\"]\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 1\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"methods\", \"properties\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                avoidQuotes: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\", \"methods\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                ignoreConstructors: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                avoidQuotes: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                avoidExplicitReturnArrows: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    minItems: 0,\r\n                    maxItems: 2\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            expectedAllPropertiesShorthanded: \"Expected shorthand for all properties.\",\r\n            expectedLiteralMethodLongform: \"Expected longform method syntax for string literal keys.\",\r\n            expectedPropertyShorthand: \"Expected property shorthand.\",\r\n            expectedPropertyLongform: \"Expected longform property syntax.\",\r\n            expectedMethodShorthand: \"Expected method shorthand.\",\r\n            expectedMethodLongform: \"Expected longform method syntax.\",\r\n            unexpectedMix: \"Unexpected mix of shorthand and non-shorthand properties.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const APPLY = context.options[0] || OPTIONS.always;\r\n        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;\r\n        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;\r\n        const APPLY_NEVER = APPLY === OPTIONS.never;\r\n        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;\r\n        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;\r\n\r\n        const PARAMS = context.options[1] || {};\r\n        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;\r\n        const AVOID_QUOTES = PARAMS.avoidQuotes;\r\n        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;\r\n\r\n        /**\r\n         * Determines if the first character of the name is a capital letter.\r\n         * @param {string} name The name of the node to evaluate.\r\n         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.\r\n         * @private\r\n         */\r\n        function isConstructor(name) {\r\n            const match = CTOR_PREFIX_REGEX.exec(name);\r\n\r\n            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'\r\n            if (!match) {\r\n                return false;\r\n            }\r\n\r\n            const firstChar = name.charAt(match.index);\r\n\r\n            return firstChar === firstChar.toUpperCase();\r\n        }\r\n\r\n        /**\r\n         * Determines if the property can have a shorthand form.\r\n         * @param {ASTNode} property Property AST node\r\n         * @returns {boolean} True if the property can have a shorthand form\r\n         * @private\r\n         */\r\n        function canHaveShorthand(property) {\r\n            return (property.kind !== \"set\" && property.kind !== \"get\" && property.type !== \"SpreadElement\" && property.type !== \"SpreadProperty\" && property.type !== \"ExperimentalSpreadProperty\");\r\n        }\r\n\r\n        /**\r\n         * Checks whether a node is a string literal.\r\n         * @param {ASTNode} node Any AST node.\r\n         * @returns {boolean} `true` if it is a string literal.\r\n         */\r\n        function isStringLiteral(node) {\r\n            return node.type === \"Literal\" && typeof node.value === \"string\";\r\n        }\r\n\r\n        /**\r\n         * Determines if the property is a shorthand or not.\r\n         * @param {ASTNode} property Property AST node\r\n         * @returns {boolean} True if the property is considered shorthand, false if not.\r\n         * @private\r\n         */\r\n        function isShorthand(property) {\r\n\r\n            // property.method is true when `{a(){}}`.\r\n            return (property.shorthand || property.method);\r\n        }\r\n\r\n        /**\r\n         * Determines if the property's key and method or value are named equally.\r\n         * @param {ASTNode} property Property AST node\r\n         * @returns {boolean} True if the key and value are named equally, false if not.\r\n         * @private\r\n         */\r\n        function isRedundant(property) {\r\n            const value = property.value;\r\n\r\n            if (value.type === \"FunctionExpression\") {\r\n                return !value.id; // Only anonymous should be shorthand method.\r\n            }\r\n            if (value.type === \"Identifier\") {\r\n                return astUtils.getStaticPropertyName(property) === value.name;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.\r\n         * @param {ASTNode} node Property AST node\r\n         * @param {boolean} checkRedundancy Whether to check longform redundancy\r\n         * @returns {void}\r\n         */\r\n        function checkConsistency(node, checkRedundancy) {\r\n\r\n            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.\r\n            const properties = node.properties.filter(canHaveShorthand);\r\n\r\n            // Do we still have properties left after filtering the getters and setters?\r\n            if (properties.length > 0) {\r\n                const shorthandProperties = properties.filter(isShorthand);\r\n\r\n                /*\r\n                 * If we do not have an equal number of longform properties as\r\n                 * shorthand properties, we are using the annotations inconsistently\r\n                 */\r\n                if (shorthandProperties.length !== properties.length) {\r\n\r\n                    // We have at least 1 shorthand property\r\n                    if (shorthandProperties.length > 0) {\r\n                        context.report({ node, messageId: \"unexpectedMix\" });\r\n                    } else if (checkRedundancy) {\r\n\r\n                        /*\r\n                         * If all properties of the object contain a method or value with a name matching it's key,\r\n                         * all the keys are redundant.\r\n                         */\r\n                        const canAlwaysUseShorthand = properties.every(isRedundant);\r\n\r\n                        if (canAlwaysUseShorthand) {\r\n                            context.report({ node, messageId: \"expectedAllPropertiesShorthanded\" });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Fixes a FunctionExpression node by making it into a shorthand property.\r\n         * @param {SourceCodeFixer} fixer The fixer object\r\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value\r\n         * @returns {Object} A fix for this node\r\n         */\r\n        function makeFunctionShorthand(fixer, node) {\r\n            const firstKeyToken = node.computed\r\n                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)\r\n                : sourceCode.getFirstToken(node.key);\r\n            const lastKeyToken = node.computed\r\n                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)\r\n                : sourceCode.getLastToken(node.key);\r\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\r\n            let keyPrefix = \"\";\r\n\r\n            // key: /* */ () => {}\r\n            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {\r\n                return null;\r\n            }\r\n\r\n            if (node.value.async) {\r\n                keyPrefix += \"async \";\r\n            }\r\n            if (node.value.generator) {\r\n                keyPrefix += \"*\";\r\n            }\r\n\r\n            const fixRange = [firstKeyToken.range[0], node.range[1]];\r\n            const methodPrefix = keyPrefix + keyText;\r\n\r\n            if (node.value.type === \"FunctionExpression\") {\r\n                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === \"Keyword\" && token.value === \"function\");\r\n                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;\r\n\r\n                return fixer.replaceTextRange(\r\n                    fixRange,\r\n                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])\r\n                );\r\n            }\r\n\r\n            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);\r\n            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);\r\n\r\n            let shouldAddParensAroundParameters = false;\r\n            let tokenBeforeParams;\r\n\r\n            if (node.value.params.length === 0) {\r\n                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);\r\n            } else {\r\n                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);\r\n            }\r\n\r\n            if (node.value.params.length === 1) {\r\n                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);\r\n                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];\r\n\r\n                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;\r\n            }\r\n\r\n            const sliceStart = shouldAddParensAroundParameters\r\n                ? node.value.params[0].range[0]\r\n                : tokenBeforeParams.range[0];\r\n            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];\r\n\r\n            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);\r\n            const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;\r\n\r\n            return fixer.replaceTextRange(\r\n                fixRange,\r\n                methodPrefix + newParamText + fnBody\r\n            );\r\n\r\n        }\r\n\r\n        /**\r\n         * Fixes a FunctionExpression node by making it into a longform property.\r\n         * @param {SourceCodeFixer} fixer The fixer object\r\n         * @param {ASTNode} node A `Property` node that has a `FunctionExpression` as its value\r\n         * @returns {Object} A fix for this node\r\n         */\r\n        function makeFunctionLongform(fixer, node) {\r\n            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === \"[\") : sourceCode.getFirstToken(node.key);\r\n            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === \"]\") : sourceCode.getLastToken(node.key);\r\n            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);\r\n            let functionHeader = \"function\";\r\n\r\n            if (node.value.async) {\r\n                functionHeader = `async ${functionHeader}`;\r\n            }\r\n            if (node.value.generator) {\r\n                functionHeader = `${functionHeader}*`;\r\n            }\r\n\r\n            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);\r\n        }\r\n\r\n        /*\r\n         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),\r\n         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is\r\n         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical\r\n         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,\r\n         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.\r\n         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them\r\n         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,\r\n         * because converting it into a method would change the value of one of the lexical identifiers.\r\n         */\r\n        const lexicalScopeStack = [];\r\n        const arrowsWithLexicalIdentifiers = new WeakSet();\r\n        const argumentsIdentifiers = new WeakSet();\r\n\r\n        /**\r\n         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.\r\n         * Also, this marks all `arguments` identifiers so that they can be detected later.\r\n         * @returns {void}\r\n         */\r\n        function enterFunction() {\r\n            lexicalScopeStack.unshift(new Set());\r\n            context.getScope().variables.filter(variable => variable.name === \"arguments\").forEach(variable => {\r\n                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.\r\n         * @returns {void}\r\n         */\r\n        function exitFunction() {\r\n            lexicalScopeStack.shift();\r\n        }\r\n\r\n        /**\r\n         * Marks the current function as having a lexical keyword. This implies that all arrow functions\r\n         * in the current lexical scope contain a reference to this lexical keyword.\r\n         * @returns {void}\r\n         */\r\n        function reportLexicalIdentifier() {\r\n            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: enterFunction,\r\n            FunctionDeclaration: enterFunction,\r\n            FunctionExpression: enterFunction,\r\n            \"Program:exit\": exitFunction,\r\n            \"FunctionDeclaration:exit\": exitFunction,\r\n            \"FunctionExpression:exit\": exitFunction,\r\n\r\n            ArrowFunctionExpression(node) {\r\n                lexicalScopeStack[0].add(node);\r\n            },\r\n            \"ArrowFunctionExpression:exit\"(node) {\r\n                lexicalScopeStack[0].delete(node);\r\n            },\r\n\r\n            ThisExpression: reportLexicalIdentifier,\r\n            Super: reportLexicalIdentifier,\r\n            MetaProperty(node) {\r\n                if (node.meta.name === \"new\" && node.property.name === \"target\") {\r\n                    reportLexicalIdentifier();\r\n                }\r\n            },\r\n            Identifier(node) {\r\n                if (argumentsIdentifiers.has(node)) {\r\n                    reportLexicalIdentifier();\r\n                }\r\n            },\r\n\r\n            ObjectExpression(node) {\r\n                if (APPLY_CONSISTENT) {\r\n                    checkConsistency(node, false);\r\n                } else if (APPLY_CONSISTENT_AS_NEEDED) {\r\n                    checkConsistency(node, true);\r\n                }\r\n            },\r\n\r\n            \"Property:exit\"(node) {\r\n                const isConciseProperty = node.method || node.shorthand;\r\n\r\n                // Ignore destructuring assignment\r\n                if (node.parent.type === \"ObjectPattern\") {\r\n                    return;\r\n                }\r\n\r\n                // getters and setters are ignored\r\n                if (node.kind === \"get\" || node.kind === \"set\") {\r\n                    return;\r\n                }\r\n\r\n                // only computed methods can fail the following checks\r\n                if (node.computed && node.value.type !== \"FunctionExpression\" && node.value.type !== \"ArrowFunctionExpression\") {\r\n                    return;\r\n                }\r\n\r\n                //--------------------------------------------------------------\r\n                // Checks for property/method shorthand.\r\n                if (isConciseProperty) {\r\n                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {\r\n                        const messageId = APPLY_NEVER ? \"expectedMethodLongform\" : \"expectedLiteralMethodLongform\";\r\n\r\n                        // { x() {} } should be written as { x: function() {} }\r\n                        context.report({\r\n                            node,\r\n                            messageId,\r\n                            fix: fixer => makeFunctionLongform(fixer, node)\r\n                        });\r\n                    } else if (APPLY_NEVER) {\r\n\r\n                        // { x } should be written as { x: x }\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"expectedPropertyLongform\",\r\n                            fix: fixer => fixer.insertTextAfter(node.key, `: ${node.key.name}`)\r\n                        });\r\n                    }\r\n                } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === \"FunctionExpression\" || node.value.type === \"ArrowFunctionExpression\")) {\r\n                    if (IGNORE_CONSTRUCTORS && node.key.type === \"Identifier\" && isConstructor(node.key.name)) {\r\n                        return;\r\n                    }\r\n                    if (AVOID_QUOTES && isStringLiteral(node.key)) {\r\n                        return;\r\n                    }\r\n\r\n                    // {[x]: function(){}} should be written as {[x]() {}}\r\n                    if (node.value.type === \"FunctionExpression\" ||\r\n                        node.value.type === \"ArrowFunctionExpression\" &&\r\n                        node.value.body.type === \"BlockStatement\" &&\r\n                        AVOID_EXPLICIT_RETURN_ARROWS &&\r\n                        !arrowsWithLexicalIdentifiers.has(node.value)\r\n                    ) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"expectedMethodShorthand\",\r\n                            fix: fixer => makeFunctionShorthand(fixer, node)\r\n                        });\r\n                    }\r\n                } else if (node.value.type === \"Identifier\" && node.key.name === node.value.name && APPLY_TO_PROPS) {\r\n\r\n                    // {x: x} should be written as {x}\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"expectedPropertyShorthand\",\r\n                        fix(fixer) {\r\n                            return fixer.replaceText(node, node.value.name);\r\n                        }\r\n                    });\r\n                } else if (node.value.type === \"Identifier\" && node.key.type === \"Literal\" && node.key.value === node.value.name && APPLY_TO_PROPS) {\r\n                    if (AVOID_QUOTES) {\r\n                        return;\r\n                    }\r\n\r\n                    // {\"x\": x} should be written as {x}\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"expectedPropertyShorthand\",\r\n                        fix(fixer) {\r\n                            return fixer.replaceText(node, node.value.name);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}