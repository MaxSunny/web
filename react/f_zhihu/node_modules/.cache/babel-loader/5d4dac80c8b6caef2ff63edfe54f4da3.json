{"ast":null,"code":"/**\r\n * @fileoverview Disallow redundant return statements\r\n * @author Teddy Katz\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      FixTracker = require(\"./utils/fix-tracker\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Removes the given element from the array.\r\n * @param {Array} array The source array to remove.\r\n * @param {any} element The target item to remove.\r\n * @returns {void}\r\n */\n\n\nfunction remove(array, element) {\n  const index = array.indexOf(element);\n\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\n/**\r\n * Checks whether it can remove the given return statement or not.\r\n * @param {ASTNode} node The return statement node to check.\r\n * @returns {boolean} `true` if the node is removable.\r\n */\n\n\nfunction isRemovable(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n}\n/**\r\n * Checks whether the given return statement is in a `finally` block or not.\r\n * @param {ASTNode} node The return statement node to check.\r\n * @returns {boolean} `true` if the node is in a `finally` block.\r\n */\n\n\nfunction isInFinally(node) {\n  for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {\n    if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\n      return true;\n    }\n  }\n\n  return false;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow redundant return statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-return\"\n    },\n    fixable: \"code\",\n    schema: [],\n    messages: {\n      unnecessaryReturn: \"Unnecessary return statement.\"\n    }\n  },\n\n  create(context) {\n    const segmentInfoMap = new WeakMap();\n    const usedUnreachableSegments = new WeakSet();\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\r\n     * Checks whether the given segment is terminated by a return statement or not.\r\n     * @param {CodePathSegment} segment The segment to check.\r\n     * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\r\n     */\n\n    function isReturned(segment) {\n      const info = segmentInfoMap.get(segment);\n      return !info || info.returned;\n    }\n    /**\r\n     * Collects useless return statements from the given previous segments.\r\n     *\r\n     * A previous segment may be an unreachable segment.\r\n     * In that case, the information object of the unreachable segment is not\r\n     * initialized because `onCodePathSegmentStart` event is not notified for\r\n     * unreachable segments.\r\n     * This goes to the previous segments of the unreachable segment recursively\r\n     * if the unreachable segment was generated by a return statement. Otherwise,\r\n     * this ignores the unreachable segment.\r\n     *\r\n     * This behavior would simulate code paths for the case that the return\r\n     * statement does not exist.\r\n     * @param {ASTNode[]} uselessReturns The collected return statements.\r\n     * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\r\n     * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\r\n     * @returns {ASTNode[]} `uselessReturns`.\r\n     */\n\n\n    function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\n      const traversedSegments = providedTraversedSegments || new WeakSet();\n\n      for (const segment of prevSegments) {\n        if (!segment.reachable) {\n          if (!traversedSegments.has(segment)) {\n            traversedSegments.add(segment);\n            getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);\n          }\n\n          continue;\n        }\n\n        uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\n      }\n\n      return uselessReturns;\n    }\n    /**\r\n     * Removes the return statements on the given segment from the useless return\r\n     * statement list.\r\n     *\r\n     * This segment may be an unreachable segment.\r\n     * In that case, the information object of the unreachable segment is not\r\n     * initialized because `onCodePathSegmentStart` event is not notified for\r\n     * unreachable segments.\r\n     * This goes to the previous segments of the unreachable segment recursively\r\n     * if the unreachable segment was generated by a return statement. Otherwise,\r\n     * this ignores the unreachable segment.\r\n     *\r\n     * This behavior would simulate code paths for the case that the return\r\n     * statement does not exist.\r\n     * @param {CodePathSegment} segment The segment to get return statements.\r\n     * @returns {void}\r\n     */\n\n\n    function markReturnStatementsOnSegmentAsUsed(segment) {\n      if (!segment.reachable) {\n        usedUnreachableSegments.add(segment);\n        segment.allPrevSegments.filter(isReturned).filter(prevSegment => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);\n        return;\n      }\n\n      const info = segmentInfoMap.get(segment);\n\n      for (const node of info.uselessReturns) {\n        remove(scopeInfo.uselessReturns, node);\n      }\n\n      info.uselessReturns = [];\n    }\n    /**\r\n     * Removes the return statements on the current segments from the useless\r\n     * return statement list.\r\n     *\r\n     * This function will be called at every statement except FunctionDeclaration,\r\n     * BlockStatement, and BreakStatement.\r\n     *\r\n     * - FunctionDeclarations are always executed whether it's returned or not.\r\n     * - BlockStatements do nothing.\r\n     * - BreakStatements go the next merely.\r\n     * @returns {void}\r\n     */\n\n\n    function markReturnStatementsOnCurrentSegmentsAsUsed() {\n      scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      // Makes and pushs a new scope information.\n      onCodePathStart(codePath) {\n        scopeInfo = {\n          upper: scopeInfo,\n          uselessReturns: [],\n          codePath\n        };\n      },\n\n      // Reports useless return statements if exist.\n      onCodePathEnd() {\n        for (const node of scopeInfo.uselessReturns) {\n          context.report({\n            node,\n            loc: node.loc,\n            messageId: \"unnecessaryReturn\",\n\n            fix(fixer) {\n              if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\n                /*\r\n                 * Extend the replacement range to include the\r\n                 * entire function to avoid conflicting with\r\n                 * no-else-return.\r\n                 * https://github.com/eslint/eslint/issues/8026\r\n                 */\n                return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);\n              }\n\n              return null;\n            }\n\n          });\n        }\n\n        scopeInfo = scopeInfo.upper;\n      },\n\n      /*\r\n       * Initializes segments.\r\n       * NOTE: This event is notified for only reachable segments.\r\n       */\n      onCodePathSegmentStart(segment) {\n        const info = {\n          uselessReturns: getUselessReturns([], segment.allPrevSegments),\n          returned: false\n        }; // Stores the info.\n\n        segmentInfoMap.set(segment, info);\n      },\n\n      // Adds ReturnStatement node to check whether it's useless or not.\n      ReturnStatement(node) {\n        if (node.argument) {\n          markReturnStatementsOnCurrentSegmentsAsUsed();\n        }\n\n        if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\n        !scopeInfo.codePath.currentSegments.some(s => s.reachable)) {\n          return;\n        }\n\n        for (const segment of scopeInfo.codePath.currentSegments) {\n          const info = segmentInfoMap.get(segment);\n\n          if (info) {\n            info.uselessReturns.push(node);\n            info.returned = true;\n          }\n        }\n\n        scopeInfo.uselessReturns.push(node);\n      },\n\n      /*\r\n       * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\r\n       * Removes return statements of the current segments from the useless return statement list.\r\n       */\n      ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\n      ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-return.js"],"names":["astUtils","require","FixTracker","remove","array","element","index","indexOf","splice","isRemovable","node","STATEMENT_LIST_PARENTS","has","parent","type","isInFinally","currentNode","isFunction","finalizer","module","exports","meta","docs","description","recommended","url","fixable","schema","messages","unnecessaryReturn","create","context","segmentInfoMap","WeakMap","usedUnreachableSegments","WeakSet","sourceCode","getSourceCode","scopeInfo","isReturned","segment","info","get","returned","getUselessReturns","uselessReturns","prevSegments","providedTraversedSegments","traversedSegments","reachable","add","allPrevSegments","filter","push","markReturnStatementsOnSegmentAsUsed","prevSegment","forEach","markReturnStatementsOnCurrentSegmentsAsUsed","codePath","currentSegments","onCodePathStart","upper","onCodePathEnd","report","loc","messageId","fix","fixer","getCommentsInside","length","retainEnclosingFunction","onCodePathSegmentStart","set","ReturnStatement","argument","isInLoop","some","s","ClassDeclaration","ContinueStatement","DebuggerStatement","DoWhileStatement","EmptyStatement","ExpressionStatement","ForInStatement","ForOfStatement","ForStatement","IfStatement","ImportDeclaration","LabeledStatement","SwitchStatement","ThrowStatement","TryStatement","VariableDeclaration","WhileStatement","WithStatement","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallow redundant return statements\r\n * @author Teddy Katz\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\"),\r\n    FixTracker = require(\"./utils/fix-tracker\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Removes the given element from the array.\r\n * @param {Array} array The source array to remove.\r\n * @param {any} element The target item to remove.\r\n * @returns {void}\r\n */\r\nfunction remove(array, element) {\r\n    const index = array.indexOf(element);\r\n\r\n    if (index !== -1) {\r\n        array.splice(index, 1);\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether it can remove the given return statement or not.\r\n * @param {ASTNode} node The return statement node to check.\r\n * @returns {boolean} `true` if the node is removable.\r\n */\r\nfunction isRemovable(node) {\r\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\r\n}\r\n\r\n/**\r\n * Checks whether the given return statement is in a `finally` block or not.\r\n * @param {ASTNode} node The return statement node to check.\r\n * @returns {boolean} `true` if the node is in a `finally` block.\r\n */\r\nfunction isInFinally(node) {\r\n    for (\r\n        let currentNode = node;\r\n        currentNode && currentNode.parent && !astUtils.isFunction(currentNode);\r\n        currentNode = currentNode.parent\r\n    ) {\r\n        if (currentNode.parent.type === \"TryStatement\" && currentNode.parent.finalizer === currentNode) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow redundant return statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-useless-return\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n        schema: [],\r\n\r\n        messages: {\r\n            unnecessaryReturn: \"Unnecessary return statement.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const segmentInfoMap = new WeakMap();\r\n        const usedUnreachableSegments = new WeakSet();\r\n        const sourceCode = context.getSourceCode();\r\n        let scopeInfo = null;\r\n\r\n        /**\r\n         * Checks whether the given segment is terminated by a return statement or not.\r\n         * @param {CodePathSegment} segment The segment to check.\r\n         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.\r\n         */\r\n        function isReturned(segment) {\r\n            const info = segmentInfoMap.get(segment);\r\n\r\n            return !info || info.returned;\r\n        }\r\n\r\n        /**\r\n         * Collects useless return statements from the given previous segments.\r\n         *\r\n         * A previous segment may be an unreachable segment.\r\n         * In that case, the information object of the unreachable segment is not\r\n         * initialized because `onCodePathSegmentStart` event is not notified for\r\n         * unreachable segments.\r\n         * This goes to the previous segments of the unreachable segment recursively\r\n         * if the unreachable segment was generated by a return statement. Otherwise,\r\n         * this ignores the unreachable segment.\r\n         *\r\n         * This behavior would simulate code paths for the case that the return\r\n         * statement does not exist.\r\n         * @param {ASTNode[]} uselessReturns The collected return statements.\r\n         * @param {CodePathSegment[]} prevSegments The previous segments to traverse.\r\n         * @param {WeakSet<CodePathSegment>} [providedTraversedSegments] A set of segments that have already been traversed in this call\r\n         * @returns {ASTNode[]} `uselessReturns`.\r\n         */\r\n        function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {\r\n            const traversedSegments = providedTraversedSegments || new WeakSet();\r\n\r\n            for (const segment of prevSegments) {\r\n                if (!segment.reachable) {\r\n                    if (!traversedSegments.has(segment)) {\r\n                        traversedSegments.add(segment);\r\n                        getUselessReturns(\r\n                            uselessReturns,\r\n                            segment.allPrevSegments.filter(isReturned),\r\n                            traversedSegments\r\n                        );\r\n                    }\r\n                    continue;\r\n                }\r\n\r\n                uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);\r\n            }\r\n\r\n            return uselessReturns;\r\n        }\r\n\r\n        /**\r\n         * Removes the return statements on the given segment from the useless return\r\n         * statement list.\r\n         *\r\n         * This segment may be an unreachable segment.\r\n         * In that case, the information object of the unreachable segment is not\r\n         * initialized because `onCodePathSegmentStart` event is not notified for\r\n         * unreachable segments.\r\n         * This goes to the previous segments of the unreachable segment recursively\r\n         * if the unreachable segment was generated by a return statement. Otherwise,\r\n         * this ignores the unreachable segment.\r\n         *\r\n         * This behavior would simulate code paths for the case that the return\r\n         * statement does not exist.\r\n         * @param {CodePathSegment} segment The segment to get return statements.\r\n         * @returns {void}\r\n         */\r\n        function markReturnStatementsOnSegmentAsUsed(segment) {\r\n            if (!segment.reachable) {\r\n                usedUnreachableSegments.add(segment);\r\n                segment.allPrevSegments\r\n                    .filter(isReturned)\r\n                    .filter(prevSegment => !usedUnreachableSegments.has(prevSegment))\r\n                    .forEach(markReturnStatementsOnSegmentAsUsed);\r\n                return;\r\n            }\r\n\r\n            const info = segmentInfoMap.get(segment);\r\n\r\n            for (const node of info.uselessReturns) {\r\n                remove(scopeInfo.uselessReturns, node);\r\n            }\r\n            info.uselessReturns = [];\r\n        }\r\n\r\n        /**\r\n         * Removes the return statements on the current segments from the useless\r\n         * return statement list.\r\n         *\r\n         * This function will be called at every statement except FunctionDeclaration,\r\n         * BlockStatement, and BreakStatement.\r\n         *\r\n         * - FunctionDeclarations are always executed whether it's returned or not.\r\n         * - BlockStatements do nothing.\r\n         * - BreakStatements go the next merely.\r\n         * @returns {void}\r\n         */\r\n        function markReturnStatementsOnCurrentSegmentsAsUsed() {\r\n            scopeInfo\r\n                .codePath\r\n                .currentSegments\r\n                .forEach(markReturnStatementsOnSegmentAsUsed);\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            // Makes and pushs a new scope information.\r\n            onCodePathStart(codePath) {\r\n                scopeInfo = {\r\n                    upper: scopeInfo,\r\n                    uselessReturns: [],\r\n                    codePath\r\n                };\r\n            },\r\n\r\n            // Reports useless return statements if exist.\r\n            onCodePathEnd() {\r\n                for (const node of scopeInfo.uselessReturns) {\r\n                    context.report({\r\n                        node,\r\n                        loc: node.loc,\r\n                        messageId: \"unnecessaryReturn\",\r\n                        fix(fixer) {\r\n                            if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {\r\n\r\n                                /*\r\n                                 * Extend the replacement range to include the\r\n                                 * entire function to avoid conflicting with\r\n                                 * no-else-return.\r\n                                 * https://github.com/eslint/eslint/issues/8026\r\n                                 */\r\n                                return new FixTracker(fixer, sourceCode)\r\n                                    .retainEnclosingFunction(node)\r\n                                    .remove(node);\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                }\r\n\r\n                scopeInfo = scopeInfo.upper;\r\n            },\r\n\r\n            /*\r\n             * Initializes segments.\r\n             * NOTE: This event is notified for only reachable segments.\r\n             */\r\n            onCodePathSegmentStart(segment) {\r\n                const info = {\r\n                    uselessReturns: getUselessReturns([], segment.allPrevSegments),\r\n                    returned: false\r\n                };\r\n\r\n                // Stores the info.\r\n                segmentInfoMap.set(segment, info);\r\n            },\r\n\r\n            // Adds ReturnStatement node to check whether it's useless or not.\r\n            ReturnStatement(node) {\r\n                if (node.argument) {\r\n                    markReturnStatementsOnCurrentSegmentsAsUsed();\r\n                }\r\n                if (\r\n                    node.argument ||\r\n                    astUtils.isInLoop(node) ||\r\n                    isInFinally(node) ||\r\n\r\n                    // Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).\r\n                    !scopeInfo.codePath.currentSegments.some(s => s.reachable)\r\n                ) {\r\n                    return;\r\n                }\r\n\r\n                for (const segment of scopeInfo.codePath.currentSegments) {\r\n                    const info = segmentInfoMap.get(segment);\r\n\r\n                    if (info) {\r\n                        info.uselessReturns.push(node);\r\n                        info.returned = true;\r\n                    }\r\n                }\r\n                scopeInfo.uselessReturns.push(node);\r\n            },\r\n\r\n            /*\r\n             * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.\r\n             * Removes return statements of the current segments from the useless return statement list.\r\n             */\r\n            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,\r\n            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}