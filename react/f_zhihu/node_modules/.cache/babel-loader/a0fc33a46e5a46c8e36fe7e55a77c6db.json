{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst eslintUtils = require(\"eslint-utils\");\n\nconst precedence = astUtils.getPrecedence; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary boolean casts\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForLogicalOperands: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedCall: \"Redundant Boolean call.\",\n      unexpectedNegation: \"Redundant double negation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Node types which have a test which will coerce values to booleans.\n\n    const BOOLEAN_NODE_TYPES = [\"IfStatement\", \"DoWhileStatement\", \"WhileStatement\", \"ConditionalExpression\", \"ForStatement\"];\n    /**\r\n     * Check if a node is a Boolean function or constructor.\r\n     * @param {ASTNode} node the node\r\n     * @returns {boolean} If the node is Boolean function or constructor\r\n     */\n\n    function isBooleanFunctionOrConstructorCall(node) {\n      // Boolean(<bool>) and new Boolean(<bool>)\n      return (node.type === \"CallExpression\" || node.type === \"NewExpression\") && node.callee.type === \"Identifier\" && node.callee.name === \"Boolean\";\n    }\n    /**\r\n     * Checks whether the node is a logical expression and that the option is enabled\r\n     * @param {ASTNode} node the node\r\n     * @returns {boolean} if the node is a logical expression and option is enabled\r\n     */\n\n\n    function isLogicalContext(node) {\n      return node.type === \"LogicalExpression\" && (node.operator === \"||\" || node.operator === \"&&\") && context.options.length && context.options[0].enforceForLogicalOperands === true;\n    }\n    /**\r\n     * Check if a node is in a context where its value would be coerced to a boolean at runtime.\r\n     * @param {ASTNode} node The node\r\n     * @returns {boolean} If it is in a boolean context\r\n     */\n\n\n    function isInBooleanContext(node) {\n      return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test || // !<bool>\n      node.parent.type === \"UnaryExpression\" && node.parent.operator === \"!\";\n    }\n    /**\r\n     * Checks whether the node is a context that should report an error\r\n     * Acts recursively if it is in a logical context\r\n     * @param {ASTNode} node the node\r\n     * @returns {boolean} If the node is in one of the flagged contexts\r\n     */\n\n\n    function isInFlaggedContext(node) {\n      if (node.parent.type === \"ChainExpression\") {\n        return isInFlaggedContext(node.parent);\n      }\n\n      return isInBooleanContext(node) || isLogicalContext(node.parent) && // For nested logical statements\n      isInFlaggedContext(node.parent);\n    }\n    /**\r\n     * Check if a node has comments inside.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if it has comments inside.\r\n     */\n\n\n    function hasCommentsInside(node) {\n      return Boolean(sourceCode.getCommentsInside(node).length);\n    }\n    /**\r\n     * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node is parenthesized.\r\n     * @private\r\n     */\n\n\n    function isParenthesized(node) {\n      return eslintUtils.isParenthesized(1, node, sourceCode);\n    }\n    /**\r\n     * Determines whether the given node needs to be parenthesized when replacing the previous node.\r\n     * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\r\n     * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\r\n     * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\r\n     * @param {ASTNode} previousNode Previous node.\r\n     * @param {ASTNode} node The node to check.\r\n     * @throws {Error} (Unreachable.)\r\n     * @returns {boolean} `true` if the node needs to be parenthesized.\r\n     */\n\n\n    function needsParens(previousNode, node) {\n      if (previousNode.parent.type === \"ChainExpression\") {\n        return needsParens(previousNode.parent, node);\n      }\n\n      if (isParenthesized(previousNode)) {\n        // parentheses around the previous node will stay, so there is no need for an additional pair\n        return false;\n      } // parent of the previous node will become parent of the replacement node\n\n\n      const parent = previousNode.parent;\n\n      switch (parent.type) {\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return node.type === \"SequenceExpression\";\n\n        case \"IfStatement\":\n        case \"DoWhileStatement\":\n        case \"WhileStatement\":\n        case \"ForStatement\":\n          return false;\n\n        case \"ConditionalExpression\":\n          return precedence(node) <= precedence(parent);\n\n        case \"UnaryExpression\":\n          return precedence(node) < precedence(parent);\n\n        case \"LogicalExpression\":\n          if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\n            return true;\n          }\n\n          if (previousNode === parent.left) {\n            return precedence(node) < precedence(parent);\n          }\n\n          return precedence(node) <= precedence(parent);\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(`Unexpected parent type: ${parent.type}`);\n      }\n    }\n\n    return {\n      UnaryExpression(node) {\n        const parent = node.parent; // Exit early if it's guaranteed not to match\n\n        if (node.operator !== \"!\" || parent.type !== \"UnaryExpression\" || parent.operator !== \"!\") {\n          return;\n        }\n\n        if (isInFlaggedContext(parent)) {\n          context.report({\n            node: parent,\n            messageId: \"unexpectedNegation\",\n\n            fix(fixer) {\n              if (hasCommentsInside(parent)) {\n                return null;\n              }\n\n              if (needsParens(parent, node.argument)) {\n                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\n              }\n\n              let prefix = \"\";\n              const tokenBefore = sourceCode.getTokenBefore(parent);\n              const firstReplacementToken = sourceCode.getFirstToken(node.argument);\n\n              if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {\n                prefix = \" \";\n              }\n\n              return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\n            }\n\n          });\n        }\n      },\n\n      CallExpression(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\n          return;\n        }\n\n        if (isInFlaggedContext(node)) {\n          context.report({\n            node,\n            messageId: \"unexpectedCall\",\n\n            fix(fixer) {\n              const parent = node.parent;\n\n              if (node.arguments.length === 0) {\n                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\n                  /*\r\n                   * !Boolean() -> true\r\n                   */\n                  if (hasCommentsInside(parent)) {\n                    return null;\n                  }\n\n                  const replacement = \"true\";\n                  let prefix = \"\";\n                  const tokenBefore = sourceCode.getTokenBefore(parent);\n\n                  if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {\n                    prefix = \" \";\n                  }\n\n                  return fixer.replaceText(parent, prefix + replacement);\n                }\n                /*\r\n                 * Boolean() -> false\r\n                 */\n\n\n                if (hasCommentsInside(node)) {\n                  return null;\n                }\n\n                return fixer.replaceText(node, \"false\");\n              }\n\n              if (node.arguments.length === 1) {\n                const argument = node.arguments[0];\n\n                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\n                  return null;\n                }\n                /*\r\n                 * Boolean(expression) -> expression\r\n                 */\n\n\n                if (needsParens(node, argument)) {\n                  return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\n                }\n\n                return fixer.replaceText(node, sourceCode.getText(argument));\n              } // two or more arguments\n\n\n              return null;\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-extra-boolean-cast.js"],"names":["astUtils","require","eslintUtils","precedence","getPrecedence","module","exports","meta","type","docs","description","recommended","url","schema","properties","enforceForLogicalOperands","default","additionalProperties","fixable","messages","unexpectedCall","unexpectedNegation","create","context","sourceCode","getSourceCode","BOOLEAN_NODE_TYPES","isBooleanFunctionOrConstructorCall","node","callee","name","isLogicalContext","operator","options","length","isInBooleanContext","parent","arguments","indexOf","test","isInFlaggedContext","hasCommentsInside","Boolean","getCommentsInside","isParenthesized","needsParens","previousNode","isMixedLogicalAndCoalesceExpressions","left","Error","UnaryExpression","report","messageId","fix","fixer","argument","replaceText","getText","prefix","tokenBefore","getTokenBefore","firstReplacementToken","getFirstToken","range","canTokensBeAdjacent","CallExpression","replacement"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag unnecessary double negation in Boolean contexts\r\n * @author Brandon Mills\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst eslintUtils = require(\"eslint-utils\");\r\n\r\nconst precedence = astUtils.getPrecedence;\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary boolean casts\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-extra-boolean-cast\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                enforceForLogicalOperands: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpectedCall: \"Redundant Boolean call.\",\r\n            unexpectedNegation: \"Redundant double negation.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        // Node types which have a test which will coerce values to booleans.\r\n        const BOOLEAN_NODE_TYPES = [\r\n            \"IfStatement\",\r\n            \"DoWhileStatement\",\r\n            \"WhileStatement\",\r\n            \"ConditionalExpression\",\r\n            \"ForStatement\"\r\n        ];\r\n\r\n        /**\r\n         * Check if a node is a Boolean function or constructor.\r\n         * @param {ASTNode} node the node\r\n         * @returns {boolean} If the node is Boolean function or constructor\r\n         */\r\n        function isBooleanFunctionOrConstructorCall(node) {\r\n\r\n            // Boolean(<bool>) and new Boolean(<bool>)\r\n            return (node.type === \"CallExpression\" || node.type === \"NewExpression\") &&\r\n                    node.callee.type === \"Identifier\" &&\r\n                        node.callee.name === \"Boolean\";\r\n        }\r\n\r\n        /**\r\n         * Checks whether the node is a logical expression and that the option is enabled\r\n         * @param {ASTNode} node the node\r\n         * @returns {boolean} if the node is a logical expression and option is enabled\r\n         */\r\n        function isLogicalContext(node) {\r\n            return node.type === \"LogicalExpression\" &&\r\n            (node.operator === \"||\" || node.operator === \"&&\") &&\r\n            (context.options.length && context.options[0].enforceForLogicalOperands === true);\r\n\r\n        }\r\n\r\n\r\n        /**\r\n         * Check if a node is in a context where its value would be coerced to a boolean at runtime.\r\n         * @param {ASTNode} node The node\r\n         * @returns {boolean} If it is in a boolean context\r\n         */\r\n        function isInBooleanContext(node) {\r\n            return (\r\n                (isBooleanFunctionOrConstructorCall(node.parent) &&\r\n                node === node.parent.arguments[0]) ||\r\n\r\n                (BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 &&\r\n                    node === node.parent.test) ||\r\n\r\n                // !<bool>\r\n                (node.parent.type === \"UnaryExpression\" &&\r\n                    node.parent.operator === \"!\")\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks whether the node is a context that should report an error\r\n         * Acts recursively if it is in a logical context\r\n         * @param {ASTNode} node the node\r\n         * @returns {boolean} If the node is in one of the flagged contexts\r\n         */\r\n        function isInFlaggedContext(node) {\r\n            if (node.parent.type === \"ChainExpression\") {\r\n                return isInFlaggedContext(node.parent);\r\n            }\r\n\r\n            return isInBooleanContext(node) ||\r\n            (isLogicalContext(node.parent) &&\r\n\r\n            // For nested logical statements\r\n            isInFlaggedContext(node.parent)\r\n            );\r\n        }\r\n\r\n\r\n        /**\r\n         * Check if a node has comments inside.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} `true` if it has comments inside.\r\n         */\r\n        function hasCommentsInside(node) {\r\n            return Boolean(sourceCode.getCommentsInside(node).length);\r\n        }\r\n\r\n        /**\r\n         * Checks if the given node is wrapped in grouping parentheses. Parentheses for constructs such as if() don't count.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} `true` if the node is parenthesized.\r\n         * @private\r\n         */\r\n        function isParenthesized(node) {\r\n            return eslintUtils.isParenthesized(1, node, sourceCode);\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given node needs to be parenthesized when replacing the previous node.\r\n         * It assumes that `previousNode` is the node to be reported by this rule, so it has a limited list\r\n         * of possible parent node types. By the same assumption, the node's role in a particular parent is already known.\r\n         * For example, if the parent is `ConditionalExpression`, `previousNode` must be its `test` child.\r\n         * @param {ASTNode} previousNode Previous node.\r\n         * @param {ASTNode} node The node to check.\r\n         * @throws {Error} (Unreachable.)\r\n         * @returns {boolean} `true` if the node needs to be parenthesized.\r\n         */\r\n        function needsParens(previousNode, node) {\r\n            if (previousNode.parent.type === \"ChainExpression\") {\r\n                return needsParens(previousNode.parent, node);\r\n            }\r\n            if (isParenthesized(previousNode)) {\r\n\r\n                // parentheses around the previous node will stay, so there is no need for an additional pair\r\n                return false;\r\n            }\r\n\r\n            // parent of the previous node will become parent of the replacement node\r\n            const parent = previousNode.parent;\r\n\r\n            switch (parent.type) {\r\n                case \"CallExpression\":\r\n                case \"NewExpression\":\r\n                    return node.type === \"SequenceExpression\";\r\n                case \"IfStatement\":\r\n                case \"DoWhileStatement\":\r\n                case \"WhileStatement\":\r\n                case \"ForStatement\":\r\n                    return false;\r\n                case \"ConditionalExpression\":\r\n                    return precedence(node) <= precedence(parent);\r\n                case \"UnaryExpression\":\r\n                    return precedence(node) < precedence(parent);\r\n                case \"LogicalExpression\":\r\n                    if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {\r\n                        return true;\r\n                    }\r\n                    if (previousNode === parent.left) {\r\n                        return precedence(node) < precedence(parent);\r\n                    }\r\n                    return precedence(node) <= precedence(parent);\r\n\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw new Error(`Unexpected parent type: ${parent.type}`);\r\n            }\r\n        }\r\n\r\n        return {\r\n            UnaryExpression(node) {\r\n                const parent = node.parent;\r\n\r\n\r\n                // Exit early if it's guaranteed not to match\r\n                if (node.operator !== \"!\" ||\r\n                          parent.type !== \"UnaryExpression\" ||\r\n                          parent.operator !== \"!\") {\r\n                    return;\r\n                }\r\n\r\n\r\n                if (isInFlaggedContext(parent)) {\r\n                    context.report({\r\n                        node: parent,\r\n                        messageId: \"unexpectedNegation\",\r\n                        fix(fixer) {\r\n                            if (hasCommentsInside(parent)) {\r\n                                return null;\r\n                            }\r\n\r\n                            if (needsParens(parent, node.argument)) {\r\n                                return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);\r\n                            }\r\n\r\n                            let prefix = \"\";\r\n                            const tokenBefore = sourceCode.getTokenBefore(parent);\r\n                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);\r\n\r\n                            if (\r\n                                tokenBefore &&\r\n                                tokenBefore.range[1] === parent.range[0] &&\r\n                                !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)\r\n                            ) {\r\n                                prefix = \" \";\r\n                            }\r\n\r\n                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));\r\n                        }\r\n                    });\r\n                }\r\n            },\r\n\r\n            CallExpression(node) {\r\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"Boolean\") {\r\n                    return;\r\n                }\r\n\r\n                if (isInFlaggedContext(node)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedCall\",\r\n                        fix(fixer) {\r\n                            const parent = node.parent;\r\n\r\n                            if (node.arguments.length === 0) {\r\n                                if (parent.type === \"UnaryExpression\" && parent.operator === \"!\") {\r\n\r\n                                    /*\r\n                                     * !Boolean() -> true\r\n                                     */\r\n\r\n                                    if (hasCommentsInside(parent)) {\r\n                                        return null;\r\n                                    }\r\n\r\n                                    const replacement = \"true\";\r\n                                    let prefix = \"\";\r\n                                    const tokenBefore = sourceCode.getTokenBefore(parent);\r\n\r\n                                    if (\r\n                                        tokenBefore &&\r\n                                        tokenBefore.range[1] === parent.range[0] &&\r\n                                        !astUtils.canTokensBeAdjacent(tokenBefore, replacement)\r\n                                    ) {\r\n                                        prefix = \" \";\r\n                                    }\r\n\r\n                                    return fixer.replaceText(parent, prefix + replacement);\r\n                                }\r\n\r\n                                /*\r\n                                 * Boolean() -> false\r\n                                 */\r\n\r\n                                if (hasCommentsInside(node)) {\r\n                                    return null;\r\n                                }\r\n\r\n                                return fixer.replaceText(node, \"false\");\r\n                            }\r\n\r\n                            if (node.arguments.length === 1) {\r\n                                const argument = node.arguments[0];\r\n\r\n                                if (argument.type === \"SpreadElement\" || hasCommentsInside(node)) {\r\n                                    return null;\r\n                                }\r\n\r\n                                /*\r\n                                 * Boolean(expression) -> expression\r\n                                 */\r\n\r\n                                if (needsParens(node, argument)) {\r\n                                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);\r\n                                }\r\n\r\n                                return fixer.replaceText(node, sourceCode.getText(argument));\r\n                            }\r\n\r\n                            // two or more arguments\r\n                            return null;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}