{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow unused labels.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unused labels\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-labels\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unused: \"'{{name}}:' is defined but never used.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let scopeInfo = null;\n    /**\r\n     * Adds a scope info to the stack.\r\n     * @param {ASTNode} node A node to add. This is a LabeledStatement.\r\n     * @returns {void}\r\n     */\n\n    function enterLabeledScope(node) {\n      scopeInfo = {\n        label: node.label.name,\n        used: false,\n        upper: scopeInfo\n      };\n    }\n    /**\r\n     * Removes the top of the stack.\r\n     * At the same time, this reports the label if it's never used.\r\n     * @param {ASTNode} node A node to report. This is a LabeledStatement.\r\n     * @returns {void}\r\n     */\n\n\n    function exitLabeledScope(node) {\n      if (!scopeInfo.used) {\n        context.report({\n          node: node.label,\n          messageId: \"unused\",\n          data: node.label,\n\n          fix(fixer) {\n            /*\r\n             * Only perform a fix if there are no comments between the label and the body. This will be the case\r\n             * when there is exactly one token/comment (the \":\") between the label and the body.\r\n             */\n            if (sourceCode.getTokenAfter(node.label, {\n              includeComments: true\n            }) === sourceCode.getTokenBefore(node.body, {\n              includeComments: true\n            })) {\n              return fixer.removeRange([node.range[0], node.body.range[0]]);\n            }\n\n            return null;\n          }\n\n        });\n      }\n\n      scopeInfo = scopeInfo.upper;\n    }\n    /**\r\n     * Marks the label of a given node as used.\r\n     * @param {ASTNode} node A node to mark. This is a BreakStatement or\r\n     *      ContinueStatement.\r\n     * @returns {void}\r\n     */\n\n\n    function markAsUsed(node) {\n      if (!node.label) {\n        return;\n      }\n\n      const label = node.label.name;\n      let info = scopeInfo;\n\n      while (info) {\n        if (info.label === label) {\n          info.used = true;\n          break;\n        }\n\n        info = info.upper;\n      }\n    }\n\n    return {\n      LabeledStatement: enterLabeledScope,\n      \"LabeledStatement:exit\": exitLabeledScope,\n      BreakStatement: markAsUsed,\n      ContinueStatement: markAsUsed\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unused-labels.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","fixable","messages","unused","create","context","sourceCode","getSourceCode","scopeInfo","enterLabeledScope","node","label","name","used","upper","exitLabeledScope","report","messageId","data","fix","fixer","getTokenAfter","includeComments","getTokenBefore","body","removeRange","range","markAsUsed","info","LabeledStatement","BreakStatement","ContinueStatement"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;;AACAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,wBADX;AAEFC,MAAAA,WAAW,EAAE,IAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,EATN;AAWFC,IAAAA,OAAO,EAAE,MAXP;AAaFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,MAAM,EAAE;AADF;AAbR,GADO;;AAmBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,UAAU,GAAGD,OAAO,CAACE,aAAR,EAAnB;AACA,QAAIC,SAAS,GAAG,IAAhB;AAEA;AACR;AACA;AACA;AACA;;AACQ,aAASC,iBAAT,CAA2BC,IAA3B,EAAiC;AAC7BF,MAAAA,SAAS,GAAG;AACRG,QAAAA,KAAK,EAAED,IAAI,CAACC,KAAL,CAAWC,IADV;AAERC,QAAAA,IAAI,EAAE,KAFE;AAGRC,QAAAA,KAAK,EAAEN;AAHC,OAAZ;AAKH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASO,gBAAT,CAA0BL,IAA1B,EAAgC;AAC5B,UAAI,CAACF,SAAS,CAACK,IAAf,EAAqB;AACjBR,QAAAA,OAAO,CAACW,MAAR,CAAe;AACXN,UAAAA,IAAI,EAAEA,IAAI,CAACC,KADA;AAEXM,UAAAA,SAAS,EAAE,QAFA;AAGXC,UAAAA,IAAI,EAAER,IAAI,CAACC,KAHA;;AAIXQ,UAAAA,GAAG,CAACC,KAAD,EAAQ;AAEP;AACxB;AACA;AACA;AACwB,gBAAId,UAAU,CAACe,aAAX,CAAyBX,IAAI,CAACC,KAA9B,EAAqC;AAAEW,cAAAA,eAAe,EAAE;AAAnB,aAArC,MACIhB,UAAU,CAACiB,cAAX,CAA0Bb,IAAI,CAACc,IAA/B,EAAqC;AAAEF,cAAAA,eAAe,EAAE;AAAnB,aAArC,CADR,EACyE;AACrE,qBAAOF,KAAK,CAACK,WAAN,CAAkB,CAACf,IAAI,CAACgB,KAAL,CAAW,CAAX,CAAD,EAAgBhB,IAAI,CAACc,IAAL,CAAUE,KAAV,CAAgB,CAAhB,CAAhB,CAAlB,CAAP;AACH;;AAED,mBAAO,IAAP;AACH;;AAhBU,SAAf;AAkBH;;AAEDlB,MAAAA,SAAS,GAAGA,SAAS,CAACM,KAAtB;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASa,UAAT,CAAoBjB,IAApB,EAA0B;AACtB,UAAI,CAACA,IAAI,CAACC,KAAV,EAAiB;AACb;AACH;;AAED,YAAMA,KAAK,GAAGD,IAAI,CAACC,KAAL,CAAWC,IAAzB;AACA,UAAIgB,IAAI,GAAGpB,SAAX;;AAEA,aAAOoB,IAAP,EAAa;AACT,YAAIA,IAAI,CAACjB,KAAL,KAAeA,KAAnB,EAA0B;AACtBiB,UAAAA,IAAI,CAACf,IAAL,GAAY,IAAZ;AACA;AACH;;AACDe,QAAAA,IAAI,GAAGA,IAAI,CAACd,KAAZ;AACH;AACJ;;AAED,WAAO;AACHe,MAAAA,gBAAgB,EAAEpB,iBADf;AAEH,+BAAyBM,gBAFtB;AAGHe,MAAAA,cAAc,EAAEH,UAHb;AAIHI,MAAAA,iBAAiB,EAAEJ;AAJhB,KAAP;AAMH;;AAhGY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to disallow unused labels.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unused labels\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-unused-labels\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unused: \"'{{name}}:' is defined but never used.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        let scopeInfo = null;\r\n\r\n        /**\r\n         * Adds a scope info to the stack.\r\n         * @param {ASTNode} node A node to add. This is a LabeledStatement.\r\n         * @returns {void}\r\n         */\r\n        function enterLabeledScope(node) {\r\n            scopeInfo = {\r\n                label: node.label.name,\r\n                used: false,\r\n                upper: scopeInfo\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Removes the top of the stack.\r\n         * At the same time, this reports the label if it's never used.\r\n         * @param {ASTNode} node A node to report. This is a LabeledStatement.\r\n         * @returns {void}\r\n         */\r\n        function exitLabeledScope(node) {\r\n            if (!scopeInfo.used) {\r\n                context.report({\r\n                    node: node.label,\r\n                    messageId: \"unused\",\r\n                    data: node.label,\r\n                    fix(fixer) {\r\n\r\n                        /*\r\n                         * Only perform a fix if there are no comments between the label and the body. This will be the case\r\n                         * when there is exactly one token/comment (the \":\") between the label and the body.\r\n                         */\r\n                        if (sourceCode.getTokenAfter(node.label, { includeComments: true }) ===\r\n                                sourceCode.getTokenBefore(node.body, { includeComments: true })) {\r\n                            return fixer.removeRange([node.range[0], node.body.range[0]]);\r\n                        }\r\n\r\n                        return null;\r\n                    }\r\n                });\r\n            }\r\n\r\n            scopeInfo = scopeInfo.upper;\r\n        }\r\n\r\n        /**\r\n         * Marks the label of a given node as used.\r\n         * @param {ASTNode} node A node to mark. This is a BreakStatement or\r\n         *      ContinueStatement.\r\n         * @returns {void}\r\n         */\r\n        function markAsUsed(node) {\r\n            if (!node.label) {\r\n                return;\r\n            }\r\n\r\n            const label = node.label.name;\r\n            let info = scopeInfo;\r\n\r\n            while (info) {\r\n                if (info.label === label) {\r\n                    info.used = true;\r\n                    break;\r\n                }\r\n                info = info.upper;\r\n            }\r\n        }\r\n\r\n        return {\r\n            LabeledStatement: enterLabeledScope,\r\n            \"LabeledStatement:exit\": exitLabeledScope,\r\n            BreakStatement: markAsUsed,\r\n            ContinueStatement: markAsUsed\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}