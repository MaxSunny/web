{"ast":null,"code":"/**\r\n * @fileoverview Disallows unnecessary `return await`\r\n * @author Jordan Harband\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow unnecessary `return await`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-return-await\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Reports a found unnecessary `await` expression.\r\n     * @param {ASTNode} node The node representing the `await` expression to report\r\n     * @returns {void}\r\n     */\n    function reportUnnecessaryAwait(node) {\n      context.report({\n        node: context.getSourceCode().getFirstToken(node),\n        loc: node.loc,\n        messageId: \"redundantUseOfAwait\"\n      });\n    }\n    /**\r\n     * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\r\n     * this function. For example, a statement in a `try` block will always have an error handler. A statement in\r\n     * a `catch` block will only have an error handler if there is also a `finally` block.\r\n     * @param {ASTNode} node A node representing a location where an could be thrown\r\n     * @returns {boolean} `true` if a thrown error will be caught/handled in this function\r\n     */\n\n\n    function hasErrorHandler(node) {\n      let ancestor = node;\n\n      while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\n        if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\n          return true;\n        }\n\n        ancestor = ancestor.parent;\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\r\n     * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\r\n     * @param {ASTNode} node A node representing the `await` expression to check\r\n     * @returns {boolean} The checking result\r\n     */\n\n\n    function isInTailCallPosition(node) {\n      if (node.parent.type === \"ArrowFunctionExpression\") {\n        return true;\n      }\n\n      if (node.parent.type === \"ReturnStatement\") {\n        return !hasErrorHandler(node.parent);\n      }\n\n      if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\n        return isInTailCallPosition(node.parent);\n      }\n\n      return false;\n    }\n\n    return {\n      AwaitExpression(node) {\n        if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\n          reportUnnecessaryAwait(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-return-await.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","messages","redundantUseOfAwait","create","context","reportUnnecessaryAwait","node","report","getSourceCode","getFirstToken","loc","messageId","hasErrorHandler","ancestor","isFunction","parent","block","handler","finalizer","isInTailCallPosition","consequent","alternate","right","expressions","length","AwaitExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallows unnecessary `return await`\r\n * @author Jordan Harband\r\n */\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow unnecessary `return await`\",\r\n\r\n            recommended: false,\r\n\r\n            url: \"https://eslint.org/docs/rules/no-return-await\"\r\n        },\r\n\r\n        fixable: null,\r\n\r\n        schema: [\r\n        ],\r\n\r\n        messages: {\r\n            redundantUseOfAwait: \"Redundant use of `await` on a return value.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Reports a found unnecessary `await` expression.\r\n         * @param {ASTNode} node The node representing the `await` expression to report\r\n         * @returns {void}\r\n         */\r\n        function reportUnnecessaryAwait(node) {\r\n            context.report({\r\n                node: context.getSourceCode().getFirstToken(node),\r\n                loc: node.loc,\r\n                messageId: \"redundantUseOfAwait\"\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting\r\n         * this function. For example, a statement in a `try` block will always have an error handler. A statement in\r\n         * a `catch` block will only have an error handler if there is also a `finally` block.\r\n         * @param {ASTNode} node A node representing a location where an could be thrown\r\n         * @returns {boolean} `true` if a thrown error will be caught/handled in this function\r\n         */\r\n        function hasErrorHandler(node) {\r\n            let ancestor = node;\r\n\r\n            while (!astUtils.isFunction(ancestor) && ancestor.type !== \"Program\") {\r\n                if (ancestor.parent.type === \"TryStatement\" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {\r\n                    return true;\r\n                }\r\n                ancestor = ancestor.parent;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,\r\n         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.\r\n         * @param {ASTNode} node A node representing the `await` expression to check\r\n         * @returns {boolean} The checking result\r\n         */\r\n        function isInTailCallPosition(node) {\r\n            if (node.parent.type === \"ArrowFunctionExpression\") {\r\n                return true;\r\n            }\r\n            if (node.parent.type === \"ReturnStatement\") {\r\n                return !hasErrorHandler(node.parent);\r\n            }\r\n            if (node.parent.type === \"ConditionalExpression\" && (node === node.parent.consequent || node === node.parent.alternate)) {\r\n                return isInTailCallPosition(node.parent);\r\n            }\r\n            if (node.parent.type === \"LogicalExpression\" && node === node.parent.right) {\r\n                return isInTailCallPosition(node.parent);\r\n            }\r\n            if (node.parent.type === \"SequenceExpression\" && node === node.parent.expressions[node.parent.expressions.length - 1]) {\r\n                return isInTailCallPosition(node.parent);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        return {\r\n            AwaitExpression(node) {\r\n                if (isInTailCallPosition(node) && !hasErrorHandler(node)) {\r\n                    reportUnnecessaryAwait(node);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}