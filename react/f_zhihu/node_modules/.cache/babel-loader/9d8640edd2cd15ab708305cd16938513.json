{"ast":null,"code":"/**\r\n * @fileoverview Prefers object spread property over Object.assign\r\n * @author Sharmila Jesupaul\r\n * See LICENSE file in root directory for full license.\r\n */\n\"use strict\";\n\nconst {\n  CALL,\n  ReferenceTracker\n} = require(\"eslint-utils\");\n\nconst {\n  isCommaToken,\n  isOpeningParenToken,\n  isClosingParenToken,\n  isParenthesised\n} = require(\"./utils/ast-utils\");\n\nconst ANY_SPACE = /\\s/u;\n/**\r\n * Helper that checks if the Object.assign call has array spread\r\n * @param {ASTNode} node The node that the rule warns on\r\n * @returns {boolean} - Returns true if the Object.assign call has array spread\r\n */\n\nfunction hasArraySpread(node) {\n  return node.arguments.some(arg => arg.type === \"SpreadElement\");\n}\n/**\r\n * Determines whether the given node is an accessor property (getter/setter).\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} `true` if the node is a getter or a setter.\r\n */\n\n\nfunction isAccessorProperty(node) {\n  return node.type === \"Property\" && (node.kind === \"get\" || node.kind === \"set\");\n}\n/**\r\n * Determines whether the given object expression node has accessor properties (getters/setters).\r\n * @param {ASTNode} node `ObjectExpression` node to check.\r\n * @returns {boolean} `true` if the node has at least one getter/setter.\r\n */\n\n\nfunction hasAccessors(node) {\n  return node.properties.some(isAccessorProperty);\n}\n/**\r\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\r\n * @param {ASTNode} node `CallExpression` node to check.\r\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\r\n */\n\n\nfunction hasArgumentsWithAccessors(node) {\n  return node.arguments.filter(arg => arg.type === \"ObjectExpression\").some(hasAccessors);\n}\n/**\r\n * Helper that checks if the node needs parentheses to be valid JS.\r\n * The default is to wrap the node in parentheses to avoid parsing errors.\r\n * @param {ASTNode} node The node that the rule warns on\r\n * @param {Object} sourceCode in context sourcecode object\r\n * @returns {boolean} - Returns true if the node needs parentheses\r\n */\n\n\nfunction needsParens(node, sourceCode) {\n  const parent = node.parent;\n\n  switch (parent.type) {\n    case \"VariableDeclarator\":\n    case \"ArrayExpression\":\n    case \"ReturnStatement\":\n    case \"CallExpression\":\n    case \"Property\":\n      return false;\n\n    case \"AssignmentExpression\":\n      return parent.left === node && !isParenthesised(sourceCode, node);\n\n    default:\n      return !isParenthesised(sourceCode, node);\n  }\n}\n/**\r\n * Determines if an argument needs parentheses. The default is to not add parens.\r\n * @param {ASTNode} node The node to be checked.\r\n * @param {Object} sourceCode in context sourcecode object\r\n * @returns {boolean} True if the node needs parentheses\r\n */\n\n\nfunction argNeedsParens(node, sourceCode) {\n  switch (node.type) {\n    case \"AssignmentExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ConditionalExpression\":\n      return !isParenthesised(sourceCode, node);\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Get the parenthesis tokens of a given ObjectExpression node.\r\n * This includes the braces of the object literal and enclosing parentheses.\r\n * @param {ASTNode} node The node to get.\r\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\r\n */\n\n\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\n  const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\n  let leftNext = sourceCode.getTokenBefore(node);\n  let rightNext = sourceCode.getTokenAfter(node); // Note: don't include the parens of the argument list.\n\n  while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {\n    parens.push(leftNext, rightNext);\n    leftNext = sourceCode.getTokenBefore(leftNext);\n    rightNext = sourceCode.getTokenAfter(rightNext);\n  }\n\n  return parens.sort((a, b) => a.range[0] - b.range[0]);\n}\n/**\r\n * Get the range of a given token and around whitespaces.\r\n * @param {Token} token The token to get range.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {number} The end of the range of the token and around whitespaces.\r\n */\n\n\nfunction getStartWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let start = token.range[0]; // If the previous token is a line comment then skip this step to avoid commenting this token out.\n\n  {\n    const prevToken = sourceCode.getTokenBefore(token, {\n      includeComments: true\n    });\n\n    if (prevToken && prevToken.type === \"Line\") {\n      return start;\n    }\n  } // Detect spaces before the token.\n\n  while (ANY_SPACE.test(text[start - 1] || \"\")) {\n    start -= 1;\n  }\n\n  return start;\n}\n/**\r\n * Get the range of a given token and around whitespaces.\r\n * @param {Token} token The token to get range.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {number} The start of the range of the token and around whitespaces.\r\n */\n\n\nfunction getEndWithSpaces(token, sourceCode) {\n  const text = sourceCode.text;\n  let end = token.range[1]; // Detect spaces after the token.\n\n  while (ANY_SPACE.test(text[end] || \"\")) {\n    end += 1;\n  }\n\n  return end;\n}\n/**\r\n * Autofixes the Object.assign call to use an object spread instead.\r\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\r\n * @param {string} sourceCode sourceCode of the Object.assign call\r\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\r\n */\n\n\nfunction defineFixer(node, sourceCode) {\n  return function* (fixer) {\n    const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\n    const rightParen = sourceCode.getLastToken(node); // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\n\n    yield fixer.removeRange([node.range[0], leftParen.range[0]]); // Replace the parens of argument list to braces.\n\n    if (needsParens(node, sourceCode)) {\n      yield fixer.replaceText(leftParen, \"({\");\n      yield fixer.replaceText(rightParen, \"})\");\n    } else {\n      yield fixer.replaceText(leftParen, \"{\");\n      yield fixer.replaceText(rightParen, \"}\");\n    } // Process arguments.\n\n\n    for (const argNode of node.arguments) {\n      const innerParens = getParenTokens(argNode, leftParen, sourceCode);\n      const left = innerParens.shift();\n      const right = innerParens.pop();\n\n      if (argNode.type === \"ObjectExpression\") {\n        const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\n        const maybeArgumentComma = sourceCode.getTokenAfter(right);\n        /*\r\n         * Make bare this object literal.\r\n         * And remove spaces inside of the braces for better formatting.\r\n         */\n\n        for (const innerParen of innerParens) {\n          yield fixer.remove(innerParen);\n        }\n\n        const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\n        const rightRange = [Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\n        right.range[1]];\n        yield fixer.removeRange(leftRange);\n        yield fixer.removeRange(rightRange); // Remove the comma of this argument if it's duplication.\n\n        if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {\n          yield fixer.remove(maybeArgumentComma);\n        }\n      } else {\n        // Make spread.\n        if (argNeedsParens(argNode, sourceCode)) {\n          yield fixer.insertTextBefore(left, \"...(\");\n          yield fixer.insertTextAfter(right, \")\");\n        } else {\n          yield fixer.insertTextBefore(left, \"...\");\n        }\n      }\n    }\n  };\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-object-spread\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\n      useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    return {\n      Program() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        const trackMap = {\n          Object: {\n            assign: {\n              [CALL]: true\n            }\n          }\n        }; // Iterate all calls of `Object.assign` (only of the global variable `Object`).\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences(trackMap)) {\n          if (node.arguments.length >= 1 && node.arguments[0].type === \"ObjectExpression\" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {\n            const messageId = node.arguments.length === 1 ? \"useLiteralMessage\" : \"useSpreadMessage\";\n            const fix = defineFixer(node, sourceCode);\n            context.report({\n              node,\n              messageId,\n              fix\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-object-spread.js"],"names":["CALL","ReferenceTracker","require","isCommaToken","isOpeningParenToken","isClosingParenToken","isParenthesised","ANY_SPACE","hasArraySpread","node","arguments","some","arg","type","isAccessorProperty","kind","hasAccessors","properties","hasArgumentsWithAccessors","filter","needsParens","sourceCode","parent","left","argNeedsParens","getParenTokens","leftArgumentListParen","parens","getFirstToken","getLastToken","leftNext","getTokenBefore","rightNext","getTokenAfter","range","push","sort","a","b","getStartWithSpaces","token","text","start","prevToken","includeComments","test","getEndWithSpaces","end","defineFixer","fixer","leftParen","callee","rightParen","removeRange","replaceText","argNode","innerParens","shift","right","pop","maybeTrailingComma","maybeArgumentComma","innerParen","remove","leftRange","rightRange","Math","max","length","insertTextBefore","insertTextAfter","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","useSpreadMessage","useLiteralMessage","create","context","getSourceCode","Program","scope","getScope","tracker","trackMap","Object","assign","iterateGlobalReferences","messageId","fix","report"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Prefers object spread property over Object.assign\r\n * @author Sharmila Jesupaul\r\n * See LICENSE file in root directory for full license.\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst { CALL, ReferenceTracker } = require(\"eslint-utils\");\r\nconst {\r\n    isCommaToken,\r\n    isOpeningParenToken,\r\n    isClosingParenToken,\r\n    isParenthesised\r\n} = require(\"./utils/ast-utils\");\r\n\r\nconst ANY_SPACE = /\\s/u;\r\n\r\n/**\r\n * Helper that checks if the Object.assign call has array spread\r\n * @param {ASTNode} node The node that the rule warns on\r\n * @returns {boolean} - Returns true if the Object.assign call has array spread\r\n */\r\nfunction hasArraySpread(node) {\r\n    return node.arguments.some(arg => arg.type === \"SpreadElement\");\r\n}\r\n\r\n/**\r\n * Determines whether the given node is an accessor property (getter/setter).\r\n * @param {ASTNode} node Node to check.\r\n * @returns {boolean} `true` if the node is a getter or a setter.\r\n */\r\nfunction isAccessorProperty(node) {\r\n    return node.type === \"Property\" &&\r\n        (node.kind === \"get\" || node.kind === \"set\");\r\n}\r\n\r\n/**\r\n * Determines whether the given object expression node has accessor properties (getters/setters).\r\n * @param {ASTNode} node `ObjectExpression` node to check.\r\n * @returns {boolean} `true` if the node has at least one getter/setter.\r\n */\r\nfunction hasAccessors(node) {\r\n    return node.properties.some(isAccessorProperty);\r\n}\r\n\r\n/**\r\n * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).\r\n * @param {ASTNode} node `CallExpression` node to check.\r\n * @returns {boolean} `true` if the node has at least one argument that is an object expression with at least one getter/setter.\r\n */\r\nfunction hasArgumentsWithAccessors(node) {\r\n    return node.arguments\r\n        .filter(arg => arg.type === \"ObjectExpression\")\r\n        .some(hasAccessors);\r\n}\r\n\r\n/**\r\n * Helper that checks if the node needs parentheses to be valid JS.\r\n * The default is to wrap the node in parentheses to avoid parsing errors.\r\n * @param {ASTNode} node The node that the rule warns on\r\n * @param {Object} sourceCode in context sourcecode object\r\n * @returns {boolean} - Returns true if the node needs parentheses\r\n */\r\nfunction needsParens(node, sourceCode) {\r\n    const parent = node.parent;\r\n\r\n    switch (parent.type) {\r\n        case \"VariableDeclarator\":\r\n        case \"ArrayExpression\":\r\n        case \"ReturnStatement\":\r\n        case \"CallExpression\":\r\n        case \"Property\":\r\n            return false;\r\n        case \"AssignmentExpression\":\r\n            return parent.left === node && !isParenthesised(sourceCode, node);\r\n        default:\r\n            return !isParenthesised(sourceCode, node);\r\n    }\r\n}\r\n\r\n/**\r\n * Determines if an argument needs parentheses. The default is to not add parens.\r\n * @param {ASTNode} node The node to be checked.\r\n * @param {Object} sourceCode in context sourcecode object\r\n * @returns {boolean} True if the node needs parentheses\r\n */\r\nfunction argNeedsParens(node, sourceCode) {\r\n    switch (node.type) {\r\n        case \"AssignmentExpression\":\r\n        case \"ArrowFunctionExpression\":\r\n        case \"ConditionalExpression\":\r\n            return !isParenthesised(sourceCode, node);\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Get the parenthesis tokens of a given ObjectExpression node.\r\n * This includes the braces of the object literal and enclosing parentheses.\r\n * @param {ASTNode} node The node to get.\r\n * @param {Token} leftArgumentListParen The opening paren token of the argument list.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token[]} The parenthesis tokens of the node. This is sorted by the location.\r\n */\r\nfunction getParenTokens(node, leftArgumentListParen, sourceCode) {\r\n    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];\r\n    let leftNext = sourceCode.getTokenBefore(node);\r\n    let rightNext = sourceCode.getTokenAfter(node);\r\n\r\n    // Note: don't include the parens of the argument list.\r\n    while (\r\n        leftNext &&\r\n        rightNext &&\r\n        leftNext.range[0] > leftArgumentListParen.range[0] &&\r\n        isOpeningParenToken(leftNext) &&\r\n        isClosingParenToken(rightNext)\r\n    ) {\r\n        parens.push(leftNext, rightNext);\r\n        leftNext = sourceCode.getTokenBefore(leftNext);\r\n        rightNext = sourceCode.getTokenAfter(rightNext);\r\n    }\r\n\r\n    return parens.sort((a, b) => a.range[0] - b.range[0]);\r\n}\r\n\r\n/**\r\n * Get the range of a given token and around whitespaces.\r\n * @param {Token} token The token to get range.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {number} The end of the range of the token and around whitespaces.\r\n */\r\nfunction getStartWithSpaces(token, sourceCode) {\r\n    const text = sourceCode.text;\r\n    let start = token.range[0];\r\n\r\n    // If the previous token is a line comment then skip this step to avoid commenting this token out.\r\n    {\r\n        const prevToken = sourceCode.getTokenBefore(token, { includeComments: true });\r\n\r\n        if (prevToken && prevToken.type === \"Line\") {\r\n            return start;\r\n        }\r\n    }\r\n\r\n    // Detect spaces before the token.\r\n    while (ANY_SPACE.test(text[start - 1] || \"\")) {\r\n        start -= 1;\r\n    }\r\n\r\n    return start;\r\n}\r\n\r\n/**\r\n * Get the range of a given token and around whitespaces.\r\n * @param {Token} token The token to get range.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {number} The start of the range of the token and around whitespaces.\r\n */\r\nfunction getEndWithSpaces(token, sourceCode) {\r\n    const text = sourceCode.text;\r\n    let end = token.range[1];\r\n\r\n    // Detect spaces after the token.\r\n    while (ANY_SPACE.test(text[end] || \"\")) {\r\n        end += 1;\r\n    }\r\n\r\n    return end;\r\n}\r\n\r\n/**\r\n * Autofixes the Object.assign call to use an object spread instead.\r\n * @param {ASTNode|null} node The node that the rule warns on, i.e. the Object.assign call\r\n * @param {string} sourceCode sourceCode of the Object.assign call\r\n * @returns {Function} autofixer - replaces the Object.assign with a spread object.\r\n */\r\nfunction defineFixer(node, sourceCode) {\r\n    return function *(fixer) {\r\n        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);\r\n        const rightParen = sourceCode.getLastToken(node);\r\n\r\n        // Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.\r\n        yield fixer.removeRange([node.range[0], leftParen.range[0]]);\r\n\r\n        // Replace the parens of argument list to braces.\r\n        if (needsParens(node, sourceCode)) {\r\n            yield fixer.replaceText(leftParen, \"({\");\r\n            yield fixer.replaceText(rightParen, \"})\");\r\n        } else {\r\n            yield fixer.replaceText(leftParen, \"{\");\r\n            yield fixer.replaceText(rightParen, \"}\");\r\n        }\r\n\r\n        // Process arguments.\r\n        for (const argNode of node.arguments) {\r\n            const innerParens = getParenTokens(argNode, leftParen, sourceCode);\r\n            const left = innerParens.shift();\r\n            const right = innerParens.pop();\r\n\r\n            if (argNode.type === \"ObjectExpression\") {\r\n                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);\r\n                const maybeArgumentComma = sourceCode.getTokenAfter(right);\r\n\r\n                /*\r\n                 * Make bare this object literal.\r\n                 * And remove spaces inside of the braces for better formatting.\r\n                 */\r\n                for (const innerParen of innerParens) {\r\n                    yield fixer.remove(innerParen);\r\n                }\r\n                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];\r\n                const rightRange = [\r\n                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap\r\n                    right.range[1]\r\n                ];\r\n\r\n                yield fixer.removeRange(leftRange);\r\n                yield fixer.removeRange(rightRange);\r\n\r\n                // Remove the comma of this argument if it's duplication.\r\n                if (\r\n                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&\r\n                    isCommaToken(maybeArgumentComma)\r\n                ) {\r\n                    yield fixer.remove(maybeArgumentComma);\r\n                }\r\n            } else {\r\n\r\n                // Make spread.\r\n                if (argNeedsParens(argNode, sourceCode)) {\r\n                    yield fixer.insertTextBefore(left, \"...(\");\r\n                    yield fixer.insertTextAfter(right, \")\");\r\n                } else {\r\n                    yield fixer.insertTextBefore(left, \"...\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description:\r\n                \"disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-object-spread\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            useSpreadMessage: \"Use an object spread instead of `Object.assign` eg: `{ ...foo }`.\",\r\n            useLiteralMessage: \"Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        return {\r\n            Program() {\r\n                const scope = context.getScope();\r\n                const tracker = new ReferenceTracker(scope);\r\n                const trackMap = {\r\n                    Object: {\r\n                        assign: { [CALL]: true }\r\n                    }\r\n                };\r\n\r\n                // Iterate all calls of `Object.assign` (only of the global variable `Object`).\r\n                for (const { node } of tracker.iterateGlobalReferences(trackMap)) {\r\n                    if (\r\n                        node.arguments.length >= 1 &&\r\n                        node.arguments[0].type === \"ObjectExpression\" &&\r\n                        !hasArraySpread(node) &&\r\n                        !(\r\n                            node.arguments.length > 1 &&\r\n                            hasArgumentsWithAccessors(node)\r\n                        )\r\n                    ) {\r\n                        const messageId = node.arguments.length === 1\r\n                            ? \"useLiteralMessage\"\r\n                            : \"useSpreadMessage\";\r\n                        const fix = defineFixer(node, sourceCode);\r\n\r\n                        context.report({ node, messageId, fix });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}