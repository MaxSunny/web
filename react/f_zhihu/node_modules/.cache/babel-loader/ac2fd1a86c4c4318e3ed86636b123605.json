{"ast":null,"code":"/**\r\n * @fileoverview A class of the code path segment.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"./debug-helpers\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\n\nfunction isReachable(segment) {\n  return segment.reachable;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * A code path segment.\r\n */\n\n\nclass CodePathSegment {\n  /**\r\n   * @param {string} id An identifier.\r\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n   *   This array includes unreachable segments.\r\n   * @param {boolean} reachable A flag which shows this is reachable.\r\n   */\n  constructor(id, allPrevSegments, reachable) {\n    /**\r\n     * The identifier of this code path.\r\n     * Rules use it to store additional information of each rule.\r\n     * @type {string}\r\n     */\n    this.id = id;\n    /**\r\n     * An array of the next segments.\r\n     * @type {CodePathSegment[]}\r\n     */\n\n    this.nextSegments = [];\n    /**\r\n     * An array of the previous segments.\r\n     * @type {CodePathSegment[]}\r\n     */\n\n    this.prevSegments = allPrevSegments.filter(isReachable);\n    /**\r\n     * An array of the next segments.\r\n     * This array includes unreachable segments.\r\n     * @type {CodePathSegment[]}\r\n     */\n\n    this.allNextSegments = [];\n    /**\r\n     * An array of the previous segments.\r\n     * This array includes unreachable segments.\r\n     * @type {CodePathSegment[]}\r\n     */\n\n    this.allPrevSegments = allPrevSegments;\n    /**\r\n     * A flag which shows this is reachable.\r\n     * @type {boolean}\r\n     */\n\n    this.reachable = reachable; // Internal data.\n\n    Object.defineProperty(this, \"internal\", {\n      value: {\n        used: false,\n        loopedPrevSegments: []\n      }\n    });\n    /* istanbul ignore if */\n\n    if (debug.enabled) {\n      this.internal.nodes = [];\n    }\n  }\n  /**\r\n   * Checks a given previous segment is coming from the end of a loop.\r\n   * @param {CodePathSegment} segment A previous segment to check.\r\n   * @returns {boolean} `true` if the segment is coming from the end of a loop.\r\n   */\n\n\n  isLoopedPrevSegment(segment) {\n    return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n  }\n  /**\r\n   * Creates the root segment.\r\n   * @param {string} id An identifier.\r\n   * @returns {CodePathSegment} The created segment.\r\n   */\n\n\n  static newRoot(id) {\n    return new CodePathSegment(id, [], true);\n  }\n  /**\r\n   * Creates a segment that follows given segments.\r\n   * @param {string} id An identifier.\r\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n   * @returns {CodePathSegment} The created segment.\r\n   */\n\n\n  static newNext(id, allPrevSegments) {\n    return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));\n  }\n  /**\r\n   * Creates an unreachable segment that follows given segments.\r\n   * @param {string} id An identifier.\r\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n   * @returns {CodePathSegment} The created segment.\r\n   */\n\n\n  static newUnreachable(id, allPrevSegments) {\n    const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\n    /*\r\n     * In `if (a) return a; foo();` case, the unreachable segment preceded by\r\n     * the return statement is not used but must not be remove.\r\n     */\n\n    CodePathSegment.markUsed(segment);\n    return segment;\n  }\n  /**\r\n   * Creates a segment that follows given segments.\r\n   * This factory method does not connect with `allPrevSegments`.\r\n   * But this inherits `reachable` flag.\r\n   * @param {string} id An identifier.\r\n   * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n   * @returns {CodePathSegment} The created segment.\r\n   */\n\n\n  static newDisconnected(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n  }\n  /**\r\n   * Makes a given segment being used.\r\n   *\r\n   * And this function registers the segment into the previous segments as a next.\r\n   * @param {CodePathSegment} segment A segment to mark.\r\n   * @returns {void}\r\n   */\n\n\n  static markUsed(segment) {\n    if (segment.internal.used) {\n      return;\n    }\n\n    segment.internal.used = true;\n    let i;\n\n    if (segment.reachable) {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        const prevSegment = segment.allPrevSegments[i];\n        prevSegment.allNextSegments.push(segment);\n        prevSegment.nextSegments.push(segment);\n      }\n    } else {\n      for (i = 0; i < segment.allPrevSegments.length; ++i) {\n        segment.allPrevSegments[i].allNextSegments.push(segment);\n      }\n    }\n  }\n  /**\r\n   * Marks a previous segment as looped.\r\n   * @param {CodePathSegment} segment A segment.\r\n   * @param {CodePathSegment} prevSegment A previous segment to mark.\r\n   * @returns {void}\r\n   */\n\n\n  static markPrevSegmentAsLooped(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n  }\n  /**\r\n   * Replaces unused segments with the previous segments of each unused segment.\r\n   * @param {CodePathSegment[]} segments An array of segments to replace.\r\n   * @returns {CodePathSegment[]} The replaced array.\r\n   */\n\n\n  static flattenUnusedSegments(segments) {\n    const done = Object.create(null);\n    const retv = [];\n\n    for (let i = 0; i < segments.length; ++i) {\n      const segment = segments[i]; // Ignores duplicated.\n\n      if (done[segment.id]) {\n        continue;\n      } // Use previous segments if unused.\n\n\n      if (!segment.internal.used) {\n        for (let j = 0; j < segment.allPrevSegments.length; ++j) {\n          const prevSegment = segment.allPrevSegments[j];\n\n          if (!done[prevSegment.id]) {\n            done[prevSegment.id] = true;\n            retv.push(prevSegment);\n          }\n        }\n      } else {\n        done[segment.id] = true;\n        retv.push(segment);\n      }\n    }\n\n    return retv;\n  }\n\n}\n\nmodule.exports = CodePathSegment;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js"],"names":["debug","require","isReachable","segment","reachable","CodePathSegment","constructor","id","allPrevSegments","nextSegments","prevSegments","filter","allNextSegments","Object","defineProperty","value","used","loopedPrevSegments","enabled","internal","nodes","isLoopedPrevSegment","indexOf","newRoot","newNext","flattenUnusedSegments","some","newUnreachable","markUsed","newDisconnected","i","length","prevSegment","push","markPrevSegmentAsLooped","segments","done","create","retv","j","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A class of the code path segment.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst debug = require(\"./debug-helpers\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * A code path segment.\r\n */\r\nclass CodePathSegment {\r\n\r\n    /**\r\n     * @param {string} id An identifier.\r\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n     *   This array includes unreachable segments.\r\n     * @param {boolean} reachable A flag which shows this is reachable.\r\n     */\r\n    constructor(id, allPrevSegments, reachable) {\r\n\r\n        /**\r\n         * The identifier of this code path.\r\n         * Rules use it to store additional information of each rule.\r\n         * @type {string}\r\n         */\r\n        this.id = id;\r\n\r\n        /**\r\n         * An array of the next segments.\r\n         * @type {CodePathSegment[]}\r\n         */\r\n        this.nextSegments = [];\r\n\r\n        /**\r\n         * An array of the previous segments.\r\n         * @type {CodePathSegment[]}\r\n         */\r\n        this.prevSegments = allPrevSegments.filter(isReachable);\r\n\r\n        /**\r\n         * An array of the next segments.\r\n         * This array includes unreachable segments.\r\n         * @type {CodePathSegment[]}\r\n         */\r\n        this.allNextSegments = [];\r\n\r\n        /**\r\n         * An array of the previous segments.\r\n         * This array includes unreachable segments.\r\n         * @type {CodePathSegment[]}\r\n         */\r\n        this.allPrevSegments = allPrevSegments;\r\n\r\n        /**\r\n         * A flag which shows this is reachable.\r\n         * @type {boolean}\r\n         */\r\n        this.reachable = reachable;\r\n\r\n        // Internal data.\r\n        Object.defineProperty(this, \"internal\", {\r\n            value: {\r\n                used: false,\r\n                loopedPrevSegments: []\r\n            }\r\n        });\r\n\r\n        /* istanbul ignore if */\r\n        if (debug.enabled) {\r\n            this.internal.nodes = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks a given previous segment is coming from the end of a loop.\r\n     * @param {CodePathSegment} segment A previous segment to check.\r\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\r\n     */\r\n    isLoopedPrevSegment(segment) {\r\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Creates the root segment.\r\n     * @param {string} id An identifier.\r\n     * @returns {CodePathSegment} The created segment.\r\n     */\r\n    static newRoot(id) {\r\n        return new CodePathSegment(id, [], true);\r\n    }\r\n\r\n    /**\r\n     * Creates a segment that follows given segments.\r\n     * @param {string} id An identifier.\r\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n     * @returns {CodePathSegment} The created segment.\r\n     */\r\n    static newNext(id, allPrevSegments) {\r\n        return new CodePathSegment(\r\n            id,\r\n            CodePathSegment.flattenUnusedSegments(allPrevSegments),\r\n            allPrevSegments.some(isReachable)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates an unreachable segment that follows given segments.\r\n     * @param {string} id An identifier.\r\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n     * @returns {CodePathSegment} The created segment.\r\n     */\r\n    static newUnreachable(id, allPrevSegments) {\r\n        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);\r\n\r\n        /*\r\n         * In `if (a) return a; foo();` case, the unreachable segment preceded by\r\n         * the return statement is not used but must not be remove.\r\n         */\r\n        CodePathSegment.markUsed(segment);\r\n\r\n        return segment;\r\n    }\r\n\r\n    /**\r\n     * Creates a segment that follows given segments.\r\n     * This factory method does not connect with `allPrevSegments`.\r\n     * But this inherits `reachable` flag.\r\n     * @param {string} id An identifier.\r\n     * @param {CodePathSegment[]} allPrevSegments An array of the previous segments.\r\n     * @returns {CodePathSegment} The created segment.\r\n     */\r\n    static newDisconnected(id, allPrevSegments) {\r\n        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\r\n    }\r\n\r\n    /**\r\n     * Makes a given segment being used.\r\n     *\r\n     * And this function registers the segment into the previous segments as a next.\r\n     * @param {CodePathSegment} segment A segment to mark.\r\n     * @returns {void}\r\n     */\r\n    static markUsed(segment) {\r\n        if (segment.internal.used) {\r\n            return;\r\n        }\r\n        segment.internal.used = true;\r\n\r\n        let i;\r\n\r\n        if (segment.reachable) {\r\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\r\n                const prevSegment = segment.allPrevSegments[i];\r\n\r\n                prevSegment.allNextSegments.push(segment);\r\n                prevSegment.nextSegments.push(segment);\r\n            }\r\n        } else {\r\n            for (i = 0; i < segment.allPrevSegments.length; ++i) {\r\n                segment.allPrevSegments[i].allNextSegments.push(segment);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Marks a previous segment as looped.\r\n     * @param {CodePathSegment} segment A segment.\r\n     * @param {CodePathSegment} prevSegment A previous segment to mark.\r\n     * @returns {void}\r\n     */\r\n    static markPrevSegmentAsLooped(segment, prevSegment) {\r\n        segment.internal.loopedPrevSegments.push(prevSegment);\r\n    }\r\n\r\n    /**\r\n     * Replaces unused segments with the previous segments of each unused segment.\r\n     * @param {CodePathSegment[]} segments An array of segments to replace.\r\n     * @returns {CodePathSegment[]} The replaced array.\r\n     */\r\n    static flattenUnusedSegments(segments) {\r\n        const done = Object.create(null);\r\n        const retv = [];\r\n\r\n        for (let i = 0; i < segments.length; ++i) {\r\n            const segment = segments[i];\r\n\r\n            // Ignores duplicated.\r\n            if (done[segment.id]) {\r\n                continue;\r\n            }\r\n\r\n            // Use previous segments if unused.\r\n            if (!segment.internal.used) {\r\n                for (let j = 0; j < segment.allPrevSegments.length; ++j) {\r\n                    const prevSegment = segment.allPrevSegments[j];\r\n\r\n                    if (!done[prevSegment.id]) {\r\n                        done[prevSegment.id] = true;\r\n                        retv.push(prevSegment);\r\n                    }\r\n                }\r\n            } else {\r\n                done[segment.id] = true;\r\n                retv.push(segment);\r\n            }\r\n        }\r\n\r\n        return retv;\r\n    }\r\n}\r\n\r\nmodule.exports = CodePathSegment;\r\n"]},"metadata":{},"sourceType":"script"}