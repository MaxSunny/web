{"ast":null,"code":"/**\r\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\r\n * @author Josh Perez\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u; // `null` literal must be handled separately.\n\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce dot notation whenever possible\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/dot-notation\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowKeywords: {\n          type: \"boolean\",\n          default: true\n        },\n        allowPattern: {\n          type: \"string\",\n          default: \"\"\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      useDot: \"[{{key}}] is better written in dot notation.\",\n      useBrackets: \".{{key}} is a syntax error.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\n    const sourceCode = context.getSourceCode();\n    let allowPattern;\n\n    if (options.allowPattern) {\n      allowPattern = new RegExp(options.allowPattern, \"u\");\n    }\n    /**\r\n     * Check if the property is valid dot notation\r\n     * @param {ASTNode} node The dot notation node\r\n     * @param {string} value Value which is to be checked\r\n     * @returns {void}\r\n     */\n\n\n    function checkComputedProperty(node, value) {\n      if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {\n        const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\n        context.report({\n          node: node.property,\n          messageId: \"useDot\",\n          data: {\n            key: formattedValue\n          },\n\n          *fix(fixer) {\n            const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\n            const rightBracket = sourceCode.getLastToken(node);\n            const nextToken = sourceCode.getTokenAfter(node); // Don't perform any fixes if there are comments inside the brackets.\n\n            if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\n              return;\n            } // Replace the brackets by an identifier.\n\n\n            if (!node.optional) {\n              yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? \" .\" : \".\");\n            }\n\n            yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value); // Insert a space after the property if it will be connected to the next token.\n\n            if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {\n              yield fixer.insertTextAfter(node, \" \");\n            }\n          }\n\n        });\n      }\n    }\n\n    return {\n      MemberExpression(node) {\n        if (node.computed && node.property.type === \"Literal\" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {\n          checkComputedProperty(node, node.property.value);\n        }\n\n        if (node.computed && node.property.type === \"TemplateLiteral\" && node.property.expressions.length === 0) {\n          checkComputedProperty(node, node.property.quasis[0].value.cooked);\n        }\n\n        if (!allowKeywords && !node.computed && node.property.type === \"Identifier\" && keywords.indexOf(String(node.property.name)) !== -1) {\n          context.report({\n            node: node.property,\n            messageId: \"useBrackets\",\n            data: {\n              key: node.property.name\n            },\n\n            *fix(fixer) {\n              const dotToken = sourceCode.getTokenBefore(node.property); // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\n\n              if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\n                return;\n              } // Don't perform any fixes if there are comments between the dot and the property name.\n\n\n              if (sourceCode.commentsExistBetween(dotToken, node.property)) {\n                return;\n              } // Replace the identifier to brackets.\n\n\n              if (!node.optional) {\n                yield fixer.remove(dotToken);\n              }\n\n              yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/dot-notation.js"],"names":["astUtils","require","keywords","validIdentifier","literalTypesToCheck","Set","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowKeywords","default","allowPattern","additionalProperties","fixable","messages","useDot","useBrackets","create","context","options","sourceCode","getSourceCode","RegExp","checkComputedProperty","node","value","test","indexOf","String","formattedValue","property","JSON","stringify","report","messageId","data","key","fix","fixer","leftBracket","getTokenAfter","object","isOpeningBracketToken","rightBracket","getLastToken","nextToken","commentsExistBetween","optional","insertTextBefore","isDecimalInteger","replaceTextRange","range","canTokensBeAdjacent","insertTextAfter","MemberExpression","computed","has","isNullLiteral","expressions","length","quasis","cooked","name","dotToken","getTokenBefore","remove","replaceText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.\r\n * @author Josh Perez\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst keywords = require(\"./utils/keywords\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;\r\n\r\n// `null` literal must be handled separately.\r\nconst literalTypesToCheck = new Set([\"string\", \"boolean\"]);\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce dot notation whenever possible\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/dot-notation\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowKeywords: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    allowPattern: {\r\n                        type: \"string\",\r\n                        default: \"\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            useDot: \"[{{key}}] is better written in dot notation.\",\r\n            useBrackets: \".{{key}} is a syntax error.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        let allowPattern;\r\n\r\n        if (options.allowPattern) {\r\n            allowPattern = new RegExp(options.allowPattern, \"u\");\r\n        }\r\n\r\n        /**\r\n         * Check if the property is valid dot notation\r\n         * @param {ASTNode} node The dot notation node\r\n         * @param {string} value Value which is to be checked\r\n         * @returns {void}\r\n         */\r\n        function checkComputedProperty(node, value) {\r\n            if (\r\n                validIdentifier.test(value) &&\r\n                (allowKeywords || keywords.indexOf(String(value)) === -1) &&\r\n                !(allowPattern && allowPattern.test(value))\r\n            ) {\r\n                const formattedValue = node.property.type === \"Literal\" ? JSON.stringify(value) : `\\`${value}\\``;\r\n\r\n                context.report({\r\n                    node: node.property,\r\n                    messageId: \"useDot\",\r\n                    data: {\r\n                        key: formattedValue\r\n                    },\r\n                    *fix(fixer) {\r\n                        const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);\r\n                        const rightBracket = sourceCode.getLastToken(node);\r\n                        const nextToken = sourceCode.getTokenAfter(node);\r\n\r\n                        // Don't perform any fixes if there are comments inside the brackets.\r\n                        if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {\r\n                            return;\r\n                        }\r\n\r\n                        // Replace the brackets by an identifier.\r\n                        if (!node.optional) {\r\n                            yield fixer.insertTextBefore(\r\n                                leftBracket,\r\n                                astUtils.isDecimalInteger(node.object) ? \" .\" : \".\"\r\n                            );\r\n                        }\r\n                        yield fixer.replaceTextRange(\r\n                            [leftBracket.range[0], rightBracket.range[1]],\r\n                            value\r\n                        );\r\n\r\n                        // Insert a space after the property if it will be connected to the next token.\r\n                        if (\r\n                            nextToken &&\r\n                            rightBracket.range[1] === nextToken.range[0] &&\r\n                            !astUtils.canTokensBeAdjacent(String(value), nextToken)\r\n                        ) {\r\n                            yield fixer.insertTextAfter(node, \" \");\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            MemberExpression(node) {\r\n                if (\r\n                    node.computed &&\r\n                    node.property.type === \"Literal\" &&\r\n                    (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))\r\n                ) {\r\n                    checkComputedProperty(node, node.property.value);\r\n                }\r\n                if (\r\n                    node.computed &&\r\n                    node.property.type === \"TemplateLiteral\" &&\r\n                    node.property.expressions.length === 0\r\n                ) {\r\n                    checkComputedProperty(node, node.property.quasis[0].value.cooked);\r\n                }\r\n                if (\r\n                    !allowKeywords &&\r\n                    !node.computed &&\r\n                    node.property.type === \"Identifier\" &&\r\n                    keywords.indexOf(String(node.property.name)) !== -1\r\n                ) {\r\n                    context.report({\r\n                        node: node.property,\r\n                        messageId: \"useBrackets\",\r\n                        data: {\r\n                            key: node.property.name\r\n                        },\r\n                        *fix(fixer) {\r\n                            const dotToken = sourceCode.getTokenBefore(node.property);\r\n\r\n                            // A statement that starts with `let[` is parsed as a destructuring variable declaration, not a MemberExpression.\r\n                            if (node.object.type === \"Identifier\" && node.object.name === \"let\" && !node.optional) {\r\n                                return;\r\n                            }\r\n\r\n                            // Don't perform any fixes if there are comments between the dot and the property name.\r\n                            if (sourceCode.commentsExistBetween(dotToken, node.property)) {\r\n                                return;\r\n                            }\r\n\r\n                            // Replace the identifier to brackets.\r\n                            if (!node.optional) {\r\n                                yield fixer.remove(dotToken);\r\n                            }\r\n                            yield fixer.replaceText(node.property, `[\"${node.property.name}\"]`);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}