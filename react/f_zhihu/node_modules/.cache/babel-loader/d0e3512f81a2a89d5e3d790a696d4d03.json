{"ast":null,"code":"/**\r\n * @fileoverview Enforces that a return statement is present in property getters.\r\n * @author Aladdin-ADD(hh_2013@foxmail.com)\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\n/**\r\n * Checks a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce `return` statements in getters\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/getter-return\"\n    },\n    fixable: null,\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowImplicit: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected to return a value in {{name}}.\",\n      expectedAlways: \"Expected {{name}} to always return a value.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      allowImplicit: false\n    };\n    const sourceCode = context.getSourceCode();\n    let funcInfo = {\n      upper: null,\n      codePath: null,\n      hasReturn: false,\n      shouldCheck: false,\n      node: null\n    };\n    /**\r\n     * Checks whether or not the last code path segment is reachable.\r\n     * Then reports this function if the segment is reachable.\r\n     *\r\n     * If the last code path segment is reachable, there are paths which are not\r\n     * returned or thrown.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {void}\r\n     */\n\n    function checkLastSegment(node) {\n      if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {\n        context.report({\n          node,\n          loc: astUtils.getFunctionHeadLoc(node, sourceCode),\n          messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\n          data: {\n            name: astUtils.getFunctionNameWithKind(funcInfo.node)\n          }\n        });\n      }\n    }\n    /**\r\n     * Checks whether a node means a getter function.\r\n     * @param {ASTNode} node a node to check.\r\n     * @returns {boolean} if node means a getter, return true; else return false.\r\n     */\n\n\n    function isGetter(node) {\n      const parent = node.parent;\n\n      if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\n        if (parent.kind === \"get\") {\n          return true;\n        }\n\n        if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\n          // Object.defineProperty()\n          if (parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\n            return true;\n          } // Object.defineProperties()\n\n\n          if (parent.parent.parent.type === \"Property\" && parent.parent.parent.parent.type === \"ObjectExpression\" && parent.parent.parent.parent.parent.type === \"CallExpression\" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    }\n\n    return {\n      // Stacks this function's information.\n      onCodePathStart(codePath, node) {\n        funcInfo = {\n          upper: funcInfo,\n          codePath,\n          hasReturn: false,\n          shouldCheck: isGetter(node),\n          node\n        };\n      },\n\n      // Pops this function's information.\n      onCodePathEnd() {\n        funcInfo = funcInfo.upper;\n      },\n\n      // Checks the return statement is valid.\n      ReturnStatement(node) {\n        if (funcInfo.shouldCheck) {\n          funcInfo.hasReturn = true; // if allowImplicit: false, should also check node.argument\n\n          if (!options.allowImplicit && !node.argument) {\n            context.report({\n              node,\n              messageId: \"expected\",\n              data: {\n                name: astUtils.getFunctionNameWithKind(funcInfo.node)\n              }\n            });\n          }\n        }\n      },\n\n      // Reports a given function if the last path is reachable.\n      \"FunctionExpression:exit\": checkLastSegment,\n      \"ArrowFunctionExpression:exit\": checkLastSegment\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/getter-return.js"],"names":["astUtils","require","TARGET_NODE_TYPE","isReachable","segment","reachable","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","allowImplicit","default","additionalProperties","messages","expected","expectedAlways","create","context","options","sourceCode","getSourceCode","funcInfo","upper","codePath","hasReturn","shouldCheck","node","checkLastSegment","currentSegments","some","report","loc","getFunctionHeadLoc","messageId","data","name","getFunctionNameWithKind","isGetter","parent","test","body","kind","getStaticPropertyName","callee","onCodePathStart","onCodePathEnd","ReturnStatement","argument"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Enforces that a return statement is present in property getters.\r\n * @author Aladdin-ADD(hh_2013@foxmail.com)\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\nconst TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;\r\n\r\n/**\r\n * Checks a given code path segment is reachable.\r\n * @param {CodePathSegment} segment A segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"enforce `return` statements in getters\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/getter-return\"\r\n        },\r\n\r\n        fixable: null,\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowImplicit: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            expected: \"Expected to return a value in {{name}}.\",\r\n            expectedAlways: \"Expected {{name}} to always return a value.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0] || { allowImplicit: false };\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        let funcInfo = {\r\n            upper: null,\r\n            codePath: null,\r\n            hasReturn: false,\r\n            shouldCheck: false,\r\n            node: null\r\n        };\r\n\r\n        /**\r\n         * Checks whether or not the last code path segment is reachable.\r\n         * Then reports this function if the segment is reachable.\r\n         *\r\n         * If the last code path segment is reachable, there are paths which are not\r\n         * returned or thrown.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkLastSegment(node) {\r\n            if (funcInfo.shouldCheck &&\r\n                funcInfo.codePath.currentSegments.some(isReachable)\r\n            ) {\r\n                context.report({\r\n                    node,\r\n                    loc: astUtils.getFunctionHeadLoc(node, sourceCode),\r\n                    messageId: funcInfo.hasReturn ? \"expectedAlways\" : \"expected\",\r\n                    data: {\r\n                        name: astUtils.getFunctionNameWithKind(funcInfo.node)\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether a node means a getter function.\r\n         * @param {ASTNode} node a node to check.\r\n         * @returns {boolean} if node means a getter, return true; else return false.\r\n         */\r\n        function isGetter(node) {\r\n            const parent = node.parent;\r\n\r\n            if (TARGET_NODE_TYPE.test(node.type) && node.body.type === \"BlockStatement\") {\r\n                if (parent.kind === \"get\") {\r\n                    return true;\r\n                }\r\n                if (parent.type === \"Property\" && astUtils.getStaticPropertyName(parent) === \"get\" && parent.parent.type === \"ObjectExpression\") {\r\n\r\n                    // Object.defineProperty()\r\n                    if (parent.parent.parent.type === \"CallExpression\" &&\r\n                        astUtils.getStaticPropertyName(parent.parent.parent.callee) === \"defineProperty\") {\r\n                        return true;\r\n                    }\r\n\r\n                    // Object.defineProperties()\r\n                    if (parent.parent.parent.type === \"Property\" &&\r\n                        parent.parent.parent.parent.type === \"ObjectExpression\" &&\r\n                        parent.parent.parent.parent.parent.type === \"CallExpression\" &&\r\n                        astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === \"defineProperties\") {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        return {\r\n\r\n            // Stacks this function's information.\r\n            onCodePathStart(codePath, node) {\r\n                funcInfo = {\r\n                    upper: funcInfo,\r\n                    codePath,\r\n                    hasReturn: false,\r\n                    shouldCheck: isGetter(node),\r\n                    node\r\n                };\r\n            },\r\n\r\n            // Pops this function's information.\r\n            onCodePathEnd() {\r\n                funcInfo = funcInfo.upper;\r\n            },\r\n\r\n            // Checks the return statement is valid.\r\n            ReturnStatement(node) {\r\n                if (funcInfo.shouldCheck) {\r\n                    funcInfo.hasReturn = true;\r\n\r\n                    // if allowImplicit: false, should also check node.argument\r\n                    if (!options.allowImplicit && !node.argument) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"expected\",\r\n                            data: {\r\n                                name: astUtils.getFunctionNameWithKind(funcInfo.node)\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            },\r\n\r\n            // Reports a given function if the last path is reachable.\r\n            \"FunctionExpression:exit\": checkLastSegment,\r\n            \"ArrowFunctionExpression:exit\": checkLastSegment\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}