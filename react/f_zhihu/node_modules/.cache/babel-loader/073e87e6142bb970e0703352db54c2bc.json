{"ast":null,"code":"/**\r\n * @fileoverview Rule to require sorting of import declarations\r\n * @author Christian Schuller\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce sorted import declarations within modules\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/sort-imports\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreCase: {\n          type: \"boolean\",\n          default: false\n        },\n        memberSyntaxSortOrder: {\n          type: \"array\",\n          items: {\n            enum: [\"none\", \"all\", \"multiple\", \"single\"]\n          },\n          uniqueItems: true,\n          minItems: 4,\n          maxItems: 4\n        },\n        ignoreDeclarationSort: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreMemberSort: {\n          type: \"boolean\",\n          default: false\n        },\n        allowSeparatedGroups: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\n      sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\n      unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\n    }\n  },\n\n  create(context) {\n    const configuration = context.options[0] || {},\n          ignoreCase = configuration.ignoreCase || false,\n          ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\n          ignoreMemberSort = configuration.ignoreMemberSort || false,\n          memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\n          allowSeparatedGroups = configuration.allowSeparatedGroups || false,\n          sourceCode = context.getSourceCode();\n    let previousDeclaration = null;\n    /**\r\n     * Gets the used member syntax style.\r\n     *\r\n     * import \"my-module.js\" --> none\r\n     * import * as myModule from \"my-module.js\" --> all\r\n     * import {myMember} from \"my-module.js\" --> single\r\n     * import {foo, bar} from  \"my-module.js\" --> multiple\r\n     * @param {ASTNode} node the ImportDeclaration node.\r\n     * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\r\n     */\n\n    function usedMemberSyntax(node) {\n      if (node.specifiers.length === 0) {\n        return \"none\";\n      }\n\n      if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\n        return \"all\";\n      }\n\n      if (node.specifiers.length === 1) {\n        return \"single\";\n      }\n\n      return \"multiple\";\n    }\n    /**\r\n     * Gets the group by member parameter index for given declaration.\r\n     * @param {ASTNode} node the ImportDeclaration node.\r\n     * @returns {number} the declaration group by member index.\r\n     */\n\n\n    function getMemberParameterGroupIndex(node) {\n      return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\n    }\n    /**\r\n     * Gets the local name of the first imported module.\r\n     * @param {ASTNode} node the ImportDeclaration node.\r\n     * @returns {?string} the local name of the first imported module.\r\n     */\n\n\n    function getFirstLocalMemberName(node) {\n      if (node.specifiers[0]) {\n        return node.specifiers[0].local.name;\n      }\n\n      return null;\n    }\n    /**\r\n     * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\r\n     * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\r\n     * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\r\n     * on two consecutive lines.\r\n     * @param {ASTNode} left node that appears before the given `right` node.\r\n     * @param {ASTNode} right node that appears after the given `left` node.\r\n     * @returns {number} number of lines between nodes.\r\n     */\n\n\n    function getNumberOfLinesBetween(left, right) {\n      return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\n    }\n\n    return {\n      ImportDeclaration(node) {\n        if (!ignoreDeclarationSort) {\n          if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {\n            // reset declaration sort\n            previousDeclaration = null;\n          }\n\n          if (previousDeclaration) {\n            const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\n                  previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\n            let currentLocalMemberName = getFirstLocalMemberName(node),\n                previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\n\n            if (ignoreCase) {\n              previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\n              currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\n            }\n            /*\r\n             * When the current declaration uses a different member syntax,\r\n             * then check if the ordering is correct.\r\n             * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\r\n             */\n\n\n            if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\n              if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\n                context.report({\n                  node,\n                  messageId: \"unexpectedSyntaxOrder\",\n                  data: {\n                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\n                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\n                  }\n                });\n              }\n            } else {\n              if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {\n                context.report({\n                  node,\n                  messageId: \"sortImportsAlphabetically\"\n                });\n              }\n            }\n          }\n\n          previousDeclaration = node;\n        }\n\n        if (!ignoreMemberSort) {\n          const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\n          const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\n          const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\n\n          if (firstUnsortedIndex !== -1) {\n            context.report({\n              node: importSpecifiers[firstUnsortedIndex],\n              messageId: \"sortMembersAlphabetically\",\n              data: {\n                memberName: importSpecifiers[firstUnsortedIndex].local.name\n              },\n\n              fix(fixer) {\n                if (importSpecifiers.some(specifier => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\n                  // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\n                  return null;\n                }\n\n                return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers // Clone the importSpecifiers array to avoid mutating it\n                .slice() // Sort the array into the desired order\n                .sort((specifierA, specifierB) => {\n                  const aName = getSortableName(specifierA);\n                  const bName = getSortableName(specifierB);\n                  return aName > bName ? 1 : -1;\n                }) // Build a string out of the sorted list of import specifiers and the text between the originals\n                .reduce((sourceText, specifier, index) => {\n                  const textAfterSpecifier = index === importSpecifiers.length - 1 ? \"\" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\n                  return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\n                }, \"\"));\n              }\n\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/sort-imports.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","ignoreCase","default","memberSyntaxSortOrder","items","enum","uniqueItems","minItems","maxItems","ignoreDeclarationSort","ignoreMemberSort","allowSeparatedGroups","additionalProperties","fixable","messages","sortImportsAlphabetically","sortMembersAlphabetically","unexpectedSyntaxOrder","create","context","configuration","options","sourceCode","getSourceCode","previousDeclaration","usedMemberSyntax","node","specifiers","length","getMemberParameterGroupIndex","indexOf","getFirstLocalMemberName","local","name","getNumberOfLinesBetween","left","right","Math","max","loc","start","line","end","ImportDeclaration","currentMemberSyntaxGroupIndex","previousMemberSyntaxGroupIndex","currentLocalMemberName","previousLocalMemberName","toLowerCase","report","messageId","data","syntaxA","syntaxB","importSpecifiers","filter","specifier","getSortableName","firstUnsortedIndex","map","findIndex","index","array","memberName","fix","fixer","some","getCommentsBefore","getCommentsAfter","replaceTextRange","range","slice","sort","specifierA","specifierB","aName","bName","reduce","sourceText","textAfterSpecifier","getText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require sorting of import declarations\r\n * @author Christian Schuller\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce sorted import declarations within modules\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/sort-imports\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignoreCase: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    memberSyntaxSortOrder: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            enum: [\"none\", \"all\", \"multiple\", \"single\"]\r\n                        },\r\n                        uniqueItems: true,\r\n                        minItems: 4,\r\n                        maxItems: 4\r\n                    },\r\n                    ignoreDeclarationSort: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    ignoreMemberSort: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowSeparatedGroups: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            sortImportsAlphabetically: \"Imports should be sorted alphabetically.\",\r\n            sortMembersAlphabetically: \"Member '{{memberName}}' of the import declaration should be sorted alphabetically.\",\r\n            unexpectedSyntaxOrder: \"Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const configuration = context.options[0] || {},\r\n            ignoreCase = configuration.ignoreCase || false,\r\n            ignoreDeclarationSort = configuration.ignoreDeclarationSort || false,\r\n            ignoreMemberSort = configuration.ignoreMemberSort || false,\r\n            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || [\"none\", \"all\", \"multiple\", \"single\"],\r\n            allowSeparatedGroups = configuration.allowSeparatedGroups || false,\r\n            sourceCode = context.getSourceCode();\r\n        let previousDeclaration = null;\r\n\r\n        /**\r\n         * Gets the used member syntax style.\r\n         *\r\n         * import \"my-module.js\" --> none\r\n         * import * as myModule from \"my-module.js\" --> all\r\n         * import {myMember} from \"my-module.js\" --> single\r\n         * import {foo, bar} from  \"my-module.js\" --> multiple\r\n         * @param {ASTNode} node the ImportDeclaration node.\r\n         * @returns {string} used member parameter style, [\"all\", \"multiple\", \"single\"]\r\n         */\r\n        function usedMemberSyntax(node) {\r\n            if (node.specifiers.length === 0) {\r\n                return \"none\";\r\n            }\r\n            if (node.specifiers[0].type === \"ImportNamespaceSpecifier\") {\r\n                return \"all\";\r\n            }\r\n            if (node.specifiers.length === 1) {\r\n                return \"single\";\r\n            }\r\n            return \"multiple\";\r\n\r\n        }\r\n\r\n        /**\r\n         * Gets the group by member parameter index for given declaration.\r\n         * @param {ASTNode} node the ImportDeclaration node.\r\n         * @returns {number} the declaration group by member index.\r\n         */\r\n        function getMemberParameterGroupIndex(node) {\r\n            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));\r\n        }\r\n\r\n        /**\r\n         * Gets the local name of the first imported module.\r\n         * @param {ASTNode} node the ImportDeclaration node.\r\n         * @returns {?string} the local name of the first imported module.\r\n         */\r\n        function getFirstLocalMemberName(node) {\r\n            if (node.specifiers[0]) {\r\n                return node.specifiers[0].local.name;\r\n            }\r\n            return null;\r\n\r\n        }\r\n\r\n        /**\r\n         * Calculates number of lines between two nodes. It is assumed that the given `left` node appears before\r\n         * the given `right` node in the source code. Lines are counted from the end of the `left` node till the\r\n         * start of the `right` node. If the given nodes are on the same line, it returns `0`, same as if they were\r\n         * on two consecutive lines.\r\n         * @param {ASTNode} left node that appears before the given `right` node.\r\n         * @param {ASTNode} right node that appears after the given `left` node.\r\n         * @returns {number} number of lines between nodes.\r\n         */\r\n        function getNumberOfLinesBetween(left, right) {\r\n            return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);\r\n        }\r\n\r\n        return {\r\n            ImportDeclaration(node) {\r\n                if (!ignoreDeclarationSort) {\r\n                    if (\r\n                        previousDeclaration &&\r\n                        allowSeparatedGroups &&\r\n                        getNumberOfLinesBetween(previousDeclaration, node) > 0\r\n                    ) {\r\n\r\n                        // reset declaration sort\r\n                        previousDeclaration = null;\r\n                    }\r\n\r\n                    if (previousDeclaration) {\r\n                        const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),\r\n                            previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);\r\n                        let currentLocalMemberName = getFirstLocalMemberName(node),\r\n                            previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);\r\n\r\n                        if (ignoreCase) {\r\n                            previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();\r\n                            currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();\r\n                        }\r\n\r\n                        /*\r\n                         * When the current declaration uses a different member syntax,\r\n                         * then check if the ordering is correct.\r\n                         * Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.\r\n                         */\r\n                        if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {\r\n                            if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {\r\n                                context.report({\r\n                                    node,\r\n                                    messageId: \"unexpectedSyntaxOrder\",\r\n                                    data: {\r\n                                        syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],\r\n                                        syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]\r\n                                    }\r\n                                });\r\n                            }\r\n                        } else {\r\n                            if (previousLocalMemberName &&\r\n                                currentLocalMemberName &&\r\n                                currentLocalMemberName < previousLocalMemberName\r\n                            ) {\r\n                                context.report({\r\n                                    node,\r\n                                    messageId: \"sortImportsAlphabetically\"\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    previousDeclaration = node;\r\n                }\r\n\r\n                if (!ignoreMemberSort) {\r\n                    const importSpecifiers = node.specifiers.filter(specifier => specifier.type === \"ImportSpecifier\");\r\n                    const getSortableName = ignoreCase ? specifier => specifier.local.name.toLowerCase() : specifier => specifier.local.name;\r\n                    const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);\r\n\r\n                    if (firstUnsortedIndex !== -1) {\r\n                        context.report({\r\n                            node: importSpecifiers[firstUnsortedIndex],\r\n                            messageId: \"sortMembersAlphabetically\",\r\n                            data: { memberName: importSpecifiers[firstUnsortedIndex].local.name },\r\n                            fix(fixer) {\r\n                                if (importSpecifiers.some(specifier =>\r\n                                    sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {\r\n\r\n                                    // If there are comments in the ImportSpecifier list, don't rearrange the specifiers.\r\n                                    return null;\r\n                                }\r\n\r\n                                return fixer.replaceTextRange(\r\n                                    [importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]],\r\n                                    importSpecifiers\r\n\r\n                                        // Clone the importSpecifiers array to avoid mutating it\r\n                                        .slice()\r\n\r\n                                        // Sort the array into the desired order\r\n                                        .sort((specifierA, specifierB) => {\r\n                                            const aName = getSortableName(specifierA);\r\n                                            const bName = getSortableName(specifierB);\r\n\r\n                                            return aName > bName ? 1 : -1;\r\n                                        })\r\n\r\n                                        // Build a string out of the sorted list of import specifiers and the text between the originals\r\n                                        .reduce((sourceText, specifier, index) => {\r\n                                            const textAfterSpecifier = index === importSpecifiers.length - 1\r\n                                                ? \"\"\r\n                                                : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);\r\n\r\n                                            return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;\r\n                                        }, \"\")\r\n                                );\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}