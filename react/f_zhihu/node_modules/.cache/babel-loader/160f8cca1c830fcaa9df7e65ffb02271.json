{"ast":null,"code":"/**\r\n * @fileoverview `FileEnumerator` class.\r\n *\r\n * `FileEnumerator` class has two responsibilities:\r\n *\r\n * 1. Find target files by processing glob patterns.\r\n * 2. Tie each target file and appropriate configuration.\r\n *\r\n * It provides a method:\r\n *\r\n * - `iterateFiles(patterns)`\r\n *     Iterate files which are matched by given patterns together with the\r\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\r\n *     While iterating files, it loads the configuration file of each directory\r\n *     before iterate files on the directory, so we can use the configuration\r\n *     files to determine target files.\r\n *\r\n * @example\r\n * const enumerator = new FileEnumerator();\r\n * const linter = new Linter();\r\n *\r\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\r\n *     const code = fs.readFileSync(filePath, \"utf8\");\r\n *     const messages = linter.verify(code, config, filePath);\r\n *\r\n *     console.log(messages);\r\n * }\r\n *\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst getGlobParent = require(\"glob-parent\");\n\nconst isGlob = require(\"is-glob\");\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst {\n  Minimatch\n} = require(\"minimatch\");\n\nconst {\n  Legacy: {\n    IgnorePattern,\n    CascadingConfigArrayFactory\n  }\n} = require(\"@eslint/eslintrc\");\n\nconst debug = require(\"debug\")(\"eslint:file-enumerator\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst minimatchOpts = {\n  dot: true,\n  matchBase: true\n};\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\nconst NONE = 0;\nconst IGNORED_SILENTLY = 1;\nconst IGNORED = 2; // For VSCode intellisense\n\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\n\n/**\r\n * @typedef {Object} FileEnumeratorOptions\r\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\r\n * @property {string} [cwd] The base directory to start lookup.\r\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} [ignore] The flag to check ignored files.\r\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\r\n */\n\n/**\r\n * @typedef {Object} FileAndConfig\r\n * @property {string} filePath The path to a target file.\r\n * @property {ConfigArray} config The config entries of that file.\r\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\r\n */\n\n/**\r\n * @typedef {Object} FileEntry\r\n * @property {string} filePath The path to a target file.\r\n * @property {ConfigArray} config The config entries of that file.\r\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\r\n * - `NONE` means the file is a target file.\r\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\r\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\r\n */\n\n/**\r\n * @typedef {Object} FileEnumeratorInternalSlots\r\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\r\n * @property {string} cwd The base directory to start lookup.\r\n * @property {RegExp|null} extensionRegExp The RegExp to test if a string ends with specific file extensions.\r\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} ignoreFlag The flag to check ignored files.\r\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\r\n */\n\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\n\nconst internalSlotsMap = new WeakMap();\n/**\r\n * Check if a string is a glob pattern or not.\r\n * @param {string} pattern A glob pattern.\r\n * @returns {boolean} `true` if the string is a glob pattern.\r\n */\n\nfunction isGlobPattern(pattern) {\n  return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\n}\n/**\r\n * Get stats of a given path.\r\n * @param {string} filePath The path to target file.\r\n * @throws {Error} As may be thrown by `fs.statSync`.\r\n * @returns {fs.Stats|null} The stats.\r\n * @private\r\n */\n\n\nfunction statSafeSync(filePath) {\n  try {\n    return fs.statSync(filePath);\n  } catch (error) {\n    /* istanbul ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n\n    return null;\n  }\n}\n/**\r\n * Get filenames in a given path to a directory.\r\n * @param {string} directoryPath The path to target directory.\r\n * @throws {Error} As may be thrown by `fs.readdirSync`.\r\n * @returns {import(\"fs\").Dirent[]} The filenames.\r\n * @private\r\n */\n\n\nfunction readdirSafeSync(directoryPath) {\n  try {\n    return fs.readdirSync(directoryPath, {\n      withFileTypes: true\n    });\n  } catch (error) {\n    /* istanbul ignore next */\n    if (error.code !== \"ENOENT\") {\n      throw error;\n    }\n\n    return [];\n  }\n}\n/**\r\n * Create a `RegExp` object to detect extensions.\r\n * @param {string[] | null} extensions The extensions to create.\r\n * @returns {RegExp | null} The created `RegExp` object or null.\r\n */\n\n\nfunction createExtensionRegExp(extensions) {\n  if (extensions) {\n    const normalizedExts = extensions.map(ext => escapeRegExp(ext.startsWith(\".\") ? ext.slice(1) : ext));\n    return new RegExp(`.\\\\.(?:${normalizedExts.join(\"|\")})$`, \"u\");\n  }\n\n  return null;\n}\n/**\r\n * The error type when no files match a glob.\r\n */\n\n\nclass NoFilesFoundError extends Error {\n  /**\r\n   * @param {string} pattern The glob pattern which was not found.\r\n   * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\r\n   */\n  constructor(pattern, globDisabled) {\n    super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\n    this.messageTemplate = \"file-not-found\";\n    this.messageData = {\n      pattern,\n      globDisabled\n    };\n  }\n\n}\n/**\r\n * The error type when there are files matched by a glob, but all of them have been ignored.\r\n */\n\n\nclass AllFilesIgnoredError extends Error {\n  /**\r\n   * @param {string} pattern The glob pattern which was not found.\r\n   */\n  constructor(pattern) {\n    super(`All files matched by '${pattern}' are ignored.`);\n    this.messageTemplate = \"all-files-ignored\";\n    this.messageData = {\n      pattern\n    };\n  }\n\n}\n/**\r\n * This class provides the functionality that enumerates every file which is\r\n * matched by given glob patterns and that configuration.\r\n */\n\n\nclass FileEnumerator {\n  /**\r\n   * Initialize this enumerator.\r\n   * @param {FileEnumeratorOptions} options The options.\r\n   */\n  constructor() {\n    let {\n      cwd = process.cwd(),\n      configArrayFactory = new CascadingConfigArrayFactory({\n        cwd,\n        getEslintRecommendedConfig: () => require(\"../../conf/eslint-recommended.js\"),\n        getEslintAllConfig: () => require(\"../../conf/eslint-all.js\")\n      }),\n      extensions = null,\n      globInputPaths = true,\n      errorOnUnmatchedPattern = true,\n      ignore = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    internalSlotsMap.set(this, {\n      configArrayFactory,\n      cwd,\n      defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\n      extensionRegExp: createExtensionRegExp(extensions),\n      globInputPaths,\n      errorOnUnmatchedPattern,\n      ignoreFlag: ignore\n    });\n  }\n  /**\r\n   * Check if a given file is target or not.\r\n   * @param {string} filePath The path to a candidate file.\r\n   * @param {ConfigArray} [providedConfig] Optional. The configuration for the file.\r\n   * @returns {boolean} `true` if the file is a target.\r\n   */\n\n\n  isTargetPath(filePath, providedConfig) {\n    const {\n      configArrayFactory,\n      extensionRegExp\n    } = internalSlotsMap.get(this); // If `--ext` option is present, use it.\n\n    if (extensionRegExp) {\n      return extensionRegExp.test(filePath);\n    } // `.js` file is target by default.\n\n\n    if (filePath.endsWith(\".js\")) {\n      return true;\n    } // use `overrides[].files` to check additional targets.\n\n\n    const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {\n      ignoreNotFoundError: true\n    });\n    return config.isAdditionalTargetPath(filePath);\n  }\n  /**\r\n   * Iterate files which are matched by given glob patterns.\r\n   * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\r\n   * @throws {NoFilesFoundError|AllFilesIgnoredError} On an unmatched pattern.\r\n   * @returns {IterableIterator<FileAndConfig>} The found files.\r\n   */\n\n\n  *iterateFiles(patternOrPatterns) {\n    const {\n      globInputPaths,\n      errorOnUnmatchedPattern\n    } = internalSlotsMap.get(this);\n    const patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];\n    debug(\"Start to iterate files: %o\", patterns); // The set of paths to remove duplicate.\n\n    const set = new Set();\n\n    for (const pattern of patterns) {\n      let foundRegardlessOfIgnored = false;\n      let found = false; // Skip empty string.\n\n      if (!pattern) {\n        continue;\n      } // Iterate files of this pattern.\n\n\n      for (const {\n        config,\n        filePath,\n        flag\n      } of this._iterateFiles(pattern)) {\n        foundRegardlessOfIgnored = true;\n\n        if (flag === IGNORED_SILENTLY) {\n          continue;\n        }\n\n        found = true; // Remove duplicate paths while yielding paths.\n\n        if (!set.has(filePath)) {\n          set.add(filePath);\n          yield {\n            config,\n            filePath,\n            ignored: flag === IGNORED\n          };\n        }\n      } // Raise an error if any files were not found.\n\n\n      if (errorOnUnmatchedPattern) {\n        if (!foundRegardlessOfIgnored) {\n          throw new NoFilesFoundError(pattern, !globInputPaths && isGlob(pattern));\n        }\n\n        if (!found) {\n          throw new AllFilesIgnoredError(pattern);\n        }\n      }\n    }\n\n    debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\n  }\n  /**\r\n   * Iterate files which are matched by a given glob pattern.\r\n   * @param {string} pattern The glob pattern to iterate files.\r\n   * @returns {IterableIterator<FileEntry>} The found files.\r\n   */\n\n\n  _iterateFiles(pattern) {\n    const {\n      cwd,\n      globInputPaths\n    } = internalSlotsMap.get(this);\n    const absolutePath = path.resolve(cwd, pattern);\n    const isDot = dotfilesPattern.test(pattern);\n    const stat = statSafeSync(absolutePath);\n\n    if (stat && stat.isDirectory()) {\n      return this._iterateFilesWithDirectory(absolutePath, isDot);\n    }\n\n    if (stat && stat.isFile()) {\n      return this._iterateFilesWithFile(absolutePath);\n    }\n\n    if (globInputPaths && isGlobPattern(pattern)) {\n      return this._iterateFilesWithGlob(absolutePath, isDot);\n    }\n\n    return [];\n  }\n  /**\r\n   * Iterate a file which is matched by a given path.\r\n   * @param {string} filePath The path to the target file.\r\n   * @returns {IterableIterator<FileEntry>} The found files.\r\n   * @private\r\n   */\n\n\n  _iterateFilesWithFile(filePath) {\n    debug(`File: ${filePath}`);\n    const {\n      configArrayFactory\n    } = internalSlotsMap.get(this);\n    const config = configArrayFactory.getConfigArrayForFile(filePath);\n\n    const ignored = this._isIgnoredFile(filePath, {\n      config,\n      direct: true\n    });\n\n    const flag = ignored ? IGNORED : NONE;\n    return [{\n      config,\n      filePath,\n      flag\n    }];\n  }\n  /**\r\n   * Iterate files in a given path.\r\n   * @param {string} directoryPath The path to the target directory.\r\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\r\n   * @returns {IterableIterator<FileEntry>} The found files.\r\n   * @private\r\n   */\n\n\n  _iterateFilesWithDirectory(directoryPath, dotfiles) {\n    debug(`Directory: ${directoryPath}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive: true,\n      selector: null\n    });\n  }\n  /**\r\n   * Iterate files which are matched by a given glob pattern.\r\n   * @param {string} pattern The glob pattern to iterate files.\r\n   * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\r\n   * @returns {IterableIterator<FileEntry>} The found files.\r\n   * @private\r\n   */\n\n\n  _iterateFilesWithGlob(pattern, dotfiles) {\n    debug(`Glob: ${pattern}`);\n    const directoryPath = path.resolve(getGlobParent(pattern));\n    const globPart = pattern.slice(directoryPath.length + 1);\n    /*\r\n     * recursive if there are `**` or path separators in the glob part.\r\n     * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\r\n     */\n\n    const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\n    const selector = new Minimatch(pattern, minimatchOpts);\n    debug(`recursive? ${recursive}`);\n    return this._iterateFilesRecursive(directoryPath, {\n      dotfiles,\n      recursive,\n      selector\n    });\n  }\n  /**\r\n   * Iterate files in a given path.\r\n   * @param {string} directoryPath The path to the target directory.\r\n   * @param {Object} options The options to iterate files.\r\n   * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\r\n   * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\r\n   * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\r\n   * @returns {IterableIterator<FileEntry>} The found files.\r\n   * @private\r\n   */\n\n\n  *_iterateFilesRecursive(directoryPath, options) {\n    debug(`Enter the directory: ${directoryPath}`);\n    const {\n      configArrayFactory\n    } = internalSlotsMap.get(this);\n    /** @type {ConfigArray|null} */\n\n    let config = null; // Enumerate the files of this directory.\n\n    for (const entry of readdirSafeSync(directoryPath)) {\n      const filePath = path.join(directoryPath, entry.name);\n      const fileInfo = entry.isSymbolicLink() ? statSafeSync(filePath) : entry;\n\n      if (!fileInfo) {\n        continue;\n      } // Check if the file is matched.\n\n\n      if (fileInfo.isFile()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath,\n          /*\r\n           * We must ignore `ConfigurationNotFoundError` at this\r\n           * point because we don't know if target files exist in\r\n           * this directory.\r\n           */\n          {\n            ignoreNotFoundError: true\n          });\n        }\n\n        const matched = options.selector // Started with a glob pattern; choose by the pattern.\n        ? options.selector.match(filePath) // Started with a directory path; choose by file extensions.\n        : this.isTargetPath(filePath, config);\n\n        if (matched) {\n          const ignored = this._isIgnoredFile(filePath, { ...options,\n            config\n          });\n\n          const flag = ignored ? IGNORED_SILENTLY : NONE;\n          debug(`Yield: ${entry.name}${ignored ? \" but ignored\" : \"\"}`);\n          yield {\n            config: configArrayFactory.getConfigArrayForFile(filePath),\n            filePath,\n            flag\n          };\n        } else {\n          debug(`Didn't match: ${entry.name}`);\n        } // Dive into the sub directory.\n\n      } else if (options.recursive && fileInfo.isDirectory()) {\n        if (!config) {\n          config = configArrayFactory.getConfigArrayForFile(filePath, {\n            ignoreNotFoundError: true\n          });\n        }\n\n        const ignored = this._isIgnoredFile(filePath + path.sep, { ...options,\n          config\n        });\n\n        if (!ignored) {\n          yield* this._iterateFilesRecursive(filePath, options);\n        }\n      }\n    }\n\n    debug(`Leave the directory: ${directoryPath}`);\n  }\n  /**\r\n   * Check if a given file should be ignored.\r\n   * @param {string} filePath The path to a file to check.\r\n   * @param {Object} options Options\r\n   * @param {ConfigArray} [options.config] The config for this file.\r\n   * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\r\n   * @param {boolean} [options.direct] If `true` then this is a direct specified file.\r\n   * @returns {boolean} `true` if the file should be ignored.\r\n   * @private\r\n   */\n\n\n  _isIgnoredFile(filePath, _ref) {\n    let {\n      config: providedConfig,\n      dotfiles = false,\n      direct = false\n    } = _ref;\n    const {\n      configArrayFactory,\n      defaultIgnores,\n      ignoreFlag\n    } = internalSlotsMap.get(this);\n\n    if (ignoreFlag) {\n      const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {\n        ignoreNotFoundError: true\n      });\n      const ignores = config.extractConfig(filePath).ignores || defaultIgnores;\n      return ignores(filePath, dotfiles);\n    }\n\n    return !direct && defaultIgnores(filePath, dotfiles);\n  }\n\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  FileEnumerator\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/cli-engine/file-enumerator.js"],"names":["fs","require","path","getGlobParent","isGlob","escapeRegExp","Minimatch","Legacy","IgnorePattern","CascadingConfigArrayFactory","debug","minimatchOpts","dot","matchBase","dotfilesPattern","NONE","IGNORED_SILENTLY","IGNORED","internalSlotsMap","WeakMap","isGlobPattern","pattern","sep","replace","statSafeSync","filePath","statSync","error","code","readdirSafeSync","directoryPath","readdirSync","withFileTypes","createExtensionRegExp","extensions","normalizedExts","map","ext","startsWith","slice","RegExp","join","NoFilesFoundError","Error","constructor","globDisabled","messageTemplate","messageData","AllFilesIgnoredError","FileEnumerator","cwd","process","configArrayFactory","getEslintRecommendedConfig","getEslintAllConfig","globInputPaths","errorOnUnmatchedPattern","ignore","set","defaultIgnores","createDefaultIgnore","extensionRegExp","ignoreFlag","isTargetPath","providedConfig","get","test","endsWith","config","getConfigArrayForFile","ignoreNotFoundError","isAdditionalTargetPath","iterateFiles","patternOrPatterns","patterns","Array","isArray","Set","foundRegardlessOfIgnored","found","flag","_iterateFiles","has","add","ignored","JSON","stringify","absolutePath","resolve","isDot","stat","isDirectory","_iterateFilesWithDirectory","isFile","_iterateFilesWithFile","_iterateFilesWithGlob","_isIgnoredFile","direct","dotfiles","_iterateFilesRecursive","recursive","selector","globPart","length","options","entry","name","fileInfo","isSymbolicLink","matched","match","ignores","extractConfig","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,aAAa,GAAGF,OAAO,CAAC,aAAD,CAA7B;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAMI,YAAY,GAAGJ,OAAO,CAAC,sBAAD,CAA5B;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAgBL,OAAO,CAAC,WAAD,CAA7B;;AAEA,MAAM;AACFM,EAAAA,MAAM,EAAE;AACJC,IAAAA,aADI;AAEJC,IAAAA;AAFI;AADN,IAKFR,OAAO,CAAC,kBAAD,CALX;;AAMA,MAAMS,KAAK,GAAGT,OAAO,CAAC,OAAD,CAAP,CAAiB,wBAAjB,CAAd,C,CAEA;AACA;AACA;;;AAEA,MAAMU,aAAa,GAAG;AAAEC,EAAAA,GAAG,EAAE,IAAP;AAAaC,EAAAA,SAAS,EAAE;AAAxB,CAAtB;AACA,MAAMC,eAAe,GAAG,mCAAxB;AACA,MAAMC,IAAI,GAAG,CAAb;AACA,MAAMC,gBAAgB,GAAG,CAAzB;AACA,MAAMC,OAAO,GAAG,CAAhB,C,CAEA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AACA,MAAMC,gBAAgB,GAAG,IAAIC,OAAJ,EAAzB;AAEA;AACA;AACA;AACA;AACA;;AACA,SAASC,aAAT,CAAuBC,OAAvB,EAAgC;AAC5B,SAAOjB,MAAM,CAACF,IAAI,CAACoB,GAAL,KAAa,IAAb,GAAoBD,OAAO,CAACE,OAAR,CAAgB,MAAhB,EAAwB,GAAxB,CAApB,GAAmDF,OAApD,CAAb;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,YAAT,CAAsBC,QAAtB,EAAgC;AAC5B,MAAI;AACA,WAAOzB,EAAE,CAAC0B,QAAH,CAAYD,QAAZ,CAAP;AACH,GAFD,CAEE,OAAOE,KAAP,EAAc;AACZ;AACA,QAAIA,KAAK,CAACC,IAAN,KAAe,QAAnB,EAA6B;AACzB,YAAMD,KAAN;AACH;;AACD,WAAO,IAAP;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAAyBC,aAAzB,EAAwC;AACpC,MAAI;AACA,WAAO9B,EAAE,CAAC+B,WAAH,CAAeD,aAAf,EAA8B;AAAEE,MAAAA,aAAa,EAAE;AAAjB,KAA9B,CAAP;AACH,GAFD,CAEE,OAAOL,KAAP,EAAc;AACZ;AACA,QAAIA,KAAK,CAACC,IAAN,KAAe,QAAnB,EAA6B;AACzB,YAAMD,KAAN;AACH;;AACD,WAAO,EAAP;AACH;AACJ;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASM,qBAAT,CAA+BC,UAA/B,EAA2C;AACvC,MAAIA,UAAJ,EAAgB;AACZ,UAAMC,cAAc,GAAGD,UAAU,CAACE,GAAX,CAAeC,GAAG,IAAIhC,YAAY,CACrDgC,GAAG,CAACC,UAAJ,CAAe,GAAf,IACMD,GAAG,CAACE,KAAJ,CAAU,CAAV,CADN,GAEMF,GAH+C,CAAlC,CAAvB;AAMA,WAAO,IAAIG,MAAJ,CACF,UAASL,cAAc,CAACM,IAAf,CAAoB,GAApB,CAAyB,IADhC,EAEH,GAFG,CAAP;AAIH;;AACD,SAAO,IAAP;AACH;AAED;AACA;AACA;;;AACA,MAAMC,iBAAN,SAAgCC,KAAhC,CAAsC;AAElC;AACJ;AACA;AACA;AACIC,EAAAA,WAAW,CAACvB,OAAD,EAAUwB,YAAV,EAAwB;AAC/B,UAAO,sBAAqBxB,OAAQ,eAAcwB,YAAY,GAAG,sBAAH,GAA4B,EAAG,GAA7F;AACA,SAAKC,eAAL,GAAuB,gBAAvB;AACA,SAAKC,WAAL,GAAmB;AAAE1B,MAAAA,OAAF;AAAWwB,MAAAA;AAAX,KAAnB;AACH;;AAViC;AAatC;AACA;AACA;;;AACA,MAAMG,oBAAN,SAAmCL,KAAnC,CAAyC;AAErC;AACJ;AACA;AACIC,EAAAA,WAAW,CAACvB,OAAD,EAAU;AACjB,UAAO,yBAAwBA,OAAQ,gBAAvC;AACA,SAAKyB,eAAL,GAAuB,mBAAvB;AACA,SAAKC,WAAL,GAAmB;AAAE1B,MAAAA;AAAF,KAAnB;AACH;;AAToC;AAYzC;AACA;AACA;AACA;;;AACA,MAAM4B,cAAN,CAAqB;AAEjB;AACJ;AACA;AACA;AACIL,EAAAA,WAAW,GAWH;AAAA,QAXI;AACRM,MAAAA,GAAG,GAAGC,OAAO,CAACD,GAAR,EADE;AAERE,MAAAA,kBAAkB,GAAG,IAAI3C,2BAAJ,CAAgC;AACjDyC,QAAAA,GADiD;AAEjDG,QAAAA,0BAA0B,EAAE,MAAMpD,OAAO,CAAC,kCAAD,CAFQ;AAGjDqD,QAAAA,kBAAkB,EAAE,MAAMrD,OAAO,CAAC,0BAAD;AAHgB,OAAhC,CAFb;AAORiC,MAAAA,UAAU,GAAG,IAPL;AAQRqB,MAAAA,cAAc,GAAG,IART;AASRC,MAAAA,uBAAuB,GAAG,IATlB;AAURC,MAAAA,MAAM,GAAG;AAVD,KAWJ,uEAAJ,EAAI;AACJvC,IAAAA,gBAAgB,CAACwC,GAAjB,CAAqB,IAArB,EAA2B;AACvBN,MAAAA,kBADuB;AAEvBF,MAAAA,GAFuB;AAGvBS,MAAAA,cAAc,EAAEnD,aAAa,CAACoD,mBAAd,CAAkCV,GAAlC,CAHO;AAIvBW,MAAAA,eAAe,EAAE5B,qBAAqB,CAACC,UAAD,CAJf;AAKvBqB,MAAAA,cALuB;AAMvBC,MAAAA,uBANuB;AAOvBM,MAAAA,UAAU,EAAEL;AAPW,KAA3B;AASH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,YAAY,CAACtC,QAAD,EAAWuC,cAAX,EAA2B;AACnC,UAAM;AACFZ,MAAAA,kBADE;AAEFS,MAAAA;AAFE,QAGF3C,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAHJ,CADmC,CAMnC;;AACA,QAAIJ,eAAJ,EAAqB;AACjB,aAAOA,eAAe,CAACK,IAAhB,CAAqBzC,QAArB,CAAP;AACH,KATkC,CAWnC;;;AACA,QAAIA,QAAQ,CAAC0C,QAAT,CAAkB,KAAlB,CAAJ,EAA8B;AAC1B,aAAO,IAAP;AACH,KAdkC,CAgBnC;;;AACA,UAAMC,MAAM,GACRJ,cAAc,IACdZ,kBAAkB,CAACiB,qBAAnB,CACI5C,QADJ,EAEI;AAAE6C,MAAAA,mBAAmB,EAAE;AAAvB,KAFJ,CAFJ;AAOA,WAAOF,MAAM,CAACG,sBAAP,CAA8B9C,QAA9B,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACiB,GAAZ+C,YAAY,CAACC,iBAAD,EAAoB;AAC7B,UAAM;AAAElB,MAAAA,cAAF;AAAkBC,MAAAA;AAAlB,QAA8CtC,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAApD;AACA,UAAMS,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcH,iBAAd,IACXA,iBADW,GAEX,CAACA,iBAAD,CAFN;AAIA/D,IAAAA,KAAK,CAAC,4BAAD,EAA+BgE,QAA/B,CAAL,CAN6B,CAQ7B;;AACA,UAAMhB,GAAG,GAAG,IAAImB,GAAJ,EAAZ;;AAEA,SAAK,MAAMxD,OAAX,IAAsBqD,QAAtB,EAAgC;AAC5B,UAAII,wBAAwB,GAAG,KAA/B;AACA,UAAIC,KAAK,GAAG,KAAZ,CAF4B,CAI5B;;AACA,UAAI,CAAC1D,OAAL,EAAc;AACV;AACH,OAP2B,CAS5B;;;AACA,WAAK,MAAM;AAAE+C,QAAAA,MAAF;AAAU3C,QAAAA,QAAV;AAAoBuD,QAAAA;AAApB,OAAX,IAAyC,KAAKC,aAAL,CAAmB5D,OAAnB,CAAzC,EAAsE;AAClEyD,QAAAA,wBAAwB,GAAG,IAA3B;;AACA,YAAIE,IAAI,KAAKhE,gBAAb,EAA+B;AAC3B;AACH;;AACD+D,QAAAA,KAAK,GAAG,IAAR,CALkE,CAOlE;;AACA,YAAI,CAACrB,GAAG,CAACwB,GAAJ,CAAQzD,QAAR,CAAL,EAAwB;AACpBiC,UAAAA,GAAG,CAACyB,GAAJ,CAAQ1D,QAAR;AACA,gBAAM;AACF2C,YAAAA,MADE;AAEF3C,YAAAA,QAFE;AAGF2D,YAAAA,OAAO,EAAEJ,IAAI,KAAK/D;AAHhB,WAAN;AAKH;AACJ,OA1B2B,CA4B5B;;;AACA,UAAIuC,uBAAJ,EAA6B;AACzB,YAAI,CAACsB,wBAAL,EAA+B;AAC3B,gBAAM,IAAIpC,iBAAJ,CACFrB,OADE,EAEF,CAACkC,cAAD,IAAmBnD,MAAM,CAACiB,OAAD,CAFvB,CAAN;AAIH;;AACD,YAAI,CAAC0D,KAAL,EAAY;AACR,gBAAM,IAAI/B,oBAAJ,CAAyB3B,OAAzB,CAAN;AACH;AACJ;AACJ;;AAEDX,IAAAA,KAAK,CAAE,6BAA4B2E,IAAI,CAACC,SAAL,CAAeZ,QAAf,CAAyB,EAAvD,CAAL;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACIO,EAAAA,aAAa,CAAC5D,OAAD,EAAU;AACnB,UAAM;AAAE6B,MAAAA,GAAF;AAAOK,MAAAA;AAAP,QAA0BrC,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAAhC;AACA,UAAMsB,YAAY,GAAGrF,IAAI,CAACsF,OAAL,CAAatC,GAAb,EAAkB7B,OAAlB,CAArB;AACA,UAAMoE,KAAK,GAAG3E,eAAe,CAACoD,IAAhB,CAAqB7C,OAArB,CAAd;AACA,UAAMqE,IAAI,GAAGlE,YAAY,CAAC+D,YAAD,CAAzB;;AAEA,QAAIG,IAAI,IAAIA,IAAI,CAACC,WAAL,EAAZ,EAAgC;AAC5B,aAAO,KAAKC,0BAAL,CAAgCL,YAAhC,EAA8CE,KAA9C,CAAP;AACH;;AACD,QAAIC,IAAI,IAAIA,IAAI,CAACG,MAAL,EAAZ,EAA2B;AACvB,aAAO,KAAKC,qBAAL,CAA2BP,YAA3B,CAAP;AACH;;AACD,QAAIhC,cAAc,IAAInC,aAAa,CAACC,OAAD,CAAnC,EAA8C;AAC1C,aAAO,KAAK0E,qBAAL,CAA2BR,YAA3B,EAAyCE,KAAzC,CAAP;AACH;;AAED,WAAO,EAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,qBAAqB,CAACrE,QAAD,EAAW;AAC5Bf,IAAAA,KAAK,CAAE,SAAQe,QAAS,EAAnB,CAAL;AAEA,UAAM;AAAE2B,MAAAA;AAAF,QAAyBlC,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAA/B;AACA,UAAMG,MAAM,GAAGhB,kBAAkB,CAACiB,qBAAnB,CAAyC5C,QAAzC,CAAf;;AACA,UAAM2D,OAAO,GAAG,KAAKY,cAAL,CAAoBvE,QAApB,EAA8B;AAAE2C,MAAAA,MAAF;AAAU6B,MAAAA,MAAM,EAAE;AAAlB,KAA9B,CAAhB;;AACA,UAAMjB,IAAI,GAAGI,OAAO,GAAGnE,OAAH,GAAaF,IAAjC;AAEA,WAAO,CAAC;AAAEqD,MAAAA,MAAF;AAAU3C,MAAAA,QAAV;AAAoBuD,MAAAA;AAApB,KAAD,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIY,EAAAA,0BAA0B,CAAC9D,aAAD,EAAgBoE,QAAhB,EAA0B;AAChDxF,IAAAA,KAAK,CAAE,cAAaoB,aAAc,EAA7B,CAAL;AAEA,WAAO,KAAKqE,sBAAL,CACHrE,aADG,EAEH;AAAEoE,MAAAA,QAAF;AAAYE,MAAAA,SAAS,EAAE,IAAvB;AAA6BC,MAAAA,QAAQ,EAAE;AAAvC,KAFG,CAAP;AAIH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIN,EAAAA,qBAAqB,CAAC1E,OAAD,EAAU6E,QAAV,EAAoB;AACrCxF,IAAAA,KAAK,CAAE,SAAQW,OAAQ,EAAlB,CAAL;AAEA,UAAMS,aAAa,GAAG5B,IAAI,CAACsF,OAAL,CAAarF,aAAa,CAACkB,OAAD,CAA1B,CAAtB;AACA,UAAMiF,QAAQ,GAAGjF,OAAO,CAACkB,KAAR,CAAcT,aAAa,CAACyE,MAAd,GAAuB,CAArC,CAAjB;AAEA;AACR;AACA;AACA;;AACQ,UAAMH,SAAS,GAAG,cAAclC,IAAd,CAAmBoC,QAAnB,CAAlB;AACA,UAAMD,QAAQ,GAAG,IAAI/F,SAAJ,CAAce,OAAd,EAAuBV,aAAvB,CAAjB;AAEAD,IAAAA,KAAK,CAAE,cAAa0F,SAAU,EAAzB,CAAL;AAEA,WAAO,KAAKD,sBAAL,CACHrE,aADG,EAEH;AAAEoE,MAAAA,QAAF;AAAYE,MAAAA,SAAZ;AAAuBC,MAAAA;AAAvB,KAFG,CAAP;AAIH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC2B,GAAtBF,sBAAsB,CAACrE,aAAD,EAAgB0E,OAAhB,EAAyB;AAC5C9F,IAAAA,KAAK,CAAE,wBAAuBoB,aAAc,EAAvC,CAAL;AACA,UAAM;AAAEsB,MAAAA;AAAF,QAAyBlC,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAA/B;AAEA;;AACA,QAAIG,MAAM,GAAG,IAAb,CAL4C,CAO5C;;AACA,SAAK,MAAMqC,KAAX,IAAoB5E,eAAe,CAACC,aAAD,CAAnC,EAAoD;AAChD,YAAML,QAAQ,GAAGvB,IAAI,CAACuC,IAAL,CAAUX,aAAV,EAAyB2E,KAAK,CAACC,IAA/B,CAAjB;AACA,YAAMC,QAAQ,GAAGF,KAAK,CAACG,cAAN,KAAyBpF,YAAY,CAACC,QAAD,CAArC,GAAkDgF,KAAnE;;AAEA,UAAI,CAACE,QAAL,EAAe;AACX;AACH,OAN+C,CAQhD;;;AACA,UAAIA,QAAQ,CAACd,MAAT,EAAJ,EAAuB;AACnB,YAAI,CAACzB,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAGhB,kBAAkB,CAACiB,qBAAnB,CACL5C,QADK;AAGL;AACxB;AACA;AACA;AACA;AACwB;AAAE6C,YAAAA,mBAAmB,EAAE;AAAvB,WARK,CAAT;AAUH;;AACD,cAAMuC,OAAO,GAAGL,OAAO,CAACH,QAAR,CAEZ;AAFY,UAGVG,OAAO,CAACH,QAAR,CAAiBS,KAAjB,CAAuBrF,QAAvB,CAHU,CAKZ;AALY,UAMV,KAAKsC,YAAL,CAAkBtC,QAAlB,EAA4B2C,MAA5B,CANN;;AAQA,YAAIyC,OAAJ,EAAa;AACT,gBAAMzB,OAAO,GAAG,KAAKY,cAAL,CAAoBvE,QAApB,EAA8B,EAAE,GAAG+E,OAAL;AAAcpC,YAAAA;AAAd,WAA9B,CAAhB;;AACA,gBAAMY,IAAI,GAAGI,OAAO,GAAGpE,gBAAH,GAAsBD,IAA1C;AAEAL,UAAAA,KAAK,CAAE,UAAS+F,KAAK,CAACC,IAAK,GAAEtB,OAAO,GAAG,cAAH,GAAoB,EAAG,EAAtD,CAAL;AACA,gBAAM;AACFhB,YAAAA,MAAM,EAAEhB,kBAAkB,CAACiB,qBAAnB,CAAyC5C,QAAzC,CADN;AAEFA,YAAAA,QAFE;AAGFuD,YAAAA;AAHE,WAAN;AAKH,SAVD,MAUO;AACHtE,UAAAA,KAAK,CAAE,iBAAgB+F,KAAK,CAACC,IAAK,EAA7B,CAAL;AACH,SAjCkB,CAmCvB;;AACC,OApCD,MAoCO,IAAIF,OAAO,CAACJ,SAAR,IAAqBO,QAAQ,CAAChB,WAAT,EAAzB,EAAiD;AACpD,YAAI,CAACvB,MAAL,EAAa;AACTA,UAAAA,MAAM,GAAGhB,kBAAkB,CAACiB,qBAAnB,CACL5C,QADK,EAEL;AAAE6C,YAAAA,mBAAmB,EAAE;AAAvB,WAFK,CAAT;AAIH;;AACD,cAAMc,OAAO,GAAG,KAAKY,cAAL,CACZvE,QAAQ,GAAGvB,IAAI,CAACoB,GADJ,EAEZ,EAAE,GAAGkF,OAAL;AAAcpC,UAAAA;AAAd,SAFY,CAAhB;;AAKA,YAAI,CAACgB,OAAL,EAAc;AACV,iBAAO,KAAKe,sBAAL,CAA4B1E,QAA5B,EAAsC+E,OAAtC,CAAP;AACH;AACJ;AACJ;;AAED9F,IAAAA,KAAK,CAAE,wBAAuBoB,aAAc,EAAvC,CAAL;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIkE,EAAAA,cAAc,CAACvE,QAAD,QAIX;AAAA,QAJsB;AACrB2C,MAAAA,MAAM,EAAEJ,cADa;AAErBkC,MAAAA,QAAQ,GAAG,KAFU;AAGrBD,MAAAA,MAAM,GAAG;AAHY,KAItB;AACC,UAAM;AACF7C,MAAAA,kBADE;AAEFO,MAAAA,cAFE;AAGFG,MAAAA;AAHE,QAIF5C,gBAAgB,CAAC+C,GAAjB,CAAqB,IAArB,CAJJ;;AAMA,QAAIH,UAAJ,EAAgB;AACZ,YAAMM,MAAM,GACRJ,cAAc,IACdZ,kBAAkB,CAACiB,qBAAnB,CACI5C,QADJ,EAEI;AAAE6C,QAAAA,mBAAmB,EAAE;AAAvB,OAFJ,CAFJ;AAMA,YAAMyC,OAAO,GACT3C,MAAM,CAAC4C,aAAP,CAAqBvF,QAArB,EAA+BsF,OAA/B,IAA0CpD,cAD9C;AAGA,aAAOoD,OAAO,CAACtF,QAAD,EAAWyE,QAAX,CAAd;AACH;;AAED,WAAO,CAACD,MAAD,IAAWtC,cAAc,CAAClC,QAAD,EAAWyE,QAAX,CAAhC;AACH;;AAxUgB,C,CA2UrB;AACA;AACA;;;AAEAe,MAAM,CAACC,OAAP,GAAiB;AAAEjE,EAAAA;AAAF,CAAjB","sourcesContent":["/**\r\n * @fileoverview `FileEnumerator` class.\r\n *\r\n * `FileEnumerator` class has two responsibilities:\r\n *\r\n * 1. Find target files by processing glob patterns.\r\n * 2. Tie each target file and appropriate configuration.\r\n *\r\n * It provides a method:\r\n *\r\n * - `iterateFiles(patterns)`\r\n *     Iterate files which are matched by given patterns together with the\r\n *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.\r\n *     While iterating files, it loads the configuration file of each directory\r\n *     before iterate files on the directory, so we can use the configuration\r\n *     files to determine target files.\r\n *\r\n * @example\r\n * const enumerator = new FileEnumerator();\r\n * const linter = new Linter();\r\n *\r\n * for (const { config, filePath } of enumerator.iterateFiles([\"*.js\"])) {\r\n *     const code = fs.readFileSync(filePath, \"utf8\");\r\n *     const messages = linter.verify(code, config, filePath);\r\n *\r\n *     console.log(messages);\r\n * }\r\n *\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst getGlobParent = require(\"glob-parent\");\r\nconst isGlob = require(\"is-glob\");\r\nconst escapeRegExp = require(\"escape-string-regexp\");\r\nconst { Minimatch } = require(\"minimatch\");\r\n\r\nconst {\r\n    Legacy: {\r\n        IgnorePattern,\r\n        CascadingConfigArrayFactory\r\n    }\r\n} = require(\"@eslint/eslintrc\");\r\nconst debug = require(\"debug\")(\"eslint:file-enumerator\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst minimatchOpts = { dot: true, matchBase: true };\r\nconst dotfilesPattern = /(?:(?:^\\.)|(?:[/\\\\]\\.))[^/\\\\.].*/u;\r\nconst NONE = 0;\r\nconst IGNORED_SILENTLY = 1;\r\nconst IGNORED = 2;\r\n\r\n// For VSCode intellisense\r\n/** @typedef {ReturnType<CascadingConfigArrayFactory.getConfigArrayForFile>} ConfigArray */\r\n\r\n/**\r\n * @typedef {Object} FileEnumeratorOptions\r\n * @property {CascadingConfigArrayFactory} [configArrayFactory] The factory for config arrays.\r\n * @property {string} [cwd] The base directory to start lookup.\r\n * @property {string[]} [extensions] The extensions to match files for directory patterns.\r\n * @property {boolean} [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} [ignore] The flag to check ignored files.\r\n * @property {string[]} [rulePaths] The value of `--rulesdir` option.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FileAndConfig\r\n * @property {string} filePath The path to a target file.\r\n * @property {ConfigArray} config The config entries of that file.\r\n * @property {boolean} ignored If `true` then this file should be ignored and warned because it was directly specified.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FileEntry\r\n * @property {string} filePath The path to a target file.\r\n * @property {ConfigArray} config The config entries of that file.\r\n * @property {NONE|IGNORED_SILENTLY|IGNORED} flag The flag.\r\n * - `NONE` means the file is a target file.\r\n * - `IGNORED_SILENTLY` means the file should be ignored silently.\r\n * - `IGNORED` means the file should be ignored and warned because it was directly specified.\r\n */\r\n\r\n/**\r\n * @typedef {Object} FileEnumeratorInternalSlots\r\n * @property {CascadingConfigArrayFactory} configArrayFactory The factory for config arrays.\r\n * @property {string} cwd The base directory to start lookup.\r\n * @property {RegExp|null} extensionRegExp The RegExp to test if a string ends with specific file extensions.\r\n * @property {boolean} globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.\r\n * @property {boolean} ignoreFlag The flag to check ignored files.\r\n * @property {(filePath:string, dot:boolean) => boolean} defaultIgnores The default predicate function to ignore files.\r\n */\r\n\r\n/** @type {WeakMap<FileEnumerator, FileEnumeratorInternalSlots>} */\r\nconst internalSlotsMap = new WeakMap();\r\n\r\n/**\r\n * Check if a string is a glob pattern or not.\r\n * @param {string} pattern A glob pattern.\r\n * @returns {boolean} `true` if the string is a glob pattern.\r\n */\r\nfunction isGlobPattern(pattern) {\r\n    return isGlob(path.sep === \"\\\\\" ? pattern.replace(/\\\\/gu, \"/\") : pattern);\r\n}\r\n\r\n/**\r\n * Get stats of a given path.\r\n * @param {string} filePath The path to target file.\r\n * @throws {Error} As may be thrown by `fs.statSync`.\r\n * @returns {fs.Stats|null} The stats.\r\n * @private\r\n */\r\nfunction statSafeSync(filePath) {\r\n    try {\r\n        return fs.statSync(filePath);\r\n    } catch (error) {\r\n        /* istanbul ignore next */\r\n        if (error.code !== \"ENOENT\") {\r\n            throw error;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Get filenames in a given path to a directory.\r\n * @param {string} directoryPath The path to target directory.\r\n * @throws {Error} As may be thrown by `fs.readdirSync`.\r\n * @returns {import(\"fs\").Dirent[]} The filenames.\r\n * @private\r\n */\r\nfunction readdirSafeSync(directoryPath) {\r\n    try {\r\n        return fs.readdirSync(directoryPath, { withFileTypes: true });\r\n    } catch (error) {\r\n        /* istanbul ignore next */\r\n        if (error.code !== \"ENOENT\") {\r\n            throw error;\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Create a `RegExp` object to detect extensions.\r\n * @param {string[] | null} extensions The extensions to create.\r\n * @returns {RegExp | null} The created `RegExp` object or null.\r\n */\r\nfunction createExtensionRegExp(extensions) {\r\n    if (extensions) {\r\n        const normalizedExts = extensions.map(ext => escapeRegExp(\r\n            ext.startsWith(\".\")\r\n                ? ext.slice(1)\r\n                : ext\r\n        ));\r\n\r\n        return new RegExp(\r\n            `.\\\\.(?:${normalizedExts.join(\"|\")})$`,\r\n            \"u\"\r\n        );\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * The error type when no files match a glob.\r\n */\r\nclass NoFilesFoundError extends Error {\r\n\r\n    /**\r\n     * @param {string} pattern The glob pattern which was not found.\r\n     * @param {boolean} globDisabled If `true` then the pattern was a glob pattern, but glob was disabled.\r\n     */\r\n    constructor(pattern, globDisabled) {\r\n        super(`No files matching '${pattern}' were found${globDisabled ? \" (glob was disabled)\" : \"\"}.`);\r\n        this.messageTemplate = \"file-not-found\";\r\n        this.messageData = { pattern, globDisabled };\r\n    }\r\n}\r\n\r\n/**\r\n * The error type when there are files matched by a glob, but all of them have been ignored.\r\n */\r\nclass AllFilesIgnoredError extends Error {\r\n\r\n    /**\r\n     * @param {string} pattern The glob pattern which was not found.\r\n     */\r\n    constructor(pattern) {\r\n        super(`All files matched by '${pattern}' are ignored.`);\r\n        this.messageTemplate = \"all-files-ignored\";\r\n        this.messageData = { pattern };\r\n    }\r\n}\r\n\r\n/**\r\n * This class provides the functionality that enumerates every file which is\r\n * matched by given glob patterns and that configuration.\r\n */\r\nclass FileEnumerator {\r\n\r\n    /**\r\n     * Initialize this enumerator.\r\n     * @param {FileEnumeratorOptions} options The options.\r\n     */\r\n    constructor({\r\n        cwd = process.cwd(),\r\n        configArrayFactory = new CascadingConfigArrayFactory({\r\n            cwd,\r\n            getEslintRecommendedConfig: () => require(\"../../conf/eslint-recommended.js\"),\r\n            getEslintAllConfig: () => require(\"../../conf/eslint-all.js\")\r\n        }),\r\n        extensions = null,\r\n        globInputPaths = true,\r\n        errorOnUnmatchedPattern = true,\r\n        ignore = true\r\n    } = {}) {\r\n        internalSlotsMap.set(this, {\r\n            configArrayFactory,\r\n            cwd,\r\n            defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),\r\n            extensionRegExp: createExtensionRegExp(extensions),\r\n            globInputPaths,\r\n            errorOnUnmatchedPattern,\r\n            ignoreFlag: ignore\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check if a given file is target or not.\r\n     * @param {string} filePath The path to a candidate file.\r\n     * @param {ConfigArray} [providedConfig] Optional. The configuration for the file.\r\n     * @returns {boolean} `true` if the file is a target.\r\n     */\r\n    isTargetPath(filePath, providedConfig) {\r\n        const {\r\n            configArrayFactory,\r\n            extensionRegExp\r\n        } = internalSlotsMap.get(this);\r\n\r\n        // If `--ext` option is present, use it.\r\n        if (extensionRegExp) {\r\n            return extensionRegExp.test(filePath);\r\n        }\r\n\r\n        // `.js` file is target by default.\r\n        if (filePath.endsWith(\".js\")) {\r\n            return true;\r\n        }\r\n\r\n        // use `overrides[].files` to check additional targets.\r\n        const config =\r\n            providedConfig ||\r\n            configArrayFactory.getConfigArrayForFile(\r\n                filePath,\r\n                { ignoreNotFoundError: true }\r\n            );\r\n\r\n        return config.isAdditionalTargetPath(filePath);\r\n    }\r\n\r\n    /**\r\n     * Iterate files which are matched by given glob patterns.\r\n     * @param {string|string[]} patternOrPatterns The glob patterns to iterate files.\r\n     * @throws {NoFilesFoundError|AllFilesIgnoredError} On an unmatched pattern.\r\n     * @returns {IterableIterator<FileAndConfig>} The found files.\r\n     */\r\n    *iterateFiles(patternOrPatterns) {\r\n        const { globInputPaths, errorOnUnmatchedPattern } = internalSlotsMap.get(this);\r\n        const patterns = Array.isArray(patternOrPatterns)\r\n            ? patternOrPatterns\r\n            : [patternOrPatterns];\r\n\r\n        debug(\"Start to iterate files: %o\", patterns);\r\n\r\n        // The set of paths to remove duplicate.\r\n        const set = new Set();\r\n\r\n        for (const pattern of patterns) {\r\n            let foundRegardlessOfIgnored = false;\r\n            let found = false;\r\n\r\n            // Skip empty string.\r\n            if (!pattern) {\r\n                continue;\r\n            }\r\n\r\n            // Iterate files of this pattern.\r\n            for (const { config, filePath, flag } of this._iterateFiles(pattern)) {\r\n                foundRegardlessOfIgnored = true;\r\n                if (flag === IGNORED_SILENTLY) {\r\n                    continue;\r\n                }\r\n                found = true;\r\n\r\n                // Remove duplicate paths while yielding paths.\r\n                if (!set.has(filePath)) {\r\n                    set.add(filePath);\r\n                    yield {\r\n                        config,\r\n                        filePath,\r\n                        ignored: flag === IGNORED\r\n                    };\r\n                }\r\n            }\r\n\r\n            // Raise an error if any files were not found.\r\n            if (errorOnUnmatchedPattern) {\r\n                if (!foundRegardlessOfIgnored) {\r\n                    throw new NoFilesFoundError(\r\n                        pattern,\r\n                        !globInputPaths && isGlob(pattern)\r\n                    );\r\n                }\r\n                if (!found) {\r\n                    throw new AllFilesIgnoredError(pattern);\r\n                }\r\n            }\r\n        }\r\n\r\n        debug(`Complete iterating files: ${JSON.stringify(patterns)}`);\r\n    }\r\n\r\n    /**\r\n     * Iterate files which are matched by a given glob pattern.\r\n     * @param {string} pattern The glob pattern to iterate files.\r\n     * @returns {IterableIterator<FileEntry>} The found files.\r\n     */\r\n    _iterateFiles(pattern) {\r\n        const { cwd, globInputPaths } = internalSlotsMap.get(this);\r\n        const absolutePath = path.resolve(cwd, pattern);\r\n        const isDot = dotfilesPattern.test(pattern);\r\n        const stat = statSafeSync(absolutePath);\r\n\r\n        if (stat && stat.isDirectory()) {\r\n            return this._iterateFilesWithDirectory(absolutePath, isDot);\r\n        }\r\n        if (stat && stat.isFile()) {\r\n            return this._iterateFilesWithFile(absolutePath);\r\n        }\r\n        if (globInputPaths && isGlobPattern(pattern)) {\r\n            return this._iterateFilesWithGlob(absolutePath, isDot);\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Iterate a file which is matched by a given path.\r\n     * @param {string} filePath The path to the target file.\r\n     * @returns {IterableIterator<FileEntry>} The found files.\r\n     * @private\r\n     */\r\n    _iterateFilesWithFile(filePath) {\r\n        debug(`File: ${filePath}`);\r\n\r\n        const { configArrayFactory } = internalSlotsMap.get(this);\r\n        const config = configArrayFactory.getConfigArrayForFile(filePath);\r\n        const ignored = this._isIgnoredFile(filePath, { config, direct: true });\r\n        const flag = ignored ? IGNORED : NONE;\r\n\r\n        return [{ config, filePath, flag }];\r\n    }\r\n\r\n    /**\r\n     * Iterate files in a given path.\r\n     * @param {string} directoryPath The path to the target directory.\r\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\r\n     * @returns {IterableIterator<FileEntry>} The found files.\r\n     * @private\r\n     */\r\n    _iterateFilesWithDirectory(directoryPath, dotfiles) {\r\n        debug(`Directory: ${directoryPath}`);\r\n\r\n        return this._iterateFilesRecursive(\r\n            directoryPath,\r\n            { dotfiles, recursive: true, selector: null }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Iterate files which are matched by a given glob pattern.\r\n     * @param {string} pattern The glob pattern to iterate files.\r\n     * @param {boolean} dotfiles If `true` then it doesn't skip dot files by default.\r\n     * @returns {IterableIterator<FileEntry>} The found files.\r\n     * @private\r\n     */\r\n    _iterateFilesWithGlob(pattern, dotfiles) {\r\n        debug(`Glob: ${pattern}`);\r\n\r\n        const directoryPath = path.resolve(getGlobParent(pattern));\r\n        const globPart = pattern.slice(directoryPath.length + 1);\r\n\r\n        /*\r\n         * recursive if there are `**` or path separators in the glob part.\r\n         * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.\r\n         */\r\n        const recursive = /\\*\\*|\\/|\\\\/u.test(globPart);\r\n        const selector = new Minimatch(pattern, minimatchOpts);\r\n\r\n        debug(`recursive? ${recursive}`);\r\n\r\n        return this._iterateFilesRecursive(\r\n            directoryPath,\r\n            { dotfiles, recursive, selector }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Iterate files in a given path.\r\n     * @param {string} directoryPath The path to the target directory.\r\n     * @param {Object} options The options to iterate files.\r\n     * @param {boolean} [options.dotfiles] If `true` then it doesn't skip dot files by default.\r\n     * @param {boolean} [options.recursive] If `true` then it dives into sub directories.\r\n     * @param {InstanceType<Minimatch>} [options.selector] The matcher to choose files.\r\n     * @returns {IterableIterator<FileEntry>} The found files.\r\n     * @private\r\n     */\r\n    *_iterateFilesRecursive(directoryPath, options) {\r\n        debug(`Enter the directory: ${directoryPath}`);\r\n        const { configArrayFactory } = internalSlotsMap.get(this);\r\n\r\n        /** @type {ConfigArray|null} */\r\n        let config = null;\r\n\r\n        // Enumerate the files of this directory.\r\n        for (const entry of readdirSafeSync(directoryPath)) {\r\n            const filePath = path.join(directoryPath, entry.name);\r\n            const fileInfo = entry.isSymbolicLink() ? statSafeSync(filePath) : entry;\r\n\r\n            if (!fileInfo) {\r\n                continue;\r\n            }\r\n\r\n            // Check if the file is matched.\r\n            if (fileInfo.isFile()) {\r\n                if (!config) {\r\n                    config = configArrayFactory.getConfigArrayForFile(\r\n                        filePath,\r\n\r\n                        /*\r\n                         * We must ignore `ConfigurationNotFoundError` at this\r\n                         * point because we don't know if target files exist in\r\n                         * this directory.\r\n                         */\r\n                        { ignoreNotFoundError: true }\r\n                    );\r\n                }\r\n                const matched = options.selector\r\n\r\n                    // Started with a glob pattern; choose by the pattern.\r\n                    ? options.selector.match(filePath)\r\n\r\n                    // Started with a directory path; choose by file extensions.\r\n                    : this.isTargetPath(filePath, config);\r\n\r\n                if (matched) {\r\n                    const ignored = this._isIgnoredFile(filePath, { ...options, config });\r\n                    const flag = ignored ? IGNORED_SILENTLY : NONE;\r\n\r\n                    debug(`Yield: ${entry.name}${ignored ? \" but ignored\" : \"\"}`);\r\n                    yield {\r\n                        config: configArrayFactory.getConfigArrayForFile(filePath),\r\n                        filePath,\r\n                        flag\r\n                    };\r\n                } else {\r\n                    debug(`Didn't match: ${entry.name}`);\r\n                }\r\n\r\n            // Dive into the sub directory.\r\n            } else if (options.recursive && fileInfo.isDirectory()) {\r\n                if (!config) {\r\n                    config = configArrayFactory.getConfigArrayForFile(\r\n                        filePath,\r\n                        { ignoreNotFoundError: true }\r\n                    );\r\n                }\r\n                const ignored = this._isIgnoredFile(\r\n                    filePath + path.sep,\r\n                    { ...options, config }\r\n                );\r\n\r\n                if (!ignored) {\r\n                    yield* this._iterateFilesRecursive(filePath, options);\r\n                }\r\n            }\r\n        }\r\n\r\n        debug(`Leave the directory: ${directoryPath}`);\r\n    }\r\n\r\n    /**\r\n     * Check if a given file should be ignored.\r\n     * @param {string} filePath The path to a file to check.\r\n     * @param {Object} options Options\r\n     * @param {ConfigArray} [options.config] The config for this file.\r\n     * @param {boolean} [options.dotfiles] If `true` then this is not ignore dot files by default.\r\n     * @param {boolean} [options.direct] If `true` then this is a direct specified file.\r\n     * @returns {boolean} `true` if the file should be ignored.\r\n     * @private\r\n     */\r\n    _isIgnoredFile(filePath, {\r\n        config: providedConfig,\r\n        dotfiles = false,\r\n        direct = false\r\n    }) {\r\n        const {\r\n            configArrayFactory,\r\n            defaultIgnores,\r\n            ignoreFlag\r\n        } = internalSlotsMap.get(this);\r\n\r\n        if (ignoreFlag) {\r\n            const config =\r\n                providedConfig ||\r\n                configArrayFactory.getConfigArrayForFile(\r\n                    filePath,\r\n                    { ignoreNotFoundError: true }\r\n                );\r\n            const ignores =\r\n                config.extractConfig(filePath).ignores || defaultIgnores;\r\n\r\n            return ignores(filePath, dotfiles);\r\n        }\r\n\r\n        return !direct && defaultIgnores(filePath, dotfiles);\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nmodule.exports = { FileEnumerator };\r\n"]},"metadata":{},"sourceType":"script"}