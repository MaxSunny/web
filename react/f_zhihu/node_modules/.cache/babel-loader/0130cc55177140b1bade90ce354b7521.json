{"ast":null,"code":"// Generated by LiveScript 1.6.0\n(function () {\n  var parsedTypeCheck,\n      types,\n      toString$ = {}.toString;\n  parsedTypeCheck = require('type-check').parsedTypeCheck;\n  types = {\n    '*': function (value, options) {\n      switch (toString$.call(value).slice(8, -1)) {\n        case 'Array':\n          return typeCast(value, {\n            type: 'Array'\n          }, options);\n\n        case 'Object':\n          return typeCast(value, {\n            type: 'Object'\n          }, options);\n\n        default:\n          return {\n            type: 'Just',\n            value: typesCast(value, [{\n              type: 'Undefined'\n            }, {\n              type: 'Null'\n            }, {\n              type: 'NaN'\n            }, {\n              type: 'Boolean'\n            }, {\n              type: 'Number'\n            }, {\n              type: 'Date'\n            }, {\n              type: 'RegExp'\n            }, {\n              type: 'Array'\n            }, {\n              type: 'Object'\n            }, {\n              type: 'String'\n            }], (options.explicit = true, options))\n          };\n      }\n    },\n    Undefined: function (it) {\n      if (it === 'undefined' || it === void 8) {\n        return {\n          type: 'Just',\n          value: void 8\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Null: function (it) {\n      if (it === 'null') {\n        return {\n          type: 'Just',\n          value: null\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    NaN: function (it) {\n      if (it === 'NaN') {\n        return {\n          type: 'Just',\n          value: NaN\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Boolean: function (it) {\n      if (it === 'true') {\n        return {\n          type: 'Just',\n          value: true\n        };\n      } else if (it === 'false') {\n        return {\n          type: 'Just',\n          value: false\n        };\n      } else {\n        return {\n          type: 'Nothing'\n        };\n      }\n    },\n    Number: function (it) {\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Int: function (it) {\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Float: function (it) {\n      return {\n        type: 'Just',\n        value: +it\n      };\n    },\n    Date: function (value, options) {\n      var that;\n\n      if (that = /^\\#([\\s\\S]*)\\#$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new Date(+that[1] || that[1])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new Date(+value || value)\n        };\n      }\n    },\n    RegExp: function (value, options) {\n      var that;\n\n      if (that = /^\\/([\\s\\S]*)\\/([gimy]*)$/.exec(value)) {\n        return {\n          type: 'Just',\n          value: new RegExp(that[1], that[2])\n        };\n      } else if (options.explicit) {\n        return {\n          type: 'Nothing'\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: new RegExp(value)\n        };\n      }\n    },\n    Array: function (value, options) {\n      return castArray(value, {\n        of: [{\n          type: '*'\n        }]\n      }, options);\n    },\n    Object: function (value, options) {\n      return castFields(value, {\n        of: {}\n      }, options);\n    },\n    String: function (it) {\n      var replace, that;\n\n      if (toString$.call(it).slice(8, -1) !== 'String') {\n        return {\n          type: 'Nothing'\n        };\n      }\n\n      replace = function (value, quote) {\n        return value.replace(/\\\\([^u]|u[0-9a-fA-F]{4})/g, function (all, escaped) {\n          switch (escaped[0]) {\n            case quote:\n              return quote;\n\n            case '\\\\':\n              return '\\\\';\n\n            case 'b':\n              return '\\b';\n\n            case 'f':\n              return '\\f';\n\n            case 'n':\n              return '\\n';\n\n            case 'r':\n              return '\\r';\n\n            case 't':\n              return '\\t';\n\n            case 'u':\n              return JSON.parse(\"\\\"\" + all + \"\\\"\");\n\n            default:\n              return escaped;\n          }\n        });\n      };\n\n      if (that = it.match(/^'([\\s\\S]*)'$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], \"'\")\n        };\n      } else if (that = it.match(/^\"([\\s\\S]*)\"$/)) {\n        return {\n          type: 'Just',\n          value: replace(that[1], '\"')\n        };\n      } else {\n        return {\n          type: 'Just',\n          value: it\n        };\n      }\n    }\n  };\n\n  function castArray(node, type, options) {\n    var typeOf, element;\n\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: function () {\n        var i$,\n            ref$,\n            len$,\n            results$ = [];\n\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\n          element = ref$[i$];\n          results$.push(typesCast(element, typeOf, options));\n        }\n\n        return results$;\n      }()\n    };\n  }\n\n  function castTuple(node, type, options) {\n    var result, i, i$, ref$, len$, types, cast;\n\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    result = [];\n    i = 0;\n\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\n      types = ref$[i$];\n      cast = typesCast(node[i], types, options);\n\n      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {\n        result.push(cast);\n      }\n\n      i++;\n    }\n\n    if (node.length <= i) {\n      return {\n        type: 'Just',\n        value: result\n      };\n    } else {\n      return {\n        type: 'Nothing'\n      };\n    }\n  }\n\n  function castFields(node, type, options) {\n    var typeOf, key, value;\n\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\n      return {\n        type: 'Nothing'\n      };\n    }\n\n    typeOf = type.of;\n    return {\n      type: 'Just',\n      value: function () {\n        var ref$,\n            resultObj$ = {};\n\n        for (key in ref$ = node) {\n          value = ref$[key];\n          resultObj$[typesCast(key, [{\n            type: 'String'\n          }], options)] = typesCast(value, typeOf[key] || [{\n            type: '*'\n          }], options);\n        }\n\n        return resultObj$;\n      }()\n    };\n  }\n\n  function typeCast(node, typeObj, options) {\n    var type, structure, castFunc, ref$;\n    type = typeObj.type, structure = typeObj.structure;\n\n    if (type) {\n      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];\n\n      if (!castFunc) {\n        throw new Error(\"Type not defined: \" + type + \".\");\n      }\n\n      return castFunc(node, options, typesCast);\n    } else {\n      switch (structure) {\n        case 'array':\n          return castArray(node, typeObj, options);\n\n        case 'tuple':\n          return castTuple(node, typeObj, options);\n\n        case 'fields':\n          return castFields(node, typeObj, options);\n      }\n    }\n  }\n\n  function typesCast(node, types, options) {\n    var i$, len$, type, ref$, valueType, value;\n\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\n      type = types[i$];\n      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;\n\n      if (valueType === 'Nothing') {\n        continue;\n      }\n\n      if (parsedTypeCheck([type], value, {\n        customTypes: options.customTypes\n      })) {\n        return value;\n      }\n    }\n\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\n  }\n\n  module.exports = function (node, types, options) {\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\n      return node;\n    }\n\n    return typesCast(node, types, options);\n  };\n}).call(this);","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/levn/lib/cast.js"],"names":["parsedTypeCheck","types","toString$","toString","require","value","options","call","slice","typeCast","type","typesCast","explicit","Undefined","it","Null","NaN","Boolean","Number","Int","Float","Date","that","exec","RegExp","Array","castArray","of","Object","castFields","String","replace","quote","all","escaped","JSON","parse","match","node","typeOf","element","i$","ref$","len$","results$","length","push","castTuple","result","i","cast","key","resultObj$","typeObj","structure","castFunc","customTypes","Error","valueType","stringify","module","exports"],"mappings":"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","sourcesContent":["// Generated by LiveScript 1.6.0\r\n(function(){\r\n  var parsedTypeCheck, types, toString$ = {}.toString;\r\n  parsedTypeCheck = require('type-check').parsedTypeCheck;\r\n  types = {\r\n    '*': function(value, options){\r\n      switch (toString$.call(value).slice(8, -1)) {\r\n      case 'Array':\r\n        return typeCast(value, {\r\n          type: 'Array'\r\n        }, options);\r\n      case 'Object':\r\n        return typeCast(value, {\r\n          type: 'Object'\r\n        }, options);\r\n      default:\r\n        return {\r\n          type: 'Just',\r\n          value: typesCast(value, [\r\n            {\r\n              type: 'Undefined'\r\n            }, {\r\n              type: 'Null'\r\n            }, {\r\n              type: 'NaN'\r\n            }, {\r\n              type: 'Boolean'\r\n            }, {\r\n              type: 'Number'\r\n            }, {\r\n              type: 'Date'\r\n            }, {\r\n              type: 'RegExp'\r\n            }, {\r\n              type: 'Array'\r\n            }, {\r\n              type: 'Object'\r\n            }, {\r\n              type: 'String'\r\n            }\r\n          ], (options.explicit = true, options))\r\n        };\r\n      }\r\n    },\r\n    Undefined: function(it){\r\n      if (it === 'undefined' || it === void 8) {\r\n        return {\r\n          type: 'Just',\r\n          value: void 8\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      }\r\n    },\r\n    Null: function(it){\r\n      if (it === 'null') {\r\n        return {\r\n          type: 'Just',\r\n          value: null\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      }\r\n    },\r\n    NaN: function(it){\r\n      if (it === 'NaN') {\r\n        return {\r\n          type: 'Just',\r\n          value: NaN\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      }\r\n    },\r\n    Boolean: function(it){\r\n      if (it === 'true') {\r\n        return {\r\n          type: 'Just',\r\n          value: true\r\n        };\r\n      } else if (it === 'false') {\r\n        return {\r\n          type: 'Just',\r\n          value: false\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      }\r\n    },\r\n    Number: function(it){\r\n      return {\r\n        type: 'Just',\r\n        value: +it\r\n      };\r\n    },\r\n    Int: function(it){\r\n      return {\r\n        type: 'Just',\r\n        value: +it\r\n      };\r\n    },\r\n    Float: function(it){\r\n      return {\r\n        type: 'Just',\r\n        value: +it\r\n      };\r\n    },\r\n    Date: function(value, options){\r\n      var that;\r\n      if (that = /^\\#([\\s\\S]*)\\#$/.exec(value)) {\r\n        return {\r\n          type: 'Just',\r\n          value: new Date(+that[1] || that[1])\r\n        };\r\n      } else if (options.explicit) {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Just',\r\n          value: new Date(+value || value)\r\n        };\r\n      }\r\n    },\r\n    RegExp: function(value, options){\r\n      var that;\r\n      if (that = /^\\/([\\s\\S]*)\\/([gimy]*)$/.exec(value)) {\r\n        return {\r\n          type: 'Just',\r\n          value: new RegExp(that[1], that[2])\r\n        };\r\n      } else if (options.explicit) {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Just',\r\n          value: new RegExp(value)\r\n        };\r\n      }\r\n    },\r\n    Array: function(value, options){\r\n      return castArray(value, {\r\n        of: [{\r\n          type: '*'\r\n        }]\r\n      }, options);\r\n    },\r\n    Object: function(value, options){\r\n      return castFields(value, {\r\n        of: {}\r\n      }, options);\r\n    },\r\n    String: function(it){\r\n      var replace, that;\r\n      if (toString$.call(it).slice(8, -1) !== 'String') {\r\n        return {\r\n          type: 'Nothing'\r\n        };\r\n      }\r\n      replace = function(value, quote){\r\n        return value.replace(/\\\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped){\r\n          switch (escaped[0]) {\r\n          case quote:\r\n            return quote;\r\n          case '\\\\':\r\n            return '\\\\';\r\n          case 'b':\r\n            return '\\b';\r\n          case 'f':\r\n            return '\\f';\r\n          case 'n':\r\n            return '\\n';\r\n          case 'r':\r\n            return '\\r';\r\n          case 't':\r\n            return '\\t';\r\n          case 'u':\r\n            return JSON.parse(\"\\\"\" + all + \"\\\"\");\r\n          default:\r\n            return escaped;\r\n          }\r\n        });\r\n      };\r\n      if (that = it.match(/^'([\\s\\S]*)'$/)) {\r\n        return {\r\n          type: 'Just',\r\n          value: replace(that[1], \"'\")\r\n        };\r\n      } else if (that = it.match(/^\"([\\s\\S]*)\"$/)) {\r\n        return {\r\n          type: 'Just',\r\n          value: replace(that[1], '\"')\r\n        };\r\n      } else {\r\n        return {\r\n          type: 'Just',\r\n          value: it\r\n        };\r\n      }\r\n    }\r\n  };\r\n  function castArray(node, type, options){\r\n    var typeOf, element;\r\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\r\n      return {\r\n        type: 'Nothing'\r\n      };\r\n    }\r\n    typeOf = type.of;\r\n    return {\r\n      type: 'Just',\r\n      value: (function(){\r\n        var i$, ref$, len$, results$ = [];\r\n        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {\r\n          element = ref$[i$];\r\n          results$.push(typesCast(element, typeOf, options));\r\n        }\r\n        return results$;\r\n      }())\r\n    };\r\n  }\r\n  function castTuple(node, type, options){\r\n    var result, i, i$, ref$, len$, types, cast;\r\n    if (toString$.call(node).slice(8, -1) !== 'Array') {\r\n      return {\r\n        type: 'Nothing'\r\n      };\r\n    }\r\n    result = [];\r\n    i = 0;\r\n    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {\r\n      types = ref$[i$];\r\n      cast = typesCast(node[i], types, options);\r\n      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {\r\n        result.push(cast);\r\n      }\r\n      i++;\r\n    }\r\n    if (node.length <= i) {\r\n      return {\r\n        type: 'Just',\r\n        value: result\r\n      };\r\n    } else {\r\n      return {\r\n        type: 'Nothing'\r\n      };\r\n    }\r\n  }\r\n  function castFields(node, type, options){\r\n    var typeOf, key, value;\r\n    if (toString$.call(node).slice(8, -1) !== 'Object') {\r\n      return {\r\n        type: 'Nothing'\r\n      };\r\n    }\r\n    typeOf = type.of;\r\n    return {\r\n      type: 'Just',\r\n      value: (function(){\r\n        var ref$, resultObj$ = {};\r\n        for (key in ref$ = node) {\r\n          value = ref$[key];\r\n          resultObj$[typesCast(key, [{\r\n            type: 'String'\r\n          }], options)] = typesCast(value, typeOf[key] || [{\r\n            type: '*'\r\n          }], options);\r\n        }\r\n        return resultObj$;\r\n      }())\r\n    };\r\n  }\r\n  function typeCast(node, typeObj, options){\r\n    var type, structure, castFunc, ref$;\r\n    type = typeObj.type, structure = typeObj.structure;\r\n    if (type) {\r\n      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];\r\n      if (!castFunc) {\r\n        throw new Error(\"Type not defined: \" + type + \".\");\r\n      }\r\n      return castFunc(node, options, typesCast);\r\n    } else {\r\n      switch (structure) {\r\n      case 'array':\r\n        return castArray(node, typeObj, options);\r\n      case 'tuple':\r\n        return castTuple(node, typeObj, options);\r\n      case 'fields':\r\n        return castFields(node, typeObj, options);\r\n      }\r\n    }\r\n  }\r\n  function typesCast(node, types, options){\r\n    var i$, len$, type, ref$, valueType, value;\r\n    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {\r\n      type = types[i$];\r\n      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;\r\n      if (valueType === 'Nothing') {\r\n        continue;\r\n      }\r\n      if (parsedTypeCheck([type], value, {\r\n        customTypes: options.customTypes\r\n      })) {\r\n        return value;\r\n      }\r\n    }\r\n    throw new Error(\"Value \" + JSON.stringify(node) + \" does not type check against \" + JSON.stringify(types) + \".\");\r\n  }\r\n  module.exports = function(node, types, options){\r\n    if (!options.explicit && types.length === 1 && types[0].type === 'String') {\r\n      return node;\r\n    }\r\n    return typesCast(node, types, options);\r\n  };\r\n}).call(this);\r\n"]},"metadata":{},"sourceType":"script"}