{"ast":null,"code":"/**\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\n\"use strict\";\n\nconst {\n  CALL,\n  CONSTRUCT,\n  ReferenceTracker,\n  getStringIfConstant\n} = require(\"eslint-utils\");\n\nconst {\n  RegExpParser,\n  visitRegExpAST\n} = require(\"regexpp\");\n\nconst {\n  isCombiningCharacter,\n  isEmojiModifier,\n  isRegionalIndicatorSymbol,\n  isSurrogatePair\n} = require(\"./utils/unicode\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Iterate character sequences of a given nodes.\r\n *\r\n * CharacterClassRange syntax can steal a part of character sequence,\r\n * so this function reverts CharacterClassRange syntax and restore the sequence.\r\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\r\n * @returns {IterableIterator<number[]>} The list of character sequences.\r\n */\n\n\nfunction* iterateCharacterSequence(nodes) {\n  let seq = [];\n\n  for (const node of nodes) {\n    switch (node.type) {\n      case \"Character\":\n        seq.push(node.value);\n        break;\n\n      case \"CharacterClassRange\":\n        seq.push(node.min.value);\n        yield seq;\n        seq = [node.max.value];\n        break;\n\n      case \"CharacterSet\":\n        if (seq.length > 0) {\n          yield seq;\n          seq = [];\n        }\n\n        break;\n      // no default\n    }\n  }\n\n  if (seq.length > 0) {\n    yield seq;\n  }\n}\n\nconst hasCharacterSequence = {\n  surrogatePairWithoutUFlag(chars) {\n    return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\n  },\n\n  combiningClass(chars) {\n    return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));\n  },\n\n  emojiModifier(chars) {\n    return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));\n  },\n\n  regionalIndicatorSymbol(chars) {\n    return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));\n  },\n\n  zwj(chars) {\n    const lastIndex = chars.length - 1;\n    return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 0x200d && chars[i - 1] !== 0x200d && chars[i + 1] !== 0x200d);\n  }\n\n};\nconst kinds = Object.keys(hasCharacterSequence); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow characters which are made with multiple code points in character class syntax\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\n    },\n    schema: [],\n    messages: {\n      surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\n      combiningClass: \"Unexpected combined character in character class.\",\n      emojiModifier: \"Unexpected modified Emoji in character class.\",\n      regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\n      zwj: \"Unexpected joined character sequence in character class.\"\n    }\n  },\n\n  create(context) {\n    const parser = new RegExpParser();\n    /**\r\n     * Verify a given regular expression.\r\n     * @param {Node} node The node to report.\r\n     * @param {string} pattern The regular expression pattern to verify.\r\n     * @param {string} flags The flags of the regular expression.\r\n     * @returns {void}\r\n     */\n\n    function verify(node, pattern, flags) {\n      const has = {\n        surrogatePairWithoutUFlag: false,\n        combiningClass: false,\n        variationSelector: false,\n        emojiModifier: false,\n        regionalIndicatorSymbol: false,\n        zwj: false\n      };\n      let patternNode;\n\n      try {\n        patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes(\"u\"));\n      } catch {\n        // Ignore regular expressions with syntax errors\n        return;\n      }\n\n      visitRegExpAST(patternNode, {\n        onCharacterClassEnter(ccNode) {\n          for (const chars of iterateCharacterSequence(ccNode.elements)) {\n            for (const kind of kinds) {\n              has[kind] = has[kind] || hasCharacterSequence[kind](chars);\n            }\n          }\n        }\n\n      });\n\n      for (const kind of kinds) {\n        if (has[kind]) {\n          context.report({\n            node,\n            messageId: kind\n          });\n        }\n      }\n    }\n\n    return {\n      \"Literal[regex]\"(node) {\n        verify(node, node.regex.pattern, node.regex.flags);\n      },\n\n      \"Program\"() {\n        const scope = context.getScope();\n        const tracker = new ReferenceTracker(scope);\n        /*\r\n         * Iterate calls of RegExp.\r\n         * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\r\n         *       `const {RegExp: a} = window; new a()`, etc...\r\n         */\n\n        for (const {\n          node\n        } of tracker.iterateGlobalReferences({\n          RegExp: {\n            [CALL]: true,\n            [CONSTRUCT]: true\n          }\n        })) {\n          const [patternNode, flagsNode] = node.arguments;\n          const pattern = getStringIfConstant(patternNode, scope);\n          const flags = getStringIfConstant(flagsNode, scope);\n\n          if (typeof pattern === \"string\") {\n            verify(node, pattern, flags || \"\");\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-misleading-character-class.js"],"names":["CALL","CONSTRUCT","ReferenceTracker","getStringIfConstant","require","RegExpParser","visitRegExpAST","isCombiningCharacter","isEmojiModifier","isRegionalIndicatorSymbol","isSurrogatePair","iterateCharacterSequence","nodes","seq","node","type","push","value","min","max","length","hasCharacterSequence","surrogatePairWithoutUFlag","chars","some","c","i","combiningClass","emojiModifier","regionalIndicatorSymbol","zwj","lastIndex","kinds","Object","keys","module","exports","meta","docs","description","recommended","url","schema","messages","create","context","parser","verify","pattern","flags","has","variationSelector","patternNode","parsePattern","includes","onCharacterClassEnter","ccNode","elements","kind","report","messageId","regex","scope","getScope","tracker","iterateGlobalReferences","RegExp","flagsNode","arguments"],"mappings":"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","sourcesContent":["/**\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\r\n\"use strict\";\r\n\r\nconst { CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant } = require(\"eslint-utils\");\r\nconst { RegExpParser, visitRegExpAST } = require(\"regexpp\");\r\nconst { isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair } = require(\"./utils/unicode\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Iterate character sequences of a given nodes.\r\n *\r\n * CharacterClassRange syntax can steal a part of character sequence,\r\n * so this function reverts CharacterClassRange syntax and restore the sequence.\r\n * @param {regexpp.AST.CharacterClassElement[]} nodes The node list to iterate character sequences.\r\n * @returns {IterableIterator<number[]>} The list of character sequences.\r\n */\r\nfunction *iterateCharacterSequence(nodes) {\r\n    let seq = [];\r\n\r\n    for (const node of nodes) {\r\n        switch (node.type) {\r\n            case \"Character\":\r\n                seq.push(node.value);\r\n                break;\r\n\r\n            case \"CharacterClassRange\":\r\n                seq.push(node.min.value);\r\n                yield seq;\r\n                seq = [node.max.value];\r\n                break;\r\n\r\n            case \"CharacterSet\":\r\n                if (seq.length > 0) {\r\n                    yield seq;\r\n                    seq = [];\r\n                }\r\n                break;\r\n\r\n            // no default\r\n        }\r\n    }\r\n\r\n    if (seq.length > 0) {\r\n        yield seq;\r\n    }\r\n}\r\n\r\nconst hasCharacterSequence = {\r\n    surrogatePairWithoutUFlag(chars) {\r\n        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));\r\n    },\r\n\r\n    combiningClass(chars) {\r\n        return chars.some((c, i) => (\r\n            i !== 0 &&\r\n            isCombiningCharacter(c) &&\r\n            !isCombiningCharacter(chars[i - 1])\r\n        ));\r\n    },\r\n\r\n    emojiModifier(chars) {\r\n        return chars.some((c, i) => (\r\n            i !== 0 &&\r\n            isEmojiModifier(c) &&\r\n            !isEmojiModifier(chars[i - 1])\r\n        ));\r\n    },\r\n\r\n    regionalIndicatorSymbol(chars) {\r\n        return chars.some((c, i) => (\r\n            i !== 0 &&\r\n            isRegionalIndicatorSymbol(c) &&\r\n            isRegionalIndicatorSymbol(chars[i - 1])\r\n        ));\r\n    },\r\n\r\n    zwj(chars) {\r\n        const lastIndex = chars.length - 1;\r\n\r\n        return chars.some((c, i) => (\r\n            i !== 0 &&\r\n            i !== lastIndex &&\r\n            c === 0x200d &&\r\n            chars[i - 1] !== 0x200d &&\r\n            chars[i + 1] !== 0x200d\r\n        ));\r\n    }\r\n};\r\n\r\nconst kinds = Object.keys(hasCharacterSequence);\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow characters which are made with multiple code points in character class syntax\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-misleading-character-class\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            surrogatePairWithoutUFlag: \"Unexpected surrogate pair in character class. Use 'u' flag.\",\r\n            combiningClass: \"Unexpected combined character in character class.\",\r\n            emojiModifier: \"Unexpected modified Emoji in character class.\",\r\n            regionalIndicatorSymbol: \"Unexpected national flag in character class.\",\r\n            zwj: \"Unexpected joined character sequence in character class.\"\r\n        }\r\n    },\r\n    create(context) {\r\n        const parser = new RegExpParser();\r\n\r\n        /**\r\n         * Verify a given regular expression.\r\n         * @param {Node} node The node to report.\r\n         * @param {string} pattern The regular expression pattern to verify.\r\n         * @param {string} flags The flags of the regular expression.\r\n         * @returns {void}\r\n         */\r\n        function verify(node, pattern, flags) {\r\n            const has = {\r\n                surrogatePairWithoutUFlag: false,\r\n                combiningClass: false,\r\n                variationSelector: false,\r\n                emojiModifier: false,\r\n                regionalIndicatorSymbol: false,\r\n                zwj: false\r\n            };\r\n            let patternNode;\r\n\r\n            try {\r\n                patternNode = parser.parsePattern(\r\n                    pattern,\r\n                    0,\r\n                    pattern.length,\r\n                    flags.includes(\"u\")\r\n                );\r\n            } catch {\r\n\r\n                // Ignore regular expressions with syntax errors\r\n                return;\r\n            }\r\n\r\n            visitRegExpAST(patternNode, {\r\n                onCharacterClassEnter(ccNode) {\r\n                    for (const chars of iterateCharacterSequence(ccNode.elements)) {\r\n                        for (const kind of kinds) {\r\n                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n\r\n            for (const kind of kinds) {\r\n                if (has[kind]) {\r\n                    context.report({ node, messageId: kind });\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"Literal[regex]\"(node) {\r\n                verify(node, node.regex.pattern, node.regex.flags);\r\n            },\r\n            \"Program\"() {\r\n                const scope = context.getScope();\r\n                const tracker = new ReferenceTracker(scope);\r\n\r\n                /*\r\n                 * Iterate calls of RegExp.\r\n                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,\r\n                 *       `const {RegExp: a} = window; new a()`, etc...\r\n                 */\r\n                for (const { node } of tracker.iterateGlobalReferences({\r\n                    RegExp: { [CALL]: true, [CONSTRUCT]: true }\r\n                })) {\r\n                    const [patternNode, flagsNode] = node.arguments;\r\n                    const pattern = getStringIfConstant(patternNode, scope);\r\n                    const flags = getStringIfConstant(flagsNode, scope);\r\n\r\n                    if (typeof pattern === \"string\") {\r\n                        verify(node, pattern, flags || \"\");\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}