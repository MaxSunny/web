{"ast":null,"code":"/**\r\n * @fileoverview A rule to choose between single and double quote marks\r\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst QUOTE_SETTINGS = {\n  double: {\n    quote: \"\\\"\",\n    alternateQuote: \"'\",\n    description: \"doublequote\"\n  },\n  single: {\n    quote: \"'\",\n    alternateQuote: \"\\\"\",\n    description: \"singlequote\"\n  },\n  backtick: {\n    quote: \"`\",\n    alternateQuote: \"\\\"\",\n    description: \"backtick\"\n  }\n}; // An unescaped newline is a newline preceded by an even number of backslashes.\n\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\n/**\r\n * Switches quoting of javascript string between ' \" and `\r\n * escaping and unescaping as necessary.\r\n * Only escaping of the minimal set of characters is changed.\r\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\r\n * @param {string} str A string to convert.\r\n * @returns {string} The string with changed quotes.\r\n * @private\r\n */\n\nQUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function (str) {\n  const newQuote = this.quote;\n  const oldQuote = str[0];\n\n  if (newQuote === oldQuote) {\n    return str;\n  }\n\n  return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\n    if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n      return escaped; // unescape\n    }\n\n    if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n      return `\\\\${match}`; // escape\n    }\n\n    if (newline && oldQuote === \"`\") {\n      return \"\\\\n\"; // escape newlines\n    }\n\n    return match;\n  }) + newQuote;\n};\n\nconst AVOID_ESCAPE = \"avoid-escape\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce the consistent use of either backticks, double, or single quotes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/quotes\"\n    },\n    fixable: \"code\",\n    schema: [{\n      enum: [\"single\", \"double\", \"backtick\"]\n    }, {\n      anyOf: [{\n        enum: [\"avoid-escape\"]\n      }, {\n        type: \"object\",\n        properties: {\n          avoidEscape: {\n            type: \"boolean\"\n          },\n          allowTemplateLiterals: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      wrongQuotes: \"Strings must use {{description}}.\"\n    }\n  },\n\n  create(context) {\n    const quoteOption = context.options[0],\n          settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n          options = context.options[1],\n          allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n          sourceCode = context.getSourceCode();\n    let avoidEscape = options && options.avoidEscape === true; // deprecated\n\n    if (options === AVOID_ESCAPE) {\n      avoidEscape = true;\n    }\n    /**\r\n     * Determines if a given node is part of JSX syntax.\r\n     *\r\n     * This function returns `true` in the following cases:\r\n     *\r\n     * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\r\n     * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\r\n     * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\r\n     *\r\n     * In particular, this function returns `false` in the following cases:\r\n     *\r\n     * - `<div className={\"foo\"}></div>`\r\n     * - `<div>{\"foo\"}</div>`\r\n     *\r\n     * In both cases, inside of the braces is handled as normal JavaScript.\r\n     * The braces are `JSXExpressionContainer` nodes.\r\n     * @param {ASTNode} node The Literal node to check.\r\n     * @returns {boolean} True if the node is a part of JSX, false if not.\r\n     * @private\r\n     */\n\n\n    function isJSXLiteral(node) {\n      return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\n    }\n    /**\r\n     * Checks whether or not a given node is a directive.\r\n     * The directive is a `ExpressionStatement` which has only a string literal.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} Whether or not the node is a directive.\r\n     * @private\r\n     */\n\n\n    function isDirective(node) {\n      return node.type === \"ExpressionStatement\" && node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n    }\n    /**\r\n     * Checks whether or not a given node is a part of directive prologues.\r\n     * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} Whether or not the node is a part of directive prologues.\r\n     * @private\r\n     */\n\n\n    function isPartOfDirectivePrologue(node) {\n      const block = node.parent.parent;\n\n      if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\n        return false;\n      } // Check the node is at a prologue.\n\n\n      for (let i = 0; i < block.body.length; ++i) {\n        const statement = block.body[i];\n\n        if (statement === node.parent) {\n          return true;\n        }\n\n        if (!isDirective(statement)) {\n          break;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether or not a given node is allowed as non backtick.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} Whether or not the node is allowed as non backtick.\r\n     * @private\r\n     */\n\n\n    function isAllowedAsNonBacktick(node) {\n      const parent = node.parent;\n\n      switch (parent.type) {\n        // Directive Prologues.\n        case \"ExpressionStatement\":\n          return isPartOfDirectivePrologue(node);\n        // LiteralPropertyName.\n\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n          return parent.key === node && !parent.computed;\n        // ModuleSpecifier.\n\n        case \"ImportDeclaration\":\n        case \"ExportNamedDeclaration\":\n          return parent.source === node;\n        // ModuleExportName or ModuleSpecifier.\n\n        case \"ExportAllDeclaration\":\n          return parent.exported === node || parent.source === node;\n        // ModuleExportName.\n\n        case \"ImportSpecifier\":\n          return parent.imported === node;\n        // ModuleExportName.\n\n        case \"ExportSpecifier\":\n          return parent.local === node || parent.exported === node;\n        // Others don't allow.\n\n        default:\n          return false;\n      }\n    }\n    /**\r\n     * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\r\n     * @param {ASTNode} node A TemplateLiteral node to check.\r\n     * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\r\n     * @private\r\n     */\n\n\n    function isUsingFeatureOfTemplateLiteral(node) {\n      const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\n\n      if (hasTag) {\n        return true;\n      }\n\n      const hasStringInterpolation = node.expressions.length > 0;\n\n      if (hasStringInterpolation) {\n        return true;\n      }\n\n      const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\n\n      if (isMultilineString) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return {\n      Literal(node) {\n        const val = node.value,\n              rawVal = node.raw;\n\n        if (settings && typeof val === \"string\") {\n          let isValid = quoteOption === \"backtick\" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);\n\n          if (!isValid && avoidEscape) {\n            isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n          }\n\n          if (!isValid) {\n            context.report({\n              node,\n              messageId: \"wrongQuotes\",\n              data: {\n                description: settings.description\n              },\n\n              fix(fixer) {\n                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\n                  /*\r\n                   * An octal or non-octal decimal escape sequence in a template literal would\r\n                   * produce syntax error, even in non-strict mode.\r\n                   */\n                  return null;\n                }\n\n                return fixer.replaceText(node, settings.convert(node.raw));\n              }\n\n            });\n          }\n        }\n      },\n\n      TemplateLiteral(node) {\n        // Don't throw an error if backticks are expected or a template literal feature is in use.\n        if (allowTemplateLiterals || quoteOption === \"backtick\" || isUsingFeatureOfTemplateLiteral(node)) {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"wrongQuotes\",\n          data: {\n            description: settings.description\n          },\n\n          fix(fixer) {\n            if (isPartOfDirectivePrologue(node)) {\n              /*\r\n               * TemplateLiterals in a directive prologue aren't actually directives, but if they're\r\n               * in the directive prologue, then fixing them might turn them into directives and change\r\n               * the behavior of the code.\r\n               */\n              return null;\n            }\n\n            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n          }\n\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/quotes.js"],"names":["astUtils","require","QUOTE_SETTINGS","double","quote","alternateQuote","description","single","backtick","UNESCAPED_LINEBREAK_PATTERN","RegExp","String","raw","Array","from","LINEBREAKS","join","convert","str","newQuote","oldQuote","slice","replace","match","escaped","newline","AVOID_ESCAPE","module","exports","meta","type","docs","recommended","url","fixable","schema","enum","anyOf","properties","avoidEscape","allowTemplateLiterals","additionalProperties","messages","wrongQuotes","create","context","quoteOption","options","settings","sourceCode","getSourceCode","isJSXLiteral","node","parent","isDirective","expression","value","isPartOfDirectivePrologue","block","isFunction","i","body","length","statement","isAllowedAsNonBacktick","key","computed","source","exported","imported","local","isUsingFeatureOfTemplateLiteral","hasTag","quasi","hasStringInterpolation","expressions","isMultilineString","quasis","test","Literal","val","rawVal","isValid","isSurroundedBy","indexOf","report","messageId","data","fix","fixer","hasOctalOrNonOctalDecimalEscapeSequence","replaceText","TemplateLiteral","getText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to choose between single and double quote marks\r\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst QUOTE_SETTINGS = {\r\n    double: {\r\n        quote: \"\\\"\",\r\n        alternateQuote: \"'\",\r\n        description: \"doublequote\"\r\n    },\r\n    single: {\r\n        quote: \"'\",\r\n        alternateQuote: \"\\\"\",\r\n        description: \"singlequote\"\r\n    },\r\n    backtick: {\r\n        quote: \"`\",\r\n        alternateQuote: \"\\\"\",\r\n        description: \"backtick\"\r\n    }\r\n};\r\n\r\n// An unescaped newline is a newline preceded by an even number of backslashes.\r\nconst UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\\\])(\\\\\\\\)*[${Array.from(astUtils.LINEBREAKS).join(\"\")}]`, \"u\");\r\n\r\n/**\r\n * Switches quoting of javascript string between ' \" and `\r\n * escaping and unescaping as necessary.\r\n * Only escaping of the minimal set of characters is changed.\r\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\r\n * @param {string} str A string to convert.\r\n * @returns {string} The string with changed quotes.\r\n * @private\r\n */\r\nQUOTE_SETTINGS.double.convert =\r\nQUOTE_SETTINGS.single.convert =\r\nQUOTE_SETTINGS.backtick.convert = function(str) {\r\n    const newQuote = this.quote;\r\n    const oldQuote = str[0];\r\n\r\n    if (newQuote === oldQuote) {\r\n        return str;\r\n    }\r\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\$\\{|\\r\\n?|\\n|.)|[\"'`]|\\$\\{|(\\r\\n?|\\n)/gu, (match, escaped, newline) => {\r\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\r\n            return escaped; // unescape\r\n        }\r\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\r\n            return `\\\\${match}`; // escape\r\n        }\r\n        if (newline && oldQuote === \"`\") {\r\n            return \"\\\\n\"; // escape newlines\r\n        }\r\n        return match;\r\n    }) + newQuote;\r\n};\r\n\r\nconst AVOID_ESCAPE = \"avoid-escape\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/quotes\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"single\", \"double\", \"backtick\"]\r\n            },\r\n            {\r\n                anyOf: [\r\n                    {\r\n                        enum: [\"avoid-escape\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            avoidEscape: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            allowTemplateLiterals: {\r\n                                type: \"boolean\"\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            wrongQuotes: \"Strings must use {{description}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const quoteOption = context.options[0],\r\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\r\n            options = context.options[1],\r\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\r\n            sourceCode = context.getSourceCode();\r\n        let avoidEscape = options && options.avoidEscape === true;\r\n\r\n        // deprecated\r\n        if (options === AVOID_ESCAPE) {\r\n            avoidEscape = true;\r\n        }\r\n\r\n        /**\r\n         * Determines if a given node is part of JSX syntax.\r\n         *\r\n         * This function returns `true` in the following cases:\r\n         *\r\n         * - `<div className=\"foo\"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.\r\n         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.\r\n         * - `<>foo</>` ... If the literal is a text content, the parent of the literal is `JSXFragment`.\r\n         *\r\n         * In particular, this function returns `false` in the following cases:\r\n         *\r\n         * - `<div className={\"foo\"}></div>`\r\n         * - `<div>{\"foo\"}</div>`\r\n         *\r\n         * In both cases, inside of the braces is handled as normal JavaScript.\r\n         * The braces are `JSXExpressionContainer` nodes.\r\n         * @param {ASTNode} node The Literal node to check.\r\n         * @returns {boolean} True if the node is a part of JSX, false if not.\r\n         * @private\r\n         */\r\n        function isJSXLiteral(node) {\r\n            return node.parent.type === \"JSXAttribute\" || node.parent.type === \"JSXElement\" || node.parent.type === \"JSXFragment\";\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given node is a directive.\r\n         * The directive is a `ExpressionStatement` which has only a string literal.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} Whether or not the node is a directive.\r\n         * @private\r\n         */\r\n        function isDirective(node) {\r\n            return (\r\n                node.type === \"ExpressionStatement\" &&\r\n                node.expression.type === \"Literal\" &&\r\n                typeof node.expression.value === \"string\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given node is a part of directive prologues.\r\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\r\n         * @private\r\n         */\r\n        function isPartOfDirectivePrologue(node) {\r\n            const block = node.parent.parent;\r\n\r\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !astUtils.isFunction(block.parent))) {\r\n                return false;\r\n            }\r\n\r\n            // Check the node is at a prologue.\r\n            for (let i = 0; i < block.body.length; ++i) {\r\n                const statement = block.body[i];\r\n\r\n                if (statement === node.parent) {\r\n                    return true;\r\n                }\r\n                if (!isDirective(statement)) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given node is allowed as non backtick.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\r\n         * @private\r\n         */\r\n        function isAllowedAsNonBacktick(node) {\r\n            const parent = node.parent;\r\n\r\n            switch (parent.type) {\r\n\r\n                // Directive Prologues.\r\n                case \"ExpressionStatement\":\r\n                    return isPartOfDirectivePrologue(node);\r\n\r\n                // LiteralPropertyName.\r\n                case \"Property\":\r\n                case \"PropertyDefinition\":\r\n                case \"MethodDefinition\":\r\n                    return parent.key === node && !parent.computed;\r\n\r\n                // ModuleSpecifier.\r\n                case \"ImportDeclaration\":\r\n                case \"ExportNamedDeclaration\":\r\n                    return parent.source === node;\r\n\r\n                // ModuleExportName or ModuleSpecifier.\r\n                case \"ExportAllDeclaration\":\r\n                    return parent.exported === node || parent.source === node;\r\n\r\n                // ModuleExportName.\r\n                case \"ImportSpecifier\":\r\n                    return parent.imported === node;\r\n\r\n                // ModuleExportName.\r\n                case \"ExportSpecifier\":\r\n                    return parent.local === node || parent.exported === node;\r\n\r\n                // Others don't allow.\r\n                default:\r\n                    return false;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether or not a given TemplateLiteral node is actually using any of the special features provided by template literal strings.\r\n         * @param {ASTNode} node A TemplateLiteral node to check.\r\n         * @returns {boolean} Whether or not the TemplateLiteral node is using any of the special features provided by template literal strings.\r\n         * @private\r\n         */\r\n        function isUsingFeatureOfTemplateLiteral(node) {\r\n            const hasTag = node.parent.type === \"TaggedTemplateExpression\" && node === node.parent.quasi;\r\n\r\n            if (hasTag) {\r\n                return true;\r\n            }\r\n\r\n            const hasStringInterpolation = node.expressions.length > 0;\r\n\r\n            if (hasStringInterpolation) {\r\n                return true;\r\n            }\r\n\r\n            const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);\r\n\r\n            if (isMultilineString) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        return {\r\n\r\n            Literal(node) {\r\n                const val = node.value,\r\n                    rawVal = node.raw;\r\n\r\n                if (settings && typeof val === \"string\") {\r\n                    let isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\r\n                        isJSXLiteral(node) ||\r\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\r\n\r\n                    if (!isValid && avoidEscape) {\r\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\r\n                    }\r\n\r\n                    if (!isValid) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"wrongQuotes\",\r\n                            data: {\r\n                                description: settings.description\r\n                            },\r\n                            fix(fixer) {\r\n                                if (quoteOption === \"backtick\" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {\r\n\r\n                                    /*\r\n                                     * An octal or non-octal decimal escape sequence in a template literal would\r\n                                     * produce syntax error, even in non-strict mode.\r\n                                     */\r\n                                    return null;\r\n                                }\r\n\r\n                                return fixer.replaceText(node, settings.convert(node.raw));\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            },\r\n\r\n            TemplateLiteral(node) {\r\n\r\n                // Don't throw an error if backticks are expected or a template literal feature is in use.\r\n                if (\r\n                    allowTemplateLiterals ||\r\n                    quoteOption === \"backtick\" ||\r\n                    isUsingFeatureOfTemplateLiteral(node)\r\n                ) {\r\n                    return;\r\n                }\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: \"wrongQuotes\",\r\n                    data: {\r\n                        description: settings.description\r\n                    },\r\n                    fix(fixer) {\r\n                        if (isPartOfDirectivePrologue(node)) {\r\n\r\n                            /*\r\n                             * TemplateLiterals in a directive prologue aren't actually directives, but if they're\r\n                             * in the directive prologue, then fixing them might turn them into directives and change\r\n                             * the behavior of the code.\r\n                             */\r\n                            return null;\r\n                        }\r\n                        return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}