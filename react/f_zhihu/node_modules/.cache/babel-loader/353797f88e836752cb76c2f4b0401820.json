{"ast":null,"code":"/**\r\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\r\n * @author Milos Djermanovic\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines whether the first given array is a subset of the second given array.\r\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\r\n * @param {Array} arrA The array to compare from.\r\n * @param {Array} arrB The array to compare against.\r\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\r\n */\n\n\nfunction isSubsetByComparator(comparator, arrA, arrB) {\n  return arrA.every(a => arrB.some(b => comparator(a, b)));\n}\n/**\r\n * Splits the given node by the given logical operator.\r\n * @param {string} operator Logical operator `||` or `&&`.\r\n * @param {ASTNode} node The node to split.\r\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\r\n */\n\n\nfunction splitByLogicalOperator(operator, node) {\n  if (node.type === \"LogicalExpression\" && node.operator === operator) {\n    return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\n  }\n\n  return [node];\n}\n\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow duplicate conditions in if-else-if chains\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\n    },\n    schema: [],\n    messages: {\n      unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\r\n     * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\r\n     * @param {ASTNode} a First node.\r\n     * @param {ASTNode} b Second node.\r\n     * @returns {boolean} `true` if the nodes are considered to be equal.\r\n     */\n\n    function equal(a, b) {\n      if (a.type !== b.type) {\n        return false;\n      }\n\n      if (a.type === \"LogicalExpression\" && (a.operator === \"||\" || a.operator === \"&&\") && a.operator === b.operator) {\n        return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);\n      }\n\n      return astUtils.equalTokens(a, b, sourceCode);\n    }\n\n    const isSubset = isSubsetByComparator.bind(null, equal);\n    return {\n      IfStatement(node) {\n        const test = node.test,\n              conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\" ? [test, ...splitByAnd(test)] : [test];\n        let current = node,\n            listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\n\n        while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\n          current = current.parent;\n          const currentOrOperands = splitByOr(current.test).map(splitByAnd);\n          listToCheck = listToCheck.map(orOperands => orOperands.filter(orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))));\n\n          if (listToCheck.some(orOperands => orOperands.length === 0)) {\n            context.report({\n              node: test,\n              messageId: \"unexpected\"\n            });\n            break;\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-dupe-else-if.js"],"names":["astUtils","require","isSubsetByComparator","comparator","arrA","arrB","every","a","some","b","splitByLogicalOperator","operator","node","type","left","right","splitByOr","bind","splitByAnd","module","exports","meta","docs","description","recommended","url","schema","messages","unexpected","create","context","sourceCode","getSourceCode","equal","equalTokens","isSubset","IfStatement","test","conditionsToCheck","current","listToCheck","map","c","parent","alternate","currentOrOperands","orOperands","filter","orOperand","currentOrOperand","length","report","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to disallow duplicate conditions in if-else-if chains\r\n * @author Milos Djermanovic\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines whether the first given array is a subset of the second given array.\r\n * @param {Function} comparator A function to compare two elements, should return `true` if they are equal.\r\n * @param {Array} arrA The array to compare from.\r\n * @param {Array} arrB The array to compare against.\r\n * @returns {boolean} `true` if the array `arrA` is a subset of the array `arrB`.\r\n */\r\nfunction isSubsetByComparator(comparator, arrA, arrB) {\r\n    return arrA.every(a => arrB.some(b => comparator(a, b)));\r\n}\r\n\r\n/**\r\n * Splits the given node by the given logical operator.\r\n * @param {string} operator Logical operator `||` or `&&`.\r\n * @param {ASTNode} node The node to split.\r\n * @returns {ASTNode[]} Array of conditions that makes the node when joined by the operator.\r\n */\r\nfunction splitByLogicalOperator(operator, node) {\r\n    if (node.type === \"LogicalExpression\" && node.operator === operator) {\r\n        return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];\r\n    }\r\n    return [node];\r\n}\r\n\r\nconst splitByOr = splitByLogicalOperator.bind(null, \"||\");\r\nconst splitByAnd = splitByLogicalOperator.bind(null, \"&&\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow duplicate conditions in if-else-if chains\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-dupe-else-if\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unexpected: \"This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Determines whether the two given nodes are considered to be equal. In particular, given that the nodes\r\n         * represent expressions in a boolean context, `||` and `&&` can be considered as commutative operators.\r\n         * @param {ASTNode} a First node.\r\n         * @param {ASTNode} b Second node.\r\n         * @returns {boolean} `true` if the nodes are considered to be equal.\r\n         */\r\n        function equal(a, b) {\r\n            if (a.type !== b.type) {\r\n                return false;\r\n            }\r\n\r\n            if (\r\n                a.type === \"LogicalExpression\" &&\r\n                (a.operator === \"||\" || a.operator === \"&&\") &&\r\n                a.operator === b.operator\r\n            ) {\r\n                return equal(a.left, b.left) && equal(a.right, b.right) ||\r\n                    equal(a.left, b.right) && equal(a.right, b.left);\r\n            }\r\n\r\n            return astUtils.equalTokens(a, b, sourceCode);\r\n        }\r\n\r\n        const isSubset = isSubsetByComparator.bind(null, equal);\r\n\r\n        return {\r\n            IfStatement(node) {\r\n                const test = node.test,\r\n                    conditionsToCheck = test.type === \"LogicalExpression\" && test.operator === \"&&\"\r\n                        ? [test, ...splitByAnd(test)]\r\n                        : [test];\r\n                let current = node,\r\n                    listToCheck = conditionsToCheck.map(c => splitByOr(c).map(splitByAnd));\r\n\r\n                while (current.parent && current.parent.type === \"IfStatement\" && current.parent.alternate === current) {\r\n                    current = current.parent;\r\n\r\n                    const currentOrOperands = splitByOr(current.test).map(splitByAnd);\r\n\r\n                    listToCheck = listToCheck.map(orOperands => orOperands.filter(\r\n                        orOperand => !currentOrOperands.some(currentOrOperand => isSubset(currentOrOperand, orOperand))\r\n                    ));\r\n\r\n                    if (listToCheck.some(orOperands => orOperands.length === 0)) {\r\n                        context.report({ node: test, messageId: \"unexpected\" });\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}