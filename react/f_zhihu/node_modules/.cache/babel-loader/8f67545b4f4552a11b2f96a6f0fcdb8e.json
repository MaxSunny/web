{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\r\n * @author Gyandeep Singh\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\r\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\r\n * @typedef {string|Token[]} Key\r\n */\n\n/**\r\n * Accessor nodes with the same key.\r\n * @typedef {Object} AccessorData\r\n * @property {Key} key Accessor's key\r\n * @property {ASTNode[]} getters List of getter nodes.\r\n * @property {ASTNode[]} setters List of setter nodes.\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not the given lists represent the equal tokens in the same order.\r\n * Tokens are compared by their properties, not by instance.\r\n * @param {Token[]} left First list of tokens.\r\n * @param {Token[]} right Second list of tokens.\r\n * @returns {boolean} `true` if the lists have same tokens.\r\n */\n\n\nfunction areEqualTokenLists(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (let i = 0; i < left.length; i++) {\n    const leftToken = left[i],\n          rightToken = right[i];\n\n    if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks whether or not the given keys are equal.\r\n * @param {Key} left First key.\r\n * @param {Key} right Second key.\r\n * @returns {boolean} `true` if the keys are equal.\r\n */\n\n\nfunction areEqualKeys(left, right) {\n  if (typeof left === \"string\" && typeof right === \"string\") {\n    // Statically computed names.\n    return left === right;\n  }\n\n  if (Array.isArray(left) && Array.isArray(right)) {\n    // Token lists.\n    return areEqualTokenLists(left, right);\n  }\n\n  return false;\n}\n/**\r\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is of an accessor kind.\r\n */\n\n\nfunction isAccessorKind(node) {\n  return node.kind === \"get\" || node.kind === \"set\";\n}\n/**\r\n * Checks whether or not a given node is an argument of a specified method call.\r\n * @param {ASTNode} node A node to check.\r\n * @param {number} index An expected index of the node in arguments.\r\n * @param {string} object An expected name of the object of the method.\r\n * @param {string} property An expected name of the method.\r\n * @returns {boolean} `true` if the node is an argument of the specified method call.\r\n */\n\n\nfunction isArgumentOfMethodCall(node, index, object, property) {\n  const parent = node.parent;\n  return parent.type === \"CallExpression\" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;\n}\n/**\r\n * Checks whether or not a given node is a property descriptor.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a property descriptor.\r\n */\n\n\nfunction isPropertyDescriptor(node) {\n  // Object.defineProperty(obj, \"foo\", {set: ...})\n  if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") || isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")) {\n    return true;\n  }\n  /*\r\n   * Object.defineProperties(obj, {foo: {set: ...}})\r\n   * Object.create(proto, {foo: {set: ...}})\r\n   */\n\n\n  const grandparent = node.parent.parent;\n  return grandparent.type === \"ObjectExpression\" && (isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") || isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\"));\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce getter and setter pairs in objects and classes\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/accessor-pairs\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        getWithoutSet: {\n          type: \"boolean\",\n          default: false\n        },\n        setWithoutGet: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForClassMembers: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\n      missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\n      missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\n      missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\n      missingGetterInClass: \"Getter is not present for class {{ name }}.\",\n      missingSetterInClass: \"Setter is not present for class {{ name }}.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const checkGetWithoutSet = config.getWithoutSet === true;\n    const checkSetWithoutGet = config.setWithoutGet !== false;\n    const enforceForClassMembers = config.enforceForClassMembers !== false;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Reports the given node.\r\n     * @param {ASTNode} node The node to report.\r\n     * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function report(node, messageKind) {\n      if (node.type === \"Property\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InObjectLiteral`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else if (node.type === \"MethodDefinition\") {\n        context.report({\n          node,\n          messageId: `${messageKind}InClass`,\n          loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\n          data: {\n            name: astUtils.getFunctionNameWithKind(node.value)\n          }\n        });\n      } else {\n        context.report({\n          node,\n          messageId: `${messageKind}InPropertyDescriptor`\n        });\n      }\n    }\n    /**\r\n     * Reports each of the nodes in the given list using the same messageId.\r\n     * @param {ASTNode[]} nodes Nodes to report.\r\n     * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function reportList(nodes, messageKind) {\n      for (const node of nodes) {\n        report(node, messageKind);\n      }\n    }\n    /**\r\n     * Creates a new `AccessorData` object for the given getter or setter node.\r\n     * @param {ASTNode} node A getter or setter node.\r\n     * @returns {AccessorData} New `AccessorData` object that contains the given node.\r\n     * @private\r\n     */\n\n\n    function createAccessorData(node) {\n      const name = astUtils.getStaticPropertyName(node);\n      const key = name !== null ? name : sourceCode.getTokens(node.key);\n      return {\n        key,\n        getters: node.kind === \"get\" ? [node] : [],\n        setters: node.kind === \"set\" ? [node] : []\n      };\n    }\n    /**\r\n     * Merges the given `AccessorData` object into the given accessors list.\r\n     * @param {AccessorData[]} accessors The list to merge into.\r\n     * @param {AccessorData} accessorData The object to merge.\r\n     * @returns {AccessorData[]} The same instance with the merged object.\r\n     * @private\r\n     */\n\n\n    function mergeAccessorData(accessors, accessorData) {\n      const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\n\n      if (equalKeyElement) {\n        equalKeyElement.getters.push(...accessorData.getters);\n        equalKeyElement.setters.push(...accessorData.setters);\n      } else {\n        accessors.push(accessorData);\n      }\n\n      return accessors;\n    }\n    /**\r\n     * Checks accessor pairs in the given list of nodes.\r\n     * @param {ASTNode[]} nodes The list to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkList(nodes) {\n      const accessors = nodes.filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);\n\n      for (const {\n        getters,\n        setters\n      } of accessors) {\n        if (checkSetWithoutGet && setters.length && !getters.length) {\n          reportList(setters, \"missingGetter\");\n        }\n\n        if (checkGetWithoutSet && getters.length && !setters.length) {\n          reportList(getters, \"missingSetter\");\n        }\n      }\n    }\n    /**\r\n     * Checks accessor pairs in an object literal.\r\n     * @param {ASTNode} node `ObjectExpression` node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkObjectLiteral(node) {\n      checkList(node.properties.filter(p => p.type === \"Property\"));\n    }\n    /**\r\n     * Checks accessor pairs in a property descriptor.\r\n     * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkPropertyDescriptor(node) {\n      const namesToCheck = node.properties.filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed).map(_ref => {\n        let {\n          key\n        } = _ref;\n        return key.name;\n      });\n      const hasGetter = namesToCheck.includes(\"get\");\n      const hasSetter = namesToCheck.includes(\"set\");\n\n      if (checkSetWithoutGet && hasSetter && !hasGetter) {\n        report(node, \"missingGetter\");\n      }\n\n      if (checkGetWithoutSet && hasGetter && !hasSetter) {\n        report(node, \"missingSetter\");\n      }\n    }\n    /**\r\n     * Checks the given object expression as an object literal and as a possible property descriptor.\r\n     * @param {ASTNode} node `ObjectExpression` node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkObjectExpression(node) {\n      checkObjectLiteral(node);\n\n      if (isPropertyDescriptor(node)) {\n        checkPropertyDescriptor(node);\n      }\n    }\n    /**\r\n     * Checks the given class body.\r\n     * @param {ASTNode} node `ClassBody` node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkClassBody(node) {\n      const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\n      checkList(methodDefinitions.filter(m => m.static));\n      checkList(methodDefinitions.filter(m => !m.static));\n    }\n\n    const listeners = {};\n\n    if (checkSetWithoutGet || checkGetWithoutSet) {\n      listeners.ObjectExpression = checkObjectExpression;\n\n      if (enforceForClassMembers) {\n        listeners.ClassBody = checkClassBody;\n      }\n    }\n\n    return listeners;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/accessor-pairs.js"],"names":["astUtils","require","areEqualTokenLists","left","right","length","i","leftToken","rightToken","type","value","areEqualKeys","Array","isArray","isAccessorKind","node","kind","isArgumentOfMethodCall","index","object","property","parent","isSpecificMemberAccess","callee","arguments","isPropertyDescriptor","grandparent","module","exports","meta","docs","description","recommended","url","schema","properties","getWithoutSet","default","setWithoutGet","enforceForClassMembers","additionalProperties","messages","missingGetterInPropertyDescriptor","missingSetterInPropertyDescriptor","missingGetterInObjectLiteral","missingSetterInObjectLiteral","missingGetterInClass","missingSetterInClass","create","context","config","options","checkGetWithoutSet","checkSetWithoutGet","sourceCode","getSourceCode","report","messageKind","messageId","loc","getFunctionHeadLoc","data","name","getFunctionNameWithKind","reportList","nodes","createAccessorData","getStaticPropertyName","key","getTokens","getters","setters","mergeAccessorData","accessors","accessorData","equalKeyElement","find","a","push","checkList","filter","map","reduce","checkObjectLiteral","p","checkPropertyDescriptor","namesToCheck","computed","hasGetter","includes","hasSetter","checkObjectExpression","checkClassBody","methodDefinitions","body","m","static","listeners","ObjectExpression","ClassBody"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce getter and setter pairs in objects and classes.\r\n * @author Gyandeep Singh\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Property name if it can be computed statically, otherwise the list of the tokens of the key node.\r\n * @typedef {string|Token[]} Key\r\n */\r\n\r\n/**\r\n * Accessor nodes with the same key.\r\n * @typedef {Object} AccessorData\r\n * @property {Key} key Accessor's key\r\n * @property {ASTNode[]} getters List of getter nodes.\r\n * @property {ASTNode[]} setters List of setter nodes.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not the given lists represent the equal tokens in the same order.\r\n * Tokens are compared by their properties, not by instance.\r\n * @param {Token[]} left First list of tokens.\r\n * @param {Token[]} right Second list of tokens.\r\n * @returns {boolean} `true` if the lists have same tokens.\r\n */\r\nfunction areEqualTokenLists(left, right) {\r\n    if (left.length !== right.length) {\r\n        return false;\r\n    }\r\n\r\n    for (let i = 0; i < left.length; i++) {\r\n        const leftToken = left[i],\r\n            rightToken = right[i];\r\n\r\n        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Checks whether or not the given keys are equal.\r\n * @param {Key} left First key.\r\n * @param {Key} right Second key.\r\n * @returns {boolean} `true` if the keys are equal.\r\n */\r\nfunction areEqualKeys(left, right) {\r\n    if (typeof left === \"string\" && typeof right === \"string\") {\r\n\r\n        // Statically computed names.\r\n        return left === right;\r\n    }\r\n    if (Array.isArray(left) && Array.isArray(right)) {\r\n\r\n        // Token lists.\r\n        return areEqualTokenLists(left, right);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is of an accessor kind ('get' or 'set').\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is of an accessor kind.\r\n */\r\nfunction isAccessorKind(node) {\r\n    return node.kind === \"get\" || node.kind === \"set\";\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is an argument of a specified method call.\r\n * @param {ASTNode} node A node to check.\r\n * @param {number} index An expected index of the node in arguments.\r\n * @param {string} object An expected name of the object of the method.\r\n * @param {string} property An expected name of the method.\r\n * @returns {boolean} `true` if the node is an argument of the specified method call.\r\n */\r\nfunction isArgumentOfMethodCall(node, index, object, property) {\r\n    const parent = node.parent;\r\n\r\n    return (\r\n        parent.type === \"CallExpression\" &&\r\n        astUtils.isSpecificMemberAccess(parent.callee, object, property) &&\r\n        parent.arguments[index] === node\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is a property descriptor.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a property descriptor.\r\n */\r\nfunction isPropertyDescriptor(node) {\r\n\r\n    // Object.defineProperty(obj, \"foo\", {set: ...})\r\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\r\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\r\n    ) {\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Object.defineProperties(obj, {foo: {set: ...}})\r\n     * Object.create(proto, {foo: {set: ...}})\r\n     */\r\n    const grandparent = node.parent.parent;\r\n\r\n    return grandparent.type === \"ObjectExpression\" && (\r\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"create\") ||\r\n        isArgumentOfMethodCall(grandparent, 1, \"Object\", \"defineProperties\")\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce getter and setter pairs in objects and classes\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/accessor-pairs\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                getWithoutSet: {\r\n                    type: \"boolean\",\r\n                    default: false\r\n                },\r\n                setWithoutGet: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                },\r\n                enforceForClassMembers: {\r\n                    type: \"boolean\",\r\n                    default: true\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            missingGetterInPropertyDescriptor: \"Getter is not present in property descriptor.\",\r\n            missingSetterInPropertyDescriptor: \"Setter is not present in property descriptor.\",\r\n            missingGetterInObjectLiteral: \"Getter is not present for {{ name }}.\",\r\n            missingSetterInObjectLiteral: \"Setter is not present for {{ name }}.\",\r\n            missingGetterInClass: \"Getter is not present for class {{ name }}.\",\r\n            missingSetterInClass: \"Setter is not present for class {{ name }}.\"\r\n        }\r\n    },\r\n    create(context) {\r\n        const config = context.options[0] || {};\r\n        const checkGetWithoutSet = config.getWithoutSet === true;\r\n        const checkSetWithoutGet = config.setWithoutGet !== false;\r\n        const enforceForClassMembers = config.enforceForClassMembers !== false;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Reports the given node.\r\n         * @param {ASTNode} node The node to report.\r\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node, messageKind) {\r\n            if (node.type === \"Property\") {\r\n                context.report({\r\n                    node,\r\n                    messageId: `${messageKind}InObjectLiteral`,\r\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\r\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\r\n                });\r\n            } else if (node.type === \"MethodDefinition\") {\r\n                context.report({\r\n                    node,\r\n                    messageId: `${messageKind}InClass`,\r\n                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),\r\n                    data: { name: astUtils.getFunctionNameWithKind(node.value) }\r\n                });\r\n            } else {\r\n                context.report({\r\n                    node,\r\n                    messageId: `${messageKind}InPropertyDescriptor`\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports each of the nodes in the given list using the same messageId.\r\n         * @param {ASTNode[]} nodes Nodes to report.\r\n         * @param {string} messageKind \"missingGetter\" or \"missingSetter\".\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function reportList(nodes, messageKind) {\r\n            for (const node of nodes) {\r\n                report(node, messageKind);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Creates a new `AccessorData` object for the given getter or setter node.\r\n         * @param {ASTNode} node A getter or setter node.\r\n         * @returns {AccessorData} New `AccessorData` object that contains the given node.\r\n         * @private\r\n         */\r\n        function createAccessorData(node) {\r\n            const name = astUtils.getStaticPropertyName(node);\r\n            const key = (name !== null) ? name : sourceCode.getTokens(node.key);\r\n\r\n            return {\r\n                key,\r\n                getters: node.kind === \"get\" ? [node] : [],\r\n                setters: node.kind === \"set\" ? [node] : []\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Merges the given `AccessorData` object into the given accessors list.\r\n         * @param {AccessorData[]} accessors The list to merge into.\r\n         * @param {AccessorData} accessorData The object to merge.\r\n         * @returns {AccessorData[]} The same instance with the merged object.\r\n         * @private\r\n         */\r\n        function mergeAccessorData(accessors, accessorData) {\r\n            const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));\r\n\r\n            if (equalKeyElement) {\r\n                equalKeyElement.getters.push(...accessorData.getters);\r\n                equalKeyElement.setters.push(...accessorData.setters);\r\n            } else {\r\n                accessors.push(accessorData);\r\n            }\r\n\r\n            return accessors;\r\n        }\r\n\r\n        /**\r\n         * Checks accessor pairs in the given list of nodes.\r\n         * @param {ASTNode[]} nodes The list to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkList(nodes) {\r\n            const accessors = nodes\r\n                .filter(isAccessorKind)\r\n                .map(createAccessorData)\r\n                .reduce(mergeAccessorData, []);\r\n\r\n            for (const { getters, setters } of accessors) {\r\n                if (checkSetWithoutGet && setters.length && !getters.length) {\r\n                    reportList(setters, \"missingGetter\");\r\n                }\r\n                if (checkGetWithoutSet && getters.length && !setters.length) {\r\n                    reportList(getters, \"missingSetter\");\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks accessor pairs in an object literal.\r\n         * @param {ASTNode} node `ObjectExpression` node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkObjectLiteral(node) {\r\n            checkList(node.properties.filter(p => p.type === \"Property\"));\r\n        }\r\n\r\n        /**\r\n         * Checks accessor pairs in a property descriptor.\r\n         * @param {ASTNode} node Property descriptor `ObjectExpression` node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkPropertyDescriptor(node) {\r\n            const namesToCheck = node.properties\r\n                .filter(p => p.type === \"Property\" && p.kind === \"init\" && !p.computed)\r\n                .map(({ key }) => key.name);\r\n\r\n            const hasGetter = namesToCheck.includes(\"get\");\r\n            const hasSetter = namesToCheck.includes(\"set\");\r\n\r\n            if (checkSetWithoutGet && hasSetter && !hasGetter) {\r\n                report(node, \"missingGetter\");\r\n            }\r\n            if (checkGetWithoutSet && hasGetter && !hasSetter) {\r\n                report(node, \"missingSetter\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the given object expression as an object literal and as a possible property descriptor.\r\n         * @param {ASTNode} node `ObjectExpression` node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkObjectExpression(node) {\r\n            checkObjectLiteral(node);\r\n            if (isPropertyDescriptor(node)) {\r\n                checkPropertyDescriptor(node);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the given class body.\r\n         * @param {ASTNode} node `ClassBody` node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkClassBody(node) {\r\n            const methodDefinitions = node.body.filter(m => m.type === \"MethodDefinition\");\r\n\r\n            checkList(methodDefinitions.filter(m => m.static));\r\n            checkList(methodDefinitions.filter(m => !m.static));\r\n        }\r\n\r\n        const listeners = {};\r\n\r\n        if (checkSetWithoutGet || checkGetWithoutSet) {\r\n            listeners.ObjectExpression = checkObjectExpression;\r\n            if (enforceForClassMembers) {\r\n                listeners.ClassBody = checkClassBody;\r\n            }\r\n        }\r\n\r\n        return listeners;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}