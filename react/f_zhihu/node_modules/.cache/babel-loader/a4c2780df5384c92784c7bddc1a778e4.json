{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce line breaks after each array element\r\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks after each array element\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/array-element-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: {\n      definitions: {\n        basicConfig: {\n          oneOf: [{\n            enum: [\"always\", \"never\", \"consistent\"]\n          }, {\n            type: \"object\",\n            properties: {\n              multiline: {\n                type: \"boolean\"\n              },\n              minItems: {\n                type: [\"integer\", \"null\"],\n                minimum: 0\n              }\n            },\n            additionalProperties: false\n          }]\n        }\n      },\n      items: [{\n        oneOf: [{\n          $ref: \"#/definitions/basicConfig\"\n        }, {\n          type: \"object\",\n          properties: {\n            ArrayExpression: {\n              $ref: \"#/definitions/basicConfig\"\n            },\n            ArrayPattern: {\n              $ref: \"#/definitions/basicConfig\"\n            }\n          },\n          additionalProperties: false,\n          minProperties: 1\n        }]\n      }]\n    },\n    messages: {\n      unexpectedLineBreak: \"There should be no linebreak here.\",\n      missingLineBreak: \"There should be a linebreak after this element.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //----------------------------------------------------------------------\n    // Helpers\n    //----------------------------------------------------------------------\n\n    /**\r\n     * Normalizes a given option value.\r\n     * @param {string|Object|undefined} providedOption An option value to parse.\r\n     * @returns {{multiline: boolean, minItems: number}} Normalized option object.\r\n     */\n\n    function normalizeOptionValue(providedOption) {\n      let consistent = false;\n      let multiline = false;\n      let minItems;\n      const option = providedOption || \"always\";\n\n      if (!option || option === \"always\" || option.minItems === 0) {\n        minItems = 0;\n      } else if (option === \"never\") {\n        minItems = Number.POSITIVE_INFINITY;\n      } else if (option === \"consistent\") {\n        consistent = true;\n        minItems = Number.POSITIVE_INFINITY;\n      } else {\n        multiline = Boolean(option.multiline);\n        minItems = option.minItems || Number.POSITIVE_INFINITY;\n      }\n\n      return {\n        consistent,\n        multiline,\n        minItems\n      };\n    }\n    /**\r\n     * Normalizes a given option value.\r\n     * @param {string|Object|undefined} options An option value to parse.\r\n     * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\r\n     */\n\n\n    function normalizeOptions(options) {\n      if (options && (options.ArrayExpression || options.ArrayPattern)) {\n        let expressionOptions, patternOptions;\n\n        if (options.ArrayExpression) {\n          expressionOptions = normalizeOptionValue(options.ArrayExpression);\n        }\n\n        if (options.ArrayPattern) {\n          patternOptions = normalizeOptionValue(options.ArrayPattern);\n        }\n\n        return {\n          ArrayExpression: expressionOptions,\n          ArrayPattern: patternOptions\n        };\n      }\n\n      const value = normalizeOptionValue(options);\n      return {\n        ArrayExpression: value,\n        ArrayPattern: value\n      };\n    }\n    /**\r\n     * Reports that there shouldn't be a line break after the first token\r\n     * @param {Token} token The token to use for the report.\r\n     * @returns {void}\r\n     */\n\n\n    function reportNoLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"unexpectedLineBreak\",\n\n        fix(fixer) {\n          if (astUtils.isCommentToken(tokenBefore)) {\n            return null;\n          }\n\n          if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\n            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\n          }\n          /*\r\n           * This will check if the comma is on the same line as the next element\r\n           * Following array:\r\n           * [\r\n           *     1\r\n           *     , 2\r\n           *     , 3\r\n           * ]\r\n           *\r\n           * will be fixed to:\r\n           * [\r\n           *     1, 2, 3\r\n           * ]\r\n           */\n\n\n          const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {\n            includeComments: true\n          });\n\n          if (astUtils.isCommentToken(twoTokensBefore)) {\n            return null;\n          }\n\n          return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\n        }\n\n      });\n    }\n    /**\r\n     * Reports that there should be a line break after the first token\r\n     * @param {Token} token The token to use for the report.\r\n     * @returns {void}\r\n     */\n\n\n    function reportRequiredLineBreak(token) {\n      const tokenBefore = sourceCode.getTokenBefore(token, {\n        includeComments: true\n      });\n      context.report({\n        loc: {\n          start: tokenBefore.loc.end,\n          end: token.loc.start\n        },\n        messageId: \"missingLineBreak\",\n\n        fix(fixer) {\n          return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\n        }\n\n      });\n    }\n    /**\r\n     * Reports a given node if it violated this rule.\r\n     * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\r\n     * @returns {void}\r\n     */\n\n\n    function check(node) {\n      const elements = node.elements;\n      const normalizedOptions = normalizeOptions(context.options[0]);\n      const options = normalizedOptions[node.type];\n\n      if (!options) {\n        return;\n      }\n\n      let elementBreak = false;\n      /*\r\n       * MULTILINE: true\r\n       * loop through every element and check\r\n       * if at least one element has linebreaks inside\r\n       * this ensures that following is not valid (due to elements are on the same line):\r\n       *\r\n       * [\r\n       *      1,\r\n       *      2,\r\n       *      3\r\n       * ]\r\n       */\n\n      if (options.multiline) {\n        elementBreak = elements.filter(element => element !== null).some(element => element.loc.start.line !== element.loc.end.line);\n      }\n\n      const linebreaksCount = node.elements.map((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return false;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n        return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\n      }).filter(isBreak => isBreak === true).length;\n      const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;\n      elements.forEach((element, i) => {\n        const previousElement = elements[i - 1];\n\n        if (i === 0 || element === null || previousElement === null) {\n          return;\n        }\n\n        const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\n        const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\n        const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\n\n        if (needsLinebreaks) {\n          if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportRequiredLineBreak(firstTokenOfCurrentElement);\n          }\n        } else {\n          if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\n            reportNoLineBreak(firstTokenOfCurrentElement);\n          }\n        }\n      });\n    } //----------------------------------------------------------------------\n    // Public\n    //----------------------------------------------------------------------\n\n\n    return {\n      ArrayPattern: check,\n      ArrayExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/array-element-newline.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","definitions","basicConfig","oneOf","enum","properties","multiline","minItems","minimum","additionalProperties","items","$ref","ArrayExpression","ArrayPattern","minProperties","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","normalizeOptionValue","providedOption","consistent","option","Number","POSITIVE_INFINITY","Boolean","normalizeOptions","options","expressionOptions","patternOptions","value","reportNoLineBreak","token","tokenBefore","getTokenBefore","includeComments","report","loc","start","end","messageId","fix","fixer","isCommentToken","isTokenOnSameLine","replaceTextRange","range","twoTokensBefore","reportRequiredLineBreak","check","node","elements","normalizedOptions","elementBreak","filter","element","some","line","linebreaksCount","map","i","previousElement","commaToken","getFirstTokenBetween","isCommaToken","lastTokenOfPreviousElement","firstTokenOfCurrentElement","getTokenAfter","isBreak","length","needsLinebreaks","forEach"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce line breaks after each array element\r\n * @author Jan Peer Stöcklmair <https://github.com/JPeer264>\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce line breaks after each array element\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/array-element-newline\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: {\r\n            definitions: {\r\n                basicConfig: {\r\n                    oneOf: [\r\n                        {\r\n                            enum: [\"always\", \"never\", \"consistent\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                multiline: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                minItems: {\r\n                                    type: [\"integer\", \"null\"],\r\n                                    minimum: 0\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ]\r\n                }\r\n            },\r\n            items: [\r\n                {\r\n                    oneOf: [\r\n                        {\r\n                            $ref: \"#/definitions/basicConfig\"\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                ArrayExpression: {\r\n                                    $ref: \"#/definitions/basicConfig\"\r\n                                },\r\n                                ArrayPattern: {\r\n                                    $ref: \"#/definitions/basicConfig\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false,\r\n                            minProperties: 1\r\n                        }\r\n                    ]\r\n                }\r\n            ]\r\n        },\r\n\r\n        messages: {\r\n            unexpectedLineBreak: \"There should be no linebreak here.\",\r\n            missingLineBreak: \"There should be a linebreak after this element.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //----------------------------------------------------------------------\r\n        // Helpers\r\n        //----------------------------------------------------------------------\r\n\r\n        /**\r\n         * Normalizes a given option value.\r\n         * @param {string|Object|undefined} providedOption An option value to parse.\r\n         * @returns {{multiline: boolean, minItems: number}} Normalized option object.\r\n         */\r\n        function normalizeOptionValue(providedOption) {\r\n            let consistent = false;\r\n            let multiline = false;\r\n            let minItems;\r\n\r\n            const option = providedOption || \"always\";\r\n\r\n            if (!option || option === \"always\" || option.minItems === 0) {\r\n                minItems = 0;\r\n            } else if (option === \"never\") {\r\n                minItems = Number.POSITIVE_INFINITY;\r\n            } else if (option === \"consistent\") {\r\n                consistent = true;\r\n                minItems = Number.POSITIVE_INFINITY;\r\n            } else {\r\n                multiline = Boolean(option.multiline);\r\n                minItems = option.minItems || Number.POSITIVE_INFINITY;\r\n            }\r\n\r\n            return { consistent, multiline, minItems };\r\n        }\r\n\r\n        /**\r\n         * Normalizes a given option value.\r\n         * @param {string|Object|undefined} options An option value to parse.\r\n         * @returns {{ArrayExpression: {multiline: boolean, minItems: number}, ArrayPattern: {multiline: boolean, minItems: number}}} Normalized option object.\r\n         */\r\n        function normalizeOptions(options) {\r\n            if (options && (options.ArrayExpression || options.ArrayPattern)) {\r\n                let expressionOptions, patternOptions;\r\n\r\n                if (options.ArrayExpression) {\r\n                    expressionOptions = normalizeOptionValue(options.ArrayExpression);\r\n                }\r\n\r\n                if (options.ArrayPattern) {\r\n                    patternOptions = normalizeOptionValue(options.ArrayPattern);\r\n                }\r\n\r\n                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions };\r\n            }\r\n\r\n            const value = normalizeOptionValue(options);\r\n\r\n            return { ArrayExpression: value, ArrayPattern: value };\r\n        }\r\n\r\n        /**\r\n         * Reports that there shouldn't be a line break after the first token\r\n         * @param {Token} token The token to use for the report.\r\n         * @returns {void}\r\n         */\r\n        function reportNoLineBreak(token) {\r\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\r\n\r\n            context.report({\r\n                loc: {\r\n                    start: tokenBefore.loc.end,\r\n                    end: token.loc.start\r\n                },\r\n                messageId: \"unexpectedLineBreak\",\r\n                fix(fixer) {\r\n                    if (astUtils.isCommentToken(tokenBefore)) {\r\n                        return null;\r\n                    }\r\n\r\n                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {\r\n                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \");\r\n                    }\r\n\r\n                    /*\r\n                     * This will check if the comma is on the same line as the next element\r\n                     * Following array:\r\n                     * [\r\n                     *     1\r\n                     *     , 2\r\n                     *     , 3\r\n                     * ]\r\n                     *\r\n                     * will be fixed to:\r\n                     * [\r\n                     *     1, 2, 3\r\n                     * ]\r\n                     */\r\n                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true });\r\n\r\n                    if (astUtils.isCommentToken(twoTokensBefore)) {\r\n                        return null;\r\n                    }\r\n\r\n                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], \"\");\r\n\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports that there should be a line break after the first token\r\n         * @param {Token} token The token to use for the report.\r\n         * @returns {void}\r\n         */\r\n        function reportRequiredLineBreak(token) {\r\n            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true });\r\n\r\n            context.report({\r\n                loc: {\r\n                    start: tokenBefore.loc.end,\r\n                    end: token.loc.start\r\n                },\r\n                messageId: \"missingLineBreak\",\r\n                fix(fixer) {\r\n                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\");\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports a given node if it violated this rule.\r\n         * @param {ASTNode} node A node to check. This is an ObjectExpression node or an ObjectPattern node.\r\n         * @returns {void}\r\n         */\r\n        function check(node) {\r\n            const elements = node.elements;\r\n            const normalizedOptions = normalizeOptions(context.options[0]);\r\n            const options = normalizedOptions[node.type];\r\n\r\n            if (!options) {\r\n                return;\r\n            }\r\n\r\n            let elementBreak = false;\r\n\r\n            /*\r\n             * MULTILINE: true\r\n             * loop through every element and check\r\n             * if at least one element has linebreaks inside\r\n             * this ensures that following is not valid (due to elements are on the same line):\r\n             *\r\n             * [\r\n             *      1,\r\n             *      2,\r\n             *      3\r\n             * ]\r\n             */\r\n            if (options.multiline) {\r\n                elementBreak = elements\r\n                    .filter(element => element !== null)\r\n                    .some(element => element.loc.start.line !== element.loc.end.line);\r\n            }\r\n\r\n            const linebreaksCount = node.elements.map((element, i) => {\r\n                const previousElement = elements[i - 1];\r\n\r\n                if (i === 0 || element === null || previousElement === null) {\r\n                    return false;\r\n                }\r\n\r\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\r\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\r\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\r\n\r\n                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);\r\n            }).filter(isBreak => isBreak === true).length;\r\n\r\n            const needsLinebreaks = (\r\n                elements.length >= options.minItems ||\r\n                (\r\n                    options.multiline &&\r\n                    elementBreak\r\n                ) ||\r\n                (\r\n                    options.consistent &&\r\n                    linebreaksCount > 0 &&\r\n                    linebreaksCount < node.elements.length\r\n                )\r\n            );\r\n\r\n            elements.forEach((element, i) => {\r\n                const previousElement = elements[i - 1];\r\n\r\n                if (i === 0 || element === null || previousElement === null) {\r\n                    return;\r\n                }\r\n\r\n                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);\r\n                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);\r\n                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);\r\n\r\n                if (needsLinebreaks) {\r\n                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\r\n                        reportRequiredLineBreak(firstTokenOfCurrentElement);\r\n                    }\r\n                } else {\r\n                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {\r\n                        reportNoLineBreak(firstTokenOfCurrentElement);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Public\r\n        //----------------------------------------------------------------------\r\n\r\n        return {\r\n            ArrayPattern: check,\r\n            ArrayExpression: check\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}