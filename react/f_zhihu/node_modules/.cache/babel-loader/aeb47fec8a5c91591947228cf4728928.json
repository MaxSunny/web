{"ast":null,"code":"/**\r\n * @fileoverview Helper class to aid in constructing fix commands.\r\n * @author Alan Pierce\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./ast-utils\"); //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * A helper class to combine fix options into a fix command. Currently, it\r\n * exposes some \"retain\" methods that extend the range of the text being\r\n * replaced so that other fixes won't touch that region in the same pass.\r\n */\n\n\nclass FixTracker {\n  /**\r\n   * Create a new FixTracker.\r\n   * @param {ruleFixer} fixer A ruleFixer instance.\r\n   * @param {SourceCode} sourceCode A SourceCode object for the current code.\r\n   */\n  constructor(fixer, sourceCode) {\n    this.fixer = fixer;\n    this.sourceCode = sourceCode;\n    this.retainedRange = null;\n  }\n  /**\r\n   * Mark the given range as \"retained\", meaning that other fixes may not\r\n   * may not modify this region in the same pass.\r\n   * @param {int[]} range The range to retain.\r\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n   */\n\n\n  retainRange(range) {\n    this.retainedRange = range;\n    return this;\n  }\n  /**\r\n   * Given a node, find the function containing it (or the entire program) and\r\n   * mark it as retained, meaning that other fixes may not modify it in this\r\n   * pass. This is useful for avoiding conflicts in fixes that modify control\r\n   * flow.\r\n   * @param {ASTNode} node The node to use as a starting point.\r\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n   */\n\n\n  retainEnclosingFunction(node) {\n    const functionNode = astUtils.getUpperFunction(node);\n    return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\n  }\n  /**\r\n   * Given a node or token, find the token before and afterward, and mark that\r\n   * range as retained, meaning that other fixes may not modify it in this\r\n   * pass. This is useful for avoiding conflicts in fixes that make a small\r\n   * change to the code where the AST should not be changed.\r\n   * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\r\n   *      point. The token to the left and right are use in the range.\r\n   * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n   */\n\n\n  retainSurroundingTokens(nodeOrToken) {\n    const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\n    const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\n    return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\n  }\n  /**\r\n   * Create a fix command that replaces the given range with the given text,\r\n   * accounting for any retained ranges.\r\n   * @param {int[]} range The range to remove in the fix.\r\n   * @param {string} text The text to insert in place of the range.\r\n   * @returns {Object} The fix command.\r\n   */\n\n\n  replaceTextRange(range, text) {\n    let actualRange;\n\n    if (this.retainedRange) {\n      actualRange = [Math.min(this.retainedRange[0], range[0]), Math.max(this.retainedRange[1], range[1])];\n    } else {\n      actualRange = range;\n    }\n\n    return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));\n  }\n  /**\r\n   * Create a fix command that removes the given node or token, accounting for\r\n   * any retained ranges.\r\n   * @param {ASTNode|Token} nodeOrToken The node or token to remove.\r\n   * @returns {Object} The fix command.\r\n   */\n\n\n  remove(nodeOrToken) {\n    return this.replaceTextRange(nodeOrToken.range, \"\");\n  }\n\n}\n\nmodule.exports = FixTracker;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/utils/fix-tracker.js"],"names":["astUtils","require","FixTracker","constructor","fixer","sourceCode","retainedRange","retainRange","range","retainEnclosingFunction","node","functionNode","getUpperFunction","ast","retainSurroundingTokens","nodeOrToken","tokenBefore","getTokenBefore","tokenAfter","getTokenAfter","replaceTextRange","text","actualRange","Math","min","max","slice","remove","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,UAAN,CAAiB;AAEb;AACJ;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,KAAD,EAAQC,UAAR,EAAoB;AAC3B,SAAKD,KAAL,GAAaA,KAAb;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,aAAL,GAAqB,IAArB;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACf,SAAKF,aAAL,GAAqBE,KAArB;AACA,WAAO,IAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,uBAAuB,CAACC,IAAD,EAAO;AAC1B,UAAMC,YAAY,GAAGX,QAAQ,CAACY,gBAAT,CAA0BF,IAA1B,CAArB;AAEA,WAAO,KAAKH,WAAL,CAAiBI,YAAY,GAAGA,YAAY,CAACH,KAAhB,GAAwB,KAAKH,UAAL,CAAgBQ,GAAhB,CAAoBL,KAAzE,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIM,EAAAA,uBAAuB,CAACC,WAAD,EAAc;AACjC,UAAMC,WAAW,GAAG,KAAKX,UAAL,CAAgBY,cAAhB,CAA+BF,WAA/B,KAA+CA,WAAnE;AACA,UAAMG,UAAU,GAAG,KAAKb,UAAL,CAAgBc,aAAhB,CAA8BJ,WAA9B,KAA8CA,WAAjE;AAEA,WAAO,KAAKR,WAAL,CAAiB,CAACS,WAAW,CAACR,KAAZ,CAAkB,CAAlB,CAAD,EAAuBU,UAAU,CAACV,KAAX,CAAiB,CAAjB,CAAvB,CAAjB,CAAP;AACH;AAED;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIY,EAAAA,gBAAgB,CAACZ,KAAD,EAAQa,IAAR,EAAc;AAC1B,QAAIC,WAAJ;;AAEA,QAAI,KAAKhB,aAAT,EAAwB;AACpBgB,MAAAA,WAAW,GAAG,CACVC,IAAI,CAACC,GAAL,CAAS,KAAKlB,aAAL,CAAmB,CAAnB,CAAT,EAAgCE,KAAK,CAAC,CAAD,CAArC,CADU,EAEVe,IAAI,CAACE,GAAL,CAAS,KAAKnB,aAAL,CAAmB,CAAnB,CAAT,EAAgCE,KAAK,CAAC,CAAD,CAArC,CAFU,CAAd;AAIH,KALD,MAKO;AACHc,MAAAA,WAAW,GAAGd,KAAd;AACH;;AAED,WAAO,KAAKJ,KAAL,CAAWgB,gBAAX,CACHE,WADG,EAEH,KAAKjB,UAAL,CAAgBgB,IAAhB,CAAqBK,KAArB,CAA2BJ,WAAW,CAAC,CAAD,CAAtC,EAA2Cd,KAAK,CAAC,CAAD,CAAhD,IACIa,IADJ,GAEI,KAAKhB,UAAL,CAAgBgB,IAAhB,CAAqBK,KAArB,CAA2BlB,KAAK,CAAC,CAAD,CAAhC,EAAqCc,WAAW,CAAC,CAAD,CAAhD,CAJD,CAAP;AAMH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIK,EAAAA,MAAM,CAACZ,WAAD,EAAc;AAChB,WAAO,KAAKK,gBAAL,CAAsBL,WAAW,CAACP,KAAlC,EAAyC,EAAzC,CAAP;AACH;;AAzFY;;AA4FjBoB,MAAM,CAACC,OAAP,GAAiB3B,UAAjB","sourcesContent":["/**\r\n * @fileoverview Helper class to aid in constructing fix commands.\r\n * @author Alan Pierce\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * A helper class to combine fix options into a fix command. Currently, it\r\n * exposes some \"retain\" methods that extend the range of the text being\r\n * replaced so that other fixes won't touch that region in the same pass.\r\n */\r\nclass FixTracker {\r\n\r\n    /**\r\n     * Create a new FixTracker.\r\n     * @param {ruleFixer} fixer A ruleFixer instance.\r\n     * @param {SourceCode} sourceCode A SourceCode object for the current code.\r\n     */\r\n    constructor(fixer, sourceCode) {\r\n        this.fixer = fixer;\r\n        this.sourceCode = sourceCode;\r\n        this.retainedRange = null;\r\n    }\r\n\r\n    /**\r\n     * Mark the given range as \"retained\", meaning that other fixes may not\r\n     * may not modify this region in the same pass.\r\n     * @param {int[]} range The range to retain.\r\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n     */\r\n    retainRange(range) {\r\n        this.retainedRange = range;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Given a node, find the function containing it (or the entire program) and\r\n     * mark it as retained, meaning that other fixes may not modify it in this\r\n     * pass. This is useful for avoiding conflicts in fixes that modify control\r\n     * flow.\r\n     * @param {ASTNode} node The node to use as a starting point.\r\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n     */\r\n    retainEnclosingFunction(node) {\r\n        const functionNode = astUtils.getUpperFunction(node);\r\n\r\n        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);\r\n    }\r\n\r\n    /**\r\n     * Given a node or token, find the token before and afterward, and mark that\r\n     * range as retained, meaning that other fixes may not modify it in this\r\n     * pass. This is useful for avoiding conflicts in fixes that make a small\r\n     * change to the code where the AST should not be changed.\r\n     * @param {ASTNode|Token} nodeOrToken The node or token to use as a starting\r\n     *      point. The token to the left and right are use in the range.\r\n     * @returns {FixTracker} The same RuleFixer, for chained calls.\r\n     */\r\n    retainSurroundingTokens(nodeOrToken) {\r\n        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;\r\n        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;\r\n\r\n        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);\r\n    }\r\n\r\n    /**\r\n     * Create a fix command that replaces the given range with the given text,\r\n     * accounting for any retained ranges.\r\n     * @param {int[]} range The range to remove in the fix.\r\n     * @param {string} text The text to insert in place of the range.\r\n     * @returns {Object} The fix command.\r\n     */\r\n    replaceTextRange(range, text) {\r\n        let actualRange;\r\n\r\n        if (this.retainedRange) {\r\n            actualRange = [\r\n                Math.min(this.retainedRange[0], range[0]),\r\n                Math.max(this.retainedRange[1], range[1])\r\n            ];\r\n        } else {\r\n            actualRange = range;\r\n        }\r\n\r\n        return this.fixer.replaceTextRange(\r\n            actualRange,\r\n            this.sourceCode.text.slice(actualRange[0], range[0]) +\r\n                text +\r\n                this.sourceCode.text.slice(range[1], actualRange[1])\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Create a fix command that removes the given node or token, accounting for\r\n     * any retained ranges.\r\n     * @param {ASTNode|Token} nodeOrToken The node or token to remove.\r\n     * @returns {Object} The fix command.\r\n     */\r\n    remove(nodeOrToken) {\r\n        return this.replaceTextRange(nodeOrToken.range, \"\");\r\n    }\r\n}\r\n\r\nmodule.exports = FixTracker;\r\n"]},"metadata":{},"sourceType":"script"}