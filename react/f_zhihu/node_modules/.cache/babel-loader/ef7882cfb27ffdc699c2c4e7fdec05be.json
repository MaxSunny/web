{"ast":null,"code":"/**\r\n * @fileoverview Validate strings passed to the RegExp constructor\r\n * @author Michael Ficarra\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\n\nconst validator = new RegExpValidator();\nconst validFlags = /[dgimsuy]/gu;\nconst undefined1 = void 0; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow invalid regular expression strings in `RegExp` constructors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowConstructorFlags: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      regexMessage: \"{{message}}.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0];\n    let allowedFlags = null;\n\n    if (options && options.allowConstructorFlags) {\n      const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\n\n      if (temp) {\n        allowedFlags = new RegExp(`[${temp}]`, \"giu\");\n      }\n    }\n    /**\r\n     * Check if node is a string\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {boolean} True if its a string\r\n     * @private\r\n     */\n\n\n    function isString(node) {\n      return node && node.type === \"Literal\" && typeof node.value === \"string\";\n    }\n    /**\r\n     * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\r\n     * Examples:\r\n     *     new RegExp(\".\")         // => \"\"\r\n     *     new RegExp(\".\", \"gu\")   // => \"gu\"\r\n     *     new RegExp(\".\", flags)  // => null\r\n     * @param {ASTNode} node `CallExpression` or `NewExpression` node\r\n     * @returns {string|null} flags if they can be determined, `null` otherwise\r\n     * @private\r\n     */\n\n\n    function getFlags(node) {\n      if (node.arguments.length < 2) {\n        return \"\";\n      }\n\n      if (isString(node.arguments[1])) {\n        return node.arguments[1].value;\n      }\n\n      return null;\n    }\n    /**\r\n     * Check syntax error in a given pattern.\r\n     * @param {string} pattern The RegExp pattern to validate.\r\n     * @param {boolean} uFlag The Unicode flag.\r\n     * @returns {string|null} The syntax error.\r\n     */\n\n\n    function validateRegExpPattern(pattern, uFlag) {\n      try {\n        validator.validatePattern(pattern, undefined1, undefined1, uFlag);\n        return null;\n      } catch (err) {\n        return err.message;\n      }\n    }\n    /**\r\n     * Check syntax error in a given flags.\r\n     * @param {string} flags The RegExp flags to validate.\r\n     * @returns {string|null} The syntax error.\r\n     */\n\n\n    function validateRegExpFlags(flags) {\n      try {\n        validator.validateFlags(flags);\n        return null;\n      } catch {\n        return `Invalid flags supplied to RegExp constructor '${flags}'`;\n      }\n    }\n\n    return {\n      \"CallExpression, NewExpression\"(node) {\n        if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\n          return;\n        }\n\n        const pattern = node.arguments[0].value;\n        let flags = getFlags(node);\n\n        if (flags && allowedFlags) {\n          flags = flags.replace(allowedFlags, \"\");\n        }\n\n        const message = flags && validateRegExpFlags(flags) || ( // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\n        flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes(\"u\")));\n\n        if (message) {\n          context.report({\n            node,\n            messageId: \"regexMessage\",\n            data: {\n              message\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-invalid-regexp.js"],"names":["RegExpValidator","require","validator","validFlags","undefined1","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowConstructorFlags","items","additionalProperties","messages","regexMessage","create","context","options","allowedFlags","temp","join","replace","RegExp","isString","node","value","getFlags","arguments","length","validateRegExpPattern","pattern","uFlag","validatePattern","err","message","validateRegExpFlags","flags","validateFlags","callee","name","includes","report","messageId","data"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Validate strings passed to the RegExp constructor\r\n * @author Michael Ficarra\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst RegExpValidator = require(\"regexpp\").RegExpValidator;\r\nconst validator = new RegExpValidator();\r\nconst validFlags = /[dgimsuy]/gu;\r\nconst undefined1 = void 0;\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow invalid regular expression strings in `RegExp` constructors\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-invalid-regexp\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                allowConstructorFlags: {\r\n                    type: \"array\",\r\n                    items: {\r\n                        type: \"string\"\r\n                    }\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n\r\n        messages: {\r\n            regexMessage: \"{{message}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0];\r\n        let allowedFlags = null;\r\n\r\n        if (options && options.allowConstructorFlags) {\r\n            const temp = options.allowConstructorFlags.join(\"\").replace(validFlags, \"\");\r\n\r\n            if (temp) {\r\n                allowedFlags = new RegExp(`[${temp}]`, \"giu\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if node is a string\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {boolean} True if its a string\r\n         * @private\r\n         */\r\n        function isString(node) {\r\n            return node && node.type === \"Literal\" && typeof node.value === \"string\";\r\n        }\r\n\r\n        /**\r\n         * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call\r\n         * Examples:\r\n         *     new RegExp(\".\")         // => \"\"\r\n         *     new RegExp(\".\", \"gu\")   // => \"gu\"\r\n         *     new RegExp(\".\", flags)  // => null\r\n         * @param {ASTNode} node `CallExpression` or `NewExpression` node\r\n         * @returns {string|null} flags if they can be determined, `null` otherwise\r\n         * @private\r\n         */\r\n        function getFlags(node) {\r\n            if (node.arguments.length < 2) {\r\n                return \"\";\r\n            }\r\n\r\n            if (isString(node.arguments[1])) {\r\n                return node.arguments[1].value;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Check syntax error in a given pattern.\r\n         * @param {string} pattern The RegExp pattern to validate.\r\n         * @param {boolean} uFlag The Unicode flag.\r\n         * @returns {string|null} The syntax error.\r\n         */\r\n        function validateRegExpPattern(pattern, uFlag) {\r\n            try {\r\n                validator.validatePattern(pattern, undefined1, undefined1, uFlag);\r\n                return null;\r\n            } catch (err) {\r\n                return err.message;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check syntax error in a given flags.\r\n         * @param {string} flags The RegExp flags to validate.\r\n         * @returns {string|null} The syntax error.\r\n         */\r\n        function validateRegExpFlags(flags) {\r\n            try {\r\n                validator.validateFlags(flags);\r\n                return null;\r\n            } catch {\r\n                return `Invalid flags supplied to RegExp constructor '${flags}'`;\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"CallExpression, NewExpression\"(node) {\r\n                if (node.callee.type !== \"Identifier\" || node.callee.name !== \"RegExp\" || !isString(node.arguments[0])) {\r\n                    return;\r\n                }\r\n                const pattern = node.arguments[0].value;\r\n                let flags = getFlags(node);\r\n\r\n                if (flags && allowedFlags) {\r\n                    flags = flags.replace(allowedFlags, \"\");\r\n                }\r\n\r\n                const message =\r\n                    (\r\n                        flags && validateRegExpFlags(flags)\r\n                    ) ||\r\n                    (\r\n\r\n                        // If flags are unknown, report the regex only if its pattern is invalid both with and without the \"u\" flag\r\n                        flags === null\r\n                            ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false)\r\n                            : validateRegExpPattern(pattern, flags.includes(\"u\"))\r\n                    );\r\n\r\n                if (message) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"regexMessage\",\r\n                        data: { message }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}