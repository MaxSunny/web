{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst FUNC_EXPR_NODE_TYPES = [\"ArrowFunctionExpression\", \"FunctionExpression\"];\nconst CALL_EXPR_NODE_TYPE = [\"CallExpression\"];\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-shadow\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        builtinGlobals: {\n          type: \"boolean\",\n          default: false\n        },\n        hoist: {\n          enum: [\"all\", \"functions\", \"never\"],\n          default: \"functions\"\n        },\n        allow: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        ignoreOnInitialization: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\n      noShadowGlobal: \"'{{name}}' is already a global variable.\"\n    }\n  },\n\n  create(context) {\n    const options = {\n      builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\n      hoist: context.options[0] && context.options[0].hoist || \"functions\",\n      allow: context.options[0] && context.options[0].allow || [],\n      ignoreOnInitialization: context.options[0] && context.options[0].ignoreOnInitialization\n    };\n    /**\r\n     * Checks whether or not a given location is inside of the range of a given node.\r\n     * @param {ASTNode} node An node to check.\r\n     * @param {number} location A location to check.\r\n     * @returns {boolean} `true` if the location is inside of the range of the node.\r\n     */\n\n    function isInRange(node, location) {\n      return node && node.range[0] <= location && location <= node.range[1];\n    }\n    /**\r\n     * Searches from the current node through its ancestry to find a matching node.\r\n     * @param {ASTNode} node a node to get.\r\n     * @param {(node: ASTNode) => boolean} match a callback that checks whether or not the node verifies its condition or not.\r\n     * @returns {ASTNode|null} the matching node.\r\n     */\n\n\n    function findSelfOrAncestor(node, match) {\n      let currentNode = node;\n\n      while (currentNode && !match(currentNode)) {\n        currentNode = currentNode.parent;\n      }\n\n      return currentNode;\n    }\n    /**\r\n     * Finds function's outer scope.\r\n     * @param {Scope} scope Function's own scope.\r\n     * @returns {Scope} Function's outer scope.\r\n     */\n\n\n    function getOuterScope(scope) {\n      const upper = scope.upper;\n\n      if (upper.type === \"function-expression-name\") {\n        return upper.upper;\n      }\n\n      return upper;\n    }\n    /**\r\n     * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\r\n     * @param {Object} variable a variable to check.\r\n     * @param {Object} shadowedVariable a shadowedVariable to check.\r\n     * @returns {boolean} Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\r\n     */\n\n\n    function isInitPatternNode(variable, shadowedVariable) {\n      const outerDef = shadowedVariable.defs[0];\n\n      if (!outerDef) {\n        return false;\n      }\n\n      const {\n        variableScope\n      } = variable.scope;\n\n      if (!(FUNC_EXPR_NODE_TYPES.includes(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {\n        return false;\n      }\n\n      const fun = variableScope.block;\n      const {\n        parent\n      } = fun;\n      const callExpression = findSelfOrAncestor(parent, node => CALL_EXPR_NODE_TYPE.includes(node.type));\n\n      if (!callExpression) {\n        return false;\n      }\n\n      let node = outerDef.name;\n      const location = callExpression.range[1];\n\n      while (node) {\n        if (node.type === \"VariableDeclarator\") {\n          if (isInRange(node.init, location)) {\n            return true;\n          }\n\n          if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {\n            return true;\n          }\n\n          break;\n        } else if (node.type === \"AssignmentPattern\") {\n          if (isInRange(node.right, location)) {\n            return true;\n          }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n          break;\n        }\n\n        node = node.parent;\n      }\n\n      return false;\n    }\n    /**\r\n     * Check if variable name is allowed.\r\n     * @param {ASTNode} variable The variable to check.\r\n     * @returns {boolean} Whether or not the variable name is allowed.\r\n     */\n\n\n    function isAllowed(variable) {\n      return options.allow.indexOf(variable.name) !== -1;\n    }\n    /**\r\n     * Checks if a variable of the class name in the class scope of ClassDeclaration.\r\n     *\r\n     * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\r\n     * So we should ignore the variable in the class scope.\r\n     * @param {Object} variable The variable to check.\r\n     * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\r\n     */\n\n\n    function isDuplicatedClassNameVariable(variable) {\n      const block = variable.scope.block;\n      return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\n    }\n    /**\r\n     * Checks if a variable is inside the initializer of scopeVar.\r\n     *\r\n     * To avoid reporting at declarations such as `var a = function a() {};`.\r\n     * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\r\n     * @param {Object} variable The variable to check.\r\n     * @param {Object} scopeVar The scope variable to look for.\r\n     * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\r\n     */\n\n\n    function isOnInitializer(variable, scopeVar) {\n      const outerScope = scopeVar.scope;\n      const outerDef = scopeVar.defs[0];\n      const outer = outerDef && outerDef.parent && outerDef.parent.range;\n      const innerScope = variable.scope;\n      const innerDef = variable.defs[0];\n      const inner = innerDef && innerDef.name.range;\n      return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\" || innerDef.node.type === \"ClassExpression\") && outerScope === innerScope.upper;\n    }\n    /**\r\n     * Get a range of a variable's identifier node.\r\n     * @param {Object} variable The variable to get.\r\n     * @returns {Array|undefined} The range of the variable's identifier node.\r\n     */\n\n\n    function getNameRange(variable) {\n      const def = variable.defs[0];\n      return def && def.name.range;\n    }\n    /**\r\n     * Get declared line and column of a variable.\r\n     * @param {eslint-scope.Variable} variable The variable to get.\r\n     * @returns {Object} The declared line and column of the variable.\r\n     */\n\n\n    function getDeclaredLocation(variable) {\n      const identifier = variable.identifiers[0];\n      let obj;\n\n      if (identifier) {\n        obj = {\n          global: false,\n          line: identifier.loc.start.line,\n          column: identifier.loc.start.column + 1\n        };\n      } else {\n        obj = {\n          global: true\n        };\n      }\n\n      return obj;\n    }\n    /**\r\n     * Checks if a variable is in TDZ of scopeVar.\r\n     * @param {Object} variable The variable to check.\r\n     * @param {Object} scopeVar The variable of TDZ.\r\n     * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\r\n     */\n\n\n    function isInTdz(variable, scopeVar) {\n      const outerDef = scopeVar.defs[0];\n      const inner = getNameRange(variable);\n      const outer = getNameRange(scopeVar);\n      return inner && outer && inner[1] < outer[0] && ( // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\n      options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\");\n    }\n    /**\r\n     * Checks the current context for shadowed variables.\r\n     * @param {Scope} scope Fixme\r\n     * @returns {void}\r\n     */\n\n\n    function checkForShadows(scope) {\n      const variables = scope.variables;\n\n      for (let i = 0; i < variables.length; ++i) {\n        const variable = variables[i]; // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\n\n        if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {\n          continue;\n        } // Gets shadowed variable.\n\n\n        const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\n\n        if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && \"writeable\" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) && !(options.hoist !== \"all\" && isInTdz(variable, shadowed))) {\n          const location = getDeclaredLocation(shadowed);\n          const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\n          const data = {\n            name: variable.name\n          };\n\n          if (!location.global) {\n            data.shadowedLine = location.line;\n            data.shadowedColumn = location.column;\n          }\n\n          context.report({\n            node: variable.identifiers[0],\n            messageId,\n            data\n          });\n        }\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        const stack = globalScope.childScopes.slice();\n\n        while (stack.length) {\n          const scope = stack.pop();\n          stack.push(...scope.childScopes);\n          checkForShadows(scope);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-shadow.js"],"names":["astUtils","require","FUNC_EXPR_NODE_TYPES","CALL_EXPR_NODE_TYPE","FOR_IN_OF_TYPE","SENTINEL_TYPE","module","exports","meta","type","docs","description","recommended","url","schema","properties","builtinGlobals","default","hoist","enum","allow","items","ignoreOnInitialization","additionalProperties","messages","noShadow","noShadowGlobal","create","context","options","isInRange","node","location","range","findSelfOrAncestor","match","currentNode","parent","getOuterScope","scope","upper","isInitPatternNode","variable","shadowedVariable","outerDef","defs","variableScope","includes","block","fun","callExpression","name","init","test","right","isAllowed","indexOf","isDuplicatedClassNameVariable","id","identifiers","isOnInitializer","scopeVar","outerScope","outer","innerScope","innerDef","inner","getNameRange","def","getDeclaredLocation","identifier","obj","global","line","loc","start","column","isInTdz","checkForShadows","variables","i","length","shadowed","getVariableByName","messageId","data","shadowedLine","shadowedColumn","report","globalScope","getScope","stack","childScopes","slice","pop","push"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag on declaring variables already declared in the outer scope\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst FUNC_EXPR_NODE_TYPES = [\"ArrowFunctionExpression\", \"FunctionExpression\"];\r\nconst CALL_EXPR_NODE_TYPE = [\"CallExpression\"];\r\nconst FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;\r\nconst SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow variable declarations from shadowing variables declared in the outer scope\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-shadow\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    builtinGlobals: { type: \"boolean\", default: false },\r\n                    hoist: { enum: [\"all\", \"functions\", \"never\"], default: \"functions\" },\r\n                    allow: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    ignoreOnInitialization: { type: \"boolean\", default: false }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            noShadow: \"'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.\",\r\n            noShadowGlobal: \"'{{name}}' is already a global variable.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = {\r\n            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,\r\n            hoist: (context.options[0] && context.options[0].hoist) || \"functions\",\r\n            allow: (context.options[0] && context.options[0].allow) || [],\r\n            ignoreOnInitialization: context.options[0] && context.options[0].ignoreOnInitialization\r\n        };\r\n\r\n        /**\r\n         * Checks whether or not a given location is inside of the range of a given node.\r\n         * @param {ASTNode} node An node to check.\r\n         * @param {number} location A location to check.\r\n         * @returns {boolean} `true` if the location is inside of the range of the node.\r\n         */\r\n        function isInRange(node, location) {\r\n            return node && node.range[0] <= location && location <= node.range[1];\r\n        }\r\n\r\n        /**\r\n         * Searches from the current node through its ancestry to find a matching node.\r\n         * @param {ASTNode} node a node to get.\r\n         * @param {(node: ASTNode) => boolean} match a callback that checks whether or not the node verifies its condition or not.\r\n         * @returns {ASTNode|null} the matching node.\r\n         */\r\n        function findSelfOrAncestor(node, match) {\r\n            let currentNode = node;\r\n\r\n            while (currentNode && !match(currentNode)) {\r\n                currentNode = currentNode.parent;\r\n            }\r\n            return currentNode;\r\n        }\r\n\r\n        /**\r\n         * Finds function's outer scope.\r\n         * @param {Scope} scope Function's own scope.\r\n         * @returns {Scope} Function's outer scope.\r\n         */\r\n        function getOuterScope(scope) {\r\n            const upper = scope.upper;\r\n\r\n            if (upper.type === \"function-expression-name\") {\r\n                return upper.upper;\r\n            }\r\n            return upper;\r\n        }\r\n\r\n        /**\r\n         * Checks if a variable and a shadowedVariable have the same init pattern ancestor.\r\n         * @param {Object} variable a variable to check.\r\n         * @param {Object} shadowedVariable a shadowedVariable to check.\r\n         * @returns {boolean} Whether or not the variable and the shadowedVariable have the same init pattern ancestor.\r\n         */\r\n        function isInitPatternNode(variable, shadowedVariable) {\r\n            const outerDef = shadowedVariable.defs[0];\r\n\r\n            if (!outerDef) {\r\n                return false;\r\n            }\r\n\r\n            const { variableScope } = variable.scope;\r\n\r\n\r\n            if (!(FUNC_EXPR_NODE_TYPES.includes(variableScope.block.type) && getOuterScope(variableScope) === shadowedVariable.scope)) {\r\n                return false;\r\n            }\r\n\r\n            const fun = variableScope.block;\r\n            const { parent } = fun;\r\n\r\n            const callExpression = findSelfOrAncestor(\r\n                parent,\r\n                node => CALL_EXPR_NODE_TYPE.includes(node.type)\r\n            );\r\n\r\n            if (!callExpression) {\r\n                return false;\r\n            }\r\n\r\n            let node = outerDef.name;\r\n            const location = callExpression.range[1];\r\n\r\n            while (node) {\r\n                if (node.type === \"VariableDeclarator\") {\r\n                    if (isInRange(node.init, location)) {\r\n                        return true;\r\n                    }\r\n                    if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&\r\n                        isInRange(node.parent.parent.right, location)\r\n                    ) {\r\n                        return true;\r\n                    }\r\n                    break;\r\n                } else if (node.type === \"AssignmentPattern\") {\r\n                    if (isInRange(node.right, location)) {\r\n                        return true;\r\n                    }\r\n                } else if (SENTINEL_TYPE.test(node.type)) {\r\n                    break;\r\n                }\r\n\r\n                node = node.parent;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check if variable name is allowed.\r\n         * @param {ASTNode} variable The variable to check.\r\n         * @returns {boolean} Whether or not the variable name is allowed.\r\n         */\r\n        function isAllowed(variable) {\r\n            return options.allow.indexOf(variable.name) !== -1;\r\n        }\r\n\r\n        /**\r\n         * Checks if a variable of the class name in the class scope of ClassDeclaration.\r\n         *\r\n         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.\r\n         * So we should ignore the variable in the class scope.\r\n         * @param {Object} variable The variable to check.\r\n         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.\r\n         */\r\n        function isDuplicatedClassNameVariable(variable) {\r\n            const block = variable.scope.block;\r\n\r\n            return block.type === \"ClassDeclaration\" && block.id === variable.identifiers[0];\r\n        }\r\n\r\n        /**\r\n         * Checks if a variable is inside the initializer of scopeVar.\r\n         *\r\n         * To avoid reporting at declarations such as `var a = function a() {};`.\r\n         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.\r\n         * @param {Object} variable The variable to check.\r\n         * @param {Object} scopeVar The scope variable to look for.\r\n         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.\r\n         */\r\n        function isOnInitializer(variable, scopeVar) {\r\n            const outerScope = scopeVar.scope;\r\n            const outerDef = scopeVar.defs[0];\r\n            const outer = outerDef && outerDef.parent && outerDef.parent.range;\r\n            const innerScope = variable.scope;\r\n            const innerDef = variable.defs[0];\r\n            const inner = innerDef && innerDef.name.range;\r\n\r\n            return (\r\n                outer &&\r\n                 inner &&\r\n                 outer[0] < inner[0] &&\r\n                 inner[1] < outer[1] &&\r\n                 ((innerDef.type === \"FunctionName\" && innerDef.node.type === \"FunctionExpression\") || innerDef.node.type === \"ClassExpression\") &&\r\n                 outerScope === innerScope.upper\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Get a range of a variable's identifier node.\r\n         * @param {Object} variable The variable to get.\r\n         * @returns {Array|undefined} The range of the variable's identifier node.\r\n         */\r\n        function getNameRange(variable) {\r\n            const def = variable.defs[0];\r\n\r\n            return def && def.name.range;\r\n        }\r\n\r\n        /**\r\n         * Get declared line and column of a variable.\r\n         * @param {eslint-scope.Variable} variable The variable to get.\r\n         * @returns {Object} The declared line and column of the variable.\r\n         */\r\n        function getDeclaredLocation(variable) {\r\n            const identifier = variable.identifiers[0];\r\n            let obj;\r\n\r\n            if (identifier) {\r\n                obj = {\r\n                    global: false,\r\n                    line: identifier.loc.start.line,\r\n                    column: identifier.loc.start.column + 1\r\n                };\r\n            } else {\r\n                obj = {\r\n                    global: true\r\n                };\r\n            }\r\n            return obj;\r\n        }\r\n\r\n        /**\r\n         * Checks if a variable is in TDZ of scopeVar.\r\n         * @param {Object} variable The variable to check.\r\n         * @param {Object} scopeVar The variable of TDZ.\r\n         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.\r\n         */\r\n        function isInTdz(variable, scopeVar) {\r\n            const outerDef = scopeVar.defs[0];\r\n            const inner = getNameRange(variable);\r\n            const outer = getNameRange(scopeVar);\r\n\r\n            return (\r\n                inner &&\r\n                 outer &&\r\n                 inner[1] < outer[0] &&\r\n\r\n                 // Excepts FunctionDeclaration if is {\"hoist\":\"function\"}.\r\n                 (options.hoist !== \"functions\" || !outerDef || outerDef.node.type !== \"FunctionDeclaration\")\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks the current context for shadowed variables.\r\n         * @param {Scope} scope Fixme\r\n         * @returns {void}\r\n         */\r\n        function checkForShadows(scope) {\r\n            const variables = scope.variables;\r\n\r\n            for (let i = 0; i < variables.length; ++i) {\r\n                const variable = variables[i];\r\n\r\n                // Skips \"arguments\" or variables of a class name in the class scope of ClassDeclaration.\r\n                if (variable.identifiers.length === 0 ||\r\n                     isDuplicatedClassNameVariable(variable) ||\r\n                     isAllowed(variable)\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                // Gets shadowed variable.\r\n                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);\r\n\r\n                if (shadowed &&\r\n                      (shadowed.identifiers.length > 0 || (options.builtinGlobals && \"writeable\" in shadowed)) &&\r\n                      !isOnInitializer(variable, shadowed) &&\r\n                      !(options.ignoreOnInitialization && isInitPatternNode(variable, shadowed)) &&\r\n                      !(options.hoist !== \"all\" && isInTdz(variable, shadowed))\r\n                ) {\r\n                    const location = getDeclaredLocation(shadowed);\r\n                    const messageId = location.global ? \"noShadowGlobal\" : \"noShadow\";\r\n                    const data = { name: variable.name };\r\n\r\n                    if (!location.global) {\r\n                        data.shadowedLine = location.line;\r\n                        data.shadowedColumn = location.column;\r\n                    }\r\n                    context.report({\r\n                        node: variable.identifiers[0],\r\n                        messageId,\r\n                        data\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\"() {\r\n                const globalScope = context.getScope();\r\n                const stack = globalScope.childScopes.slice();\r\n\r\n                while (stack.length) {\r\n                    const scope = stack.pop();\r\n\r\n                    stack.push(...scope.childScopes);\r\n                    checkForShadows(scope);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}