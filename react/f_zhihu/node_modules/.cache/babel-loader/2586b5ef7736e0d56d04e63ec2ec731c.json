{"ast":null,"code":"'use strict';\n/*! (c) 2020 Andrea Giammarchi */\n\nconst {\n  parse: $parse,\n  stringify: $stringify\n} = JSON;\nconst {\n  keys\n} = Object;\nconst Primitive = String; // it could be Number\n\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => value instanceof Primitive ? Primitive(value) : value;\n\nconst Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n\n  for (let ke = keys(output), {\n    length\n  } = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({\n          k,\n          a: [input, parsed, tmp, $]\n        });\n      } else output[k] = $.call(output, k, tmp);\n    } else if (output[k] !== ignore) output[k] = $.call(output, k, value);\n  }\n\n  for (let {\n    length\n  } = lazy, i = 0; i < length; i++) {\n    const {\n      k,\n      a\n    } = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\nconst parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ? revive(input, new Set(), value, $) : value;\n  return $.call({\n    '': tmp\n  }, '', tmp);\n};\n\nexports.parse = parse;\n\nconst stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ? (k, v) => k === '' || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;\n  const known = new Map();\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({\n    '': value\n  }, '', value));\n  let firstRun = !i;\n\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n\n  return '[' + output.join(',') + ']';\n\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n\n    const after = $.call(this, key, value);\n\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n\n    return after;\n  }\n};\n\nexports.stringify = stringify;\n\nconst toJSON = any => $parse(stringify(any));\n\nexports.toJSON = toJSON;\n\nconst fromJSON = any => parse($stringify(any));\n\nexports.fromJSON = fromJSON;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/flatted/cjs/index.js"],"names":["parse","$parse","stringify","$stringify","JSON","keys","Object","Primitive","String","primitive","ignore","object","noop","_","value","primitives","Primitives","revive","input","parsed","output","$","lazy","ke","length","y","k","tmp","has","add","push","a","call","i","apply","set","known","index","text","reviver","map","Set","exports","replacer","space","v","indexOf","Map","firstRun","replace","join","key","after","get","toJSON","any","fromJSON"],"mappings":"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","sourcesContent":["'use strict';\r\n/*! (c) 2020 Andrea Giammarchi */\r\n\r\nconst {parse: $parse, stringify: $stringify} = JSON;\r\nconst {keys} = Object;\r\n\r\nconst Primitive = String;   // it could be Number\r\nconst primitive = 'string'; // it could be 'number'\r\n\r\nconst ignore = {};\r\nconst object = 'object';\r\n\r\nconst noop = (_, value) => value;\r\n\r\nconst primitives = value => (\r\n  value instanceof Primitive ? Primitive(value) : value\r\n);\r\n\r\nconst Primitives = (_, value) => (\r\n  typeof value === primitive ? new Primitive(value) : value\r\n);\r\n\r\nconst revive = (input, parsed, output, $) => {\r\n  const lazy = [];\r\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\r\n    const k = ke[y];\r\n    const value = output[k];\r\n    if (value instanceof Primitive) {\r\n      const tmp = input[value];\r\n      if (typeof tmp === object && !parsed.has(tmp)) {\r\n        parsed.add(tmp);\r\n        output[k] = ignore;\r\n        lazy.push({k, a: [input, parsed, tmp, $]});\r\n      }\r\n      else\r\n        output[k] = $.call(output, k, tmp);\r\n    }\r\n    else if (output[k] !== ignore)\r\n      output[k] = $.call(output, k, value);\r\n  }\r\n  for (let {length} = lazy, i = 0; i < length; i++) {\r\n    const {k, a} = lazy[i];\r\n    output[k] = $.call(output, k, revive.apply(null, a));\r\n  }\r\n  return output;\r\n};\r\n\r\nconst set = (known, input, value) => {\r\n  const index = Primitive(input.push(value) - 1);\r\n  known.set(value, index);\r\n  return index;\r\n};\r\n\r\nconst parse = (text, reviver) => {\r\n  const input = $parse(text, Primitives).map(primitives);\r\n  const value = input[0];\r\n  const $ = reviver || noop;\r\n  const tmp = typeof value === object && value ?\r\n              revive(input, new Set, value, $) :\r\n              value;\r\n  return $.call({'': tmp}, '', tmp);\r\n};\r\nexports.parse = parse;\r\n\r\nconst stringify = (value, replacer, space) => {\r\n  const $ = replacer && typeof replacer === object ?\r\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\r\n            (replacer || noop);\r\n  const known = new Map;\r\n  const input = [];\r\n  const output = [];\r\n  let i = +set(known, input, $.call({'': value}, '', value));\r\n  let firstRun = !i;\r\n  while (i < input.length) {\r\n    firstRun = true;\r\n    output[i] = $stringify(input[i++], replace, space);\r\n  }\r\n  return '[' + output.join(',') + ']';\r\n  function replace(key, value) {\r\n    if (firstRun) {\r\n      firstRun = !firstRun;\r\n      return value;\r\n    }\r\n    const after = $.call(this, key, value);\r\n    switch (typeof after) {\r\n      case object:\r\n        if (after === null) return after;\r\n      case primitive:\r\n        return known.get(after) || set(known, input, after);\r\n    }\r\n    return after;\r\n  }\r\n};\r\nexports.stringify = stringify;\r\n\r\nconst toJSON = any => $parse(stringify(any));\r\nexports.toJSON = toJSON;\r\nconst fromJSON = any => parse($stringify(any));\r\nexports.fromJSON = fromJSON;\r\n"]},"metadata":{},"sourceType":"script"}