{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag creation of function inside a loop\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets the containing loop node of a specified node.\r\n *\r\n * We don't need to check nested functions, so this ignores those.\r\n * `Scope.through` contains references of nested functions.\r\n * @param {ASTNode} node An AST node to get.\r\n * @returns {ASTNode|null} The containing loop node of the specified node, or\r\n *      `null`.\r\n */\n\nfunction getContainingLoopNode(node) {\n  for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\n    const parent = currentNode.parent;\n\n    switch (parent.type) {\n      case \"WhileStatement\":\n      case \"DoWhileStatement\":\n        return parent;\n\n      case \"ForStatement\":\n        // `init` is outside of the loop.\n        if (parent.init !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        // `right` is outside of the loop.\n        if (parent.right !== currentNode) {\n          return parent;\n        }\n\n        break;\n\n      case \"ArrowFunctionExpression\":\n      case \"FunctionExpression\":\n      case \"FunctionDeclaration\":\n        // We don't need to check nested functions.\n        return null;\n\n      default:\n        break;\n    }\n  }\n\n  return null;\n}\n/**\r\n * Gets the containing loop node of a given node.\r\n * If the loop was nested, this returns the most outer loop.\r\n * @param {ASTNode} node A node to get. This is a loop node.\r\n * @param {ASTNode|null} excludedNode A node that the result node should not\r\n *      include.\r\n * @returns {ASTNode} The most outer loop node.\r\n */\n\n\nfunction getTopLoopNode(node, excludedNode) {\n  const border = excludedNode ? excludedNode.range[1] : 0;\n  let retv = node;\n  let containingLoopNode = node;\n\n  while (containingLoopNode && containingLoopNode.range[0] >= border) {\n    retv = containingLoopNode;\n    containingLoopNode = getContainingLoopNode(containingLoopNode);\n  }\n\n  return retv;\n}\n/**\r\n * Checks whether a given reference which refers to an upper scope's variable is\r\n * safe or not.\r\n * @param {ASTNode} loopNode A containing loop node.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is safe or not.\r\n */\n\n\nfunction isSafe(loopNode, reference) {\n  const variable = reference.resolved;\n  const definition = variable && variable.defs[0];\n  const declaration = definition && definition.parent;\n  const kind = declaration && declaration.type === \"VariableDeclaration\" ? declaration.kind : \"\"; // Variables which are declared by `const` is safe.\n\n  if (kind === \"const\") {\n    return true;\n  }\n  /*\r\n   * Variables which are declared by `let` in the loop is safe.\r\n   * It's a different instance from the next loop step's.\r\n   */\n\n\n  if (kind === \"let\" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {\n    return true;\n  }\n  /*\r\n   * WriteReferences which exist after this border are unsafe because those\r\n   * can modify the variable.\r\n   */\n\n\n  const border = getTopLoopNode(loopNode, kind === \"let\" ? declaration : null).range[0];\n  /**\r\n   * Checks whether a given reference is safe or not.\r\n   * The reference is every reference of the upper scope's variable we are\r\n   * looking now.\r\n   *\r\n   * It's safeafe if the reference matches one of the following condition.\r\n   * - is readonly.\r\n   * - doesn't exist inside a local function and after the border.\r\n   * @param {eslint-scope.Reference} upperRef A reference to check.\r\n   * @returns {boolean} `true` if the reference is safe.\r\n   */\n\n  function isSafeReference(upperRef) {\n    const id = upperRef.identifier;\n    return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;\n  }\n\n  return Boolean(variable) && variable.references.every(isSafeReference);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow function declarations that contain unsafe references inside loop statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-loop-func\"\n    },\n    schema: [],\n    messages: {\n      unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * Reports functions which match the following condition:\r\n     *\r\n     * - has a loop node in ancestors.\r\n     * - has any references which refers to an unsafe variable.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     */\n    function checkForLoops(node) {\n      const loopNode = getContainingLoopNode(node);\n\n      if (!loopNode) {\n        return;\n      }\n\n      const references = context.getScope().through;\n      const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\n\n      if (unsafeRefs.length > 0) {\n        context.report({\n          node,\n          messageId: \"unsafeRefs\",\n          data: {\n            varNames: `'${unsafeRefs.join(\"', '\")}'`\n          }\n        });\n      }\n    }\n\n    return {\n      ArrowFunctionExpression: checkForLoops,\n      FunctionExpression: checkForLoops,\n      FunctionDeclaration: checkForLoops\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-loop-func.js"],"names":["getContainingLoopNode","node","currentNode","parent","type","init","right","getTopLoopNode","excludedNode","border","range","retv","containingLoopNode","isSafe","loopNode","reference","variable","resolved","definition","defs","declaration","kind","isSafeReference","upperRef","id","identifier","isWrite","scope","variableScope","from","Boolean","references","every","module","exports","meta","docs","description","recommended","url","schema","messages","unsafeRefs","create","context","checkForLoops","getScope","through","filter","r","map","name","length","report","messageId","data","varNames","join","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag creation of function inside a loop\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets the containing loop node of a specified node.\r\n *\r\n * We don't need to check nested functions, so this ignores those.\r\n * `Scope.through` contains references of nested functions.\r\n * @param {ASTNode} node An AST node to get.\r\n * @returns {ASTNode|null} The containing loop node of the specified node, or\r\n *      `null`.\r\n */\r\nfunction getContainingLoopNode(node) {\r\n    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {\r\n        const parent = currentNode.parent;\r\n\r\n        switch (parent.type) {\r\n            case \"WhileStatement\":\r\n            case \"DoWhileStatement\":\r\n                return parent;\r\n\r\n            case \"ForStatement\":\r\n\r\n                // `init` is outside of the loop.\r\n                if (parent.init !== currentNode) {\r\n                    return parent;\r\n                }\r\n                break;\r\n\r\n            case \"ForInStatement\":\r\n            case \"ForOfStatement\":\r\n\r\n                // `right` is outside of the loop.\r\n                if (parent.right !== currentNode) {\r\n                    return parent;\r\n                }\r\n                break;\r\n\r\n            case \"ArrowFunctionExpression\":\r\n            case \"FunctionExpression\":\r\n            case \"FunctionDeclaration\":\r\n\r\n                // We don't need to check nested functions.\r\n                return null;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets the containing loop node of a given node.\r\n * If the loop was nested, this returns the most outer loop.\r\n * @param {ASTNode} node A node to get. This is a loop node.\r\n * @param {ASTNode|null} excludedNode A node that the result node should not\r\n *      include.\r\n * @returns {ASTNode} The most outer loop node.\r\n */\r\nfunction getTopLoopNode(node, excludedNode) {\r\n    const border = excludedNode ? excludedNode.range[1] : 0;\r\n    let retv = node;\r\n    let containingLoopNode = node;\r\n\r\n    while (containingLoopNode && containingLoopNode.range[0] >= border) {\r\n        retv = containingLoopNode;\r\n        containingLoopNode = getContainingLoopNode(containingLoopNode);\r\n    }\r\n\r\n    return retv;\r\n}\r\n\r\n/**\r\n * Checks whether a given reference which refers to an upper scope's variable is\r\n * safe or not.\r\n * @param {ASTNode} loopNode A containing loop node.\r\n * @param {eslint-scope.Reference} reference A reference to check.\r\n * @returns {boolean} `true` if the reference is safe or not.\r\n */\r\nfunction isSafe(loopNode, reference) {\r\n    const variable = reference.resolved;\r\n    const definition = variable && variable.defs[0];\r\n    const declaration = definition && definition.parent;\r\n    const kind = (declaration && declaration.type === \"VariableDeclaration\")\r\n        ? declaration.kind\r\n        : \"\";\r\n\r\n    // Variables which are declared by `const` is safe.\r\n    if (kind === \"const\") {\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Variables which are declared by `let` in the loop is safe.\r\n     * It's a different instance from the next loop step's.\r\n     */\r\n    if (kind === \"let\" &&\r\n        declaration.range[0] > loopNode.range[0] &&\r\n        declaration.range[1] < loopNode.range[1]\r\n    ) {\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * WriteReferences which exist after this border are unsafe because those\r\n     * can modify the variable.\r\n     */\r\n    const border = getTopLoopNode(\r\n        loopNode,\r\n        (kind === \"let\") ? declaration : null\r\n    ).range[0];\r\n\r\n    /**\r\n     * Checks whether a given reference is safe or not.\r\n     * The reference is every reference of the upper scope's variable we are\r\n     * looking now.\r\n     *\r\n     * It's safeafe if the reference matches one of the following condition.\r\n     * - is readonly.\r\n     * - doesn't exist inside a local function and after the border.\r\n     * @param {eslint-scope.Reference} upperRef A reference to check.\r\n     * @returns {boolean} `true` if the reference is safe.\r\n     */\r\n    function isSafeReference(upperRef) {\r\n        const id = upperRef.identifier;\r\n\r\n        return (\r\n            !upperRef.isWrite() ||\r\n            variable.scope.variableScope === upperRef.from.variableScope &&\r\n            id.range[0] < border\r\n        );\r\n    }\r\n\r\n    return Boolean(variable) && variable.references.every(isSafeReference);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow function declarations that contain unsafe references inside loop statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-loop-func\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unsafeRefs: \"Function declared in a loop contains unsafe references to variable(s) {{ varNames }}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * Reports functions which match the following condition:\r\n         *\r\n         * - has a loop node in ancestors.\r\n         * - has any references which refers to an unsafe variable.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkForLoops(node) {\r\n            const loopNode = getContainingLoopNode(node);\r\n\r\n            if (!loopNode) {\r\n                return;\r\n            }\r\n\r\n            const references = context.getScope().through;\r\n            const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);\r\n\r\n            if (unsafeRefs.length > 0) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unsafeRefs\",\r\n                    data: { varNames: `'${unsafeRefs.join(\"', '\")}'` }\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            ArrowFunctionExpression: checkForLoops,\r\n            FunctionExpression: checkForLoops,\r\n            FunctionDeclaration: checkForLoops\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}