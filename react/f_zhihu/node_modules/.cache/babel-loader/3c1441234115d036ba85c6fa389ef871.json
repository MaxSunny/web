{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag comparisons to the value NaN\r\n * @author James Allardice\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines if the given node is a NaN `Identifier` node.\r\n * @param {ASTNode|null} node The node to check.\r\n * @returns {boolean} `true` if the node is 'NaN' identifier.\r\n */\n\n\nfunction isNaNIdentifier(node) {\n  return Boolean(node) && (astUtils.isSpecificId(node, \"NaN\") || astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\"));\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require calls to `isNaN()` when checking for `NaN`\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/use-isnan\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        enforceForSwitchCase: {\n          type: \"boolean\",\n          default: true\n        },\n        enforceForIndexOf: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\n      switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\n      caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\n      indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\n    }\n  },\n\n  create(context) {\n    const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\n    const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\n    /**\r\n     * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n    function checkBinaryExpression(node) {\n      if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {\n        context.report({\n          node,\n          messageId: \"comparisonWithNaN\"\n        });\n      }\n    }\n    /**\r\n     * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSwitchStatement(node) {\n      if (isNaNIdentifier(node.discriminant)) {\n        context.report({\n          node,\n          messageId: \"switchNaN\"\n        });\n      }\n\n      for (const switchCase of node.cases) {\n        if (isNaNIdentifier(switchCase.test)) {\n          context.report({\n            node: switchCase,\n            messageId: \"caseNaN\"\n          });\n        }\n      }\n    }\n    /**\r\n     * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkCallExpression(node) {\n      const callee = astUtils.skipChainExpression(node.callee);\n\n      if (callee.type === \"MemberExpression\") {\n        const methodName = astUtils.getStaticPropertyName(callee);\n\n        if ((methodName === \"indexOf\" || methodName === \"lastIndexOf\") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {\n          context.report({\n            node,\n            messageId: \"indexOfNaN\",\n            data: {\n              methodName\n            }\n          });\n        }\n      }\n    }\n\n    const listeners = {\n      BinaryExpression: checkBinaryExpression\n    };\n\n    if (enforceForSwitchCase) {\n      listeners.SwitchStatement = checkSwitchStatement;\n    }\n\n    if (enforceForIndexOf) {\n      listeners.CallExpression = checkCallExpression;\n    }\n\n    return listeners;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/use-isnan.js"],"names":["astUtils","require","isNaNIdentifier","node","Boolean","isSpecificId","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","properties","enforceForSwitchCase","default","enforceForIndexOf","additionalProperties","messages","comparisonWithNaN","switchNaN","caseNaN","indexOfNaN","create","context","options","checkBinaryExpression","test","operator","left","right","report","messageId","checkSwitchStatement","discriminant","switchCase","cases","checkCallExpression","callee","skipChainExpression","methodName","getStaticPropertyName","arguments","length","data","listeners","BinaryExpression","SwitchStatement","CallExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag comparisons to the value NaN\r\n * @author James Allardice\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines if the given node is a NaN `Identifier` node.\r\n * @param {ASTNode|null} node The node to check.\r\n * @returns {boolean} `true` if the node is 'NaN' identifier.\r\n */\r\nfunction isNaNIdentifier(node) {\r\n    return Boolean(node) && (\r\n        astUtils.isSpecificId(node, \"NaN\") ||\r\n        astUtils.isSpecificMemberAccess(node, \"Number\", \"NaN\")\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"require calls to `isNaN()` when checking for `NaN`\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/use-isnan\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    enforceForSwitchCase: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    enforceForIndexOf: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            comparisonWithNaN: \"Use the isNaN function to compare with NaN.\",\r\n            switchNaN: \"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.\",\r\n            caseNaN: \"'case NaN' can never match. Use Number.isNaN before the switch.\",\r\n            indexOfNaN: \"Array prototype method '{{ methodName }}' cannot find NaN.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const enforceForSwitchCase = !context.options[0] || context.options[0].enforceForSwitchCase;\r\n        const enforceForIndexOf = context.options[0] && context.options[0].enforceForIndexOf;\r\n\r\n        /**\r\n         * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkBinaryExpression(node) {\r\n            if (\r\n                /^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&\r\n                (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))\r\n            ) {\r\n                context.report({ node, messageId: \"comparisonWithNaN\" });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSwitchStatement(node) {\r\n            if (isNaNIdentifier(node.discriminant)) {\r\n                context.report({ node, messageId: \"switchNaN\" });\r\n            }\r\n\r\n            for (const switchCase of node.cases) {\r\n                if (isNaNIdentifier(switchCase.test)) {\r\n                    context.report({ node: switchCase, messageId: \"caseNaN\" });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkCallExpression(node) {\r\n            const callee = astUtils.skipChainExpression(node.callee);\r\n\r\n            if (callee.type === \"MemberExpression\") {\r\n                const methodName = astUtils.getStaticPropertyName(callee);\r\n\r\n                if (\r\n                    (methodName === \"indexOf\" || methodName === \"lastIndexOf\") &&\r\n                    node.arguments.length === 1 &&\r\n                    isNaNIdentifier(node.arguments[0])\r\n                ) {\r\n                    context.report({ node, messageId: \"indexOfNaN\", data: { methodName } });\r\n                }\r\n            }\r\n        }\r\n\r\n        const listeners = {\r\n            BinaryExpression: checkBinaryExpression\r\n        };\r\n\r\n        if (enforceForSwitchCase) {\r\n            listeners.SwitchStatement = checkSwitchStatement;\r\n        }\r\n\r\n        if (enforceForIndexOf) {\r\n            listeners.CallExpression = checkCallExpression;\r\n        }\r\n\r\n        return listeners;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}