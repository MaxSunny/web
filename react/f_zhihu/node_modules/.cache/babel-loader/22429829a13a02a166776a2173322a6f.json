{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of eval() statement\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst candidatesOfGlobalObject = Object.freeze([\"global\", \"window\", \"globalThis\"]);\n/**\r\n * Checks a given node is a MemberExpression node which has the specified name's\r\n * property.\r\n * @param {ASTNode} node A node to check.\r\n * @param {string} name A name to check.\r\n * @returns {boolean} `true` if the node is a MemberExpression node which has\r\n *      the specified name's property\r\n */\n\nfunction isMember(node, name) {\n  return astUtils.isSpecificMemberAccess(node, null, name);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow the use of `eval()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-eval\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowIndirect: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"eval can be harmful.\"\n    }\n  },\n\n  create(context) {\n    const allowIndirect = Boolean(context.options[0] && context.options[0].allowIndirect);\n    const sourceCode = context.getSourceCode();\n    let funcInfo = null;\n    /**\r\n     * Pushs a variable scope (Program or Function) information to the stack.\r\n     *\r\n     * This is used in order to check whether or not `this` binding is a\r\n     * reference to the global object.\r\n     * @param {ASTNode} node A node of the scope. This is one of Program,\r\n     *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\r\n     * @returns {void}\r\n     */\n\n    function enterVarScope(node) {\n      const strict = context.getScope().isStrict;\n      funcInfo = {\n        upper: funcInfo,\n        node,\n        strict,\n        defaultThis: false,\n        initialized: strict\n      };\n    }\n    /**\r\n     * Pops a variable scope from the stack.\r\n     * @returns {void}\r\n     */\n\n\n    function exitVarScope() {\n      funcInfo = funcInfo.upper;\n    }\n    /**\r\n     * Reports a given node.\r\n     *\r\n     * `node` is `Identifier` or `MemberExpression`.\r\n     * The parent of `node` might be `CallExpression`.\r\n     *\r\n     * The location of the report is always `eval` `Identifier` (or possibly\r\n     * `Literal`). The type of the report is `CallExpression` if the parent is\r\n     * `CallExpression`. Otherwise, it's the given node type.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function report(node) {\n      const parent = node.parent;\n      const locationNode = node.type === \"MemberExpression\" ? node.property : node;\n      const reportNode = parent.type === \"CallExpression\" && parent.callee === node ? parent : node;\n      context.report({\n        node: reportNode,\n        loc: locationNode.loc,\n        messageId: \"unexpected\"\n      });\n    }\n    /**\r\n     * Reports accesses of `eval` via the global object.\r\n     * @param {eslint-scope.Scope} globalScope The global scope.\r\n     * @returns {void}\r\n     */\n\n\n    function reportAccessingEvalViaGlobalObject(globalScope) {\n      for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\n        const name = candidatesOfGlobalObject[i];\n        const variable = astUtils.getVariableByName(globalScope, name);\n\n        if (!variable) {\n          continue;\n        }\n\n        const references = variable.references;\n\n        for (let j = 0; j < references.length; ++j) {\n          const identifier = references[j].identifier;\n          let node = identifier.parent; // To detect code like `window.window.eval`.\n\n          while (isMember(node, name)) {\n            node = node.parent;\n          } // Reports.\n\n\n          if (isMember(node, \"eval\")) {\n            report(node);\n          }\n        }\n      }\n    }\n    /**\r\n     * Reports all accesses of `eval` (excludes direct calls to eval).\r\n     * @param {eslint-scope.Scope} globalScope The global scope.\r\n     * @returns {void}\r\n     */\n\n\n    function reportAccessingEval(globalScope) {\n      const variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n      if (!variable) {\n        return;\n      }\n\n      const references = variable.references;\n\n      for (let i = 0; i < references.length; ++i) {\n        const reference = references[i];\n        const id = reference.identifier;\n\n        if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n          // Is accessing to eval (excludes direct calls to eval)\n          report(id);\n        }\n      }\n    }\n\n    if (allowIndirect) {\n      // Checks only direct calls to eval. It's simple!\n      return {\n        \"CallExpression:exit\"(node) {\n          const callee = node.callee;\n          /*\r\n           * Optional call (`eval?.(\"code\")`) is not direct eval.\r\n           * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\r\n           * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\r\n           */\n\n          if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\n            report(callee);\n          }\n        }\n\n      };\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = node.callee;\n\n        if (astUtils.isSpecificId(callee, \"eval\")) {\n          report(callee);\n        }\n      },\n\n      Program(node) {\n        const scope = context.getScope(),\n              features = context.parserOptions.ecmaFeatures || {},\n              strict = scope.isStrict || node.sourceType === \"module\" || features.globalReturn && scope.childScopes[0].isStrict;\n        funcInfo = {\n          upper: null,\n          node,\n          strict,\n          defaultThis: true,\n          initialized: true\n        };\n      },\n\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        exitVarScope();\n        reportAccessingEval(globalScope);\n        reportAccessingEvalViaGlobalObject(globalScope);\n      },\n\n      FunctionDeclaration: enterVarScope,\n      \"FunctionDeclaration:exit\": exitVarScope,\n      FunctionExpression: enterVarScope,\n      \"FunctionExpression:exit\": exitVarScope,\n      ArrowFunctionExpression: enterVarScope,\n      \"ArrowFunctionExpression:exit\": exitVarScope,\n      \"PropertyDefinition > *.value\": enterVarScope,\n      \"PropertyDefinition > *.value:exit\": exitVarScope,\n      StaticBlock: enterVarScope,\n      \"StaticBlock:exit\": exitVarScope,\n\n      ThisExpression(node) {\n        if (!isMember(node.parent, \"eval\")) {\n          return;\n        }\n        /*\r\n         * `this.eval` is found.\r\n         * Checks whether or not the value of `this` is the global object.\r\n         */\n\n\n        if (!funcInfo.initialized) {\n          funcInfo.initialized = true;\n          funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);\n        }\n\n        if (!funcInfo.strict && funcInfo.defaultThis) {\n          // `this.eval` is possible built-in `eval`.\n          report(node.parent);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-eval.js"],"names":["astUtils","require","candidatesOfGlobalObject","Object","freeze","isMember","node","name","isSpecificMemberAccess","module","exports","meta","type","docs","description","recommended","url","schema","properties","allowIndirect","default","additionalProperties","messages","unexpected","create","context","Boolean","options","sourceCode","getSourceCode","funcInfo","enterVarScope","strict","getScope","isStrict","upper","defaultThis","initialized","exitVarScope","report","parent","locationNode","property","reportNode","callee","loc","messageId","reportAccessingEvalViaGlobalObject","globalScope","i","length","variable","getVariableByName","references","j","identifier","reportAccessingEval","reference","id","isCallee","optional","isSpecificId","Program","scope","features","parserOptions","ecmaFeatures","sourceType","globalReturn","childScopes","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","StaticBlock","ThisExpression","isDefaultThisBinding"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;;AAEA,MAAMC,wBAAwB,GAAGC,MAAM,CAACC,MAAP,CAAc,CAC3C,QAD2C,EAE3C,QAF2C,EAG3C,YAH2C,CAAd,CAAjC;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,IAAxB,EAA8B;AAC1B,SAAOP,QAAQ,CAACQ,sBAAT,CAAgCF,IAAhC,EAAsC,IAAtC,EAA4CC,IAA5C,CAAP;AACH,C,CAED;AACA;AACA;;AAEA;;;AACAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,8BADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CACJ;AACIL,MAAAA,IAAI,EAAE,QADV;AAEIM,MAAAA,UAAU,EAAE;AACRC,QAAAA,aAAa,EAAE;AAAEP,UAAAA,IAAI,EAAE,SAAR;AAAmBQ,UAAAA,OAAO,EAAE;AAA5B;AADP,OAFhB;AAKIC,MAAAA,oBAAoB,EAAE;AAL1B,KADI,CATN;AAmBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE;AADN;AAnBR,GADO;;AAyBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMN,aAAa,GAAGO,OAAO,CACzBD,OAAO,CAACE,OAAR,CAAgB,CAAhB,KACAF,OAAO,CAACE,OAAR,CAAgB,CAAhB,EAAmBR,aAFM,CAA7B;AAIA,UAAMS,UAAU,GAAGH,OAAO,CAACI,aAAR,EAAnB;AACA,QAAIC,QAAQ,GAAG,IAAf;AAEA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACQ,aAASC,aAAT,CAAuBzB,IAAvB,EAA6B;AACzB,YAAM0B,MAAM,GAAGP,OAAO,CAACQ,QAAR,GAAmBC,QAAlC;AAEAJ,MAAAA,QAAQ,GAAG;AACPK,QAAAA,KAAK,EAAEL,QADA;AAEPxB,QAAAA,IAFO;AAGP0B,QAAAA,MAHO;AAIPI,QAAAA,WAAW,EAAE,KAJN;AAKPC,QAAAA,WAAW,EAAEL;AALN,OAAX;AAOH;AAED;AACR;AACA;AACA;;;AACQ,aAASM,YAAT,GAAwB;AACpBR,MAAAA,QAAQ,GAAGA,QAAQ,CAACK,KAApB;AACH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASI,MAAT,CAAgBjC,IAAhB,EAAsB;AAClB,YAAMkC,MAAM,GAAGlC,IAAI,CAACkC,MAApB;AACA,YAAMC,YAAY,GAAGnC,IAAI,CAACM,IAAL,KAAc,kBAAd,GACfN,IAAI,CAACoC,QADU,GAEfpC,IAFN;AAIA,YAAMqC,UAAU,GAAGH,MAAM,CAAC5B,IAAP,KAAgB,gBAAhB,IAAoC4B,MAAM,CAACI,MAAP,KAAkBtC,IAAtD,GACbkC,MADa,GAEblC,IAFN;AAIAmB,MAAAA,OAAO,CAACc,MAAR,CAAe;AACXjC,QAAAA,IAAI,EAAEqC,UADK;AAEXE,QAAAA,GAAG,EAAEJ,YAAY,CAACI,GAFP;AAGXC,QAAAA,SAAS,EAAE;AAHA,OAAf;AAKH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASC,kCAAT,CAA4CC,WAA5C,EAAyD;AACrD,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/C,wBAAwB,CAACgD,MAA7C,EAAqD,EAAED,CAAvD,EAA0D;AACtD,cAAM1C,IAAI,GAAGL,wBAAwB,CAAC+C,CAAD,CAArC;AACA,cAAME,QAAQ,GAAGnD,QAAQ,CAACoD,iBAAT,CAA2BJ,WAA3B,EAAwCzC,IAAxC,CAAjB;;AAEA,YAAI,CAAC4C,QAAL,EAAe;AACX;AACH;;AAED,cAAME,UAAU,GAAGF,QAAQ,CAACE,UAA5B;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,UAAU,CAACH,MAA/B,EAAuC,EAAEI,CAAzC,EAA4C;AACxC,gBAAMC,UAAU,GAAGF,UAAU,CAACC,CAAD,CAAV,CAAcC,UAAjC;AACA,cAAIjD,IAAI,GAAGiD,UAAU,CAACf,MAAtB,CAFwC,CAIxC;;AACA,iBAAOnC,QAAQ,CAACC,IAAD,EAAOC,IAAP,CAAf,EAA6B;AACzBD,YAAAA,IAAI,GAAGA,IAAI,CAACkC,MAAZ;AACH,WAPuC,CASxC;;;AACA,cAAInC,QAAQ,CAACC,IAAD,EAAO,MAAP,CAAZ,EAA4B;AACxBiC,YAAAA,MAAM,CAACjC,IAAD,CAAN;AACH;AACJ;AACJ;AACJ;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASkD,mBAAT,CAA6BR,WAA7B,EAA0C;AACtC,YAAMG,QAAQ,GAAGnD,QAAQ,CAACoD,iBAAT,CAA2BJ,WAA3B,EAAwC,MAAxC,CAAjB;;AAEA,UAAI,CAACG,QAAL,EAAe;AACX;AACH;;AAED,YAAME,UAAU,GAAGF,QAAQ,CAACE,UAA5B;;AAEA,WAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,UAAU,CAACH,MAA/B,EAAuC,EAAED,CAAzC,EAA4C;AACxC,cAAMQ,SAAS,GAAGJ,UAAU,CAACJ,CAAD,CAA5B;AACA,cAAMS,EAAE,GAAGD,SAAS,CAACF,UAArB;;AAEA,YAAIG,EAAE,CAACnD,IAAH,KAAY,MAAZ,IAAsB,CAACP,QAAQ,CAAC2D,QAAT,CAAkBD,EAAlB,CAA3B,EAAkD;AAE9C;AACAnB,UAAAA,MAAM,CAACmB,EAAD,CAAN;AACH;AACJ;AACJ;;AAED,QAAIvC,aAAJ,EAAmB;AAEf;AACA,aAAO;AACH,8BAAsBb,IAAtB,EAA4B;AACxB,gBAAMsC,MAAM,GAAGtC,IAAI,CAACsC,MAApB;AAEA;AACpB;AACA;AACA;AACA;;AACoB,cAAI,CAACtC,IAAI,CAACsD,QAAN,IAAkB5D,QAAQ,CAAC6D,YAAT,CAAsBjB,MAAtB,EAA8B,MAA9B,CAAtB,EAA6D;AACzDL,YAAAA,MAAM,CAACK,MAAD,CAAN;AACH;AACJ;;AAZE,OAAP;AAcH;;AAED,WAAO;AACH,4BAAsBtC,IAAtB,EAA4B;AACxB,cAAMsC,MAAM,GAAGtC,IAAI,CAACsC,MAApB;;AAEA,YAAI5C,QAAQ,CAAC6D,YAAT,CAAsBjB,MAAtB,EAA8B,MAA9B,CAAJ,EAA2C;AACvCL,UAAAA,MAAM,CAACK,MAAD,CAAN;AACH;AACJ,OAPE;;AASHkB,MAAAA,OAAO,CAACxD,IAAD,EAAO;AACV,cAAMyD,KAAK,GAAGtC,OAAO,CAACQ,QAAR,EAAd;AAAA,cACI+B,QAAQ,GAAGvC,OAAO,CAACwC,aAAR,CAAsBC,YAAtB,IAAsC,EADrD;AAAA,cAEIlC,MAAM,GACF+B,KAAK,CAAC7B,QAAN,IACA5B,IAAI,CAAC6D,UAAL,KAAoB,QADpB,IAECH,QAAQ,CAACI,YAAT,IAAyBL,KAAK,CAACM,WAAN,CAAkB,CAAlB,EAAqBnC,QALvD;AAOAJ,QAAAA,QAAQ,GAAG;AACPK,UAAAA,KAAK,EAAE,IADA;AAEP7B,UAAAA,IAFO;AAGP0B,UAAAA,MAHO;AAIPI,UAAAA,WAAW,EAAE,IAJN;AAKPC,UAAAA,WAAW,EAAE;AALN,SAAX;AAOH,OAxBE;;AA0BH,uBAAiB;AACb,cAAMW,WAAW,GAAGvB,OAAO,CAACQ,QAAR,EAApB;AAEAK,QAAAA,YAAY;AACZkB,QAAAA,mBAAmB,CAACR,WAAD,CAAnB;AACAD,QAAAA,kCAAkC,CAACC,WAAD,CAAlC;AACH,OAhCE;;AAkCHsB,MAAAA,mBAAmB,EAAEvC,aAlClB;AAmCH,kCAA4BO,YAnCzB;AAoCHiC,MAAAA,kBAAkB,EAAExC,aApCjB;AAqCH,iCAA2BO,YArCxB;AAsCHkC,MAAAA,uBAAuB,EAAEzC,aAtCtB;AAuCH,sCAAgCO,YAvC7B;AAwCH,sCAAgCP,aAxC7B;AAyCH,2CAAqCO,YAzClC;AA0CHmC,MAAAA,WAAW,EAAE1C,aA1CV;AA2CH,0BAAoBO,YA3CjB;;AA6CHoC,MAAAA,cAAc,CAACpE,IAAD,EAAO;AACjB,YAAI,CAACD,QAAQ,CAACC,IAAI,CAACkC,MAAN,EAAc,MAAd,CAAb,EAAoC;AAChC;AACH;AAED;AAChB;AACA;AACA;;;AACgB,YAAI,CAACV,QAAQ,CAACO,WAAd,EAA2B;AACvBP,UAAAA,QAAQ,CAACO,WAAT,GAAuB,IAAvB;AACAP,UAAAA,QAAQ,CAACM,WAAT,GAAuBpC,QAAQ,CAAC2E,oBAAT,CACnB7C,QAAQ,CAACxB,IADU,EAEnBsB,UAFmB,CAAvB;AAIH;;AAED,YAAI,CAACE,QAAQ,CAACE,MAAV,IAAoBF,QAAQ,CAACM,WAAjC,EAA8C;AAE1C;AACAG,UAAAA,MAAM,CAACjC,IAAI,CAACkC,MAAN,CAAN;AACH;AACJ;;AAnEE,KAAP;AAsEH;;AA/OY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of eval() statement\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst candidatesOfGlobalObject = Object.freeze([\r\n    \"global\",\r\n    \"window\",\r\n    \"globalThis\"\r\n]);\r\n\r\n/**\r\n * Checks a given node is a MemberExpression node which has the specified name's\r\n * property.\r\n * @param {ASTNode} node A node to check.\r\n * @param {string} name A name to check.\r\n * @returns {boolean} `true` if the node is a MemberExpression node which has\r\n *      the specified name's property\r\n */\r\nfunction isMember(node, name) {\r\n    return astUtils.isSpecificMemberAccess(node, null, name);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow the use of `eval()`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-eval\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowIndirect: { type: \"boolean\", default: false }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpected: \"eval can be harmful.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const allowIndirect = Boolean(\r\n            context.options[0] &&\r\n            context.options[0].allowIndirect\r\n        );\r\n        const sourceCode = context.getSourceCode();\r\n        let funcInfo = null;\r\n\r\n        /**\r\n         * Pushs a variable scope (Program or Function) information to the stack.\r\n         *\r\n         * This is used in order to check whether or not `this` binding is a\r\n         * reference to the global object.\r\n         * @param {ASTNode} node A node of the scope. This is one of Program,\r\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\r\n         * @returns {void}\r\n         */\r\n        function enterVarScope(node) {\r\n            const strict = context.getScope().isStrict;\r\n\r\n            funcInfo = {\r\n                upper: funcInfo,\r\n                node,\r\n                strict,\r\n                defaultThis: false,\r\n                initialized: strict\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Pops a variable scope from the stack.\r\n         * @returns {void}\r\n         */\r\n        function exitVarScope() {\r\n            funcInfo = funcInfo.upper;\r\n        }\r\n\r\n        /**\r\n         * Reports a given node.\r\n         *\r\n         * `node` is `Identifier` or `MemberExpression`.\r\n         * The parent of `node` might be `CallExpression`.\r\n         *\r\n         * The location of the report is always `eval` `Identifier` (or possibly\r\n         * `Literal`). The type of the report is `CallExpression` if the parent is\r\n         * `CallExpression`. Otherwise, it's the given node type.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            const parent = node.parent;\r\n            const locationNode = node.type === \"MemberExpression\"\r\n                ? node.property\r\n                : node;\r\n\r\n            const reportNode = parent.type === \"CallExpression\" && parent.callee === node\r\n                ? parent\r\n                : node;\r\n\r\n            context.report({\r\n                node: reportNode,\r\n                loc: locationNode.loc,\r\n                messageId: \"unexpected\"\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports accesses of `eval` via the global object.\r\n         * @param {eslint-scope.Scope} globalScope The global scope.\r\n         * @returns {void}\r\n         */\r\n        function reportAccessingEvalViaGlobalObject(globalScope) {\r\n            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {\r\n                const name = candidatesOfGlobalObject[i];\r\n                const variable = astUtils.getVariableByName(globalScope, name);\r\n\r\n                if (!variable) {\r\n                    continue;\r\n                }\r\n\r\n                const references = variable.references;\r\n\r\n                for (let j = 0; j < references.length; ++j) {\r\n                    const identifier = references[j].identifier;\r\n                    let node = identifier.parent;\r\n\r\n                    // To detect code like `window.window.eval`.\r\n                    while (isMember(node, name)) {\r\n                        node = node.parent;\r\n                    }\r\n\r\n                    // Reports.\r\n                    if (isMember(node, \"eval\")) {\r\n                        report(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports all accesses of `eval` (excludes direct calls to eval).\r\n         * @param {eslint-scope.Scope} globalScope The global scope.\r\n         * @returns {void}\r\n         */\r\n        function reportAccessingEval(globalScope) {\r\n            const variable = astUtils.getVariableByName(globalScope, \"eval\");\r\n\r\n            if (!variable) {\r\n                return;\r\n            }\r\n\r\n            const references = variable.references;\r\n\r\n            for (let i = 0; i < references.length; ++i) {\r\n                const reference = references[i];\r\n                const id = reference.identifier;\r\n\r\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\r\n\r\n                    // Is accessing to eval (excludes direct calls to eval)\r\n                    report(id);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (allowIndirect) {\r\n\r\n            // Checks only direct calls to eval. It's simple!\r\n            return {\r\n                \"CallExpression:exit\"(node) {\r\n                    const callee = node.callee;\r\n\r\n                    /*\r\n                     * Optional call (`eval?.(\"code\")`) is not direct eval.\r\n                     * The direct eval is only step 6.a.vi of https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation\r\n                     * But the optional call is https://tc39.es/ecma262/#sec-optional-chaining-chain-evaluation\r\n                     */\r\n                    if (!node.optional && astUtils.isSpecificId(callee, \"eval\")) {\r\n                        report(callee);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        return {\r\n            \"CallExpression:exit\"(node) {\r\n                const callee = node.callee;\r\n\r\n                if (astUtils.isSpecificId(callee, \"eval\")) {\r\n                    report(callee);\r\n                }\r\n            },\r\n\r\n            Program(node) {\r\n                const scope = context.getScope(),\r\n                    features = context.parserOptions.ecmaFeatures || {},\r\n                    strict =\r\n                        scope.isStrict ||\r\n                        node.sourceType === \"module\" ||\r\n                        (features.globalReturn && scope.childScopes[0].isStrict);\r\n\r\n                funcInfo = {\r\n                    upper: null,\r\n                    node,\r\n                    strict,\r\n                    defaultThis: true,\r\n                    initialized: true\r\n                };\r\n            },\r\n\r\n            \"Program:exit\"() {\r\n                const globalScope = context.getScope();\r\n\r\n                exitVarScope();\r\n                reportAccessingEval(globalScope);\r\n                reportAccessingEvalViaGlobalObject(globalScope);\r\n            },\r\n\r\n            FunctionDeclaration: enterVarScope,\r\n            \"FunctionDeclaration:exit\": exitVarScope,\r\n            FunctionExpression: enterVarScope,\r\n            \"FunctionExpression:exit\": exitVarScope,\r\n            ArrowFunctionExpression: enterVarScope,\r\n            \"ArrowFunctionExpression:exit\": exitVarScope,\r\n            \"PropertyDefinition > *.value\": enterVarScope,\r\n            \"PropertyDefinition > *.value:exit\": exitVarScope,\r\n            StaticBlock: enterVarScope,\r\n            \"StaticBlock:exit\": exitVarScope,\r\n\r\n            ThisExpression(node) {\r\n                if (!isMember(node.parent, \"eval\")) {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * `this.eval` is found.\r\n                 * Checks whether or not the value of `this` is the global object.\r\n                 */\r\n                if (!funcInfo.initialized) {\r\n                    funcInfo.initialized = true;\r\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\r\n                        funcInfo.node,\r\n                        sourceCode\r\n                    );\r\n                }\r\n\r\n                if (!funcInfo.strict && funcInfo.defaultThis) {\r\n\r\n                    // `this.eval` is possible built-in `eval`.\r\n                    report(node.parent);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}