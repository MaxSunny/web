{"ast":null,"code":"/**\r\n * @fileoverview The event generator for AST nodes.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esquery = require(\"esquery\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\r\n * An object describing an AST selector\r\n * @typedef {Object} ASTSelector\r\n * @property {string} rawSelector The string that was parsed into this selector\r\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\r\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\r\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\r\n * or `null` if all node types could cause a match\r\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\r\n * @property {number} identifierCount The total number of identifier queries in this selector\r\n */\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Computes the union of one or more arrays\r\n * @param {...any[]} arrays One or more arrays to union\r\n * @returns {any[]} The union of the input arrays\r\n */\n\n\nfunction union() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  return [...new Set(arrays.flat())];\n}\n/**\r\n * Computes the intersection of one or more arrays\r\n * @param {...any[]} arrays One or more arrays to intersect\r\n * @returns {any[]} The intersection of the input arrays\r\n */\n\n\nfunction intersection() {\n  for (var _len2 = arguments.length, arrays = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    arrays[_key2] = arguments[_key2];\n  }\n\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  let result = [...new Set(arrays[0])];\n\n  for (const array of arrays.slice(1)) {\n    result = result.filter(x => array.includes(x));\n  }\n\n  return result;\n}\n/**\r\n * Gets the possible types of a selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\r\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\r\n */\n\n\nfunction getPossibleTypes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"identifier\":\n      return [parsedSelector.value];\n\n    case \"matches\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\n\n        if (typesForComponents.every(Boolean)) {\n          return union(...typesForComponents);\n        }\n\n        return null;\n      }\n\n    case \"compound\":\n      {\n        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent); // If all of the components could match any type, then the compound could also match any type.\n\n        if (!typesForComponents.length) {\n          return null;\n        }\n        /*\r\n         * If at least one of the components could only match a particular type, the compound could only match\r\n         * the intersection of those types.\r\n         */\n\n\n        return intersection(...typesForComponents);\n      }\n\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return getPossibleTypes(parsedSelector.right);\n\n    case \"class\":\n      if (parsedSelector.name === \"function\") {\n        return [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"];\n      }\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n/**\r\n * Counts the number of class, pseudo-class, and attribute queries in this selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\r\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\r\n */\n\n\nfunction countClassAttributes(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\n\n    case \"attribute\":\n    case \"field\":\n    case \"nth-child\":\n    case \"nth-last-child\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\r\n * Counts the number of identifier queries in this selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\r\n * @returns {number} The number of identifier queries\r\n */\n\n\nfunction countIdentifiers(parsedSelector) {\n  switch (parsedSelector.type) {\n    case \"child\":\n    case \"descendant\":\n    case \"sibling\":\n    case \"adjacent\":\n      return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\n\n    case \"compound\":\n    case \"not\":\n    case \"matches\":\n      return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\n\n    case \"identifier\":\n      return 1;\n\n    default:\n      return 0;\n  }\n}\n/**\r\n * Compares the specificity of two selector objects, with CSS-like rules.\r\n * @param {ASTSelector} selectorA An AST selector descriptor\r\n * @param {ASTSelector} selectorB Another AST selector descriptor\r\n * @returns {number}\r\n * a value less than 0 if selectorA is less specific than selectorB\r\n * a value greater than 0 if selectorA is more specific than selectorB\r\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\r\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\r\n */\n\n\nfunction compareSpecificity(selectorA, selectorB) {\n  return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\n}\n/**\r\n * Parses a raw selector string, and throws a useful error if parsing fails.\r\n * @param {string} rawSelector A raw AST selector\r\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\r\n * @throws {Error} An error if the selector is invalid\r\n */\n\n\nfunction tryParseSelector(rawSelector) {\n  try {\n    return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\n  } catch (err) {\n    if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\n      throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\n    }\n\n    throw err;\n  }\n}\n\nconst selectorCache = new Map();\n/**\r\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\r\n * @param {string} rawSelector A raw AST selector\r\n * @returns {ASTSelector} A selector descriptor\r\n */\n\nfunction parseSelector(rawSelector) {\n  if (selectorCache.has(rawSelector)) {\n    return selectorCache.get(rawSelector);\n  }\n\n  const parsedSelector = tryParseSelector(rawSelector);\n  const result = {\n    rawSelector,\n    isExit: rawSelector.endsWith(\":exit\"),\n    parsedSelector,\n    listenerTypes: getPossibleTypes(parsedSelector),\n    attributeCount: countClassAttributes(parsedSelector),\n    identifierCount: countIdentifiers(parsedSelector)\n  };\n  selectorCache.set(rawSelector, result);\n  return result;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * The event generator for AST nodes.\r\n * This implements below interface.\r\n *\r\n * ```ts\r\n * interface EventGenerator {\r\n *     emitter: SafeEmitter;\r\n *     enterNode(node: ASTNode): void;\r\n *     leaveNode(node: ASTNode): void;\r\n * }\r\n * ```\r\n */\n\n\nclass NodeEventGenerator {\n  /**\r\n   * @param {SafeEmitter} emitter\r\n   * An SafeEmitter which is the destination of events. This emitter must already\r\n   * have registered listeners for all of the events that it needs to listen for.\r\n   * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\r\n   * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\r\n   * @returns {NodeEventGenerator} new instance\r\n   */\n  constructor(emitter, esqueryOptions) {\n    this.emitter = emitter;\n    this.esqueryOptions = esqueryOptions;\n    this.currentAncestry = [];\n    this.enterSelectorsByNodeType = new Map();\n    this.exitSelectorsByNodeType = new Map();\n    this.anyTypeEnterSelectors = [];\n    this.anyTypeExitSelectors = [];\n    emitter.eventNames().forEach(rawSelector => {\n      const selector = parseSelector(rawSelector);\n\n      if (selector.listenerTypes) {\n        const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\n        selector.listenerTypes.forEach(nodeType => {\n          if (!typeMap.has(nodeType)) {\n            typeMap.set(nodeType, []);\n          }\n\n          typeMap.get(nodeType).push(selector);\n        });\n        return;\n      }\n\n      const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n      selectors.push(selector);\n    });\n    this.anyTypeEnterSelectors.sort(compareSpecificity);\n    this.anyTypeExitSelectors.sort(compareSpecificity);\n    this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n    this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\n  }\n  /**\r\n   * Checks a selector against a node, and emits it if it matches\r\n   * @param {ASTNode} node The node to check\r\n   * @param {ASTSelector} selector An AST selector descriptor\r\n   * @returns {void}\r\n   */\n\n\n  applySelector(node, selector) {\n    if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\n      this.emitter.emit(selector.rawSelector, node);\n    }\n  }\n  /**\r\n   * Applies all appropriate selectors to a node, in specificity order\r\n   * @param {ASTNode} node The node to check\r\n   * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\r\n   * @returns {void}\r\n   */\n\n\n  applySelectors(node, isExit) {\n    const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\n    const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\n    /*\r\n     * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\r\n     * Iterate through each of them, applying selectors in the right order.\r\n     */\n\n    let selectorsByTypeIndex = 0;\n    let anyTypeSelectorsIndex = 0;\n\n    while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\n      if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {\n        this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\n      } else {\n        this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\n      }\n    }\n  }\n  /**\r\n   * Emits an event of entering AST node.\r\n   * @param {ASTNode} node A node which was entered.\r\n   * @returns {void}\r\n   */\n\n\n  enterNode(node) {\n    if (node.parent) {\n      this.currentAncestry.unshift(node.parent);\n    }\n\n    this.applySelectors(node, false);\n  }\n  /**\r\n   * Emits an event of leaving AST node.\r\n   * @param {ASTNode} node A node which was left.\r\n   * @returns {void}\r\n   */\n\n\n  leaveNode(node) {\n    this.applySelectors(node, true);\n    this.currentAncestry.shift();\n  }\n\n}\n\nmodule.exports = NodeEventGenerator;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/node-event-generator.js"],"names":["esquery","require","union","arrays","Set","flat","intersection","length","result","array","slice","filter","x","includes","getPossibleTypes","parsedSelector","type","value","typesForComponents","selectors","map","every","Boolean","typesForComponent","right","name","countClassAttributes","left","reduce","sum","childSelector","countIdentifiers","compareSpecificity","selectorA","selectorB","attributeCount","identifierCount","rawSelector","tryParseSelector","parse","replace","err","location","start","offset","SyntaxError","message","selectorCache","Map","parseSelector","has","get","isExit","endsWith","listenerTypes","set","NodeEventGenerator","constructor","emitter","esqueryOptions","currentAncestry","enterSelectorsByNodeType","exitSelectorsByNodeType","anyTypeEnterSelectors","anyTypeExitSelectors","eventNames","forEach","selector","typeMap","nodeType","push","sort","selectorList","applySelector","node","matches","emit","applySelectors","selectorsByNodeType","anyTypeSelectors","selectorsByTypeIndex","anyTypeSelectorsIndex","enterNode","parent","unshift","leaveNode","shift","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview The event generator for AST nodes.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst esquery = require(\"esquery\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * An object describing an AST selector\r\n * @typedef {Object} ASTSelector\r\n * @property {string} rawSelector The string that was parsed into this selector\r\n * @property {boolean} isExit `true` if this should be emitted when exiting the node rather than when entering\r\n * @property {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\r\n * @property {string[]|null} listenerTypes A list of node types that could possibly cause the selector to match,\r\n * or `null` if all node types could cause a match\r\n * @property {number} attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector\r\n * @property {number} identifierCount The total number of identifier queries in this selector\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Computes the union of one or more arrays\r\n * @param {...any[]} arrays One or more arrays to union\r\n * @returns {any[]} The union of the input arrays\r\n */\r\nfunction union(...arrays) {\r\n    return [...new Set(arrays.flat())];\r\n}\r\n\r\n/**\r\n * Computes the intersection of one or more arrays\r\n * @param {...any[]} arrays One or more arrays to intersect\r\n * @returns {any[]} The intersection of the input arrays\r\n */\r\nfunction intersection(...arrays) {\r\n    if (arrays.length === 0) {\r\n        return [];\r\n    }\r\n\r\n    let result = [...new Set(arrays[0])];\r\n\r\n    for (const array of arrays.slice(1)) {\r\n        result = result.filter(x => array.includes(x));\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Gets the possible types of a selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the matching behavior of the selector\r\n * @returns {string[]|null} The node types that could possibly trigger this selector, or `null` if all node types could trigger it\r\n */\r\nfunction getPossibleTypes(parsedSelector) {\r\n    switch (parsedSelector.type) {\r\n        case \"identifier\":\r\n            return [parsedSelector.value];\r\n\r\n        case \"matches\": {\r\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);\r\n\r\n            if (typesForComponents.every(Boolean)) {\r\n                return union(...typesForComponents);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        case \"compound\": {\r\n            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);\r\n\r\n            // If all of the components could match any type, then the compound could also match any type.\r\n            if (!typesForComponents.length) {\r\n                return null;\r\n            }\r\n\r\n            /*\r\n             * If at least one of the components could only match a particular type, the compound could only match\r\n             * the intersection of those types.\r\n             */\r\n            return intersection(...typesForComponents);\r\n        }\r\n\r\n        case \"child\":\r\n        case \"descendant\":\r\n        case \"sibling\":\r\n        case \"adjacent\":\r\n            return getPossibleTypes(parsedSelector.right);\r\n\r\n        case \"class\":\r\n            if (parsedSelector.name === \"function\") {\r\n                return [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"];\r\n            }\r\n\r\n            return null;\r\n\r\n        default:\r\n            return null;\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Counts the number of class, pseudo-class, and attribute queries in this selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\r\n * @returns {number} The number of class, pseudo-class, and attribute queries in this selector\r\n */\r\nfunction countClassAttributes(parsedSelector) {\r\n    switch (parsedSelector.type) {\r\n        case \"child\":\r\n        case \"descendant\":\r\n        case \"sibling\":\r\n        case \"adjacent\":\r\n            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);\r\n\r\n        case \"compound\":\r\n        case \"not\":\r\n        case \"matches\":\r\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);\r\n\r\n        case \"attribute\":\r\n        case \"field\":\r\n        case \"nth-child\":\r\n        case \"nth-last-child\":\r\n            return 1;\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Counts the number of identifier queries in this selector\r\n * @param {Object} parsedSelector An object (from esquery) describing the selector's matching behavior\r\n * @returns {number} The number of identifier queries\r\n */\r\nfunction countIdentifiers(parsedSelector) {\r\n    switch (parsedSelector.type) {\r\n        case \"child\":\r\n        case \"descendant\":\r\n        case \"sibling\":\r\n        case \"adjacent\":\r\n            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);\r\n\r\n        case \"compound\":\r\n        case \"not\":\r\n        case \"matches\":\r\n            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);\r\n\r\n        case \"identifier\":\r\n            return 1;\r\n\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Compares the specificity of two selector objects, with CSS-like rules.\r\n * @param {ASTSelector} selectorA An AST selector descriptor\r\n * @param {ASTSelector} selectorB Another AST selector descriptor\r\n * @returns {number}\r\n * a value less than 0 if selectorA is less specific than selectorB\r\n * a value greater than 0 if selectorA is more specific than selectorB\r\n * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically\r\n * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically\r\n */\r\nfunction compareSpecificity(selectorA, selectorB) {\r\n    return selectorA.attributeCount - selectorB.attributeCount ||\r\n        selectorA.identifierCount - selectorB.identifierCount ||\r\n        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);\r\n}\r\n\r\n/**\r\n * Parses a raw selector string, and throws a useful error if parsing fails.\r\n * @param {string} rawSelector A raw AST selector\r\n * @returns {Object} An object (from esquery) describing the matching behavior of this selector\r\n * @throws {Error} An error if the selector is invalid\r\n */\r\nfunction tryParseSelector(rawSelector) {\r\n    try {\r\n        return esquery.parse(rawSelector.replace(/:exit$/u, \"\"));\r\n    } catch (err) {\r\n        if (err.location && err.location.start && typeof err.location.start.offset === \"number\") {\r\n            throw new SyntaxError(`Syntax error in selector \"${rawSelector}\" at position ${err.location.start.offset}: ${err.message}`);\r\n        }\r\n        throw err;\r\n    }\r\n}\r\n\r\nconst selectorCache = new Map();\r\n\r\n/**\r\n * Parses a raw selector string, and returns the parsed selector along with specificity and type information.\r\n * @param {string} rawSelector A raw AST selector\r\n * @returns {ASTSelector} A selector descriptor\r\n */\r\nfunction parseSelector(rawSelector) {\r\n    if (selectorCache.has(rawSelector)) {\r\n        return selectorCache.get(rawSelector);\r\n    }\r\n\r\n    const parsedSelector = tryParseSelector(rawSelector);\r\n\r\n    const result = {\r\n        rawSelector,\r\n        isExit: rawSelector.endsWith(\":exit\"),\r\n        parsedSelector,\r\n        listenerTypes: getPossibleTypes(parsedSelector),\r\n        attributeCount: countClassAttributes(parsedSelector),\r\n        identifierCount: countIdentifiers(parsedSelector)\r\n    };\r\n\r\n    selectorCache.set(rawSelector, result);\r\n    return result;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * The event generator for AST nodes.\r\n * This implements below interface.\r\n *\r\n * ```ts\r\n * interface EventGenerator {\r\n *     emitter: SafeEmitter;\r\n *     enterNode(node: ASTNode): void;\r\n *     leaveNode(node: ASTNode): void;\r\n * }\r\n * ```\r\n */\r\nclass NodeEventGenerator {\r\n\r\n    /**\r\n     * @param {SafeEmitter} emitter\r\n     * An SafeEmitter which is the destination of events. This emitter must already\r\n     * have registered listeners for all of the events that it needs to listen for.\r\n     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)\r\n     * @param {ESQueryOptions} esqueryOptions `esquery` options for traversing custom nodes.\r\n     * @returns {NodeEventGenerator} new instance\r\n     */\r\n    constructor(emitter, esqueryOptions) {\r\n        this.emitter = emitter;\r\n        this.esqueryOptions = esqueryOptions;\r\n        this.currentAncestry = [];\r\n        this.enterSelectorsByNodeType = new Map();\r\n        this.exitSelectorsByNodeType = new Map();\r\n        this.anyTypeEnterSelectors = [];\r\n        this.anyTypeExitSelectors = [];\r\n\r\n        emitter.eventNames().forEach(rawSelector => {\r\n            const selector = parseSelector(rawSelector);\r\n\r\n            if (selector.listenerTypes) {\r\n                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;\r\n\r\n                selector.listenerTypes.forEach(nodeType => {\r\n                    if (!typeMap.has(nodeType)) {\r\n                        typeMap.set(nodeType, []);\r\n                    }\r\n                    typeMap.get(nodeType).push(selector);\r\n                });\r\n                return;\r\n            }\r\n            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\r\n\r\n            selectors.push(selector);\r\n        });\r\n\r\n        this.anyTypeEnterSelectors.sort(compareSpecificity);\r\n        this.anyTypeExitSelectors.sort(compareSpecificity);\r\n        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\r\n        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));\r\n    }\r\n\r\n    /**\r\n     * Checks a selector against a node, and emits it if it matches\r\n     * @param {ASTNode} node The node to check\r\n     * @param {ASTSelector} selector An AST selector descriptor\r\n     * @returns {void}\r\n     */\r\n    applySelector(node, selector) {\r\n        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {\r\n            this.emitter.emit(selector.rawSelector, node);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies all appropriate selectors to a node, in specificity order\r\n     * @param {ASTNode} node The node to check\r\n     * @param {boolean} isExit `false` if the node is currently being entered, `true` if it's currently being exited\r\n     * @returns {void}\r\n     */\r\n    applySelectors(node, isExit) {\r\n        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];\r\n        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;\r\n\r\n        /*\r\n         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.\r\n         * Iterate through each of them, applying selectors in the right order.\r\n         */\r\n        let selectorsByTypeIndex = 0;\r\n        let anyTypeSelectorsIndex = 0;\r\n\r\n        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {\r\n            if (\r\n                selectorsByTypeIndex >= selectorsByNodeType.length ||\r\n                anyTypeSelectorsIndex < anyTypeSelectors.length &&\r\n                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0\r\n            ) {\r\n                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);\r\n            } else {\r\n                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emits an event of entering AST node.\r\n     * @param {ASTNode} node A node which was entered.\r\n     * @returns {void}\r\n     */\r\n    enterNode(node) {\r\n        if (node.parent) {\r\n            this.currentAncestry.unshift(node.parent);\r\n        }\r\n        this.applySelectors(node, false);\r\n    }\r\n\r\n    /**\r\n     * Emits an event of leaving AST node.\r\n     * @param {ASTNode} node A node which was left.\r\n     * @returns {void}\r\n     */\r\n    leaveNode(node) {\r\n        this.applySelectors(node, true);\r\n        this.currentAncestry.shift();\r\n    }\r\n}\r\n\r\nmodule.exports = NodeEventGenerator;\r\n"]},"metadata":{},"sourceType":"script"}