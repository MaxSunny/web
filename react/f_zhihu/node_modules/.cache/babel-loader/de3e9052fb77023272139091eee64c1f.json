{"ast":null,"code":"/**\r\n * @fileoverview enforce a maximum file length\r\n * @author Alberto Rodríguez\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Creates an array of numbers from `start` up to, but not including, `end`\r\n * @param {number} start The start of the range\r\n * @param {number} end The end of the range\r\n * @returns {number[]} The range of numbers\r\n */\n\n\nfunction range(start, end) {\n  return [...Array(end - start).keys()].map(x => x + start);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of lines per file\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-lines\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          max: {\n            type: \"integer\",\n            minimum: 0\n          },\n          skipComments: {\n            type: \"boolean\"\n          },\n          skipBlankLines: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      exceed: \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    const option = context.options[0];\n    let max = 300;\n\n    if (typeof option === \"object\" && Object.prototype.hasOwnProperty.call(option, \"max\")) {\n      max = option.max;\n    } else if (typeof option === \"number\") {\n      max = option;\n    }\n\n    const skipComments = option && option.skipComments;\n    const skipBlankLines = option && option.skipBlankLines;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Returns whether or not a token is a comment node type\r\n     * @param {Token} token The token to check\r\n     * @returns {boolean} True if the token is a comment node\r\n     */\n\n    function isCommentNodeType(token) {\n      return token && (token.type === \"Block\" || token.type === \"Line\");\n    }\n    /**\r\n     * Returns the line numbers of a comment that don't have any code on the same line\r\n     * @param {Node} comment The comment node to check\r\n     * @returns {number[]} The line numbers\r\n     */\n\n\n    function getLinesWithoutCode(comment) {\n      let start = comment.loc.start.line;\n      let end = comment.loc.end.line;\n      let token;\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenBefore(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(token, comment)) {\n        start += 1;\n      }\n\n      token = comment;\n\n      do {\n        token = sourceCode.getTokenAfter(token, {\n          includeComments: true\n        });\n      } while (isCommentNodeType(token));\n\n      if (token && astUtils.isTokenOnSameLine(comment, token)) {\n        end -= 1;\n      }\n\n      if (start <= end) {\n        return range(start, end + 1);\n      }\n\n      return [];\n    }\n\n    return {\n      \"Program:exit\"() {\n        let lines = sourceCode.lines.map((text, i) => ({\n          lineNumber: i + 1,\n          text\n        }));\n        /*\r\n         * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\r\n         * That isn't a real line, so we shouldn't count it.\r\n         */\n\n        if (lines.length > 1 && lines[lines.length - 1].text === \"\") {\n          lines.pop();\n        }\n\n        if (skipBlankLines) {\n          lines = lines.filter(l => l.text.trim() !== \"\");\n        }\n\n        if (skipComments) {\n          const comments = sourceCode.getAllComments();\n          const commentLines = comments.flatMap(getLinesWithoutCode);\n          lines = lines.filter(l => !commentLines.includes(l.lineNumber));\n        }\n\n        if (lines.length > max) {\n          const loc = {\n            start: {\n              line: lines[max].lineNumber,\n              column: 0\n            },\n            end: {\n              line: sourceCode.lines.length,\n              column: sourceCode.lines[sourceCode.lines.length - 1].length\n            }\n          };\n          context.report({\n            loc,\n            messageId: \"exceed\",\n            data: {\n              max,\n              actual: lines.length\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/max-lines.js"],"names":["astUtils","require","range","start","end","Array","keys","map","x","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","minimum","properties","max","skipComments","skipBlankLines","additionalProperties","messages","exceed","create","context","option","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","isCommentNodeType","token","getLinesWithoutCode","comment","loc","line","getTokenBefore","includeComments","isTokenOnSameLine","getTokenAfter","lines","text","i","lineNumber","length","pop","filter","l","trim","comments","getAllComments","commentLines","flatMap","includes","column","report","messageId","data","actual"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB,C,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,KAAT,CAAeC,KAAf,EAAsBC,GAAtB,EAA2B;AACvB,SAAO,CAAC,GAAGC,KAAK,CAACD,GAAG,GAAGD,KAAP,CAAL,CAAmBG,IAAnB,EAAJ,EAA+BC,GAA/B,CAAmCC,CAAC,IAAIA,CAAC,GAAGL,KAA5C,CAAP;AACH,C,CAED;AACA;AACA;;AAEA;;;AACAM,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,4CADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CACJ;AACIC,MAAAA,KAAK,EAAE,CACH;AACIN,QAAAA,IAAI,EAAE,SADV;AAEIO,QAAAA,OAAO,EAAE;AAFb,OADG,EAKH;AACIP,QAAAA,IAAI,EAAE,QADV;AAEIQ,QAAAA,UAAU,EAAE;AACRC,UAAAA,GAAG,EAAE;AACDT,YAAAA,IAAI,EAAE,SADL;AAEDO,YAAAA,OAAO,EAAE;AAFR,WADG;AAKRG,UAAAA,YAAY,EAAE;AACVV,YAAAA,IAAI,EAAE;AADI,WALN;AAQRW,UAAAA,cAAc,EAAE;AACZX,YAAAA,IAAI,EAAE;AADM;AARR,SAFhB;AAcIY,QAAAA,oBAAoB,EAAE;AAd1B,OALG;AADX,KADI,CATN;AAmCFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,MAAM,EACF;AAFE;AAnCR,GADO;;AA0CbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AACZ,UAAMC,MAAM,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf;AACA,QAAIT,GAAG,GAAG,GAAV;;AAEA,QACI,OAAOQ,MAAP,KAAkB,QAAlB,IACAE,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCL,MAArC,EAA6C,KAA7C,CAFJ,EAGE;AACER,MAAAA,GAAG,GAAGQ,MAAM,CAACR,GAAb;AACH,KALD,MAKO,IAAI,OAAOQ,MAAP,KAAkB,QAAtB,EAAgC;AACnCR,MAAAA,GAAG,GAAGQ,MAAN;AACH;;AAED,UAAMP,YAAY,GAAGO,MAAM,IAAIA,MAAM,CAACP,YAAtC;AACA,UAAMC,cAAc,GAAGM,MAAM,IAAIA,MAAM,CAACN,cAAxC;AAEA,UAAMY,UAAU,GAAGP,OAAO,CAACQ,aAAR,EAAnB;AAEA;AACR;AACA;AACA;AACA;;AACQ,aAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAC9B,aAAOA,KAAK,KAAKA,KAAK,CAAC1B,IAAN,KAAe,OAAf,IAA0B0B,KAAK,CAAC1B,IAAN,KAAe,MAA9C,CAAZ;AACH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAAS2B,mBAAT,CAA6BC,OAA7B,EAAsC;AAClC,UAAIrC,KAAK,GAAGqC,OAAO,CAACC,GAAR,CAAYtC,KAAZ,CAAkBuC,IAA9B;AACA,UAAItC,GAAG,GAAGoC,OAAO,CAACC,GAAR,CAAYrC,GAAZ,CAAgBsC,IAA1B;AAEA,UAAIJ,KAAJ;AAEAA,MAAAA,KAAK,GAAGE,OAAR;;AACA,SAAG;AACCF,QAAAA,KAAK,GAAGH,UAAU,CAACQ,cAAX,CAA0BL,KAA1B,EAAiC;AACrCM,UAAAA,eAAe,EAAE;AADoB,SAAjC,CAAR;AAGH,OAJD,QAISP,iBAAiB,CAACC,KAAD,CAJ1B;;AAMA,UAAIA,KAAK,IAAItC,QAAQ,CAAC6C,iBAAT,CAA2BP,KAA3B,EAAkCE,OAAlC,CAAb,EAAyD;AACrDrC,QAAAA,KAAK,IAAI,CAAT;AACH;;AAEDmC,MAAAA,KAAK,GAAGE,OAAR;;AACA,SAAG;AACCF,QAAAA,KAAK,GAAGH,UAAU,CAACW,aAAX,CAAyBR,KAAzB,EAAgC;AACpCM,UAAAA,eAAe,EAAE;AADmB,SAAhC,CAAR;AAGH,OAJD,QAISP,iBAAiB,CAACC,KAAD,CAJ1B;;AAMA,UAAIA,KAAK,IAAItC,QAAQ,CAAC6C,iBAAT,CAA2BL,OAA3B,EAAoCF,KAApC,CAAb,EAAyD;AACrDlC,QAAAA,GAAG,IAAI,CAAP;AACH;;AAED,UAAID,KAAK,IAAIC,GAAb,EAAkB;AACd,eAAOF,KAAK,CAACC,KAAD,EAAQC,GAAG,GAAG,CAAd,CAAZ;AACH;;AACD,aAAO,EAAP;AACH;;AAED,WAAO;AACH,uBAAiB;AACb,YAAI2C,KAAK,GAAGZ,UAAU,CAACY,KAAX,CAAiBxC,GAAjB,CAAqB,CAACyC,IAAD,EAAOC,CAAP,MAAc;AAC3CC,UAAAA,UAAU,EAAED,CAAC,GAAG,CAD2B;AAE3CD,UAAAA;AAF2C,SAAd,CAArB,CAAZ;AAKA;AAChB;AACA;AACA;;AACgB,YAAID,KAAK,CAACI,MAAN,GAAe,CAAf,IAAoBJ,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAL,CAAwBH,IAAxB,KAAiC,EAAzD,EAA6D;AACzDD,UAAAA,KAAK,CAACK,GAAN;AACH;;AAED,YAAI7B,cAAJ,EAAoB;AAChBwB,UAAAA,KAAK,GAAGA,KAAK,CAACM,MAAN,CAAaC,CAAC,IAAIA,CAAC,CAACN,IAAF,CAAOO,IAAP,OAAkB,EAApC,CAAR;AACH;;AAED,YAAIjC,YAAJ,EAAkB;AACd,gBAAMkC,QAAQ,GAAGrB,UAAU,CAACsB,cAAX,EAAjB;AAEA,gBAAMC,YAAY,GAAGF,QAAQ,CAACG,OAAT,CAAiBpB,mBAAjB,CAArB;AAEAQ,UAAAA,KAAK,GAAGA,KAAK,CAACM,MAAN,CACJC,CAAC,IAAI,CAACI,YAAY,CAACE,QAAb,CAAsBN,CAAC,CAACJ,UAAxB,CADF,CAAR;AAGH;;AAED,YAAIH,KAAK,CAACI,MAAN,GAAe9B,GAAnB,EAAwB;AACpB,gBAAMoB,GAAG,GAAG;AACRtC,YAAAA,KAAK,EAAE;AACHuC,cAAAA,IAAI,EAAEK,KAAK,CAAC1B,GAAD,CAAL,CAAW6B,UADd;AAEHW,cAAAA,MAAM,EAAE;AAFL,aADC;AAKRzD,YAAAA,GAAG,EAAE;AACDsC,cAAAA,IAAI,EAAEP,UAAU,CAACY,KAAX,CAAiBI,MADtB;AAEDU,cAAAA,MAAM,EAAE1B,UAAU,CAACY,KAAX,CAAiBZ,UAAU,CAACY,KAAX,CAAiBI,MAAjB,GAA0B,CAA3C,EAA8CA;AAFrD;AALG,WAAZ;AAWAvB,UAAAA,OAAO,CAACkC,MAAR,CAAe;AACXrB,YAAAA,GADW;AAEXsB,YAAAA,SAAS,EAAE,QAFA;AAGXC,YAAAA,IAAI,EAAE;AACF3C,cAAAA,GADE;AAEF4C,cAAAA,MAAM,EAAElB,KAAK,CAACI;AAFZ;AAHK,WAAf;AAQH;AACJ;;AAlDE,KAAP;AAoDH;;AAhKY,CAAjB","sourcesContent":["/**\r\n * @fileoverview enforce a maximum file length\r\n * @author Alberto Rodríguez\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Creates an array of numbers from `start` up to, but not including, `end`\r\n * @param {number} start The start of the range\r\n * @param {number} end The end of the range\r\n * @returns {number[]} The range of numbers\r\n */\r\nfunction range(start, end) {\r\n    return [...Array(end - start).keys()].map(x => x + start);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce a maximum number of lines per file\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/max-lines\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            max: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            skipComments: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            skipBlankLines: {\r\n                                type: \"boolean\"\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n        messages: {\r\n            exceed:\r\n                \"File has too many lines ({{actual}}). Maximum allowed is {{max}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const option = context.options[0];\r\n        let max = 300;\r\n\r\n        if (\r\n            typeof option === \"object\" &&\r\n            Object.prototype.hasOwnProperty.call(option, \"max\")\r\n        ) {\r\n            max = option.max;\r\n        } else if (typeof option === \"number\") {\r\n            max = option;\r\n        }\r\n\r\n        const skipComments = option && option.skipComments;\r\n        const skipBlankLines = option && option.skipBlankLines;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Returns whether or not a token is a comment node type\r\n         * @param {Token} token The token to check\r\n         * @returns {boolean} True if the token is a comment node\r\n         */\r\n        function isCommentNodeType(token) {\r\n            return token && (token.type === \"Block\" || token.type === \"Line\");\r\n        }\r\n\r\n        /**\r\n         * Returns the line numbers of a comment that don't have any code on the same line\r\n         * @param {Node} comment The comment node to check\r\n         * @returns {number[]} The line numbers\r\n         */\r\n        function getLinesWithoutCode(comment) {\r\n            let start = comment.loc.start.line;\r\n            let end = comment.loc.end.line;\r\n\r\n            let token;\r\n\r\n            token = comment;\r\n            do {\r\n                token = sourceCode.getTokenBefore(token, {\r\n                    includeComments: true\r\n                });\r\n            } while (isCommentNodeType(token));\r\n\r\n            if (token && astUtils.isTokenOnSameLine(token, comment)) {\r\n                start += 1;\r\n            }\r\n\r\n            token = comment;\r\n            do {\r\n                token = sourceCode.getTokenAfter(token, {\r\n                    includeComments: true\r\n                });\r\n            } while (isCommentNodeType(token));\r\n\r\n            if (token && astUtils.isTokenOnSameLine(comment, token)) {\r\n                end -= 1;\r\n            }\r\n\r\n            if (start <= end) {\r\n                return range(start, end + 1);\r\n            }\r\n            return [];\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\"() {\r\n                let lines = sourceCode.lines.map((text, i) => ({\r\n                    lineNumber: i + 1,\r\n                    text\r\n                }));\r\n\r\n                /*\r\n                 * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.\r\n                 * That isn't a real line, so we shouldn't count it.\r\n                 */\r\n                if (lines.length > 1 && lines[lines.length - 1].text === \"\") {\r\n                    lines.pop();\r\n                }\r\n\r\n                if (skipBlankLines) {\r\n                    lines = lines.filter(l => l.text.trim() !== \"\");\r\n                }\r\n\r\n                if (skipComments) {\r\n                    const comments = sourceCode.getAllComments();\r\n\r\n                    const commentLines = comments.flatMap(getLinesWithoutCode);\r\n\r\n                    lines = lines.filter(\r\n                        l => !commentLines.includes(l.lineNumber)\r\n                    );\r\n                }\r\n\r\n                if (lines.length > max) {\r\n                    const loc = {\r\n                        start: {\r\n                            line: lines[max].lineNumber,\r\n                            column: 0\r\n                        },\r\n                        end: {\r\n                            line: sourceCode.lines.length,\r\n                            column: sourceCode.lines[sourceCode.lines.length - 1].length\r\n                        }\r\n                    };\r\n\r\n                    context.report({\r\n                        loc,\r\n                        messageId: \"exceed\",\r\n                        data: {\r\n                            max,\r\n                            actual: lines.length\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}