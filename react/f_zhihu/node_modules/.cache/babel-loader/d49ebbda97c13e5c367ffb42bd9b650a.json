{"ast":null,"code":"/**\r\n * @fileoverview Validates JSDoc comments are syntactically correct\r\n * @author Nicholas C. Zakas\r\n * @deprecated in ESLint v5.10.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst doctrine = require(\"doctrine\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce valid JSDoc comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/valid-jsdoc\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        prefer: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        preferType: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"string\"\n          }\n        },\n        requireReturn: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        requireReturnDescription: {\n          type: \"boolean\",\n          default: true\n        },\n        matchDescription: {\n          type: \"string\"\n        },\n        requireReturnType: {\n          type: \"boolean\",\n          default: true\n        },\n        requireParamType: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\n      expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\n      use: \"Use @{{name}} instead.\",\n      useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\n      syntaxError: \"JSDoc syntax error.\",\n      missingBrace: \"JSDoc type missing brace.\",\n      missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\n      missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\n      missingReturnType: \"Missing JSDoc return type.\",\n      missingReturnDesc: \"Missing JSDoc return description.\",\n      missingReturn: \"Missing JSDoc @{{returns}} for function.\",\n      missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\n      duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\n      unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\n    },\n    deprecated: true,\n    replacedBy: []\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          prefer = options.prefer || {},\n          sourceCode = context.getSourceCode(),\n          // these both default to true, so you have to explicitly make them false\n    requireReturn = options.requireReturn !== false,\n          requireParamDescription = options.requireParamDescription !== false,\n          requireReturnDescription = options.requireReturnDescription !== false,\n          requireReturnType = options.requireReturnType !== false,\n          requireParamType = options.requireParamType !== false,\n          preferType = options.preferType || {},\n          checkPreferType = Object.keys(preferType).length !== 0; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    // Using a stack to store if a function returns or not (handling nested functions)\n\n    const fns = [];\n    /**\r\n     * Check if node type is a Class\r\n     * @param {ASTNode} node node to check.\r\n     * @returns {boolean} True is its a class\r\n     * @private\r\n     */\n\n    function isTypeClass(node) {\n      return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n    }\n    /**\r\n     * When parsing a new function, store it in our function stack.\r\n     * @param {ASTNode} node A function node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function startFunction(node) {\n      fns.push({\n        returnPresent: node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\" || isTypeClass(node) || node.async\n      });\n    }\n    /**\r\n     * Indicate that return has been found in the current function.\r\n     * @param {ASTNode} node The return node.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function addReturn(node) {\n      const functionState = fns[fns.length - 1];\n\n      if (functionState && node.argument !== null) {\n        functionState.returnPresent = true;\n      }\n    }\n    /**\r\n     * Check if return tag type is void or undefined\r\n     * @param {Object} tag JSDoc tag\r\n     * @returns {boolean} True if its of type void or undefined\r\n     * @private\r\n     */\n\n\n    function isValidReturnType(tag) {\n      return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n    }\n    /**\r\n     * Check if type should be validated based on some exceptions\r\n     * @param {Object} type JSDoc tag\r\n     * @returns {boolean} True if it can be validated\r\n     * @private\r\n     */\n\n\n    function canTypeBeValidated(type) {\n      return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n      type !== \"NullLiteral\" && // {null}\n      type !== \"NullableLiteral\" && // {?}\n      type !== \"FunctionType\" && // {function(a)}\n      type !== \"AllLiteral\"; // {*}\n    }\n    /**\r\n     * Extract the current and expected type based on the input type object\r\n     * @param {Object} type JSDoc tag\r\n     * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\r\n     * the expected name of the annotation\r\n     * @private\r\n     */\n\n\n    function getCurrentExpectedTypes(type) {\n      let currentType;\n\n      if (type.name) {\n        currentType = type;\n      } else if (type.expression) {\n        currentType = type.expression;\n      }\n\n      return {\n        currentType,\n        expectedTypeName: currentType && preferType[currentType.name]\n      };\n    }\n    /**\r\n     * Gets the location of a JSDoc node in a file\r\n     * @param {Token} jsdocComment The comment that this node is parsed from\r\n     * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\r\n     * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\r\n     */\n\n\n    function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\n      return {\n        start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\n        end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\n      };\n    }\n    /**\r\n     * Validate type for a given JSDoc node\r\n     * @param {Object} jsdocNode JSDoc node\r\n     * @param {Object} type JSDoc tag\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function validateType(jsdocNode, type) {\n      if (!type || !canTypeBeValidated(type.type)) {\n        return;\n      }\n\n      const typesToCheck = [];\n      let elements = [];\n\n      switch (type.type) {\n        case \"TypeApplication\":\n          // {Array.<String>}\n          elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n          typesToCheck.push(getCurrentExpectedTypes(type));\n          break;\n\n        case \"RecordType\":\n          // {{20:String}}\n          elements = type.fields;\n          break;\n\n        case \"UnionType\": // {String|number|Test}\n\n        case \"ArrayType\":\n          // {[String, number, Test]}\n          elements = type.elements;\n          break;\n\n        case \"FieldType\":\n          // Array.<{count: number, votes: number}>\n          if (type.value) {\n            typesToCheck.push(getCurrentExpectedTypes(type.value));\n          }\n\n          break;\n\n        default:\n          typesToCheck.push(getCurrentExpectedTypes(type));\n      }\n\n      elements.forEach(validateType.bind(null, jsdocNode));\n      typesToCheck.forEach(typeToCheck => {\n        if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\n          context.report({\n            node: jsdocNode,\n            messageId: \"useType\",\n            loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\n            data: {\n              currentTypeName: typeToCheck.currentType.name,\n              expectedTypeName: typeToCheck.expectedTypeName\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange(typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);\n            }\n\n          });\n        }\n      });\n    }\n    /**\r\n     * Validate the JSDoc node and output warnings if anything is wrong.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkJSDoc(node) {\n      const jsdocNode = sourceCode.getJSDocComment(node),\n            functionData = fns.pop(),\n            paramTagsByName = Object.create(null),\n            paramTags = [];\n      let hasReturns = false,\n          returnsTag,\n          hasConstructor = false,\n          isInterface = false,\n          isOverride = false,\n          isAbstract = false; // make sure only to validate JSDoc comments\n\n      if (jsdocNode) {\n        let jsdoc;\n\n        try {\n          jsdoc = doctrine.parse(jsdocNode.value, {\n            strict: true,\n            unwrap: true,\n            sloppy: true,\n            range: true\n          });\n        } catch (ex) {\n          if (/braces/iu.test(ex.message)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingBrace\"\n            });\n          } else {\n            context.report({\n              node: jsdocNode,\n              messageId: \"syntaxError\"\n            });\n          }\n\n          return;\n        }\n\n        jsdoc.tags.forEach(tag => {\n          switch (tag.title.toLowerCase()) {\n            case \"param\":\n            case \"arg\":\n            case \"argument\":\n              paramTags.push(tag);\n              break;\n\n            case \"return\":\n            case \"returns\":\n              hasReturns = true;\n              returnsTag = tag;\n              break;\n\n            case \"constructor\":\n            case \"class\":\n              hasConstructor = true;\n              break;\n\n            case \"override\":\n            case \"inheritdoc\":\n              isOverride = true;\n              break;\n\n            case \"abstract\":\n            case \"virtual\":\n              isAbstract = true;\n              break;\n\n            case \"interface\":\n              isInterface = true;\n              break;\n            // no default\n          } // check tag preferences\n\n\n          if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\n            const entireTagRange = getAbsoluteRange(jsdocNode, tag);\n            context.report({\n              node: jsdocNode,\n              messageId: \"use\",\n              loc: {\n                start: entireTagRange.start,\n                end: {\n                  line: entireTagRange.start.line,\n                  column: entireTagRange.start.column + `@${tag.title}`.length\n                }\n              },\n              data: {\n                name: prefer[tag.title]\n              },\n\n              fix(fixer) {\n                return fixer.replaceTextRange([jsdocNode.range[0] + tag.range[0] + 3, jsdocNode.range[0] + tag.range[0] + tag.title.length + 3], prefer[tag.title]);\n              }\n\n            });\n          } // validate the types\n\n\n          if (checkPreferType && tag.type) {\n            validateType(jsdocNode, tag.type);\n          }\n        });\n        paramTags.forEach(param => {\n          if (requireParamType && !param.type) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamType\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (!param.description && requireParamDescription) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingParamDesc\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          }\n\n          if (paramTagsByName[param.name]) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"duplicateParam\",\n              loc: getAbsoluteRange(jsdocNode, param),\n              data: {\n                name: param.name\n              }\n            });\n          } else if (param.name.indexOf(\".\") === -1) {\n            paramTagsByName[param.name] = param;\n          }\n        });\n\n        if (hasReturns) {\n          if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unexpectedTag\",\n              loc: getAbsoluteRange(jsdocNode, returnsTag),\n              data: {\n                title: returnsTag.title\n              }\n            });\n          } else {\n            if (requireReturnType && !returnsTag.type) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnType\"\n              });\n            }\n\n            if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\n              context.report({\n                node: jsdocNode,\n                messageId: \"missingReturnDesc\"\n              });\n            }\n          }\n        } // check for functions missing @returns\n\n\n        if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" && node.parent.kind !== \"set\" && !isTypeClass(node)) {\n          if (requireReturn || functionData.returnPresent && !node.async) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"missingReturn\",\n              data: {\n                returns: prefer.returns || \"returns\"\n              }\n            });\n          }\n        } // check the parameters\n\n\n        const jsdocParamNames = Object.keys(paramTagsByName);\n\n        if (node.params) {\n          node.params.forEach((param, paramsIndex) => {\n            const bindingParam = param.type === \"AssignmentPattern\" ? param.left : param; // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n\n            if (bindingParam.type === \"Identifier\") {\n              const name = bindingParam.name;\n\n              if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"expected\",\n                  loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\n                  data: {\n                    name,\n                    jsdocName: jsdocParamNames[paramsIndex]\n                  }\n                });\n              } else if (!paramTagsByName[name] && !isOverride) {\n                context.report({\n                  node: jsdocNode,\n                  messageId: \"missingParam\",\n                  data: {\n                    name\n                  }\n                });\n              }\n            }\n          });\n        }\n\n        if (options.matchDescription) {\n          const regex = new RegExp(options.matchDescription, \"u\");\n\n          if (!regex.test(jsdoc.description)) {\n            context.report({\n              node: jsdocNode,\n              messageId: \"unsatisfiedDesc\"\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ArrowFunctionExpression: startFunction,\n      FunctionExpression: startFunction,\n      FunctionDeclaration: startFunction,\n      ClassExpression: startFunction,\n      ClassDeclaration: startFunction,\n      \"ArrowFunctionExpression:exit\": checkJSDoc,\n      \"FunctionExpression:exit\": checkJSDoc,\n      \"FunctionDeclaration:exit\": checkJSDoc,\n      \"ClassExpression:exit\": checkJSDoc,\n      \"ClassDeclaration:exit\": checkJSDoc,\n      ReturnStatement: addReturn\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/valid-jsdoc.js"],"names":["doctrine","require","module","exports","meta","type","docs","description","recommended","url","schema","properties","prefer","additionalProperties","preferType","requireReturn","default","requireParamDescription","requireReturnDescription","matchDescription","requireReturnType","requireParamType","fixable","messages","unexpectedTag","expected","use","useType","syntaxError","missingBrace","missingParamDesc","missingParamType","missingReturnType","missingReturnDesc","missingReturn","missingParam","duplicateParam","unsatisfiedDesc","deprecated","replacedBy","create","context","options","sourceCode","getSourceCode","checkPreferType","Object","keys","length","fns","isTypeClass","node","startFunction","push","returnPresent","body","async","addReturn","functionState","argument","isValidReturnType","tag","name","canTypeBeValidated","getCurrentExpectedTypes","currentType","expression","expectedTypeName","getAbsoluteRange","jsdocComment","parsedJsdocNode","start","getLocFromIndex","range","end","validateType","jsdocNode","typesToCheck","elements","applications","fields","value","forEach","bind","typeToCheck","report","messageId","loc","data","currentTypeName","fix","fixer","replaceTextRange","map","indexInComment","checkJSDoc","getJSDocComment","functionData","pop","paramTagsByName","paramTags","hasReturns","returnsTag","hasConstructor","isInterface","isOverride","isAbstract","jsdoc","parse","strict","unwrap","sloppy","ex","test","message","tags","title","toLowerCase","prototype","hasOwnProperty","call","entireTagRange","line","column","param","indexOf","parent","kind","returns","jsdocParamNames","params","paramsIndex","bindingParam","left","jsdocName","regex","RegExp","ArrowFunctionExpression","FunctionExpression","FunctionDeclaration","ClassExpression","ClassDeclaration","ReturnStatement"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Validates JSDoc comments are syntactically correct\r\n * @author Nicholas C. Zakas\r\n * @deprecated in ESLint v5.10.0\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst doctrine = require(\"doctrine\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce valid JSDoc comments\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/valid-jsdoc\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    prefer: {\r\n                        type: \"object\",\r\n                        additionalProperties: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    preferType: {\r\n                        type: \"object\",\r\n                        additionalProperties: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    requireReturn: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    requireParamDescription: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    requireReturnDescription: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    matchDescription: {\r\n                        type: \"string\"\r\n                    },\r\n                    requireReturnType: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    requireParamType: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n        messages: {\r\n            unexpectedTag: \"Unexpected @{{title}} tag; function has no return statement.\",\r\n            expected: \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\",\r\n            use: \"Use @{{name}} instead.\",\r\n            useType: \"Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.\",\r\n            syntaxError: \"JSDoc syntax error.\",\r\n            missingBrace: \"JSDoc type missing brace.\",\r\n            missingParamDesc: \"Missing JSDoc parameter description for '{{name}}'.\",\r\n            missingParamType: \"Missing JSDoc parameter type for '{{name}}'.\",\r\n            missingReturnType: \"Missing JSDoc return type.\",\r\n            missingReturnDesc: \"Missing JSDoc return description.\",\r\n            missingReturn: \"Missing JSDoc @{{returns}} for function.\",\r\n            missingParam: \"Missing JSDoc for parameter '{{name}}'.\",\r\n            duplicateParam: \"Duplicate JSDoc parameter '{{name}}'.\",\r\n            unsatisfiedDesc: \"JSDoc description does not satisfy the regex pattern.\"\r\n        },\r\n\r\n        deprecated: true,\r\n        replacedBy: []\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0] || {},\r\n            prefer = options.prefer || {},\r\n            sourceCode = context.getSourceCode(),\r\n\r\n            // these both default to true, so you have to explicitly make them false\r\n            requireReturn = options.requireReturn !== false,\r\n            requireParamDescription = options.requireParamDescription !== false,\r\n            requireReturnDescription = options.requireReturnDescription !== false,\r\n            requireReturnType = options.requireReturnType !== false,\r\n            requireParamType = options.requireParamType !== false,\r\n            preferType = options.preferType || {},\r\n            checkPreferType = Object.keys(preferType).length !== 0;\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        // Using a stack to store if a function returns or not (handling nested functions)\r\n        const fns = [];\r\n\r\n        /**\r\n         * Check if node type is a Class\r\n         * @param {ASTNode} node node to check.\r\n         * @returns {boolean} True is its a class\r\n         * @private\r\n         */\r\n        function isTypeClass(node) {\r\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\r\n        }\r\n\r\n        /**\r\n         * When parsing a new function, store it in our function stack.\r\n         * @param {ASTNode} node A function node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function startFunction(node) {\r\n            fns.push({\r\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\r\n                    isTypeClass(node) || node.async\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Indicate that return has been found in the current function.\r\n         * @param {ASTNode} node The return node.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function addReturn(node) {\r\n            const functionState = fns[fns.length - 1];\r\n\r\n            if (functionState && node.argument !== null) {\r\n                functionState.returnPresent = true;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if return tag type is void or undefined\r\n         * @param {Object} tag JSDoc tag\r\n         * @returns {boolean} True if its of type void or undefined\r\n         * @private\r\n         */\r\n        function isValidReturnType(tag) {\r\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\r\n        }\r\n\r\n        /**\r\n         * Check if type should be validated based on some exceptions\r\n         * @param {Object} type JSDoc tag\r\n         * @returns {boolean} True if it can be validated\r\n         * @private\r\n         */\r\n        function canTypeBeValidated(type) {\r\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\r\n                   type !== \"NullLiteral\" && // {null}\r\n                   type !== \"NullableLiteral\" && // {?}\r\n                   type !== \"FunctionType\" && // {function(a)}\r\n                   type !== \"AllLiteral\"; // {*}\r\n        }\r\n\r\n        /**\r\n         * Extract the current and expected type based on the input type object\r\n         * @param {Object} type JSDoc tag\r\n         * @returns {{currentType: Doctrine.Type, expectedTypeName: string}} The current type annotation and\r\n         * the expected name of the annotation\r\n         * @private\r\n         */\r\n        function getCurrentExpectedTypes(type) {\r\n            let currentType;\r\n\r\n            if (type.name) {\r\n                currentType = type;\r\n            } else if (type.expression) {\r\n                currentType = type.expression;\r\n            }\r\n\r\n            return {\r\n                currentType,\r\n                expectedTypeName: currentType && preferType[currentType.name]\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Gets the location of a JSDoc node in a file\r\n         * @param {Token} jsdocComment The comment that this node is parsed from\r\n         * @param {{range: number[]}} parsedJsdocNode A tag or other node which was parsed from this comment\r\n         * @returns {{start: SourceLocation, end: SourceLocation}} The 0-based source location for the tag\r\n         */\r\n        function getAbsoluteRange(jsdocComment, parsedJsdocNode) {\r\n            return {\r\n                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),\r\n                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Validate type for a given JSDoc node\r\n         * @param {Object} jsdocNode JSDoc node\r\n         * @param {Object} type JSDoc tag\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function validateType(jsdocNode, type) {\r\n            if (!type || !canTypeBeValidated(type.type)) {\r\n                return;\r\n            }\r\n\r\n            const typesToCheck = [];\r\n            let elements = [];\r\n\r\n            switch (type.type) {\r\n                case \"TypeApplication\": // {Array.<String>}\r\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\r\n                    typesToCheck.push(getCurrentExpectedTypes(type));\r\n                    break;\r\n                case \"RecordType\": // {{20:String}}\r\n                    elements = type.fields;\r\n                    break;\r\n                case \"UnionType\": // {String|number|Test}\r\n                case \"ArrayType\": // {[String, number, Test]}\r\n                    elements = type.elements;\r\n                    break;\r\n                case \"FieldType\": // Array.<{count: number, votes: number}>\r\n                    if (type.value) {\r\n                        typesToCheck.push(getCurrentExpectedTypes(type.value));\r\n                    }\r\n                    break;\r\n                default:\r\n                    typesToCheck.push(getCurrentExpectedTypes(type));\r\n            }\r\n\r\n            elements.forEach(validateType.bind(null, jsdocNode));\r\n\r\n            typesToCheck.forEach(typeToCheck => {\r\n                if (typeToCheck.expectedTypeName &&\r\n                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {\r\n                    context.report({\r\n                        node: jsdocNode,\r\n                        messageId: \"useType\",\r\n                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),\r\n                        data: {\r\n                            currentTypeName: typeToCheck.currentType.name,\r\n                            expectedTypeName: typeToCheck.expectedTypeName\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.replaceTextRange(\r\n                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),\r\n                                typeToCheck.expectedTypeName\r\n                            );\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Validate the JSDoc node and output warnings if anything is wrong.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkJSDoc(node) {\r\n            const jsdocNode = sourceCode.getJSDocComment(node),\r\n                functionData = fns.pop(),\r\n                paramTagsByName = Object.create(null),\r\n                paramTags = [];\r\n            let hasReturns = false,\r\n                returnsTag,\r\n                hasConstructor = false,\r\n                isInterface = false,\r\n                isOverride = false,\r\n                isAbstract = false;\r\n\r\n            // make sure only to validate JSDoc comments\r\n            if (jsdocNode) {\r\n                let jsdoc;\r\n\r\n                try {\r\n                    jsdoc = doctrine.parse(jsdocNode.value, {\r\n                        strict: true,\r\n                        unwrap: true,\r\n                        sloppy: true,\r\n                        range: true\r\n                    });\r\n                } catch (ex) {\r\n\r\n                    if (/braces/iu.test(ex.message)) {\r\n                        context.report({ node: jsdocNode, messageId: \"missingBrace\" });\r\n                    } else {\r\n                        context.report({ node: jsdocNode, messageId: \"syntaxError\" });\r\n                    }\r\n\r\n                    return;\r\n                }\r\n\r\n                jsdoc.tags.forEach(tag => {\r\n\r\n                    switch (tag.title.toLowerCase()) {\r\n\r\n                        case \"param\":\r\n                        case \"arg\":\r\n                        case \"argument\":\r\n                            paramTags.push(tag);\r\n                            break;\r\n\r\n                        case \"return\":\r\n                        case \"returns\":\r\n                            hasReturns = true;\r\n                            returnsTag = tag;\r\n                            break;\r\n\r\n                        case \"constructor\":\r\n                        case \"class\":\r\n                            hasConstructor = true;\r\n                            break;\r\n\r\n                        case \"override\":\r\n                        case \"inheritdoc\":\r\n                            isOverride = true;\r\n                            break;\r\n\r\n                        case \"abstract\":\r\n                        case \"virtual\":\r\n                            isAbstract = true;\r\n                            break;\r\n\r\n                        case \"interface\":\r\n                            isInterface = true;\r\n                            break;\r\n\r\n                        // no default\r\n                    }\r\n\r\n                    // check tag preferences\r\n                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {\r\n                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);\r\n\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"use\",\r\n                            loc: {\r\n                                start: entireTagRange.start,\r\n                                end: {\r\n                                    line: entireTagRange.start.line,\r\n                                    column: entireTagRange.start.column + `@${tag.title}`.length\r\n                                }\r\n                            },\r\n                            data: { name: prefer[tag.title] },\r\n                            fix(fixer) {\r\n                                return fixer.replaceTextRange(\r\n                                    [\r\n                                        jsdocNode.range[0] + tag.range[0] + 3,\r\n                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3\r\n                                    ],\r\n                                    prefer[tag.title]\r\n                                );\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    // validate the types\r\n                    if (checkPreferType && tag.type) {\r\n                        validateType(jsdocNode, tag.type);\r\n                    }\r\n                });\r\n\r\n                paramTags.forEach(param => {\r\n                    if (requireParamType && !param.type) {\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"missingParamType\",\r\n                            loc: getAbsoluteRange(jsdocNode, param),\r\n                            data: { name: param.name }\r\n                        });\r\n                    }\r\n                    if (!param.description && requireParamDescription) {\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"missingParamDesc\",\r\n                            loc: getAbsoluteRange(jsdocNode, param),\r\n                            data: { name: param.name }\r\n                        });\r\n                    }\r\n                    if (paramTagsByName[param.name]) {\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"duplicateParam\",\r\n                            loc: getAbsoluteRange(jsdocNode, param),\r\n                            data: { name: param.name }\r\n                        });\r\n                    } else if (param.name.indexOf(\".\") === -1) {\r\n                        paramTagsByName[param.name] = param;\r\n                    }\r\n                });\r\n\r\n                if (hasReturns) {\r\n                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"unexpectedTag\",\r\n                            loc: getAbsoluteRange(jsdocNode, returnsTag),\r\n                            data: {\r\n                                title: returnsTag.title\r\n                            }\r\n                        });\r\n                    } else {\r\n                        if (requireReturnType && !returnsTag.type) {\r\n                            context.report({ node: jsdocNode, messageId: \"missingReturnType\" });\r\n                        }\r\n\r\n                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {\r\n                            context.report({ node: jsdocNode, messageId: \"missingReturnDesc\" });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // check for functions missing @returns\r\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\r\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\r\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\r\n                    if (requireReturn || (functionData.returnPresent && !node.async)) {\r\n                        context.report({\r\n                            node: jsdocNode,\r\n                            messageId: \"missingReturn\",\r\n                            data: {\r\n                                returns: prefer.returns || \"returns\"\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n\r\n                // check the parameters\r\n                const jsdocParamNames = Object.keys(paramTagsByName);\r\n\r\n                if (node.params) {\r\n                    node.params.forEach((param, paramsIndex) => {\r\n                        const bindingParam = param.type === \"AssignmentPattern\"\r\n                            ? param.left\r\n                            : param;\r\n\r\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\r\n                        if (bindingParam.type === \"Identifier\") {\r\n                            const name = bindingParam.name;\r\n\r\n                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) {\r\n                                context.report({\r\n                                    node: jsdocNode,\r\n                                    messageId: \"expected\",\r\n                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),\r\n                                    data: {\r\n                                        name,\r\n                                        jsdocName: jsdocParamNames[paramsIndex]\r\n                                    }\r\n                                });\r\n                            } else if (!paramTagsByName[name] && !isOverride) {\r\n                                context.report({\r\n                                    node: jsdocNode,\r\n                                    messageId: \"missingParam\",\r\n                                    data: {\r\n                                        name\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n\r\n                if (options.matchDescription) {\r\n                    const regex = new RegExp(options.matchDescription, \"u\");\r\n\r\n                    if (!regex.test(jsdoc.description)) {\r\n                        context.report({ node: jsdocNode, messageId: \"unsatisfiedDesc\" });\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            ArrowFunctionExpression: startFunction,\r\n            FunctionExpression: startFunction,\r\n            FunctionDeclaration: startFunction,\r\n            ClassExpression: startFunction,\r\n            ClassDeclaration: startFunction,\r\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\r\n            \"FunctionExpression:exit\": checkJSDoc,\r\n            \"FunctionDeclaration:exit\": checkJSDoc,\r\n            \"ClassExpression:exit\": checkJSDoc,\r\n            \"ClassDeclaration:exit\": checkJSDoc,\r\n            ReturnStatement: addReturn\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}