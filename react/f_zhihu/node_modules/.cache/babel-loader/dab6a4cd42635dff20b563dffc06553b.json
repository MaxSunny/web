{"ast":null,"code":"/**\r\n * @fileoverview Source code for spaced-comments rule\r\n * @author Gyandeep Singh\r\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Escapes the control characters of a given string.\r\n * @param {string} s A string to escape.\r\n * @returns {string} An escaped string.\r\n */\n\n\nfunction escape(s) {\n  return `(?:${escapeRegExp(s)})`;\n}\n/**\r\n * Escapes the control characters of a given string.\r\n * And adds a repeat flag.\r\n * @param {string} s A string to escape.\r\n * @returns {string} An escaped string.\r\n */\n\n\nfunction escapeAndRepeat(s) {\n  return `${escape(s)}+`;\n}\n/**\r\n * Parses `markers` option.\r\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\r\n * @param {string[]} [markers] A marker list.\r\n * @returns {string[]} A marker list.\r\n */\n\n\nfunction parseMarkersOption(markers) {\n  // `*` is a marker for JSDoc comments.\n  if (markers.indexOf(\"*\") === -1) {\n    return markers.concat(\"*\");\n  }\n\n  return markers;\n}\n/**\r\n * Creates string pattern for exceptions.\r\n * Generated pattern:\r\n *\r\n * 1. A space or an exception pattern sequence.\r\n * @param {string[]} exceptions An exception pattern list.\r\n * @returns {string} A regular expression string for exceptions.\r\n */\n\n\nfunction createExceptionsPattern(exceptions) {\n  let pattern = \"\";\n  /*\r\n   * A space or an exception pattern sequence.\r\n   * []                 ==> \"\\s\"\r\n   * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\r\n   * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\r\n   * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\r\n   */\n\n  if (exceptions.length === 0) {\n    // a space.\n    pattern += \"\\\\s\";\n  } else {\n    // a space or...\n    pattern += \"(?:\\\\s|\";\n\n    if (exceptions.length === 1) {\n      // a sequence of the exception pattern.\n      pattern += escapeAndRepeat(exceptions[0]);\n    } else {\n      // a sequence of one of the exception patterns.\n      pattern += \"(?:\";\n      pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n      pattern += \")\";\n    }\n\n    pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\n  }\n\n  return pattern;\n}\n/**\r\n * Creates RegExp object for `always` mode.\r\n * Generated pattern for beginning of comment:\r\n *\r\n * 1. First, a marker or nothing.\r\n * 2. Next, a space or an exception pattern sequence.\r\n * @param {string[]} markers A marker list.\r\n * @param {string[]} exceptions An exception pattern list.\r\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\r\n */\n\n\nfunction createAlwaysStylePattern(markers, exceptions) {\n  let pattern = \"^\";\n  /*\r\n   * A marker or nothing.\r\n   * [\"*\"]            ==> \"\\*?\"\r\n   * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\r\n   * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\r\n   */\n\n  if (markers.length === 1) {\n    // the marker.\n    pattern += escape(markers[0]);\n  } else {\n    // one of markers.\n    pattern += \"(?:\";\n    pattern += markers.map(escape).join(\"|\");\n    pattern += \")\";\n  }\n\n  pattern += \"?\"; // or nothing.\n\n  pattern += createExceptionsPattern(exceptions);\n  return new RegExp(pattern, \"u\");\n}\n/**\r\n * Creates RegExp object for `never` mode.\r\n * Generated pattern for beginning of comment:\r\n *\r\n * 1. First, a marker or nothing (captured).\r\n * 2. Next, a space or a tab.\r\n * @param {string[]} markers A marker list.\r\n * @returns {RegExp} A RegExp object for `never` mode.\r\n */\n\n\nfunction createNeverStylePattern(markers) {\n  const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\n  return new RegExp(pattern, \"u\");\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/spaced-comment\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\"]\n    }, {\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        markers: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        line: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          additionalProperties: false\n        },\n        block: {\n          type: \"object\",\n          properties: {\n            exceptions: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            markers: {\n              type: \"array\",\n              items: {\n                type: \"string\"\n              }\n            },\n            balanced: {\n              type: \"boolean\",\n              default: false\n            }\n          },\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\n      expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\n      unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\n      unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\n      expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\n      expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); // Unless the first option is never, require a space\n\n    const requireSpace = context.options[0] !== \"never\";\n    /*\r\n     * Parse the second options.\r\n     * If markers don't include `\"*\"`, it's added automatically for JSDoc\r\n     * comments.\r\n     */\n\n    const config = context.options[1] || {};\n    const balanced = config.block && config.block.balanced;\n    const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\n      const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\n      const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n      const endNeverPattern = \"[ \\t]+$\"; // Create RegExp object for valid patterns.\n\n      rule[type] = {\n        beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n        endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\n        hasExceptions: exceptions.length > 0,\n        captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\n        markers: new Set(markers)\n      };\n      return rule;\n    }, {});\n    /**\r\n     * Reports a beginning spacing error with an appropriate message.\r\n     * @param {ASTNode} node A comment node to check.\r\n     * @param {string} messageId An error message to report.\r\n     * @param {Array} match An array of match results for markers.\r\n     * @param {string} refChar Character used for reference in the error message.\r\n     * @returns {void}\r\n     */\n\n    function reportBegin(node, messageId, match, refChar) {\n      const type = node.type.toLowerCase(),\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n      context.report({\n        node,\n\n        fix(fixer) {\n          const start = node.range[0];\n          let end = start + 2;\n\n          if (requireSpace) {\n            if (match) {\n              end += match[0].length;\n            }\n\n            return fixer.insertTextAfterRange([start, end], \" \");\n          }\n\n          end += match[0].length;\n          return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n        },\n\n        messageId,\n        data: {\n          refChar\n        }\n      });\n    }\n    /**\r\n     * Reports an ending spacing error with an appropriate message.\r\n     * @param {ASTNode} node A comment node to check.\r\n     * @param {string} messageId An error message to report.\r\n     * @param {string} match An array of the matched whitespace characters.\r\n     * @returns {void}\r\n     */\n\n\n    function reportEnd(node, messageId, match) {\n      context.report({\n        node,\n\n        fix(fixer) {\n          if (requireSpace) {\n            return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\n          }\n\n          const end = node.range[1] - 2,\n                start = end - match[0].length;\n          return fixer.replaceTextRange([start, end], \"\");\n        },\n\n        messageId\n      });\n    }\n    /**\r\n     * Reports a given comment if it's invalid.\r\n     * @param {ASTNode} node a comment node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkCommentForSpace(node) {\n      const type = node.type.toLowerCase(),\n            rule = styleRules[type],\n            commentIdentifier = type === \"block\" ? \"/*\" : \"//\"; // Ignores empty comments and comments that consist only of a marker.\n\n      if (node.value.length === 0 || rule.markers.has(node.value)) {\n        return;\n      }\n\n      const beginMatch = rule.beginRegex.exec(node.value);\n      const endMatch = rule.endRegex.exec(node.value); // Checks.\n\n      if (requireSpace) {\n        if (!beginMatch) {\n          const hasMarker = rule.captureMarker.exec(node.value);\n          const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n          if (rule.hasExceptions) {\n            reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\n          } else {\n            reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\n          }\n        }\n\n        if (balanced && type === \"block\" && !endMatch) {\n          reportEnd(node, \"expectedSpaceBefore\");\n        }\n      } else {\n        if (beginMatch) {\n          if (!beginMatch[1]) {\n            reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\n          } else {\n            reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\n          }\n        }\n\n        if (balanced && type === \"block\" && endMatch) {\n          reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\n        }\n      }\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/spaced-comment.js"],"names":["escapeRegExp","require","astUtils","escape","s","escapeAndRepeat","parseMarkersOption","markers","indexOf","concat","createExceptionsPattern","exceptions","pattern","length","map","join","Array","from","LINEBREAKS","createAlwaysStylePattern","RegExp","createNeverStylePattern","module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","properties","items","line","additionalProperties","block","balanced","default","messages","unexpectedSpaceAfterMarker","expectedExceptionAfter","unexpectedSpaceBefore","unexpectedSpaceAfter","expectedSpaceBefore","expectedSpaceAfter","create","context","sourceCode","getSourceCode","requireSpace","options","config","styleRules","reduce","rule","endNeverPattern","beginRegex","endRegex","hasExceptions","captureMarker","Set","reportBegin","node","messageId","match","refChar","toLowerCase","commentIdentifier","report","fix","fixer","start","range","end","insertTextAfterRange","replaceTextRange","data","reportEnd","checkCommentForSpace","value","has","beginMatch","exec","endMatch","hasMarker","marker","Program","comments","getAllComments","filter","token","forEach"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Source code for spaced-comments rule\r\n * @author Gyandeep Singh\r\n */\r\n\"use strict\";\r\n\r\nconst escapeRegExp = require(\"escape-string-regexp\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Escapes the control characters of a given string.\r\n * @param {string} s A string to escape.\r\n * @returns {string} An escaped string.\r\n */\r\nfunction escape(s) {\r\n    return `(?:${escapeRegExp(s)})`;\r\n}\r\n\r\n/**\r\n * Escapes the control characters of a given string.\r\n * And adds a repeat flag.\r\n * @param {string} s A string to escape.\r\n * @returns {string} An escaped string.\r\n */\r\nfunction escapeAndRepeat(s) {\r\n    return `${escape(s)}+`;\r\n}\r\n\r\n/**\r\n * Parses `markers` option.\r\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\r\n * @param {string[]} [markers] A marker list.\r\n * @returns {string[]} A marker list.\r\n */\r\nfunction parseMarkersOption(markers) {\r\n\r\n    // `*` is a marker for JSDoc comments.\r\n    if (markers.indexOf(\"*\") === -1) {\r\n        return markers.concat(\"*\");\r\n    }\r\n\r\n    return markers;\r\n}\r\n\r\n/**\r\n * Creates string pattern for exceptions.\r\n * Generated pattern:\r\n *\r\n * 1. A space or an exception pattern sequence.\r\n * @param {string[]} exceptions An exception pattern list.\r\n * @returns {string} A regular expression string for exceptions.\r\n */\r\nfunction createExceptionsPattern(exceptions) {\r\n    let pattern = \"\";\r\n\r\n    /*\r\n     * A space or an exception pattern sequence.\r\n     * []                 ==> \"\\s\"\r\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\r\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\r\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\r\n     */\r\n    if (exceptions.length === 0) {\r\n\r\n        // a space.\r\n        pattern += \"\\\\s\";\r\n    } else {\r\n\r\n        // a space or...\r\n        pattern += \"(?:\\\\s|\";\r\n\r\n        if (exceptions.length === 1) {\r\n\r\n            // a sequence of the exception pattern.\r\n            pattern += escapeAndRepeat(exceptions[0]);\r\n        } else {\r\n\r\n            // a sequence of one of the exception patterns.\r\n            pattern += \"(?:\";\r\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\r\n            pattern += \")\";\r\n        }\r\n        pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join(\"\")}]))`;\r\n    }\r\n\r\n    return pattern;\r\n}\r\n\r\n/**\r\n * Creates RegExp object for `always` mode.\r\n * Generated pattern for beginning of comment:\r\n *\r\n * 1. First, a marker or nothing.\r\n * 2. Next, a space or an exception pattern sequence.\r\n * @param {string[]} markers A marker list.\r\n * @param {string[]} exceptions An exception pattern list.\r\n * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.\r\n */\r\nfunction createAlwaysStylePattern(markers, exceptions) {\r\n    let pattern = \"^\";\r\n\r\n    /*\r\n     * A marker or nothing.\r\n     * [\"*\"]            ==> \"\\*?\"\r\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\r\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\r\n     */\r\n    if (markers.length === 1) {\r\n\r\n        // the marker.\r\n        pattern += escape(markers[0]);\r\n    } else {\r\n\r\n        // one of markers.\r\n        pattern += \"(?:\";\r\n        pattern += markers.map(escape).join(\"|\");\r\n        pattern += \")\";\r\n    }\r\n\r\n    pattern += \"?\"; // or nothing.\r\n    pattern += createExceptionsPattern(exceptions);\r\n\r\n    return new RegExp(pattern, \"u\");\r\n}\r\n\r\n/**\r\n * Creates RegExp object for `never` mode.\r\n * Generated pattern for beginning of comment:\r\n *\r\n * 1. First, a marker or nothing (captured).\r\n * 2. Next, a space or a tab.\r\n * @param {string[]} markers A marker list.\r\n * @returns {RegExp} A RegExp object for `never` mode.\r\n */\r\nfunction createNeverStylePattern(markers) {\r\n    const pattern = `^(${markers.map(escape).join(\"|\")})?[ \\t]+`;\r\n\r\n    return new RegExp(pattern, \"u\");\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/spaced-comment\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptions: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    markers: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    line: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            exceptions: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                }\r\n                            },\r\n                            markers: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                }\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    block: {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            exceptions: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                }\r\n                            },\r\n                            markers: {\r\n                                type: \"array\",\r\n                                items: {\r\n                                    type: \"string\"\r\n                                }\r\n                            },\r\n                            balanced: {\r\n                                type: \"boolean\",\r\n                                default: false\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedSpaceAfterMarker: \"Unexpected space or tab after marker ({{refChar}}) in comment.\",\r\n            expectedExceptionAfter: \"Expected exception block, space or tab after '{{refChar}}' in comment.\",\r\n            unexpectedSpaceBefore: \"Unexpected space or tab before '*/' in comment.\",\r\n            unexpectedSpaceAfter: \"Unexpected space or tab after '{{refChar}}' in comment.\",\r\n            expectedSpaceBefore: \"Expected space or tab before '*/' in comment.\",\r\n            expectedSpaceAfter: \"Expected space or tab after '{{refChar}}' in comment.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        // Unless the first option is never, require a space\r\n        const requireSpace = context.options[0] !== \"never\";\r\n\r\n        /*\r\n         * Parse the second options.\r\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\r\n         * comments.\r\n         */\r\n        const config = context.options[1] || {};\r\n        const balanced = config.block && config.block.balanced;\r\n\r\n        const styleRules = [\"block\", \"line\"].reduce((rule, type) => {\r\n            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);\r\n            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];\r\n            const endNeverPattern = \"[ \\t]+$\";\r\n\r\n            // Create RegExp object for valid patterns.\r\n            rule[type] = {\r\n                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\r\n                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, \"u\") : new RegExp(endNeverPattern, \"u\"),\r\n                hasExceptions: exceptions.length > 0,\r\n                captureMarker: new RegExp(`^(${markers.map(escape).join(\"|\")})`, \"u\"),\r\n                markers: new Set(markers)\r\n            };\r\n\r\n            return rule;\r\n        }, {});\r\n\r\n        /**\r\n         * Reports a beginning spacing error with an appropriate message.\r\n         * @param {ASTNode} node A comment node to check.\r\n         * @param {string} messageId An error message to report.\r\n         * @param {Array} match An array of match results for markers.\r\n         * @param {string} refChar Character used for reference in the error message.\r\n         * @returns {void}\r\n         */\r\n        function reportBegin(node, messageId, match, refChar) {\r\n            const type = node.type.toLowerCase(),\r\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\r\n\r\n            context.report({\r\n                node,\r\n                fix(fixer) {\r\n                    const start = node.range[0];\r\n                    let end = start + 2;\r\n\r\n                    if (requireSpace) {\r\n                        if (match) {\r\n                            end += match[0].length;\r\n                        }\r\n                        return fixer.insertTextAfterRange([start, end], \" \");\r\n                    }\r\n                    end += match[0].length;\r\n                    return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\r\n\r\n                },\r\n                messageId,\r\n                data: { refChar }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports an ending spacing error with an appropriate message.\r\n         * @param {ASTNode} node A comment node to check.\r\n         * @param {string} messageId An error message to report.\r\n         * @param {string} match An array of the matched whitespace characters.\r\n         * @returns {void}\r\n         */\r\n        function reportEnd(node, messageId, match) {\r\n            context.report({\r\n                node,\r\n                fix(fixer) {\r\n                    if (requireSpace) {\r\n                        return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], \" \");\r\n                    }\r\n                    const end = node.range[1] - 2,\r\n                        start = end - match[0].length;\r\n\r\n                    return fixer.replaceTextRange([start, end], \"\");\r\n\r\n                },\r\n                messageId\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Reports a given comment if it's invalid.\r\n         * @param {ASTNode} node a comment node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkCommentForSpace(node) {\r\n            const type = node.type.toLowerCase(),\r\n                rule = styleRules[type],\r\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\r\n\r\n            // Ignores empty comments and comments that consist only of a marker.\r\n            if (node.value.length === 0 || rule.markers.has(node.value)) {\r\n                return;\r\n            }\r\n\r\n            const beginMatch = rule.beginRegex.exec(node.value);\r\n            const endMatch = rule.endRegex.exec(node.value);\r\n\r\n            // Checks.\r\n            if (requireSpace) {\r\n                if (!beginMatch) {\r\n                    const hasMarker = rule.captureMarker.exec(node.value);\r\n                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\r\n\r\n                    if (rule.hasExceptions) {\r\n                        reportBegin(node, \"expectedExceptionAfter\", hasMarker, marker);\r\n                    } else {\r\n                        reportBegin(node, \"expectedSpaceAfter\", hasMarker, marker);\r\n                    }\r\n                }\r\n\r\n                if (balanced && type === \"block\" && !endMatch) {\r\n                    reportEnd(node, \"expectedSpaceBefore\");\r\n                }\r\n            } else {\r\n                if (beginMatch) {\r\n                    if (!beginMatch[1]) {\r\n                        reportBegin(node, \"unexpectedSpaceAfter\", beginMatch, commentIdentifier);\r\n                    } else {\r\n                        reportBegin(node, \"unexpectedSpaceAfterMarker\", beginMatch, beginMatch[1]);\r\n                    }\r\n                }\r\n\r\n                if (balanced && type === \"block\" && endMatch) {\r\n                    reportEnd(node, \"unexpectedSpaceBefore\", endMatch);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                const comments = sourceCode.getAllComments();\r\n\r\n                comments.filter(token => token.type !== \"Shebang\").forEach(checkCommentForSpace);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}