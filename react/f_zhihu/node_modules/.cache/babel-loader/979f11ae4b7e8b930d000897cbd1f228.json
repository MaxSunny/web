{"ast":null,"code":"/**\r\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\r\n * @author Aladdin-ADD<hh_2013@foxmail.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/for-direction\"\n    },\n    fixable: null,\n    schema: [],\n    messages: {\n      incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * report an error.\r\n     * @param {ASTNode} node the node to report.\r\n     * @returns {void}\r\n     */\n    function report(node) {\n      context.report({\n        node,\n        messageId: \"incorrectDirection\"\n      });\n    }\n    /**\r\n     * check the right side of the assignment\r\n     * @param {ASTNode} update UpdateExpression to check\r\n     * @param {int} dir expected direction that could either be turned around or invalidated\r\n     * @returns {int} return dir, the negated dir or zero if it's not clear for identifiers\r\n     */\n\n\n    function getRightDirection(update, dir) {\n      if (update.right.type === \"UnaryExpression\") {\n        if (update.right.operator === \"-\") {\n          return -dir;\n        }\n      } else if (update.right.type === \"Identifier\") {\n        return 0;\n      }\n\n      return dir;\n    }\n    /**\r\n     * check UpdateExpression add/sub the counter\r\n     * @param {ASTNode} update UpdateExpression to check\r\n     * @param {string} counter variable name to check\r\n     * @returns {int} if add return 1, if sub return -1, if nochange, return 0\r\n     */\n\n\n    function getUpdateDirection(update, counter) {\n      if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\n        if (update.operator === \"++\") {\n          return 1;\n        }\n\n        if (update.operator === \"--\") {\n          return -1;\n        }\n      }\n\n      return 0;\n    }\n    /**\r\n     * check AssignmentExpression add/sub the counter\r\n     * @param {ASTNode} update AssignmentExpression to check\r\n     * @param {string} counter variable name to check\r\n     * @returns {int} if add return 1, if sub return -1, if nochange, return 0\r\n     */\n\n\n    function getAssignmentDirection(update, counter) {\n      if (update.left.name === counter) {\n        if (update.operator === \"+=\") {\n          return getRightDirection(update, 1);\n        }\n\n        if (update.operator === \"-=\") {\n          return getRightDirection(update, -1);\n        }\n      }\n\n      return 0;\n    }\n\n    return {\n      ForStatement(node) {\n        if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\n          const counter = node.test.left.name;\n          const operator = node.test.operator;\n          const update = node.update;\n          let wrongDirection;\n\n          if (operator === \"<\" || operator === \"<=\") {\n            wrongDirection = -1;\n          } else if (operator === \">\" || operator === \">=\") {\n            wrongDirection = 1;\n          } else {\n            return;\n          }\n\n          if (update.type === \"UpdateExpression\") {\n            if (getUpdateDirection(update, counter) === wrongDirection) {\n              report(node);\n            }\n          } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\n            report(node);\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/for-direction.js"],"names":["module","exports","meta","type","docs","description","recommended","url","fixable","schema","messages","incorrectDirection","create","context","report","node","messageId","getRightDirection","update","dir","right","operator","getUpdateDirection","counter","argument","name","getAssignmentDirection","left","ForStatement","test","wrongDirection"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;;AACAA,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,SADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,+EADX;AAEFC,MAAAA,WAAW,EAAE,IAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,OAAO,EAAE,IATP;AAUFC,IAAAA,MAAM,EAAE,EAVN;AAYFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,kBAAkB,EAAE;AADd;AAZR,GADO;;AAkBbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ;AACR;AACA;AACA;AACA;AACQ,aAASC,MAAT,CAAgBC,IAAhB,EAAsB;AAClBF,MAAAA,OAAO,CAACC,MAAR,CAAe;AACXC,QAAAA,IADW;AAEXC,QAAAA,SAAS,EAAE;AAFA,OAAf;AAIH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,GAAnC,EAAwC;AACpC,UAAID,MAAM,CAACE,KAAP,CAAajB,IAAb,KAAsB,iBAA1B,EAA6C;AACzC,YAAIe,MAAM,CAACE,KAAP,CAAaC,QAAb,KAA0B,GAA9B,EAAmC;AAC/B,iBAAO,CAACF,GAAR;AACH;AACJ,OAJD,MAIO,IAAID,MAAM,CAACE,KAAP,CAAajB,IAAb,KAAsB,YAA1B,EAAwC;AAC3C,eAAO,CAAP;AACH;;AACD,aAAOgB,GAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASG,kBAAT,CAA4BJ,MAA5B,EAAoCK,OAApC,EAA6C;AACzC,UAAIL,MAAM,CAACM,QAAP,CAAgBrB,IAAhB,KAAyB,YAAzB,IAAyCe,MAAM,CAACM,QAAP,CAAgBC,IAAhB,KAAyBF,OAAtE,EAA+E;AAC3E,YAAIL,MAAM,CAACG,QAAP,KAAoB,IAAxB,EAA8B;AAC1B,iBAAO,CAAP;AACH;;AACD,YAAIH,MAAM,CAACG,QAAP,KAAoB,IAAxB,EAA8B;AAC1B,iBAAO,CAAC,CAAR;AACH;AACJ;;AACD,aAAO,CAAP;AACH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASK,sBAAT,CAAgCR,MAAhC,EAAwCK,OAAxC,EAAiD;AAC7C,UAAIL,MAAM,CAACS,IAAP,CAAYF,IAAZ,KAAqBF,OAAzB,EAAkC;AAC9B,YAAIL,MAAM,CAACG,QAAP,KAAoB,IAAxB,EAA8B;AAC1B,iBAAOJ,iBAAiB,CAACC,MAAD,EAAS,CAAT,CAAxB;AACH;;AACD,YAAIA,MAAM,CAACG,QAAP,KAAoB,IAAxB,EAA8B;AAC1B,iBAAOJ,iBAAiB,CAACC,MAAD,EAAS,CAAC,CAAV,CAAxB;AACH;AACJ;;AACD,aAAO,CAAP;AACH;;AACD,WAAO;AACHU,MAAAA,YAAY,CAACb,IAAD,EAAO;AAEf,YAAIA,IAAI,CAACc,IAAL,IAAad,IAAI,CAACc,IAAL,CAAU1B,IAAV,KAAmB,kBAAhC,IAAsDY,IAAI,CAACc,IAAL,CAAUF,IAAV,CAAexB,IAAf,KAAwB,YAA9E,IAA8FY,IAAI,CAACG,MAAvG,EAA+G;AAC3G,gBAAMK,OAAO,GAAGR,IAAI,CAACc,IAAL,CAAUF,IAAV,CAAeF,IAA/B;AACA,gBAAMJ,QAAQ,GAAGN,IAAI,CAACc,IAAL,CAAUR,QAA3B;AACA,gBAAMH,MAAM,GAAGH,IAAI,CAACG,MAApB;AAEA,cAAIY,cAAJ;;AAEA,cAAIT,QAAQ,KAAK,GAAb,IAAoBA,QAAQ,KAAK,IAArC,EAA2C;AACvCS,YAAAA,cAAc,GAAG,CAAC,CAAlB;AACH,WAFD,MAEO,IAAIT,QAAQ,KAAK,GAAb,IAAoBA,QAAQ,KAAK,IAArC,EAA2C;AAC9CS,YAAAA,cAAc,GAAG,CAAjB;AACH,WAFM,MAEA;AACH;AACH;;AAED,cAAIZ,MAAM,CAACf,IAAP,KAAgB,kBAApB,EAAwC;AACpC,gBAAImB,kBAAkB,CAACJ,MAAD,EAASK,OAAT,CAAlB,KAAwCO,cAA5C,EAA4D;AACxDhB,cAAAA,MAAM,CAACC,IAAD,CAAN;AACH;AACJ,WAJD,MAIO,IAAIG,MAAM,CAACf,IAAP,KAAgB,sBAAhB,IAA0CuB,sBAAsB,CAACR,MAAD,EAASK,OAAT,CAAtB,KAA4CO,cAA1F,EAA0G;AAC7GhB,YAAAA,MAAM,CAACC,IAAD,CAAN;AACH;AACJ;AACJ;;AA1BE,KAAP;AA4BH;;AAhHY,CAAjB","sourcesContent":["/**\r\n * @fileoverview enforce \"for\" loop update clause moving the counter in the right direction.(for-direction)\r\n * @author Aladdin-ADD<hh_2013@foxmail.com>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"enforce \\\"for\\\" loop update clause moving the counter in the right direction.\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/for-direction\"\r\n        },\r\n\r\n        fixable: null,\r\n        schema: [],\r\n\r\n        messages: {\r\n            incorrectDirection: \"The update clause in this loop moves the variable in the wrong direction.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * report an error.\r\n         * @param {ASTNode} node the node to report.\r\n         * @returns {void}\r\n         */\r\n        function report(node) {\r\n            context.report({\r\n                node,\r\n                messageId: \"incorrectDirection\"\r\n            });\r\n        }\r\n\r\n        /**\r\n         * check the right side of the assignment\r\n         * @param {ASTNode} update UpdateExpression to check\r\n         * @param {int} dir expected direction that could either be turned around or invalidated\r\n         * @returns {int} return dir, the negated dir or zero if it's not clear for identifiers\r\n         */\r\n        function getRightDirection(update, dir) {\r\n            if (update.right.type === \"UnaryExpression\") {\r\n                if (update.right.operator === \"-\") {\r\n                    return -dir;\r\n                }\r\n            } else if (update.right.type === \"Identifier\") {\r\n                return 0;\r\n            }\r\n            return dir;\r\n        }\r\n\r\n        /**\r\n         * check UpdateExpression add/sub the counter\r\n         * @param {ASTNode} update UpdateExpression to check\r\n         * @param {string} counter variable name to check\r\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\r\n         */\r\n        function getUpdateDirection(update, counter) {\r\n            if (update.argument.type === \"Identifier\" && update.argument.name === counter) {\r\n                if (update.operator === \"++\") {\r\n                    return 1;\r\n                }\r\n                if (update.operator === \"--\") {\r\n                    return -1;\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        /**\r\n         * check AssignmentExpression add/sub the counter\r\n         * @param {ASTNode} update AssignmentExpression to check\r\n         * @param {string} counter variable name to check\r\n         * @returns {int} if add return 1, if sub return -1, if nochange, return 0\r\n         */\r\n        function getAssignmentDirection(update, counter) {\r\n            if (update.left.name === counter) {\r\n                if (update.operator === \"+=\") {\r\n                    return getRightDirection(update, 1);\r\n                }\r\n                if (update.operator === \"-=\") {\r\n                    return getRightDirection(update, -1);\r\n                }\r\n            }\r\n            return 0;\r\n        }\r\n        return {\r\n            ForStatement(node) {\r\n\r\n                if (node.test && node.test.type === \"BinaryExpression\" && node.test.left.type === \"Identifier\" && node.update) {\r\n                    const counter = node.test.left.name;\r\n                    const operator = node.test.operator;\r\n                    const update = node.update;\r\n\r\n                    let wrongDirection;\r\n\r\n                    if (operator === \"<\" || operator === \"<=\") {\r\n                        wrongDirection = -1;\r\n                    } else if (operator === \">\" || operator === \">=\") {\r\n                        wrongDirection = 1;\r\n                    } else {\r\n                        return;\r\n                    }\r\n\r\n                    if (update.type === \"UpdateExpression\") {\r\n                        if (getUpdateDirection(update, counter) === wrongDirection) {\r\n                            report(node);\r\n                        }\r\n                    } else if (update.type === \"AssignmentExpression\" && getAssignmentDirection(update, counter) === wrongDirection) {\r\n                        report(node);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}