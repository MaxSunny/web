{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag declared but unused variables\r\n * @author Ilya Volodin\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\r\n * Bag of data used for formatting the `unusedVar` lint message.\r\n * @typedef {Object} UnusedVarMessageData\r\n * @property {string} varName The name of the unused var.\r\n * @property {'defined'|'assigned a value'} action Description of the vars state.\r\n * @property {string} additional Any additional info to be appended at the end.\r\n */\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused variables\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-unused-vars\"\n    },\n    schema: [{\n      oneOf: [{\n        enum: [\"all\", \"local\"]\n      }, {\n        type: \"object\",\n        properties: {\n          vars: {\n            enum: [\"all\", \"local\"]\n          },\n          varsIgnorePattern: {\n            type: \"string\"\n          },\n          args: {\n            enum: [\"all\", \"after-used\", \"none\"]\n          },\n          ignoreRestSiblings: {\n            type: \"boolean\"\n          },\n          argsIgnorePattern: {\n            type: \"string\"\n          },\n          caughtErrors: {\n            enum: [\"all\", \"none\"]\n          },\n          caughtErrorsIgnorePattern: {\n            type: \"string\"\n          },\n          destructuredArrayIgnorePattern: {\n            type: \"string\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\n    const config = {\n      vars: \"all\",\n      args: \"after-used\",\n      ignoreRestSiblings: false,\n      caughtErrors: \"none\"\n    };\n    const firstOption = context.options[0];\n\n    if (firstOption) {\n      if (typeof firstOption === \"string\") {\n        config.vars = firstOption;\n      } else {\n        config.vars = firstOption.vars || config.vars;\n        config.args = firstOption.args || config.args;\n        config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\n        config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\n\n        if (firstOption.varsIgnorePattern) {\n          config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.argsIgnorePattern) {\n          config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.caughtErrorsIgnorePattern) {\n          config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\n        }\n\n        if (firstOption.destructuredArrayIgnorePattern) {\n          config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\n        }\n      }\n    }\n    /**\r\n     * Generates the message data about the variable being defined and unused,\r\n     * including the ignore pattern if configured.\r\n     * @param {Variable} unusedVar eslint-scope variable object.\r\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\r\n     */\n\n\n    function getDefinedMessageData(unusedVar) {\n      const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\n      let type;\n      let pattern;\n\n      if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\n        type = \"args\";\n        pattern = config.caughtErrorsIgnorePattern.toString();\n      } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\n        type = \"args\";\n        pattern = config.argsIgnorePattern.toString();\n      } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\n        type = \"vars\";\n        pattern = config.varsIgnorePattern.toString();\n      }\n\n      const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\n      return {\n        varName: unusedVar.name,\n        action: \"defined\",\n        additional\n      };\n    }\n    /**\r\n     * Generate the warning message about the variable being\r\n     * assigned and unused, including the ignore pattern if configured.\r\n     * @param {Variable} unusedVar eslint-scope variable object.\r\n     * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\r\n     */\n\n\n    function getAssignedMessageData(unusedVar) {\n      const def = unusedVar.defs[0];\n      let additional = \"\";\n\n      if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\n        additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\n      } else if (config.varsIgnorePattern) {\n        additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\n      }\n\n      return {\n        varName: unusedVar.name,\n        action: \"assigned a value\",\n        additional\n      };\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n\n    const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\n    /**\r\n     * Determines if a given variable is being exported from a module.\r\n     * @param {Variable} variable eslint-scope variable object.\r\n     * @returns {boolean} True if the variable is exported, false if not.\r\n     * @private\r\n     */\n\n    function isExported(variable) {\n      const definition = variable.defs[0];\n\n      if (definition) {\n        let node = definition.node;\n\n        if (node.type === \"VariableDeclarator\") {\n          node = node.parent;\n        } else if (definition.type === \"Parameter\") {\n          return false;\n        }\n\n        return node.parent.type.indexOf(\"Export\") === 0;\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether a node is a sibling of the rest property or not.\r\n     * @param {ASTNode} node a node to check\r\n     * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\r\n     */\n\n\n    function hasRestSibling(node) {\n      return node.type === \"Property\" && node.parent.type === \"ObjectPattern\" && REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\n    }\n    /**\r\n     * Determines if a variable has a sibling rest property\r\n     * @param {Variable} variable eslint-scope variable object.\r\n     * @returns {boolean} True if the variable is exported, false if not.\r\n     * @private\r\n     */\n\n\n    function hasRestSpreadSibling(variable) {\n      if (config.ignoreRestSiblings) {\n        const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\n        const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\n        return hasRestSiblingDefinition || hasRestSiblingReference;\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines if a reference is a read operation.\r\n     * @param {Reference} ref An eslint-scope Reference\r\n     * @returns {boolean} whether the given reference represents a read operation\r\n     * @private\r\n     */\n\n\n    function isReadRef(ref) {\n      return ref.isRead();\n    }\n    /**\r\n     * Determine if an identifier is referencing an enclosing function name.\r\n     * @param {Reference} ref The reference to check.\r\n     * @param {ASTNode[]} nodes The candidate function nodes.\r\n     * @returns {boolean} True if it's a self-reference, false if not.\r\n     * @private\r\n     */\n\n\n    function isSelfReference(ref, nodes) {\n      let scope = ref.from;\n\n      while (scope) {\n        if (nodes.indexOf(scope.block) >= 0) {\n          return true;\n        }\n\n        scope = scope.upper;\n      }\n\n      return false;\n    }\n    /**\r\n     * Gets a list of function definitions for a specified variable.\r\n     * @param {Variable} variable eslint-scope variable object.\r\n     * @returns {ASTNode[]} Function nodes.\r\n     * @private\r\n     */\n\n\n    function getFunctionDefinitions(variable) {\n      const functionDefinitions = [];\n      variable.defs.forEach(def => {\n        const {\n          type,\n          node\n        } = def; // FunctionDeclarations\n\n        if (type === \"FunctionName\") {\n          functionDefinitions.push(node);\n        } // FunctionExpressions\n\n\n        if (type === \"Variable\" && node.init && (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\n          functionDefinitions.push(node.init);\n        }\n      });\n      return functionDefinitions;\n    }\n    /**\r\n     * Checks the position of given nodes.\r\n     * @param {ASTNode} inner A node which is expected as inside.\r\n     * @param {ASTNode} outer A node which is expected as outside.\r\n     * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\r\n     * @private\r\n     */\n\n\n    function isInside(inner, outer) {\n      return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];\n    }\n    /**\r\n     * Checks whether a given node is unused expression or not.\r\n     * @param {ASTNode} node The node itself\r\n     * @returns {boolean} The node is an unused expression.\r\n     * @private\r\n     */\n\n\n    function isUnusedExpression(node) {\n      const parent = node.parent;\n\n      if (parent.type === \"ExpressionStatement\") {\n        return true;\n      }\n\n      if (parent.type === \"SequenceExpression\") {\n        const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\n\n        if (!isLastExpression) {\n          return true;\n        }\n\n        return isUnusedExpression(parent);\n      }\n\n      return false;\n    }\n    /**\r\n     * If a given reference is left-hand side of an assignment, this gets\r\n     * the right-hand side node of the assignment.\r\n     *\r\n     * In the following cases, this returns null.\r\n     *\r\n     * - The reference is not the LHS of an assignment expression.\r\n     * - The reference is inside of a loop.\r\n     * - The reference is inside of a function scope which is different from\r\n     *   the declaration.\r\n     * @param {eslint-scope.Reference} ref A reference to check.\r\n     * @param {ASTNode} prevRhsNode The previous RHS node.\r\n     * @returns {ASTNode|null} The RHS node or null.\r\n     * @private\r\n     */\n\n\n    function getRhsNode(ref, prevRhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      const refScope = ref.from.variableScope;\n      const varScope = ref.resolved.scope.variableScope;\n      const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\n      /*\r\n       * Inherits the previous node if this reference is in the node.\r\n       * This is for `a = a + a`-like code.\r\n       */\n\n      if (prevRhsNode && isInside(id, prevRhsNode)) {\n        return prevRhsNode;\n      }\n\n      if (parent.type === \"AssignmentExpression\" && isUnusedExpression(parent) && id === parent.left && !canBeUsedLater) {\n        return parent.right;\n      }\n\n      return null;\n    }\n    /**\r\n     * Checks whether a given function node is stored to somewhere or not.\r\n     * If the function node is stored, the function can be used later.\r\n     * @param {ASTNode} funcNode A function node to check.\r\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n     * @returns {boolean} `true` if under the following conditions:\r\n     *      - the funcNode is assigned to a variable.\r\n     *      - the funcNode is bound as an argument of a function call.\r\n     *      - the function is bound to a property and the object satisfies above conditions.\r\n     * @private\r\n     */\n\n\n    function isStorableFunction(funcNode, rhsNode) {\n      let node = funcNode;\n      let parent = funcNode.parent;\n\n      while (parent && isInside(parent, rhsNode)) {\n        switch (parent.type) {\n          case \"SequenceExpression\":\n            if (parent.expressions[parent.expressions.length - 1] !== node) {\n              return false;\n            }\n\n            break;\n\n          case \"CallExpression\":\n          case \"NewExpression\":\n            return parent.callee !== node;\n\n          case \"AssignmentExpression\":\n          case \"TaggedTemplateExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            if (STATEMENT_TYPE.test(parent.type)) {\n              /*\r\n               * If it encountered statements, this is a complex pattern.\r\n               * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\r\n               */\n              return true;\n            }\n\n        }\n\n        node = parent;\n        parent = parent.parent;\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether a given Identifier node exists inside of a function node which can be used later.\r\n     *\r\n     * \"can be used later\" means:\r\n     * - the function is assigned to a variable.\r\n     * - the function is bound to a property and the object can be used later.\r\n     * - the function is bound as an argument of a function call.\r\n     *\r\n     * If a reference exists in a function which can be used later, the reference is read when the function is called.\r\n     * @param {ASTNode} id An Identifier node to check.\r\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n     * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\r\n     * @private\r\n     */\n\n\n    function isInsideOfStorableFunction(id, rhsNode) {\n      const funcNode = astUtils.getUpperFunction(id);\n      return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);\n    }\n    /**\r\n     * Checks whether a given reference is a read to update itself or not.\r\n     * @param {eslint-scope.Reference} ref A reference to check.\r\n     * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n     * @returns {boolean} The reference is a read to update itself.\r\n     * @private\r\n     */\n\n\n    function isReadForItself(ref, rhsNode) {\n      const id = ref.identifier;\n      const parent = id.parent;\n      return ref.isRead() && ( // self update. e.g. `a += 1`, `a++`\n      parent.type === \"AssignmentExpression\" && parent.left === id && isUnusedExpression(parent) || parent.type === \"UpdateExpression\" && isUnusedExpression(parent) || // in RHS of an assignment for itself. e.g. `a = a + 1`\n      rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));\n    }\n    /**\r\n     * Determine if an identifier is used either in for-in loops.\r\n     * @param {Reference} ref The reference to check.\r\n     * @returns {boolean} whether reference is used in the for-in loops\r\n     * @private\r\n     */\n\n\n    function isForInRef(ref) {\n      let target = ref.identifier.parent; // \"for (var ...) { return; }\"\n\n      if (target.type === \"VariableDeclarator\") {\n        target = target.parent.parent;\n      }\n\n      if (target.type !== \"ForInStatement\") {\n        return false;\n      } // \"for (...) { return; }\"\n\n\n      if (target.body.type === \"BlockStatement\") {\n        target = target.body.body[0]; // \"for (...) return;\"\n      } else {\n        target = target.body;\n      } // For empty loop body\n\n\n      if (!target) {\n        return false;\n      }\n\n      return target.type === \"ReturnStatement\";\n    }\n    /**\r\n     * Determines if the variable is used.\r\n     * @param {Variable} variable The variable to check.\r\n     * @returns {boolean} True if the variable is used\r\n     * @private\r\n     */\n\n\n    function isUsedVariable(variable) {\n      const functionNodes = getFunctionDefinitions(variable),\n            isFunctionDefinition = functionNodes.length > 0;\n      let rhsNode = null;\n      return variable.references.some(ref => {\n        if (isForInRef(ref)) {\n          return true;\n        }\n\n        const forItself = isReadForItself(ref, rhsNode);\n        rhsNode = getRhsNode(ref, rhsNode);\n        return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));\n      });\n    }\n    /**\r\n     * Checks whether the given variable is after the last used parameter.\r\n     * @param {eslint-scope.Variable} variable The variable to check.\r\n     * @returns {boolean} `true` if the variable is defined after the last\r\n     * used parameter.\r\n     */\n\n\n    function isAfterLastUsedArg(variable) {\n      const def = variable.defs[0];\n      const params = context.getDeclaredVariables(def.node);\n      const posteriorParams = params.slice(params.indexOf(variable) + 1); // If any used parameters occur after this parameter, do not report.\n\n      return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\n    }\n    /**\r\n     * Gets an array of variables without read references.\r\n     * @param {Scope} scope an eslint-scope Scope object.\r\n     * @param {Variable[]} unusedVars an array that saving result.\r\n     * @returns {Variable[]} unused variables of the scope and descendant scopes.\r\n     * @private\r\n     */\n\n\n    function collectUnusedVariables(scope, unusedVars) {\n      const variables = scope.variables;\n      const childScopes = scope.childScopes;\n      let i, l;\n\n      if (scope.type !== \"global\" || config.vars === \"all\") {\n        for (i = 0, l = variables.length; i < l; ++i) {\n          const variable = variables[i]; // skip a variable of class itself name in the class scope\n\n          if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\n            continue;\n          } // skip function expression names and variables marked with markVariableAsUsed()\n\n\n          if (scope.functionExpressionScope || variable.eslintUsed) {\n            continue;\n          } // skip implicit \"arguments\" variable\n\n\n          if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\n            continue;\n          } // explicit global variables don't have definitions.\n\n\n          const def = variable.defs[0];\n\n          if (def) {\n            const type = def.type;\n            const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\"); // skip elements of array destructuring patterns\n\n            if ((def.name.parent.type === \"ArrayPattern\" || refUsedInArrayPatterns) && config.destructuredArrayIgnorePattern && config.destructuredArrayIgnorePattern.test(def.name.name)) {\n              continue;\n            } // skip catch variables\n\n\n            if (type === \"CatchClause\") {\n              if (config.caughtErrors === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n\n            if (type === \"Parameter\") {\n              // skip any setter argument\n              if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\n                continue;\n              } // if \"args\" option is \"none\", skip any parameter\n\n\n              if (config.args === \"none\") {\n                continue;\n              } // skip ignored parameters\n\n\n              if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\n                continue;\n              } // if \"args\" option is \"after-used\", skip used variables\n\n\n              if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\n                continue;\n              }\n            } else {\n              // skip ignored variables\n              if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\n                continue;\n              }\n            }\n          }\n\n          if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\n            unusedVars.push(variable);\n          }\n        }\n      }\n\n      for (i = 0, l = childScopes.length; i < l; ++i) {\n        collectUnusedVariables(childScopes[i], unusedVars);\n      }\n\n      return unusedVars;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      \"Program:exit\"(programNode) {\n        const unusedVars = collectUnusedVariables(context.getScope(), []);\n\n        for (let i = 0, l = unusedVars.length; i < l; ++i) {\n          const unusedVar = unusedVars[i]; // Report the first declaration.\n\n          if (unusedVar.defs.length > 0) {\n            // report last write reference, https://github.com/eslint/eslint/issues/14324\n            const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\n            let referenceToReport;\n\n            if (writeReferences.length > 0) {\n              referenceToReport = writeReferences[writeReferences.length - 1];\n            }\n\n            context.report({\n              node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\n              messageId: \"unusedVar\",\n              data: unusedVar.references.some(ref => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)\n            }); // If there are no regular declaration, report the first `/*globals*/` comment directive.\n          } else if (unusedVar.eslintExplicitGlobalComments) {\n            const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\n            context.report({\n              node: programNode,\n              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\n              messageId: \"unusedVar\",\n              data: getDefinedMessageData(unusedVar)\n            });\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unused-vars.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","enum","properties","vars","varsIgnorePattern","args","ignoreRestSiblings","argsIgnorePattern","caughtErrors","caughtErrorsIgnorePattern","destructuredArrayIgnorePattern","additionalProperties","messages","unusedVar","create","context","sourceCode","getSourceCode","REST_PROPERTY_TYPE","config","firstOption","options","RegExp","getDefinedMessageData","defType","defs","pattern","toString","additional","varName","name","action","getAssignedMessageData","def","parent","STATEMENT_TYPE","isExported","variable","definition","node","indexOf","hasRestSibling","test","length","hasRestSpreadSibling","hasRestSiblingDefinition","some","hasRestSiblingReference","references","ref","identifier","isReadRef","isRead","isSelfReference","nodes","scope","from","block","upper","getFunctionDefinitions","functionDefinitions","forEach","push","init","isInside","inner","outer","range","isUnusedExpression","isLastExpression","expressions","getRhsNode","prevRhsNode","id","refScope","variableScope","varScope","resolved","canBeUsedLater","isInLoop","left","right","isStorableFunction","funcNode","rhsNode","callee","isInsideOfStorableFunction","getUpperFunction","isReadForItself","isForInRef","target","body","isUsedVariable","functionNodes","isFunctionDefinition","forItself","isAfterLastUsedArg","params","getDeclaredVariables","posteriorParams","slice","v","eslintUsed","collectUnusedVariables","unusedVars","variables","childScopes","i","l","identifiers","functionExpressionScope","refUsedInArrayPatterns","kind","isFunction","programNode","getScope","writeReferences","filter","isWrite","referenceToReport","report","messageId","data","eslintExplicitGlobalComments","directiveComment","loc","getNameLocationInGlobalDirectiveComment"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag declared but unused variables\r\n * @author Ilya Volodin\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Typedefs\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Bag of data used for formatting the `unusedVar` lint message.\r\n * @typedef {Object} UnusedVarMessageData\r\n * @property {string} varName The name of the unused var.\r\n * @property {'defined'|'assigned a value'} action Description of the vars state.\r\n * @property {string} additional Any additional info to be appended at the end.\r\n */\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow unused variables\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-unused-vars\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"all\", \"local\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            vars: {\r\n                                enum: [\"all\", \"local\"]\r\n                            },\r\n                            varsIgnorePattern: {\r\n                                type: \"string\"\r\n                            },\r\n                            args: {\r\n                                enum: [\"all\", \"after-used\", \"none\"]\r\n                            },\r\n                            ignoreRestSiblings: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            argsIgnorePattern: {\r\n                                type: \"string\"\r\n                            },\r\n                            caughtErrors: {\r\n                                enum: [\"all\", \"none\"]\r\n                            },\r\n                            caughtErrorsIgnorePattern: {\r\n                                type: \"string\"\r\n                            },\r\n                            destructuredArrayIgnorePattern: {\r\n                                type: \"string\"\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unusedVar: \"'{{varName}}' is {{action}} but never used{{additional}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;\r\n\r\n        const config = {\r\n            vars: \"all\",\r\n            args: \"after-used\",\r\n            ignoreRestSiblings: false,\r\n            caughtErrors: \"none\"\r\n        };\r\n\r\n        const firstOption = context.options[0];\r\n\r\n        if (firstOption) {\r\n            if (typeof firstOption === \"string\") {\r\n                config.vars = firstOption;\r\n            } else {\r\n                config.vars = firstOption.vars || config.vars;\r\n                config.args = firstOption.args || config.args;\r\n                config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;\r\n                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;\r\n\r\n                if (firstOption.varsIgnorePattern) {\r\n                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, \"u\");\r\n                }\r\n\r\n                if (firstOption.argsIgnorePattern) {\r\n                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, \"u\");\r\n                }\r\n\r\n                if (firstOption.caughtErrorsIgnorePattern) {\r\n                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, \"u\");\r\n                }\r\n\r\n                if (firstOption.destructuredArrayIgnorePattern) {\r\n                    config.destructuredArrayIgnorePattern = new RegExp(firstOption.destructuredArrayIgnorePattern, \"u\");\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Generates the message data about the variable being defined and unused,\r\n         * including the ignore pattern if configured.\r\n         * @param {Variable} unusedVar eslint-scope variable object.\r\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\r\n         */\r\n        function getDefinedMessageData(unusedVar) {\r\n            const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;\r\n            let type;\r\n            let pattern;\r\n\r\n            if (defType === \"CatchClause\" && config.caughtErrorsIgnorePattern) {\r\n                type = \"args\";\r\n                pattern = config.caughtErrorsIgnorePattern.toString();\r\n            } else if (defType === \"Parameter\" && config.argsIgnorePattern) {\r\n                type = \"args\";\r\n                pattern = config.argsIgnorePattern.toString();\r\n            } else if (defType !== \"Parameter\" && config.varsIgnorePattern) {\r\n                type = \"vars\";\r\n                pattern = config.varsIgnorePattern.toString();\r\n            }\r\n\r\n            const additional = type ? `. Allowed unused ${type} must match ${pattern}` : \"\";\r\n\r\n            return {\r\n                varName: unusedVar.name,\r\n                action: \"defined\",\r\n                additional\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Generate the warning message about the variable being\r\n         * assigned and unused, including the ignore pattern if configured.\r\n         * @param {Variable} unusedVar eslint-scope variable object.\r\n         * @returns {UnusedVarMessageData} The message data to be used with this unused variable.\r\n         */\r\n        function getAssignedMessageData(unusedVar) {\r\n            const def = unusedVar.defs[0];\r\n            let additional = \"\";\r\n\r\n            if (config.destructuredArrayIgnorePattern && def && def.name.parent.type === \"ArrayPattern\") {\r\n                additional = `. Allowed unused elements of array destructuring patterns must match ${config.destructuredArrayIgnorePattern.toString()}`;\r\n            } else if (config.varsIgnorePattern) {\r\n                additional = `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}`;\r\n            }\r\n\r\n            return {\r\n                varName: unusedVar.name,\r\n                action: \"assigned a value\",\r\n                additional\r\n            };\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;\r\n\r\n        /**\r\n         * Determines if a given variable is being exported from a module.\r\n         * @param {Variable} variable eslint-scope variable object.\r\n         * @returns {boolean} True if the variable is exported, false if not.\r\n         * @private\r\n         */\r\n        function isExported(variable) {\r\n\r\n            const definition = variable.defs[0];\r\n\r\n            if (definition) {\r\n\r\n                let node = definition.node;\r\n\r\n                if (node.type === \"VariableDeclarator\") {\r\n                    node = node.parent;\r\n                } else if (definition.type === \"Parameter\") {\r\n                    return false;\r\n                }\r\n\r\n                return node.parent.type.indexOf(\"Export\") === 0;\r\n            }\r\n            return false;\r\n\r\n        }\r\n\r\n        /**\r\n         * Checks whether a node is a sibling of the rest property or not.\r\n         * @param {ASTNode} node a node to check\r\n         * @returns {boolean} True if the node is a sibling of the rest property, otherwise false.\r\n         */\r\n        function hasRestSibling(node) {\r\n            return node.type === \"Property\" &&\r\n                node.parent.type === \"ObjectPattern\" &&\r\n                REST_PROPERTY_TYPE.test(node.parent.properties[node.parent.properties.length - 1].type);\r\n        }\r\n\r\n        /**\r\n         * Determines if a variable has a sibling rest property\r\n         * @param {Variable} variable eslint-scope variable object.\r\n         * @returns {boolean} True if the variable is exported, false if not.\r\n         * @private\r\n         */\r\n        function hasRestSpreadSibling(variable) {\r\n            if (config.ignoreRestSiblings) {\r\n                const hasRestSiblingDefinition = variable.defs.some(def => hasRestSibling(def.name.parent));\r\n                const hasRestSiblingReference = variable.references.some(ref => hasRestSibling(ref.identifier.parent));\r\n\r\n                return hasRestSiblingDefinition || hasRestSiblingReference;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if a reference is a read operation.\r\n         * @param {Reference} ref An eslint-scope Reference\r\n         * @returns {boolean} whether the given reference represents a read operation\r\n         * @private\r\n         */\r\n        function isReadRef(ref) {\r\n            return ref.isRead();\r\n        }\r\n\r\n        /**\r\n         * Determine if an identifier is referencing an enclosing function name.\r\n         * @param {Reference} ref The reference to check.\r\n         * @param {ASTNode[]} nodes The candidate function nodes.\r\n         * @returns {boolean} True if it's a self-reference, false if not.\r\n         * @private\r\n         */\r\n        function isSelfReference(ref, nodes) {\r\n            let scope = ref.from;\r\n\r\n            while (scope) {\r\n                if (nodes.indexOf(scope.block) >= 0) {\r\n                    return true;\r\n                }\r\n\r\n                scope = scope.upper;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Gets a list of function definitions for a specified variable.\r\n         * @param {Variable} variable eslint-scope variable object.\r\n         * @returns {ASTNode[]} Function nodes.\r\n         * @private\r\n         */\r\n        function getFunctionDefinitions(variable) {\r\n            const functionDefinitions = [];\r\n\r\n            variable.defs.forEach(def => {\r\n                const { type, node } = def;\r\n\r\n                // FunctionDeclarations\r\n                if (type === \"FunctionName\") {\r\n                    functionDefinitions.push(node);\r\n                }\r\n\r\n                // FunctionExpressions\r\n                if (type === \"Variable\" && node.init &&\r\n                    (node.init.type === \"FunctionExpression\" || node.init.type === \"ArrowFunctionExpression\")) {\r\n                    functionDefinitions.push(node.init);\r\n                }\r\n            });\r\n            return functionDefinitions;\r\n        }\r\n\r\n        /**\r\n         * Checks the position of given nodes.\r\n         * @param {ASTNode} inner A node which is expected as inside.\r\n         * @param {ASTNode} outer A node which is expected as outside.\r\n         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.\r\n         * @private\r\n         */\r\n        function isInside(inner, outer) {\r\n            return (\r\n                inner.range[0] >= outer.range[0] &&\r\n                inner.range[1] <= outer.range[1]\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks whether a given node is unused expression or not.\r\n         * @param {ASTNode} node The node itself\r\n         * @returns {boolean} The node is an unused expression.\r\n         * @private\r\n         */\r\n        function isUnusedExpression(node) {\r\n            const parent = node.parent;\r\n\r\n            if (parent.type === \"ExpressionStatement\") {\r\n                return true;\r\n            }\r\n\r\n            if (parent.type === \"SequenceExpression\") {\r\n                const isLastExpression = parent.expressions[parent.expressions.length - 1] === node;\r\n\r\n                if (!isLastExpression) {\r\n                    return true;\r\n                }\r\n                return isUnusedExpression(parent);\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * If a given reference is left-hand side of an assignment, this gets\r\n         * the right-hand side node of the assignment.\r\n         *\r\n         * In the following cases, this returns null.\r\n         *\r\n         * - The reference is not the LHS of an assignment expression.\r\n         * - The reference is inside of a loop.\r\n         * - The reference is inside of a function scope which is different from\r\n         *   the declaration.\r\n         * @param {eslint-scope.Reference} ref A reference to check.\r\n         * @param {ASTNode} prevRhsNode The previous RHS node.\r\n         * @returns {ASTNode|null} The RHS node or null.\r\n         * @private\r\n         */\r\n        function getRhsNode(ref, prevRhsNode) {\r\n            const id = ref.identifier;\r\n            const parent = id.parent;\r\n            const refScope = ref.from.variableScope;\r\n            const varScope = ref.resolved.scope.variableScope;\r\n            const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);\r\n\r\n            /*\r\n             * Inherits the previous node if this reference is in the node.\r\n             * This is for `a = a + a`-like code.\r\n             */\r\n            if (prevRhsNode && isInside(id, prevRhsNode)) {\r\n                return prevRhsNode;\r\n            }\r\n\r\n            if (parent.type === \"AssignmentExpression\" &&\r\n                isUnusedExpression(parent) &&\r\n                id === parent.left &&\r\n                !canBeUsedLater\r\n            ) {\r\n                return parent.right;\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Checks whether a given function node is stored to somewhere or not.\r\n         * If the function node is stored, the function can be used later.\r\n         * @param {ASTNode} funcNode A function node to check.\r\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n         * @returns {boolean} `true` if under the following conditions:\r\n         *      - the funcNode is assigned to a variable.\r\n         *      - the funcNode is bound as an argument of a function call.\r\n         *      - the function is bound to a property and the object satisfies above conditions.\r\n         * @private\r\n         */\r\n        function isStorableFunction(funcNode, rhsNode) {\r\n            let node = funcNode;\r\n            let parent = funcNode.parent;\r\n\r\n            while (parent && isInside(parent, rhsNode)) {\r\n                switch (parent.type) {\r\n                    case \"SequenceExpression\":\r\n                        if (parent.expressions[parent.expressions.length - 1] !== node) {\r\n                            return false;\r\n                        }\r\n                        break;\r\n\r\n                    case \"CallExpression\":\r\n                    case \"NewExpression\":\r\n                        return parent.callee !== node;\r\n\r\n                    case \"AssignmentExpression\":\r\n                    case \"TaggedTemplateExpression\":\r\n                    case \"YieldExpression\":\r\n                        return true;\r\n\r\n                    default:\r\n                        if (STATEMENT_TYPE.test(parent.type)) {\r\n\r\n                            /*\r\n                             * If it encountered statements, this is a complex pattern.\r\n                             * Since analyzing complex patterns is hard, this returns `true` to avoid false positive.\r\n                             */\r\n                            return true;\r\n                        }\r\n                }\r\n\r\n                node = parent;\r\n                parent = parent.parent;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Checks whether a given Identifier node exists inside of a function node which can be used later.\r\n         *\r\n         * \"can be used later\" means:\r\n         * - the function is assigned to a variable.\r\n         * - the function is bound to a property and the object can be used later.\r\n         * - the function is bound as an argument of a function call.\r\n         *\r\n         * If a reference exists in a function which can be used later, the reference is read when the function is called.\r\n         * @param {ASTNode} id An Identifier node to check.\r\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.\r\n         * @private\r\n         */\r\n        function isInsideOfStorableFunction(id, rhsNode) {\r\n            const funcNode = astUtils.getUpperFunction(id);\r\n\r\n            return (\r\n                funcNode &&\r\n                isInside(funcNode, rhsNode) &&\r\n                isStorableFunction(funcNode, rhsNode)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks whether a given reference is a read to update itself or not.\r\n         * @param {eslint-scope.Reference} ref A reference to check.\r\n         * @param {ASTNode} rhsNode The RHS node of the previous assignment.\r\n         * @returns {boolean} The reference is a read to update itself.\r\n         * @private\r\n         */\r\n        function isReadForItself(ref, rhsNode) {\r\n            const id = ref.identifier;\r\n            const parent = id.parent;\r\n\r\n            return ref.isRead() && (\r\n\r\n                // self update. e.g. `a += 1`, `a++`\r\n                (\r\n                    (\r\n                        parent.type === \"AssignmentExpression\" &&\r\n                        parent.left === id &&\r\n                        isUnusedExpression(parent)\r\n                    ) ||\r\n                    (\r\n                        parent.type === \"UpdateExpression\" &&\r\n                        isUnusedExpression(parent)\r\n                    )\r\n                ) ||\r\n\r\n                // in RHS of an assignment for itself. e.g. `a = a + 1`\r\n                (\r\n                    rhsNode &&\r\n                    isInside(id, rhsNode) &&\r\n                    !isInsideOfStorableFunction(id, rhsNode)\r\n                )\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Determine if an identifier is used either in for-in loops.\r\n         * @param {Reference} ref The reference to check.\r\n         * @returns {boolean} whether reference is used in the for-in loops\r\n         * @private\r\n         */\r\n        function isForInRef(ref) {\r\n            let target = ref.identifier.parent;\r\n\r\n\r\n            // \"for (var ...) { return; }\"\r\n            if (target.type === \"VariableDeclarator\") {\r\n                target = target.parent.parent;\r\n            }\r\n\r\n            if (target.type !== \"ForInStatement\") {\r\n                return false;\r\n            }\r\n\r\n            // \"for (...) { return; }\"\r\n            if (target.body.type === \"BlockStatement\") {\r\n                target = target.body.body[0];\r\n\r\n            // \"for (...) return;\"\r\n            } else {\r\n                target = target.body;\r\n            }\r\n\r\n            // For empty loop body\r\n            if (!target) {\r\n                return false;\r\n            }\r\n\r\n            return target.type === \"ReturnStatement\";\r\n        }\r\n\r\n        /**\r\n         * Determines if the variable is used.\r\n         * @param {Variable} variable The variable to check.\r\n         * @returns {boolean} True if the variable is used\r\n         * @private\r\n         */\r\n        function isUsedVariable(variable) {\r\n            const functionNodes = getFunctionDefinitions(variable),\r\n                isFunctionDefinition = functionNodes.length > 0;\r\n            let rhsNode = null;\r\n\r\n            return variable.references.some(ref => {\r\n                if (isForInRef(ref)) {\r\n                    return true;\r\n                }\r\n\r\n                const forItself = isReadForItself(ref, rhsNode);\r\n\r\n                rhsNode = getRhsNode(ref, rhsNode);\r\n\r\n                return (\r\n                    isReadRef(ref) &&\r\n                    !forItself &&\r\n                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))\r\n                );\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks whether the given variable is after the last used parameter.\r\n         * @param {eslint-scope.Variable} variable The variable to check.\r\n         * @returns {boolean} `true` if the variable is defined after the last\r\n         * used parameter.\r\n         */\r\n        function isAfterLastUsedArg(variable) {\r\n            const def = variable.defs[0];\r\n            const params = context.getDeclaredVariables(def.node);\r\n            const posteriorParams = params.slice(params.indexOf(variable) + 1);\r\n\r\n            // If any used parameters occur after this parameter, do not report.\r\n            return !posteriorParams.some(v => v.references.length > 0 || v.eslintUsed);\r\n        }\r\n\r\n        /**\r\n         * Gets an array of variables without read references.\r\n         * @param {Scope} scope an eslint-scope Scope object.\r\n         * @param {Variable[]} unusedVars an array that saving result.\r\n         * @returns {Variable[]} unused variables of the scope and descendant scopes.\r\n         * @private\r\n         */\r\n        function collectUnusedVariables(scope, unusedVars) {\r\n            const variables = scope.variables;\r\n            const childScopes = scope.childScopes;\r\n            let i, l;\r\n\r\n            if (scope.type !== \"global\" || config.vars === \"all\") {\r\n                for (i = 0, l = variables.length; i < l; ++i) {\r\n                    const variable = variables[i];\r\n\r\n                    // skip a variable of class itself name in the class scope\r\n                    if (scope.type === \"class\" && scope.block.id === variable.identifiers[0]) {\r\n                        continue;\r\n                    }\r\n\r\n                    // skip function expression names and variables marked with markVariableAsUsed()\r\n                    if (scope.functionExpressionScope || variable.eslintUsed) {\r\n                        continue;\r\n                    }\r\n\r\n                    // skip implicit \"arguments\" variable\r\n                    if (scope.type === \"function\" && variable.name === \"arguments\" && variable.identifiers.length === 0) {\r\n                        continue;\r\n                    }\r\n\r\n                    // explicit global variables don't have definitions.\r\n                    const def = variable.defs[0];\r\n\r\n                    if (def) {\r\n                        const type = def.type;\r\n                        const refUsedInArrayPatterns = variable.references.some(ref => ref.identifier.parent.type === \"ArrayPattern\");\r\n\r\n                        // skip elements of array destructuring patterns\r\n                        if (\r\n                            (\r\n                                def.name.parent.type === \"ArrayPattern\" ||\r\n                                refUsedInArrayPatterns\r\n                            ) &&\r\n                            config.destructuredArrayIgnorePattern &&\r\n                            config.destructuredArrayIgnorePattern.test(def.name.name)\r\n                        ) {\r\n                            continue;\r\n                        }\r\n\r\n                        // skip catch variables\r\n                        if (type === \"CatchClause\") {\r\n                            if (config.caughtErrors === \"none\") {\r\n                                continue;\r\n                            }\r\n\r\n                            // skip ignored parameters\r\n                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n\r\n                        if (type === \"Parameter\") {\r\n\r\n                            // skip any setter argument\r\n                            if ((def.node.parent.type === \"Property\" || def.node.parent.type === \"MethodDefinition\") && def.node.parent.kind === \"set\") {\r\n                                continue;\r\n                            }\r\n\r\n                            // if \"args\" option is \"none\", skip any parameter\r\n                            if (config.args === \"none\") {\r\n                                continue;\r\n                            }\r\n\r\n                            // skip ignored parameters\r\n                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {\r\n                                continue;\r\n                            }\r\n\r\n                            // if \"args\" option is \"after-used\", skip used variables\r\n                            if (config.args === \"after-used\" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {\r\n                                continue;\r\n                            }\r\n                        } else {\r\n\r\n                            // skip ignored variables\r\n                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {\r\n                        unusedVars.push(variable);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (i = 0, l = childScopes.length; i < l; ++i) {\r\n                collectUnusedVariables(childScopes[i], unusedVars);\r\n            }\r\n\r\n            return unusedVars;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            \"Program:exit\"(programNode) {\r\n                const unusedVars = collectUnusedVariables(context.getScope(), []);\r\n\r\n                for (let i = 0, l = unusedVars.length; i < l; ++i) {\r\n                    const unusedVar = unusedVars[i];\r\n\r\n                    // Report the first declaration.\r\n                    if (unusedVar.defs.length > 0) {\r\n\r\n                        // report last write reference, https://github.com/eslint/eslint/issues/14324\r\n                        const writeReferences = unusedVar.references.filter(ref => ref.isWrite() && ref.from.variableScope === unusedVar.scope.variableScope);\r\n\r\n                        let referenceToReport;\r\n\r\n                        if (writeReferences.length > 0) {\r\n                            referenceToReport = writeReferences[writeReferences.length - 1];\r\n                        }\r\n\r\n                        context.report({\r\n                            node: referenceToReport ? referenceToReport.identifier : unusedVar.identifiers[0],\r\n                            messageId: \"unusedVar\",\r\n                            data: unusedVar.references.some(ref => ref.isWrite())\r\n                                ? getAssignedMessageData(unusedVar)\r\n                                : getDefinedMessageData(unusedVar)\r\n                        });\r\n\r\n                    // If there are no regular declaration, report the first `/*globals*/` comment directive.\r\n                    } else if (unusedVar.eslintExplicitGlobalComments) {\r\n                        const directiveComment = unusedVar.eslintExplicitGlobalComments[0];\r\n\r\n                        context.report({\r\n                            node: programNode,\r\n                            loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),\r\n                            messageId: \"unusedVar\",\r\n                            data: getDefinedMessageData(unusedVar)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}