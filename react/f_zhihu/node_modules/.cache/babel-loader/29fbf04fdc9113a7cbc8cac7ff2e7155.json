{"ast":null,"code":"/**\r\n * @fileoverview Prefer destructuring from arrays and objects\r\n * @author Alex LaFroscia\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({\n  type: \"AssignmentExpression\"\n}); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require destructuring from arrays and/or objects\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-destructuring\"\n    },\n    fixable: \"code\",\n    schema: [{\n      /*\r\n       * old support {array: Boolean, object: Boolean}\r\n       * new support {VariableDeclarator: {}, AssignmentExpression: {}}\r\n       */\n      oneOf: [{\n        type: \"object\",\n        properties: {\n          VariableDeclarator: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          AssignmentExpression: {\n            type: \"object\",\n            properties: {\n              array: {\n                type: \"boolean\"\n              },\n              object: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          array: {\n            type: \"boolean\"\n          },\n          object: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        enforceForRenamedProperties: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      preferDestructuring: \"Use {{type}} destructuring.\"\n    }\n  },\n\n  create(context) {\n    const enabledTypes = context.options[0];\n    const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\n    let normalizedOptions = {\n      VariableDeclarator: {\n        array: true,\n        object: true\n      },\n      AssignmentExpression: {\n        array: true,\n        object: true\n      }\n    };\n\n    if (enabledTypes) {\n      normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\" ? {\n        VariableDeclarator: enabledTypes,\n        AssignmentExpression: enabledTypes\n      } : enabledTypes;\n    } //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Checks if destructuring type should be checked.\r\n     * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\r\n     * @param {string} destructuringType \"array\" or \"object\"\r\n     * @returns {boolean} `true` if the destructuring type should be checked for the given node\r\n     */\n\n\n    function shouldCheck(nodeType, destructuringType) {\n      return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];\n    }\n    /**\r\n     * Determines if the given node is accessing an array index\r\n     *\r\n     * This is used to differentiate array index access from object property\r\n     * access.\r\n     * @param {ASTNode} node the node to evaluate\r\n     * @returns {boolean} whether or not the node is an integer\r\n     */\n\n\n    function isArrayIndexAccess(node) {\n      return Number.isInteger(node.property.value);\n    }\n    /**\r\n     * Report that the given node should use destructuring\r\n     * @param {ASTNode} reportNode the node to report\r\n     * @param {string} type the type of destructuring that should have been done\r\n     * @param {Function|null} fix the fix function or null to pass to context.report\r\n     * @returns {void}\r\n     */\n\n\n    function report(reportNode, type, fix) {\n      context.report({\n        node: reportNode,\n        messageId: \"preferDestructuring\",\n        data: {\n          type\n        },\n        fix\n      });\n    }\n    /**\r\n     * Determines if a node should be fixed into object destructuring\r\n     *\r\n     * The fixer only fixes the simplest case of object destructuring,\r\n     * like: `let x = a.x`;\r\n     *\r\n     * Assignment expression is not fixed.\r\n     * Array destructuring is not fixed.\r\n     * Renamed property is not fixed.\r\n     * @param {ASTNode} node the node to evaluate\r\n     * @returns {boolean} whether or not the node should be fixed\r\n     */\n\n\n    function shouldFix(node) {\n      return node.type === \"VariableDeclarator\" && node.id.type === \"Identifier\" && node.init.type === \"MemberExpression\" && !node.init.computed && node.init.property.type === \"Identifier\" && node.id.name === node.init.property.name;\n    }\n    /**\r\n     * Fix a node into object destructuring.\r\n     * This function only handles the simplest case of object destructuring,\r\n     * see {@link shouldFix}.\r\n     * @param {SourceCodeFixer} fixer the fixer object\r\n     * @param {ASTNode} node the node to be fixed.\r\n     * @returns {Object} a fix for the node\r\n     */\n\n\n    function fixIntoObjectDestructuring(fixer, node) {\n      const rightNode = node.init;\n      const sourceCode = context.getSourceCode(); // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\n\n      if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\n        return null;\n      }\n\n      let objectText = sourceCode.getText(rightNode.object);\n\n      if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\n        objectText = `(${objectText})`;\n      }\n\n      return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);\n    }\n    /**\r\n     * Check that the `prefer-destructuring` rules are followed based on the\r\n     * given left- and right-hand side of the assignment.\r\n     *\r\n     * Pulled out into a separate method so that VariableDeclarators and\r\n     * AssignmentExpressions can share the same verification logic.\r\n     * @param {ASTNode} leftNode the left-hand side of the assignment\r\n     * @param {ASTNode} rightNode the right-hand side of the assignment\r\n     * @param {ASTNode} reportNode the node to report the error on\r\n     * @returns {void}\r\n     */\n\n\n    function performCheck(leftNode, rightNode, reportNode) {\n      if (rightNode.type !== \"MemberExpression\" || rightNode.object.type === \"Super\" || rightNode.property.type === \"PrivateIdentifier\") {\n        return;\n      }\n\n      if (isArrayIndexAccess(rightNode)) {\n        if (shouldCheck(reportNode.type, \"array\")) {\n          report(reportNode, \"array\", null);\n        }\n\n        return;\n      }\n\n      const fix = shouldFix(reportNode) ? fixer => fixIntoObjectDestructuring(fixer, reportNode) : null;\n\n      if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\n        report(reportNode, \"object\", fix);\n        return;\n      }\n\n      if (shouldCheck(reportNode.type, \"object\")) {\n        const property = rightNode.property;\n\n        if (property.type === \"Literal\" && leftNode.name === property.value || property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed) {\n          report(reportNode, \"object\", fix);\n        }\n      }\n    }\n    /**\r\n     * Check if a given variable declarator is coming from an property access\r\n     * that should be using destructuring instead\r\n     * @param {ASTNode} node the variable declarator to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkVariableDeclarator(node) {\n      // Skip if variable is declared without assignment\n      if (!node.init) {\n        return;\n      } // We only care about member expressions past this point\n\n\n      if (node.init.type !== \"MemberExpression\") {\n        return;\n      }\n\n      performCheck(node.id, node.init, node);\n    }\n    /**\r\n     * Run the `prefer-destructuring` check on an AssignmentExpression\r\n     * @param {ASTNode} node the AssignmentExpression node\r\n     * @returns {void}\r\n     */\n\n\n    function checkAssignmentExpression(node) {\n      if (node.operator === \"=\") {\n        performCheck(node.left, node.right, node);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      VariableDeclarator: checkVariableDeclarator,\n      AssignmentExpression: checkAssignmentExpression\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-destructuring.js"],"names":["astUtils","require","PRECEDENCE_OF_ASSIGNMENT_EXPR","getPrecedence","type","module","exports","meta","docs","description","recommended","url","fixable","schema","oneOf","properties","VariableDeclarator","array","object","additionalProperties","AssignmentExpression","enforceForRenamedProperties","messages","preferDestructuring","create","context","enabledTypes","options","normalizedOptions","shouldCheck","nodeType","destructuringType","isArrayIndexAccess","node","Number","isInteger","property","value","report","reportNode","fix","messageId","data","shouldFix","id","init","computed","name","fixIntoObjectDestructuring","fixer","rightNode","sourceCode","getSourceCode","getCommentsInside","length","objectText","getText","replaceText","performCheck","leftNode","checkVariableDeclarator","checkAssignmentExpression","operator","left","right"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Prefer destructuring from arrays and objects\r\n * @author Alex LaFroscia\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: \"AssignmentExpression\" });\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require destructuring from arrays and/or objects\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-destructuring\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n\r\n                /*\r\n                 * old support {array: Boolean, object: Boolean}\r\n                 * new support {VariableDeclarator: {}, AssignmentExpression: {}}\r\n                 */\r\n                oneOf: [\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            VariableDeclarator: {\r\n                                type: \"object\",\r\n                                properties: {\r\n                                    array: {\r\n                                        type: \"boolean\"\r\n                                    },\r\n                                    object: {\r\n                                        type: \"boolean\"\r\n                                    }\r\n                                },\r\n                                additionalProperties: false\r\n                            },\r\n                            AssignmentExpression: {\r\n                                type: \"object\",\r\n                                properties: {\r\n                                    array: {\r\n                                        type: \"boolean\"\r\n                                    },\r\n                                    object: {\r\n                                        type: \"boolean\"\r\n                                    }\r\n                                },\r\n                                additionalProperties: false\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            array: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            object: {\r\n                                type: \"boolean\"\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    enforceForRenamedProperties: {\r\n                        type: \"boolean\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            preferDestructuring: \"Use {{type}} destructuring.\"\r\n        }\r\n    },\r\n    create(context) {\r\n\r\n        const enabledTypes = context.options[0];\r\n        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;\r\n        let normalizedOptions = {\r\n            VariableDeclarator: { array: true, object: true },\r\n            AssignmentExpression: { array: true, object: true }\r\n        };\r\n\r\n        if (enabledTypes) {\r\n            normalizedOptions = typeof enabledTypes.array !== \"undefined\" || typeof enabledTypes.object !== \"undefined\"\r\n                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes }\r\n                : enabledTypes;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Checks if destructuring type should be checked.\r\n         * @param {string} nodeType \"AssignmentExpression\" or \"VariableDeclarator\"\r\n         * @param {string} destructuringType \"array\" or \"object\"\r\n         * @returns {boolean} `true` if the destructuring type should be checked for the given node\r\n         */\r\n        function shouldCheck(nodeType, destructuringType) {\r\n            return normalizedOptions &&\r\n                normalizedOptions[nodeType] &&\r\n                normalizedOptions[nodeType][destructuringType];\r\n        }\r\n\r\n        /**\r\n         * Determines if the given node is accessing an array index\r\n         *\r\n         * This is used to differentiate array index access from object property\r\n         * access.\r\n         * @param {ASTNode} node the node to evaluate\r\n         * @returns {boolean} whether or not the node is an integer\r\n         */\r\n        function isArrayIndexAccess(node) {\r\n            return Number.isInteger(node.property.value);\r\n        }\r\n\r\n        /**\r\n         * Report that the given node should use destructuring\r\n         * @param {ASTNode} reportNode the node to report\r\n         * @param {string} type the type of destructuring that should have been done\r\n         * @param {Function|null} fix the fix function or null to pass to context.report\r\n         * @returns {void}\r\n         */\r\n        function report(reportNode, type, fix) {\r\n            context.report({\r\n                node: reportNode,\r\n                messageId: \"preferDestructuring\",\r\n                data: { type },\r\n                fix\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Determines if a node should be fixed into object destructuring\r\n         *\r\n         * The fixer only fixes the simplest case of object destructuring,\r\n         * like: `let x = a.x`;\r\n         *\r\n         * Assignment expression is not fixed.\r\n         * Array destructuring is not fixed.\r\n         * Renamed property is not fixed.\r\n         * @param {ASTNode} node the node to evaluate\r\n         * @returns {boolean} whether or not the node should be fixed\r\n         */\r\n        function shouldFix(node) {\r\n            return node.type === \"VariableDeclarator\" &&\r\n                node.id.type === \"Identifier\" &&\r\n                node.init.type === \"MemberExpression\" &&\r\n                !node.init.computed &&\r\n                node.init.property.type === \"Identifier\" &&\r\n                node.id.name === node.init.property.name;\r\n        }\r\n\r\n        /**\r\n         * Fix a node into object destructuring.\r\n         * This function only handles the simplest case of object destructuring,\r\n         * see {@link shouldFix}.\r\n         * @param {SourceCodeFixer} fixer the fixer object\r\n         * @param {ASTNode} node the node to be fixed.\r\n         * @returns {Object} a fix for the node\r\n         */\r\n        function fixIntoObjectDestructuring(fixer, node) {\r\n            const rightNode = node.init;\r\n            const sourceCode = context.getSourceCode();\r\n\r\n            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.\r\n            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {\r\n                return null;\r\n            }\r\n\r\n            let objectText = sourceCode.getText(rightNode.object);\r\n\r\n            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {\r\n                objectText = `(${objectText})`;\r\n            }\r\n\r\n            return fixer.replaceText(\r\n                node,\r\n                `{${rightNode.property.name}} = ${objectText}`\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check that the `prefer-destructuring` rules are followed based on the\r\n         * given left- and right-hand side of the assignment.\r\n         *\r\n         * Pulled out into a separate method so that VariableDeclarators and\r\n         * AssignmentExpressions can share the same verification logic.\r\n         * @param {ASTNode} leftNode the left-hand side of the assignment\r\n         * @param {ASTNode} rightNode the right-hand side of the assignment\r\n         * @param {ASTNode} reportNode the node to report the error on\r\n         * @returns {void}\r\n         */\r\n        function performCheck(leftNode, rightNode, reportNode) {\r\n            if (\r\n                rightNode.type !== \"MemberExpression\" ||\r\n                rightNode.object.type === \"Super\" ||\r\n                rightNode.property.type === \"PrivateIdentifier\"\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (isArrayIndexAccess(rightNode)) {\r\n                if (shouldCheck(reportNode.type, \"array\")) {\r\n                    report(reportNode, \"array\", null);\r\n                }\r\n                return;\r\n            }\r\n\r\n            const fix = shouldFix(reportNode)\r\n                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)\r\n                : null;\r\n\r\n            if (shouldCheck(reportNode.type, \"object\") && enforceForRenamedProperties) {\r\n                report(reportNode, \"object\", fix);\r\n                return;\r\n            }\r\n\r\n            if (shouldCheck(reportNode.type, \"object\")) {\r\n                const property = rightNode.property;\r\n\r\n                if (\r\n                    (property.type === \"Literal\" && leftNode.name === property.value) ||\r\n                    (property.type === \"Identifier\" && leftNode.name === property.name && !rightNode.computed)\r\n                ) {\r\n                    report(reportNode, \"object\", fix);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if a given variable declarator is coming from an property access\r\n         * that should be using destructuring instead\r\n         * @param {ASTNode} node the variable declarator to check\r\n         * @returns {void}\r\n         */\r\n        function checkVariableDeclarator(node) {\r\n\r\n            // Skip if variable is declared without assignment\r\n            if (!node.init) {\r\n                return;\r\n            }\r\n\r\n            // We only care about member expressions past this point\r\n            if (node.init.type !== \"MemberExpression\") {\r\n                return;\r\n            }\r\n\r\n            performCheck(node.id, node.init, node);\r\n        }\r\n\r\n        /**\r\n         * Run the `prefer-destructuring` check on an AssignmentExpression\r\n         * @param {ASTNode} node the AssignmentExpression node\r\n         * @returns {void}\r\n         */\r\n        function checkAssignmentExpression(node) {\r\n            if (node.operator === \"=\") {\r\n                performCheck(node.left, node.right, node);\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            VariableDeclarator: checkVariableDeclarator,\r\n            AssignmentExpression: checkAssignmentExpression\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}