{"ast":null,"code":"/**\r\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given node is a concatenation.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a concatenation.\r\n */\n\n\nfunction isConcatenation(node) {\n  return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n/**\r\n * Gets the top binary expression node for concatenation in parents of a given node.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {ASTNode} the top binary expression node in parents of a given node.\r\n */\n\n\nfunction getTopConcatBinaryExpression(node) {\n  let currentNode = node;\n\n  while (isConcatenation(currentNode.parent)) {\n    currentNode = currentNode.parent;\n  }\n\n  return currentNode;\n}\n/**\r\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\r\n * @param {ASTNode} node A node to check\r\n * @returns {boolean} `true` if at least one string literal within the node contains\r\n * an octal or non-octal decimal escape sequence\r\n */\n\n\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\n  if (isConcatenation(node)) {\n    return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);\n  } // No need to check TemplateLiterals â€“ would throw parsing error\n\n\n  if (node.type === \"Literal\" && typeof node.value === \"string\") {\n    return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\n  }\n\n  return false;\n}\n/**\r\n * Checks whether or not a given binary expression has string literals.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node has string literals.\r\n */\n\n\nfunction hasStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasStringLiteral(node.right) || hasStringLiteral(node.left);\n  }\n\n  return astUtils.isStringLiteral(node);\n}\n/**\r\n * Checks whether or not a given binary expression has non string literals.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node has non string literals.\r\n */\n\n\nfunction hasNonStringLiteral(node) {\n  if (isConcatenation(node)) {\n    // `left` is deeper than `right` normally.\n    return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n  }\n\n  return !astUtils.isStringLiteral(node);\n}\n/**\r\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\r\n * @param {ASTNode} node The node that will be fixed to a template literal\r\n * @returns {boolean} `true` if the node will start with a template curly.\r\n */\n\n\nfunction startsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.left);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n}\n/**\r\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\r\n * @param {ASTNode} node The node that will be fixed to a template literal\r\n * @returns {boolean} `true` if the node will end with a template curly.\r\n */\n\n\nfunction endsWithTemplateCurly(node) {\n  if (node.type === \"BinaryExpression\") {\n    return startsWithTemplateCurly(node.right);\n  }\n\n  if (node.type === \"TemplateLiteral\") {\n    return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\n  }\n\n  return node.type !== \"Literal\" || typeof node.value !== \"string\";\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require template literals instead of string concatenation\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-template\"\n    },\n    schema: [],\n    fixable: \"code\",\n    messages: {\n      unexpectedStringConcatenation: \"Unexpected string concatenation.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    let done = Object.create(null);\n    /**\r\n     * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\r\n     * @param {ASTNode} node1 The first node\r\n     * @param {ASTNode} node2 The second node\r\n     * @returns {string} The text between the nodes, excluding other tokens\r\n     */\n\n    function getTextBetween(node1, node2) {\n      const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\n      const sourceText = sourceCode.getText();\n      return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\n    }\n    /**\r\n     * Returns a template literal form of the given node.\r\n     * @param {ASTNode} currentNode A node that should be converted to a template literal\r\n     * @param {string} textBeforeNode Text that should appear before the node\r\n     * @param {string} textAfterNode Text that should appear after the node\r\n     * @returns {string} A string form of this node, represented as a template literal\r\n     */\n\n\n    function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\n      if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\n        /*\r\n         * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\r\n         * as a template placeholder. However, if the code already contains a backslash before the ${ or `\r\n         * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\r\n         * an actual backslash character to appear before the dollar sign).\r\n         */\n        return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\n          if (matched.lastIndexOf(\"\\\\\") % 2) {\n            return `\\\\${matched}`;\n          }\n\n          return matched; // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\n        }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\n      }\n\n      if (currentNode.type === \"TemplateLiteral\") {\n        return sourceCode.getText(currentNode);\n      }\n\n      if (isConcatenation(currentNode) && hasStringLiteral(currentNode)) {\n        const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\n        const textBeforePlus = getTextBetween(currentNode.left, plusSign);\n        const textAfterPlus = getTextBetween(plusSign, currentNode.right);\n        const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\n        const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\n\n        if (leftEndsWithCurly) {\n          // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\n          // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\n        }\n\n        if (rightStartsWithCurly) {\n          // Otherwise, if the right side of the expression starts with a template curly, add the text there.\n          // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\n          return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\n        }\n        /*\r\n         * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\r\n         * the text between them.\r\n         */\n\n\n        return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\n      }\n\n      return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\n    }\n    /**\r\n     * Returns a fixer object that converts a non-string binary expression to a template literal\r\n     * @param {SourceCodeFixer} fixer The fixer object\r\n     * @param {ASTNode} node A node that should be converted to a template literal\r\n     * @returns {Object} A fix for this binary expression\r\n     */\n\n\n    function fixNonStringBinaryExpression(fixer, node) {\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n      if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\n        return null;\n      }\n\n      return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\n    }\n    /**\r\n     * Reports if a given node is string concatenation with non string literals.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForStringConcat(node) {\n      if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n        return;\n      }\n\n      const topBinaryExpr = getTopConcatBinaryExpression(node.parent); // Checks whether or not this node had been checked already.\n\n      if (done[topBinaryExpr.range[0]]) {\n        return;\n      }\n\n      done[topBinaryExpr.range[0]] = true;\n\n      if (hasNonStringLiteral(topBinaryExpr)) {\n        context.report({\n          node: topBinaryExpr,\n          messageId: \"unexpectedStringConcatenation\",\n          fix: fixer => fixNonStringBinaryExpression(fixer, node)\n        });\n      }\n    }\n\n    return {\n      Program() {\n        done = Object.create(null);\n      },\n\n      Literal: checkForStringConcat,\n      TemplateLiteral: checkForStringConcat\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-template.js"],"names":["astUtils","require","isConcatenation","node","type","operator","getTopConcatBinaryExpression","currentNode","parent","hasOctalOrNonOctalDecimalEscapeSequence","left","right","value","raw","hasStringLiteral","isStringLiteral","hasNonStringLiteral","startsWithTemplateCurly","expressions","length","quasis","range","endsWithTemplateCurly","module","exports","meta","docs","description","recommended","url","schema","fixable","messages","unexpectedStringConcatenation","create","context","sourceCode","getSourceCode","done","Object","getTextBetween","node1","node2","allTokens","concat","getTokensBetween","sourceText","getText","slice","reduce","accumulator","token","index","getTemplateLiteral","textBeforeNode","textAfterNode","replace","matched","lastIndexOf","RegExp","plusSign","getFirstTokenBetween","textBeforePlus","textAfterPlus","leftEndsWithCurly","rightStartsWithCurly","fixNonStringBinaryExpression","fixer","topBinaryExpr","replaceText","checkForStringConcat","report","messageId","fix","Program","Literal","TemplateLiteral"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given node is a concatenation.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a concatenation.\r\n */\r\nfunction isConcatenation(node) {\r\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\r\n}\r\n\r\n/**\r\n * Gets the top binary expression node for concatenation in parents of a given node.\r\n * @param {ASTNode} node A node to get.\r\n * @returns {ASTNode} the top binary expression node in parents of a given node.\r\n */\r\nfunction getTopConcatBinaryExpression(node) {\r\n    let currentNode = node;\r\n\r\n    while (isConcatenation(currentNode.parent)) {\r\n        currentNode = currentNode.parent;\r\n    }\r\n    return currentNode;\r\n}\r\n\r\n/**\r\n * Checks whether or not a node contains a string literal with an octal or non-octal decimal escape sequence\r\n * @param {ASTNode} node A node to check\r\n * @returns {boolean} `true` if at least one string literal within the node contains\r\n * an octal or non-octal decimal escape sequence\r\n */\r\nfunction hasOctalOrNonOctalDecimalEscapeSequence(node) {\r\n    if (isConcatenation(node)) {\r\n        return (\r\n            hasOctalOrNonOctalDecimalEscapeSequence(node.left) ||\r\n            hasOctalOrNonOctalDecimalEscapeSequence(node.right)\r\n        );\r\n    }\r\n\r\n    // No need to check TemplateLiterals â€“ would throw parsing error\r\n    if (node.type === \"Literal\" && typeof node.value === \"string\") {\r\n        return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given binary expression has string literals.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node has string literals.\r\n */\r\nfunction hasStringLiteral(node) {\r\n    if (isConcatenation(node)) {\r\n\r\n        // `left` is deeper than `right` normally.\r\n        return hasStringLiteral(node.right) || hasStringLiteral(node.left);\r\n    }\r\n    return astUtils.isStringLiteral(node);\r\n}\r\n\r\n/**\r\n * Checks whether or not a given binary expression has non string literals.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node has non string literals.\r\n */\r\nfunction hasNonStringLiteral(node) {\r\n    if (isConcatenation(node)) {\r\n\r\n        // `left` is deeper than `right` normally.\r\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\r\n    }\r\n    return !astUtils.isStringLiteral(node);\r\n}\r\n\r\n/**\r\n * Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.\r\n * @param {ASTNode} node The node that will be fixed to a template literal\r\n * @returns {boolean} `true` if the node will start with a template curly.\r\n */\r\nfunction startsWithTemplateCurly(node) {\r\n    if (node.type === \"BinaryExpression\") {\r\n        return startsWithTemplateCurly(node.left);\r\n    }\r\n    if (node.type === \"TemplateLiteral\") {\r\n        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];\r\n    }\r\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\r\n}\r\n\r\n/**\r\n * Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.\r\n * @param {ASTNode} node The node that will be fixed to a template literal\r\n * @returns {boolean} `true` if the node will end with a template curly.\r\n */\r\nfunction endsWithTemplateCurly(node) {\r\n    if (node.type === \"BinaryExpression\") {\r\n        return startsWithTemplateCurly(node.right);\r\n    }\r\n    if (node.type === \"TemplateLiteral\") {\r\n        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];\r\n    }\r\n    return node.type !== \"Literal\" || typeof node.value !== \"string\";\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require template literals instead of string concatenation\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-template\"\r\n        },\r\n\r\n        schema: [],\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpectedStringConcatenation: \"Unexpected string concatenation.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        let done = Object.create(null);\r\n\r\n        /**\r\n         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.\r\n         * @param {ASTNode} node1 The first node\r\n         * @param {ASTNode} node2 The second node\r\n         * @returns {string} The text between the nodes, excluding other tokens\r\n         */\r\n        function getTextBetween(node1, node2) {\r\n            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);\r\n            const sourceText = sourceCode.getText();\r\n\r\n            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), \"\");\r\n        }\r\n\r\n        /**\r\n         * Returns a template literal form of the given node.\r\n         * @param {ASTNode} currentNode A node that should be converted to a template literal\r\n         * @param {string} textBeforeNode Text that should appear before the node\r\n         * @param {string} textAfterNode Text that should appear after the node\r\n         * @returns {string} A string form of this node, represented as a template literal\r\n         */\r\n        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {\r\n            if (currentNode.type === \"Literal\" && typeof currentNode.value === \"string\") {\r\n\r\n                /*\r\n                 * If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted\r\n                 * as a template placeholder. However, if the code already contains a backslash before the ${ or `\r\n                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause\r\n                 * an actual backslash character to appear before the dollar sign).\r\n                 */\r\n                return `\\`${currentNode.raw.slice(1, -1).replace(/\\\\*(\\$\\{|`)/gu, matched => {\r\n                    if (matched.lastIndexOf(\"\\\\\") % 2) {\r\n                        return `\\\\${matched}`;\r\n                    }\r\n                    return matched;\r\n\r\n                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.\r\n                }).replace(new RegExp(`\\\\\\\\${currentNode.raw[0]}`, \"gu\"), currentNode.raw[0])}\\``;\r\n            }\r\n\r\n            if (currentNode.type === \"TemplateLiteral\") {\r\n                return sourceCode.getText(currentNode);\r\n            }\r\n\r\n            if (isConcatenation(currentNode) && hasStringLiteral(currentNode)) {\r\n                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === \"+\");\r\n                const textBeforePlus = getTextBetween(currentNode.left, plusSign);\r\n                const textAfterPlus = getTextBetween(plusSign, currentNode.right);\r\n                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);\r\n                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);\r\n\r\n                if (leftEndsWithCurly) {\r\n\r\n                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.\r\n                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`\r\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +\r\n                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);\r\n                }\r\n                if (rightStartsWithCurly) {\r\n\r\n                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.\r\n                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`\r\n                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +\r\n                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);\r\n                }\r\n\r\n                /*\r\n                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put\r\n                 * the text between them.\r\n                 */\r\n                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;\r\n            }\r\n\r\n            return `\\`\\${${textBeforeNode || \"\"}${sourceCode.getText(currentNode)}${textAfterNode || \"\"}}\\``;\r\n        }\r\n\r\n        /**\r\n         * Returns a fixer object that converts a non-string binary expression to a template literal\r\n         * @param {SourceCodeFixer} fixer The fixer object\r\n         * @param {ASTNode} node A node that should be converted to a template literal\r\n         * @returns {Object} A fix for this binary expression\r\n         */\r\n        function fixNonStringBinaryExpression(fixer, node) {\r\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\r\n\r\n            if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {\r\n                return null;\r\n            }\r\n\r\n            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));\r\n        }\r\n\r\n        /**\r\n         * Reports if a given node is string concatenation with non string literals.\r\n         * @param {ASTNode} node A node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkForStringConcat(node) {\r\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\r\n                return;\r\n            }\r\n\r\n            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);\r\n\r\n            // Checks whether or not this node had been checked already.\r\n            if (done[topBinaryExpr.range[0]]) {\r\n                return;\r\n            }\r\n            done[topBinaryExpr.range[0]] = true;\r\n\r\n            if (hasNonStringLiteral(topBinaryExpr)) {\r\n                context.report({\r\n                    node: topBinaryExpr,\r\n                    messageId: \"unexpectedStringConcatenation\",\r\n                    fix: fixer => fixNonStringBinaryExpression(fixer, node)\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                done = Object.create(null);\r\n            },\r\n\r\n            Literal: checkForStringConcat,\r\n            TemplateLiteral: checkForStringConcat\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}