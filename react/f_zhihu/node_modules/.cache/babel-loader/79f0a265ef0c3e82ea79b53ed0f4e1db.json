{"ast":null,"code":"/**\r\n * @fileoverview Require spaces around infix operators\r\n * @author Michael Ficarra\r\n */\n\"use strict\";\n\nconst {\n  isEqToken\n} = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require spacing around infix operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-infix-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        int32Hint: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      missingSpace: \"Operator '{{operator}}' must be spaced.\"\n    }\n  },\n\n  create(context) {\n    const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Returns the first token which violates the rule\r\n     * @param {ASTNode} left The left node of the main node\r\n     * @param {ASTNode} right The right node of the main node\r\n     * @param {string} op The operator of the main node\r\n     * @returns {Object} The violator token or null\r\n     * @private\r\n     */\n\n    function getFirstNonSpacedToken(left, right, op) {\n      const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\n      const prev = sourceCode.getTokenBefore(operator);\n      const next = sourceCode.getTokenAfter(operator);\n\n      if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\n        return operator;\n      }\n\n      return null;\n    }\n    /**\r\n     * Reports an AST node as a rule violation\r\n     * @param {ASTNode} mainNode The node to report\r\n     * @param {Object} culpritToken The token which has a problem\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(mainNode, culpritToken) {\n      context.report({\n        node: mainNode,\n        loc: culpritToken.loc,\n        messageId: \"missingSpace\",\n        data: {\n          operator: culpritToken.value\n        },\n\n        fix(fixer) {\n          const previousToken = sourceCode.getTokenBefore(culpritToken);\n          const afterToken = sourceCode.getTokenAfter(culpritToken);\n          let fixString = \"\";\n\n          if (culpritToken.range[0] - previousToken.range[1] === 0) {\n            fixString = \" \";\n          }\n\n          fixString += culpritToken.value;\n\n          if (afterToken.range[0] - culpritToken.range[1] === 0) {\n            fixString += \" \";\n          }\n\n          return fixer.replaceText(culpritToken, fixString);\n        }\n\n      });\n    }\n    /**\r\n     * Check if the node is binary then report\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkBinary(node) {\n      const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;\n      const rightNode = node.right; // search for = in AssignmentPattern nodes\n\n      const operator = node.operator || \"=\";\n      const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\n\n      if (nonSpacedNode) {\n        if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n    /**\r\n     * Check if the node is conditional\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkConditional(node) {\n      const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\n      const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\n\n      if (nonSpacedConsequentNode) {\n        report(node, nonSpacedConsequentNode);\n      }\n\n      if (nonSpacedAlternateNode) {\n        report(node, nonSpacedAlternateNode);\n      }\n    }\n    /**\r\n     * Check if the node is a variable\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkVar(node) {\n      const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;\n      const rightNode = node.init;\n\n      if (rightNode) {\n        const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\n\n        if (nonSpacedNode) {\n          report(node, nonSpacedNode);\n        }\n      }\n    }\n\n    return {\n      AssignmentExpression: checkBinary,\n      AssignmentPattern: checkBinary,\n      BinaryExpression: checkBinary,\n      LogicalExpression: checkBinary,\n      ConditionalExpression: checkConditional,\n      VariableDeclarator: checkVar,\n\n      PropertyDefinition(node) {\n        if (!node.value) {\n          return;\n        }\n        /*\r\n         * Because of computed properties and type annotations, some\r\n         * tokens may exist between `node.key` and `=`.\r\n         * Therefore, find the `=` from the right.\r\n         */\n\n\n        const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);\n        const leftToken = sourceCode.getTokenBefore(operatorToken);\n        const rightToken = sourceCode.getTokenAfter(operatorToken);\n\n        if (!sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) || !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)) {\n          report(node, operatorToken);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/space-infix-ops.js"],"names":["isEqToken","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","int32Hint","default","additionalProperties","messages","missingSpace","create","context","options","sourceCode","getSourceCode","getFirstNonSpacedToken","left","right","op","operator","getFirstTokenBetween","token","value","prev","getTokenBefore","next","getTokenAfter","isSpaceBetweenTokens","report","mainNode","culpritToken","node","loc","messageId","data","fix","fixer","previousToken","afterToken","fixString","range","replaceText","checkBinary","leftNode","typeAnnotation","rightNode","nonSpacedNode","getText","endsWith","checkConditional","nonSpacedConsequentNode","test","consequent","nonSpacedAlternateNode","alternate","checkVar","id","init","AssignmentExpression","AssignmentPattern","BinaryExpression","LogicalExpression","ConditionalExpression","VariableDeclarator","PropertyDefinition","operatorToken","leftToken","rightToken"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Require spaces around infix operators\r\n * @author Michael Ficarra\r\n */\r\n\"use strict\";\r\n\r\nconst { isEqToken } = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require spacing around infix operators\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/space-infix-ops\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    int32Hint: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            missingSpace: \"Operator '{{operator}}' must be spaced.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Returns the first token which violates the rule\r\n         * @param {ASTNode} left The left node of the main node\r\n         * @param {ASTNode} right The right node of the main node\r\n         * @param {string} op The operator of the main node\r\n         * @returns {Object} The violator token or null\r\n         * @private\r\n         */\r\n        function getFirstNonSpacedToken(left, right, op) {\r\n            const operator = sourceCode.getFirstTokenBetween(left, right, token => token.value === op);\r\n            const prev = sourceCode.getTokenBefore(operator);\r\n            const next = sourceCode.getTokenAfter(operator);\r\n\r\n            if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {\r\n                return operator;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Reports an AST node as a rule violation\r\n         * @param {ASTNode} mainNode The node to report\r\n         * @param {Object} culpritToken The token which has a problem\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(mainNode, culpritToken) {\r\n            context.report({\r\n                node: mainNode,\r\n                loc: culpritToken.loc,\r\n                messageId: \"missingSpace\",\r\n                data: {\r\n                    operator: culpritToken.value\r\n                },\r\n                fix(fixer) {\r\n                    const previousToken = sourceCode.getTokenBefore(culpritToken);\r\n                    const afterToken = sourceCode.getTokenAfter(culpritToken);\r\n                    let fixString = \"\";\r\n\r\n                    if (culpritToken.range[0] - previousToken.range[1] === 0) {\r\n                        fixString = \" \";\r\n                    }\r\n\r\n                    fixString += culpritToken.value;\r\n\r\n                    if (afterToken.range[0] - culpritToken.range[1] === 0) {\r\n                        fixString += \" \";\r\n                    }\r\n\r\n                    return fixer.replaceText(culpritToken, fixString);\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check if the node is binary then report\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkBinary(node) {\r\n            const leftNode = (node.left.typeAnnotation) ? node.left.typeAnnotation : node.left;\r\n            const rightNode = node.right;\r\n\r\n            // search for = in AssignmentPattern nodes\r\n            const operator = node.operator || \"=\";\r\n\r\n            const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);\r\n\r\n            if (nonSpacedNode) {\r\n                if (!(int32Hint && sourceCode.getText(node).endsWith(\"|0\"))) {\r\n                    report(node, nonSpacedNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the node is conditional\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkConditional(node) {\r\n            const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, \"?\");\r\n            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, \":\");\r\n\r\n            if (nonSpacedConsequentNode) {\r\n                report(node, nonSpacedConsequentNode);\r\n            }\r\n\r\n            if (nonSpacedAlternateNode) {\r\n                report(node, nonSpacedAlternateNode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if the node is a variable\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkVar(node) {\r\n            const leftNode = (node.id.typeAnnotation) ? node.id.typeAnnotation : node.id;\r\n            const rightNode = node.init;\r\n\r\n            if (rightNode) {\r\n                const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, \"=\");\r\n\r\n                if (nonSpacedNode) {\r\n                    report(node, nonSpacedNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            AssignmentExpression: checkBinary,\r\n            AssignmentPattern: checkBinary,\r\n            BinaryExpression: checkBinary,\r\n            LogicalExpression: checkBinary,\r\n            ConditionalExpression: checkConditional,\r\n            VariableDeclarator: checkVar,\r\n\r\n            PropertyDefinition(node) {\r\n                if (!node.value) {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * Because of computed properties and type annotations, some\r\n                 * tokens may exist between `node.key` and `=`.\r\n                 * Therefore, find the `=` from the right.\r\n                 */\r\n                const operatorToken = sourceCode.getTokenBefore(node.value, isEqToken);\r\n                const leftToken = sourceCode.getTokenBefore(operatorToken);\r\n                const rightToken = sourceCode.getTokenAfter(operatorToken);\r\n\r\n                if (\r\n                    !sourceCode.isSpaceBetweenTokens(leftToken, operatorToken) ||\r\n                    !sourceCode.isSpaceBetweenTokens(operatorToken, rightToken)\r\n                ) {\r\n                    report(node, operatorToken);\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}