{"ast":null,"code":"/**\r\n * @fileoverview A rule to ensure whitespace before blocks.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether the given node represents the body of a function.\r\n * @param {ASTNode} node the node to check.\r\n * @returns {boolean} `true` if the node is function body.\r\n */\n\n\nfunction isFunctionBody(node) {\n  const parent = node.parent;\n  return node.type === \"BlockStatement\" && astUtils.isFunction(parent) && parent.body === node;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-before-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          keywords: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          functions: {\n            enum: [\"always\", \"never\", \"off\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\", \"off\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      unexpectedSpace: \"Unexpected space before opening brace.\",\n      missingSpace: \"Missing space before opening brace.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0],\n          sourceCode = context.getSourceCode();\n    let alwaysFunctions = true,\n        alwaysKeywords = true,\n        alwaysClasses = true,\n        neverFunctions = false,\n        neverKeywords = false,\n        neverClasses = false;\n\n    if (typeof config === \"object\") {\n      alwaysFunctions = config.functions === \"always\";\n      alwaysKeywords = config.keywords === \"always\";\n      alwaysClasses = config.classes === \"always\";\n      neverFunctions = config.functions === \"never\";\n      neverKeywords = config.keywords === \"never\";\n      neverClasses = config.classes === \"never\";\n    } else if (config === \"never\") {\n      alwaysFunctions = false;\n      alwaysKeywords = false;\n      alwaysClasses = false;\n      neverFunctions = true;\n      neverKeywords = true;\n      neverClasses = true;\n    }\n    /**\r\n     * Checks whether the spacing before the given block is already controlled by another rule:\r\n     * - `arrow-spacing` checks spaces after `=>`.\r\n     * - `keyword-spacing` checks spaces after keywords in certain contexts.\r\n     * - `switch-colon-spacing` checks spaces after `:` of switch cases.\r\n     * @param {Token} precedingToken first token before the block.\r\n     * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\r\n     * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\r\n     */\n\n\n    function isConflicted(precedingToken, node) {\n      return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node) || astUtils.isColonToken(precedingToken) && node.parent && node.parent.type === \"SwitchCase\" && precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode);\n    }\n    /**\r\n     * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\r\n     * @param {ASTNode|Token} node The AST node of a BlockStatement.\r\n     * @returns {void} undefined.\r\n     */\n\n\n    function checkPrecedingSpace(node) {\n      const precedingToken = sourceCode.getTokenBefore(node);\n\n      if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\n        const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\n        let requireSpace;\n        let requireNoSpace;\n\n        if (isFunctionBody(node)) {\n          requireSpace = alwaysFunctions;\n          requireNoSpace = neverFunctions;\n        } else if (node.type === \"ClassBody\") {\n          requireSpace = alwaysClasses;\n          requireNoSpace = neverClasses;\n        } else {\n          requireSpace = alwaysKeywords;\n          requireNoSpace = neverKeywords;\n        }\n\n        if (requireSpace && !hasSpace) {\n          context.report({\n            node,\n            messageId: \"missingSpace\",\n\n            fix(fixer) {\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n          });\n        } else if (requireNoSpace && hasSpace) {\n          context.report({\n            node,\n            messageId: \"unexpectedSpace\",\n\n            fix(fixer) {\n              return fixer.removeRange([precedingToken.range[1], node.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\r\n     * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\r\n     * @param {ASTNode} node The node of a SwitchStatement.\r\n     * @returns {void} undefined.\r\n     */\n\n\n    function checkSpaceBeforeCaseBlock(node) {\n      const cases = node.cases;\n      let openingBrace;\n\n      if (cases.length > 0) {\n        openingBrace = sourceCode.getTokenBefore(cases[0]);\n      } else {\n        openingBrace = sourceCode.getLastToken(node, 1);\n      }\n\n      checkPrecedingSpace(openingBrace);\n    }\n\n    return {\n      BlockStatement: checkPrecedingSpace,\n      ClassBody: checkPrecedingSpace,\n      SwitchStatement: checkSpaceBeforeCaseBlock\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/space-before-blocks.js"],"names":["astUtils","require","isFunctionBody","node","parent","type","isFunction","body","module","exports","meta","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","keywords","functions","classes","additionalProperties","messages","unexpectedSpace","missingSpace","create","context","config","options","sourceCode","getSourceCode","alwaysFunctions","alwaysKeywords","alwaysClasses","neverFunctions","neverKeywords","neverClasses","isConflicted","precedingToken","isArrowToken","isKeywordToken","isColonToken","getSwitchCaseColonToken","checkPrecedingSpace","getTokenBefore","isTokenOnSameLine","hasSpace","isSpaceBetweenTokens","requireSpace","requireNoSpace","report","messageId","fix","fixer","insertTextBefore","removeRange","range","checkSpaceBeforeCaseBlock","cases","openingBrace","length","getLastToken","BlockStatement","ClassBody","SwitchStatement"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to ensure whitespace before blocks.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether the given node represents the body of a function.\r\n * @param {ASTNode} node the node to check.\r\n * @returns {boolean} `true` if the node is function body.\r\n */\r\nfunction isFunctionBody(node) {\r\n    const parent = node.parent;\r\n\r\n    return (\r\n        node.type === \"BlockStatement\" &&\r\n        astUtils.isFunction(parent) &&\r\n        parent.body === node\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing before blocks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/space-before-blocks\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"always\", \"never\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            keywords: {\r\n                                enum: [\"always\", \"never\", \"off\"]\r\n                            },\r\n                            functions: {\r\n                                enum: [\"always\", \"never\", \"off\"]\r\n                            },\r\n                            classes: {\r\n                                enum: [\"always\", \"never\", \"off\"]\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedSpace: \"Unexpected space before opening brace.\",\r\n            missingSpace: \"Missing space before opening brace.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const config = context.options[0],\r\n            sourceCode = context.getSourceCode();\r\n        let alwaysFunctions = true,\r\n            alwaysKeywords = true,\r\n            alwaysClasses = true,\r\n            neverFunctions = false,\r\n            neverKeywords = false,\r\n            neverClasses = false;\r\n\r\n        if (typeof config === \"object\") {\r\n            alwaysFunctions = config.functions === \"always\";\r\n            alwaysKeywords = config.keywords === \"always\";\r\n            alwaysClasses = config.classes === \"always\";\r\n            neverFunctions = config.functions === \"never\";\r\n            neverKeywords = config.keywords === \"never\";\r\n            neverClasses = config.classes === \"never\";\r\n        } else if (config === \"never\") {\r\n            alwaysFunctions = false;\r\n            alwaysKeywords = false;\r\n            alwaysClasses = false;\r\n            neverFunctions = true;\r\n            neverKeywords = true;\r\n            neverClasses = true;\r\n        }\r\n\r\n        /**\r\n         * Checks whether the spacing before the given block is already controlled by another rule:\r\n         * - `arrow-spacing` checks spaces after `=>`.\r\n         * - `keyword-spacing` checks spaces after keywords in certain contexts.\r\n         * - `switch-colon-spacing` checks spaces after `:` of switch cases.\r\n         * @param {Token} precedingToken first token before the block.\r\n         * @param {ASTNode|Token} node `BlockStatement` node or `{` token of a `SwitchStatement` node.\r\n         * @returns {boolean} `true` if requiring or disallowing spaces before the given block could produce conflicts with other rules.\r\n         */\r\n        function isConflicted(precedingToken, node) {\r\n            return (\r\n                astUtils.isArrowToken(precedingToken) ||\r\n                (\r\n                    astUtils.isKeywordToken(precedingToken) &&\r\n                    !isFunctionBody(node)\r\n                ) ||\r\n                (\r\n                    astUtils.isColonToken(precedingToken) &&\r\n                    node.parent &&\r\n                    node.parent.type === \"SwitchCase\" &&\r\n                    precedingToken === astUtils.getSwitchCaseColonToken(node.parent, sourceCode)\r\n                )\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks the given BlockStatement node has a preceding space if it doesn’t start on a new line.\r\n         * @param {ASTNode|Token} node The AST node of a BlockStatement.\r\n         * @returns {void} undefined.\r\n         */\r\n        function checkPrecedingSpace(node) {\r\n            const precedingToken = sourceCode.getTokenBefore(node);\r\n\r\n            if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {\r\n                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);\r\n                let requireSpace;\r\n                let requireNoSpace;\r\n\r\n                if (isFunctionBody(node)) {\r\n                    requireSpace = alwaysFunctions;\r\n                    requireNoSpace = neverFunctions;\r\n                } else if (node.type === \"ClassBody\") {\r\n                    requireSpace = alwaysClasses;\r\n                    requireNoSpace = neverClasses;\r\n                } else {\r\n                    requireSpace = alwaysKeywords;\r\n                    requireNoSpace = neverKeywords;\r\n                }\r\n\r\n                if (requireSpace && !hasSpace) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"missingSpace\",\r\n                        fix(fixer) {\r\n                            return fixer.insertTextBefore(node, \" \");\r\n                        }\r\n                    });\r\n                } else if (requireNoSpace && hasSpace) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedSpace\",\r\n                        fix(fixer) {\r\n                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.\r\n         * @param {ASTNode} node The node of a SwitchStatement.\r\n         * @returns {void} undefined.\r\n         */\r\n        function checkSpaceBeforeCaseBlock(node) {\r\n            const cases = node.cases;\r\n            let openingBrace;\r\n\r\n            if (cases.length > 0) {\r\n                openingBrace = sourceCode.getTokenBefore(cases[0]);\r\n            } else {\r\n                openingBrace = sourceCode.getLastToken(node, 1);\r\n            }\r\n\r\n            checkPrecedingSpace(openingBrace);\r\n        }\r\n\r\n        return {\r\n            BlockStatement: checkPrecedingSpace,\r\n            ClassBody: checkPrecedingSpace,\r\n            SwitchStatement: checkSpaceBeforeCaseBlock\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}