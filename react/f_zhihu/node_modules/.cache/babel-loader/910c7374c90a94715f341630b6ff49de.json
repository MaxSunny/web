{"ast":null,"code":"/**\r\n * @fileoverview Enforce return after a callback.\r\n * @author Jamund Ferguson\r\n * @deprecated in ESLint v7.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    deprecated: true,\n    replacedBy: [],\n    type: \"suggestion\",\n    docs: {\n      description: \"require `return` statements after callbacks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/callback-return\"\n    },\n    schema: [{\n      type: \"array\",\n      items: {\n        type: \"string\"\n      }\n    }],\n    messages: {\n      missingReturn: \"Expected return with your callback function.\"\n    }\n  },\n\n  create(context) {\n    const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Find the closest parent matching a list of types.\r\n     * @param {ASTNode} node The node whose parents we are searching\r\n     * @param {Array} types The node types to match\r\n     * @returns {ASTNode} The matched node or undefined.\r\n     */\n\n    function findClosestParentOfType(node, types) {\n      if (!node.parent) {\n        return null;\n      }\n\n      if (types.indexOf(node.parent.type) === -1) {\n        return findClosestParentOfType(node.parent, types);\n      }\n\n      return node.parent;\n    }\n    /**\r\n     * Check to see if a node contains only identifiers\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} Whether or not the node contains only identifiers\r\n     */\n\n\n    function containsOnlyIdentifiers(node) {\n      if (node.type === \"Identifier\") {\n        return true;\n      }\n\n      if (node.type === \"MemberExpression\") {\n        if (node.object.type === \"Identifier\") {\n          return true;\n        }\n\n        if (node.object.type === \"MemberExpression\") {\n          return containsOnlyIdentifiers(node.object);\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Check to see if a CallExpression is in our callback list.\r\n     * @param {ASTNode} node The node to check against our callback names list.\r\n     * @returns {boolean} Whether or not this function matches our callback name.\r\n     */\n\n\n    function isCallback(node) {\n      return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\n    }\n    /**\r\n     * Determines whether or not the callback is part of a callback expression.\r\n     * @param {ASTNode} node The callback node\r\n     * @param {ASTNode} parentNode The expression node\r\n     * @returns {boolean} Whether or not this is part of a callback expression\r\n     */\n\n\n    function isCallbackExpression(node, parentNode) {\n      // ensure the parent node exists and is an expression\n      if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n        return false;\n      } // cb()\n\n\n      if (parentNode.expression === node) {\n        return true;\n      } // special case for cb && cb() and similar\n\n\n      if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n        if (parentNode.expression.right === node) {\n          return true;\n        }\n      }\n\n      return false;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      CallExpression(node) {\n        // if we're not a callback we can return\n        if (!isCallback(node)) {\n          return;\n        } // find the closest block, return or loop\n\n\n        const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {}; // if our parent is a return we know we're ok\n\n        if (closestBlock.type === \"ReturnStatement\") {\n          return;\n        } // arrow functions don't always have blocks and implicitly return\n\n\n        if (closestBlock.type === \"ArrowFunctionExpression\") {\n          return;\n        } // block statements are part of functions and most if statements\n\n\n        if (closestBlock.type === \"BlockStatement\") {\n          // find the last item in the block\n          const lastItem = closestBlock.body[closestBlock.body.length - 1]; // if the callback is the last thing in a block that might be ok\n\n          if (isCallbackExpression(node, lastItem)) {\n            const parentType = closestBlock.parent.type; // but only if the block is part of a function\n\n            if (parentType === \"FunctionExpression\" || parentType === \"FunctionDeclaration\" || parentType === \"ArrowFunctionExpression\") {\n              return;\n            }\n          } // ending a block with a return is also ok\n\n\n          if (lastItem.type === \"ReturnStatement\") {\n            // but only if the callback is immediately before\n            if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n              return;\n            }\n          }\n        } // as long as you're the child of a function at this point you should be asked to return\n\n\n        if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n          context.report({\n            node,\n            messageId: \"missingReturn\"\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/callback-return.js"],"names":["module","exports","meta","deprecated","replacedBy","type","docs","description","recommended","url","schema","items","messages","missingReturn","create","context","callbacks","options","sourceCode","getSourceCode","findClosestParentOfType","node","types","parent","indexOf","containsOnlyIdentifiers","object","isCallback","callee","getText","isCallbackExpression","parentNode","expression","right","CallExpression","closestBlock","lastItem","body","length","parentType","report","messageId"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Enforce return after a callback.\r\n * @author Jamund Ferguson\r\n * @deprecated in ESLint v7.0.0\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        deprecated: true,\r\n\r\n        replacedBy: [],\r\n\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require `return` statements after callbacks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/callback-return\"\r\n        },\r\n\r\n        schema: [{\r\n            type: \"array\",\r\n            items: { type: \"string\" }\r\n        }],\r\n\r\n        messages: {\r\n            missingReturn: \"Expected return with your callback function.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"],\r\n            sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Find the closest parent matching a list of types.\r\n         * @param {ASTNode} node The node whose parents we are searching\r\n         * @param {Array} types The node types to match\r\n         * @returns {ASTNode} The matched node or undefined.\r\n         */\r\n        function findClosestParentOfType(node, types) {\r\n            if (!node.parent) {\r\n                return null;\r\n            }\r\n            if (types.indexOf(node.parent.type) === -1) {\r\n                return findClosestParentOfType(node.parent, types);\r\n            }\r\n            return node.parent;\r\n        }\r\n\r\n        /**\r\n         * Check to see if a node contains only identifiers\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} Whether or not the node contains only identifiers\r\n         */\r\n        function containsOnlyIdentifiers(node) {\r\n            if (node.type === \"Identifier\") {\r\n                return true;\r\n            }\r\n\r\n            if (node.type === \"MemberExpression\") {\r\n                if (node.object.type === \"Identifier\") {\r\n                    return true;\r\n                }\r\n                if (node.object.type === \"MemberExpression\") {\r\n                    return containsOnlyIdentifiers(node.object);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Check to see if a CallExpression is in our callback list.\r\n         * @param {ASTNode} node The node to check against our callback names list.\r\n         * @returns {boolean} Whether or not this function matches our callback name.\r\n         */\r\n        function isCallback(node) {\r\n            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;\r\n        }\r\n\r\n        /**\r\n         * Determines whether or not the callback is part of a callback expression.\r\n         * @param {ASTNode} node The callback node\r\n         * @param {ASTNode} parentNode The expression node\r\n         * @returns {boolean} Whether or not this is part of a callback expression\r\n         */\r\n        function isCallbackExpression(node, parentNode) {\r\n\r\n            // ensure the parent node exists and is an expression\r\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\r\n                return false;\r\n            }\r\n\r\n            // cb()\r\n            if (parentNode.expression === node) {\r\n                return true;\r\n            }\r\n\r\n            // special case for cb && cb() and similar\r\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\r\n                if (parentNode.expression.right === node) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            CallExpression(node) {\r\n\r\n                // if we're not a callback we can return\r\n                if (!isCallback(node)) {\r\n                    return;\r\n                }\r\n\r\n                // find the closest block, return or loop\r\n                const closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {};\r\n\r\n                // if our parent is a return we know we're ok\r\n                if (closestBlock.type === \"ReturnStatement\") {\r\n                    return;\r\n                }\r\n\r\n                // arrow functions don't always have blocks and implicitly return\r\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\r\n                    return;\r\n                }\r\n\r\n                // block statements are part of functions and most if statements\r\n                if (closestBlock.type === \"BlockStatement\") {\r\n\r\n                    // find the last item in the block\r\n                    const lastItem = closestBlock.body[closestBlock.body.length - 1];\r\n\r\n                    // if the callback is the last thing in a block that might be ok\r\n                    if (isCallbackExpression(node, lastItem)) {\r\n\r\n                        const parentType = closestBlock.parent.type;\r\n\r\n                        // but only if the block is part of a function\r\n                        if (parentType === \"FunctionExpression\" ||\r\n                            parentType === \"FunctionDeclaration\" ||\r\n                            parentType === \"ArrowFunctionExpression\"\r\n                        ) {\r\n                            return;\r\n                        }\r\n\r\n                    }\r\n\r\n                    // ending a block with a return is also ok\r\n                    if (lastItem.type === \"ReturnStatement\") {\r\n\r\n                        // but only if the callback is immediately before\r\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n                // as long as you're the child of a function at this point you should be asked to return\r\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\r\n                    context.report({ node, messageId: \"missingReturn\" });\r\n                }\r\n\r\n            }\r\n\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}