{"ast":null,"code":"/**\r\n * @fileoverview A rule to control the use of single variable declarations.\r\n * @author Ian Christian Myers\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Determines whether the given node is in a statement list.\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} `true` if the given node is in a statement list\r\n */\n\n\nfunction isInStatementList(node) {\n  return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce variables to be declared either together or separately in functions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/one-var\"\n    },\n    fixable: \"code\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\", \"consecutive\"]\n      }, {\n        type: \"object\",\n        properties: {\n          separateRequires: {\n            type: \"boolean\"\n          },\n          var: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          let: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          const: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          initialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          },\n          uninitialized: {\n            enum: [\"always\", \"never\", \"consecutive\"]\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\n      combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\n      splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\n      splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\n      splitRequires: \"Split requires to be separated into a single block.\",\n      combine: \"Combine this with the previous '{{type}}' statement.\",\n      split: \"Split '{{type}}' declarations into multiple statements.\"\n    }\n  },\n\n  create(context) {\n    const MODE_ALWAYS = \"always\";\n    const MODE_NEVER = \"never\";\n    const MODE_CONSECUTIVE = \"consecutive\";\n    const mode = context.options[0] || MODE_ALWAYS;\n    const options = {};\n\n    if (typeof mode === \"string\") {\n      // simple options configuration with just a string\n      options.var = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.let = {\n        uninitialized: mode,\n        initialized: mode\n      };\n      options.const = {\n        uninitialized: mode,\n        initialized: mode\n      };\n    } else if (typeof mode === \"object\") {\n      // options configuration is an object\n      options.separateRequires = !!mode.separateRequires;\n      options.var = {\n        uninitialized: mode.var,\n        initialized: mode.var\n      };\n      options.let = {\n        uninitialized: mode.let,\n        initialized: mode.let\n      };\n      options.const = {\n        uninitialized: mode.const,\n        initialized: mode.const\n      };\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\n        options.var.uninitialized = mode.uninitialized;\n        options.let.uninitialized = mode.uninitialized;\n        options.const.uninitialized = mode.uninitialized;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\n        options.var.initialized = mode.initialized;\n        options.let.initialized = mode.initialized;\n        options.const.initialized = mode.initialized;\n      }\n    }\n\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    const functionStack = [];\n    const blockStack = [];\n    /**\r\n     * Increments the blockStack counter.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function startBlock() {\n      blockStack.push({\n        let: {\n          initialized: false,\n          uninitialized: false\n        },\n        const: {\n          initialized: false,\n          uninitialized: false\n        }\n      });\n    }\n    /**\r\n     * Increments the functionStack counter.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function startFunction() {\n      functionStack.push({\n        initialized: false,\n        uninitialized: false\n      });\n      startBlock();\n    }\n    /**\r\n     * Decrements the blockStack counter.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function endBlock() {\n      blockStack.pop();\n    }\n    /**\r\n     * Decrements the functionStack counter.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function endFunction() {\n      functionStack.pop();\n      endBlock();\n    }\n    /**\r\n     * Check if a variable declaration is a require.\r\n     * @param {ASTNode} decl variable declaration Node\r\n     * @returns {bool} if decl is a require, return true; else return false.\r\n     * @private\r\n     */\n\n\n    function isRequire(decl) {\n      return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\n    }\n    /**\r\n     * Records whether initialized/uninitialized/required variables are defined in current scope.\r\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n     * @param {ASTNode[]} declarations List of declarations\r\n     * @param {Object} currentScope The scope being investigated\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function recordTypes(statementType, declarations, currentScope) {\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n            currentScope.uninitialized = true;\n          }\n        } else {\n          if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n            if (options.separateRequires && isRequire(declarations[i])) {\n              currentScope.required = true;\n            } else {\n              currentScope.initialized = true;\n            }\n          }\n        }\n      }\n    }\n    /**\r\n     * Determines the current scope (function or block)\r\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n     * @returns {Object} The scope associated with statementType\r\n     */\n\n\n    function getCurrentScope(statementType) {\n      let currentScope;\n\n      if (statementType === \"var\") {\n        currentScope = functionStack[functionStack.length - 1];\n      } else if (statementType === \"let\") {\n        currentScope = blockStack[blockStack.length - 1].let;\n      } else if (statementType === \"const\") {\n        currentScope = blockStack[blockStack.length - 1].const;\n      }\n\n      return currentScope;\n    }\n    /**\r\n     * Counts the number of initialized and uninitialized declarations in a list of declarations\r\n     * @param {ASTNode[]} declarations List of declarations\r\n     * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\r\n     * @private\r\n     */\n\n\n    function countDeclarations(declarations) {\n      const counts = {\n        uninitialized: 0,\n        initialized: 0\n      };\n\n      for (let i = 0; i < declarations.length; i++) {\n        if (declarations[i].init === null) {\n          counts.uninitialized++;\n        } else {\n          counts.initialized++;\n        }\n      }\n\n      return counts;\n    }\n    /**\r\n     * Determines if there is more than one var statement in the current scope.\r\n     * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n     * @param {ASTNode[]} declarations List of declarations\r\n     * @returns {boolean} Returns true if it is the first var declaration, false if not.\r\n     * @private\r\n     */\n\n\n    function hasOnlyOneStatement(statementType, declarations) {\n      const declarationCounts = countDeclarations(declarations);\n      const currentOptions = options[statementType] || {};\n      const currentScope = getCurrentScope(statementType);\n      const hasRequires = declarations.some(isRequire);\n\n      if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n        if (currentScope.uninitialized || currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (declarationCounts.uninitialized > 0) {\n        if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n          return false;\n        }\n      }\n\n      if (declarationCounts.initialized > 0) {\n        if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n          if (!hasRequires) {\n            return false;\n          }\n        }\n      }\n\n      if (currentScope.required && hasRequires) {\n        return false;\n      }\n\n      recordTypes(statementType, declarations, currentScope);\n      return true;\n    }\n    /**\r\n     * Fixer to join VariableDeclaration's into a single declaration\r\n     * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\r\n     * @returns {Function} The fixer function\r\n     */\n\n\n    function joinDeclarations(declarations) {\n      const declaration = declarations[0];\n      const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\n      const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\n      const previousNode = body[currentIndex - 1];\n      return fixer => {\n        const type = sourceCode.getTokenBefore(declaration);\n        const prevSemi = sourceCode.getTokenBefore(type);\n        const res = [];\n\n        if (previousNode && previousNode.kind === sourceCode.getText(type)) {\n          if (prevSemi.value === \";\") {\n            res.push(fixer.replaceText(prevSemi, \",\"));\n          } else {\n            res.push(fixer.insertTextAfter(prevSemi, \",\"));\n          }\n\n          res.push(fixer.replaceText(type, \"\"));\n        }\n\n        return res;\n      };\n    }\n    /**\r\n     * Fixer to split a VariableDeclaration into individual declarations\r\n     * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\r\n     * @returns {Function|null} The fixer function\r\n     */\n\n\n    function splitDeclarations(declaration) {\n      const {\n        parent\n      } = declaration; // don't autofix code such as: if (foo) var x, y;\n\n      if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\n        return null;\n      }\n\n      return fixer => declaration.declarations.map(declarator => {\n        const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\n\n        if (tokenAfterDeclarator === null) {\n          return null;\n        }\n\n        const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {\n          includeComments: true\n        });\n\n        if (tokenAfterDeclarator.value !== \",\") {\n          return null;\n        }\n\n        const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\n        /*\r\n         * `var x,y`\r\n         * tokenAfterDeclarator ^^ afterComma\r\n         */\n\n        if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\n          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\n        }\n        /*\r\n         * `var x,\r\n         * tokenAfterDeclarator ^\r\n         *      y`\r\n         *      ^ afterComma\r\n         */\n\n\n        if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === \"Line\" || afterComma.type === \"Block\") {\n          let lastComment = afterComma;\n\n          while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\n            lastComment = sourceCode.getTokenAfter(lastComment, {\n              includeComments: true\n            });\n          }\n\n          return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);\n        }\n\n        return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\n      }).filter(x => x);\n    }\n    /**\r\n     * Checks a given VariableDeclaration node for errors.\r\n     * @param {ASTNode} node The VariableDeclaration node to check\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function checkVariableDeclaration(node) {\n      const parent = node.parent;\n      const type = node.kind;\n\n      if (!options[type]) {\n        return;\n      }\n\n      const declarations = node.declarations;\n      const declarationCounts = countDeclarations(declarations);\n      const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\n\n      if (options[type].initialized === MODE_ALWAYS) {\n        if (options.separateRequires && mixedRequires) {\n          context.report({\n            node,\n            messageId: \"splitRequires\"\n          });\n        }\n      } // consecutive\n\n\n      const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;\n\n      if (nodeIndex > 0) {\n        const previousNode = parent.body[nodeIndex - 1];\n        const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\n        const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\n\n        if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {\n          const previousDeclCounts = countDeclarations(previousNode.declarations);\n\n          if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\n            context.report({\n              node,\n              messageId: \"combine\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // always\n\n\n      if (!hasOnlyOneStatement(type, declarations)) {\n        if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n          context.report({\n            node,\n            messageId: \"combine\",\n            data: {\n              type\n            },\n            fix: joinDeclarations(declarations)\n          });\n        } else {\n          if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\n            context.report({\n              node,\n              messageId: \"combineInitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n\n          if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\n            if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\n              return;\n            }\n\n            context.report({\n              node,\n              messageId: \"combineUninitialized\",\n              data: {\n                type\n              },\n              fix: joinDeclarations(declarations)\n            });\n          }\n        }\n      } // never\n\n\n      if (parent.type !== \"ForStatement\" || parent.init !== node) {\n        const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n        if (totalDeclarations > 1) {\n          if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n            // both initialized and uninitialized\n            context.report({\n              node,\n              messageId: \"split\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n            // initialized\n            context.report({\n              node,\n              messageId: \"splitInitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n            // uninitialized\n            context.report({\n              node,\n              messageId: \"splitUninitialized\",\n              data: {\n                type\n              },\n              fix: splitDeclarations(node)\n            });\n          }\n        }\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      Program: startFunction,\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      StaticBlock: startFunction,\n      // StaticBlock creates a new scope for `var` variables\n      BlockStatement: startBlock,\n      ForStatement: startBlock,\n      ForInStatement: startBlock,\n      ForOfStatement: startBlock,\n      SwitchStatement: startBlock,\n      VariableDeclaration: checkVariableDeclaration,\n      \"ForStatement:exit\": endBlock,\n      \"ForOfStatement:exit\": endBlock,\n      \"ForInStatement:exit\": endBlock,\n      \"SwitchStatement:exit\": endBlock,\n      \"BlockStatement:exit\": endBlock,\n      \"Program:exit\": endFunction,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction,\n      \"StaticBlock:exit\": endFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/one-var.js"],"names":["astUtils","require","isInStatementList","node","STATEMENT_LIST_PARENTS","has","parent","type","module","exports","meta","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","separateRequires","var","let","const","additionalProperties","initialized","uninitialized","messages","combineUninitialized","combineInitialized","splitUninitialized","splitInitialized","splitRequires","combine","split","create","context","MODE_ALWAYS","MODE_NEVER","MODE_CONSECUTIVE","mode","options","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","functionStack","blockStack","startBlock","push","startFunction","endBlock","pop","endFunction","isRequire","decl","init","callee","name","recordTypes","statementType","declarations","currentScope","i","length","required","getCurrentScope","countDeclarations","counts","hasOnlyOneStatement","declarationCounts","currentOptions","hasRequires","some","joinDeclarations","declaration","body","Array","isArray","currentIndex","findIndex","range","previousNode","fixer","getTokenBefore","prevSemi","res","kind","getText","value","replaceText","insertTextAfter","splitDeclarations","map","declarator","tokenAfterDeclarator","getTokenAfter","afterComma","includeComments","exportPlacement","loc","start","line","end","lastComment","replaceTextRange","text","slice","filter","x","checkVariableDeclaration","mixedRequires","every","report","messageId","nodeIndex","indexOf","isPreviousNodeDeclaration","declarationsWithPrevious","concat","previousDeclCounts","data","fix","left","totalDeclarations","Program","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","StaticBlock","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","VariableDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to control the use of single variable declarations.\r\n * @author Ian Christian Myers\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Determines whether the given node is in a statement list.\r\n * @param {ASTNode} node node to check\r\n * @returns {boolean} `true` if the given node is in a statement list\r\n */\r\nfunction isInStatementList(node) {\r\n    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce variables to be declared either together or separately in functions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/one-var\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"always\", \"never\", \"consecutive\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            separateRequires: {\r\n                                type: \"boolean\"\r\n                            },\r\n                            var: {\r\n                                enum: [\"always\", \"never\", \"consecutive\"]\r\n                            },\r\n                            let: {\r\n                                enum: [\"always\", \"never\", \"consecutive\"]\r\n                            },\r\n                            const: {\r\n                                enum: [\"always\", \"never\", \"consecutive\"]\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            initialized: {\r\n                                enum: [\"always\", \"never\", \"consecutive\"]\r\n                            },\r\n                            uninitialized: {\r\n                                enum: [\"always\", \"never\", \"consecutive\"]\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            combineUninitialized: \"Combine this with the previous '{{type}}' statement with uninitialized variables.\",\r\n            combineInitialized: \"Combine this with the previous '{{type}}' statement with initialized variables.\",\r\n            splitUninitialized: \"Split uninitialized '{{type}}' declarations into multiple statements.\",\r\n            splitInitialized: \"Split initialized '{{type}}' declarations into multiple statements.\",\r\n            splitRequires: \"Split requires to be separated into a single block.\",\r\n            combine: \"Combine this with the previous '{{type}}' statement.\",\r\n            split: \"Split '{{type}}' declarations into multiple statements.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const MODE_ALWAYS = \"always\";\r\n        const MODE_NEVER = \"never\";\r\n        const MODE_CONSECUTIVE = \"consecutive\";\r\n        const mode = context.options[0] || MODE_ALWAYS;\r\n\r\n        const options = {};\r\n\r\n        if (typeof mode === \"string\") { // simple options configuration with just a string\r\n            options.var = { uninitialized: mode, initialized: mode };\r\n            options.let = { uninitialized: mode, initialized: mode };\r\n            options.const = { uninitialized: mode, initialized: mode };\r\n        } else if (typeof mode === \"object\") { // options configuration is an object\r\n            options.separateRequires = !!mode.separateRequires;\r\n            options.var = { uninitialized: mode.var, initialized: mode.var };\r\n            options.let = { uninitialized: mode.let, initialized: mode.let };\r\n            options.const = { uninitialized: mode.const, initialized: mode.const };\r\n            if (Object.prototype.hasOwnProperty.call(mode, \"uninitialized\")) {\r\n                options.var.uninitialized = mode.uninitialized;\r\n                options.let.uninitialized = mode.uninitialized;\r\n                options.const.uninitialized = mode.uninitialized;\r\n            }\r\n            if (Object.prototype.hasOwnProperty.call(mode, \"initialized\")) {\r\n                options.var.initialized = mode.initialized;\r\n                options.let.initialized = mode.initialized;\r\n                options.const.initialized = mode.initialized;\r\n            }\r\n        }\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        const functionStack = [];\r\n        const blockStack = [];\r\n\r\n        /**\r\n         * Increments the blockStack counter.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function startBlock() {\r\n            blockStack.push({\r\n                let: { initialized: false, uninitialized: false },\r\n                const: { initialized: false, uninitialized: false }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Increments the functionStack counter.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function startFunction() {\r\n            functionStack.push({ initialized: false, uninitialized: false });\r\n            startBlock();\r\n        }\r\n\r\n        /**\r\n         * Decrements the blockStack counter.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function endBlock() {\r\n            blockStack.pop();\r\n        }\r\n\r\n        /**\r\n         * Decrements the functionStack counter.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function endFunction() {\r\n            functionStack.pop();\r\n            endBlock();\r\n        }\r\n\r\n        /**\r\n         * Check if a variable declaration is a require.\r\n         * @param {ASTNode} decl variable declaration Node\r\n         * @returns {bool} if decl is a require, return true; else return false.\r\n         * @private\r\n         */\r\n        function isRequire(decl) {\r\n            return decl.init && decl.init.type === \"CallExpression\" && decl.init.callee.name === \"require\";\r\n        }\r\n\r\n        /**\r\n         * Records whether initialized/uninitialized/required variables are defined in current scope.\r\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n         * @param {ASTNode[]} declarations List of declarations\r\n         * @param {Object} currentScope The scope being investigated\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function recordTypes(statementType, declarations, currentScope) {\r\n            for (let i = 0; i < declarations.length; i++) {\r\n                if (declarations[i].init === null) {\r\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\r\n                        currentScope.uninitialized = true;\r\n                    }\r\n                } else {\r\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\r\n                        if (options.separateRequires && isRequire(declarations[i])) {\r\n                            currentScope.required = true;\r\n                        } else {\r\n                            currentScope.initialized = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Determines the current scope (function or block)\r\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n         * @returns {Object} The scope associated with statementType\r\n         */\r\n        function getCurrentScope(statementType) {\r\n            let currentScope;\r\n\r\n            if (statementType === \"var\") {\r\n                currentScope = functionStack[functionStack.length - 1];\r\n            } else if (statementType === \"let\") {\r\n                currentScope = blockStack[blockStack.length - 1].let;\r\n            } else if (statementType === \"const\") {\r\n                currentScope = blockStack[blockStack.length - 1].const;\r\n            }\r\n            return currentScope;\r\n        }\r\n\r\n        /**\r\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\r\n         * @param {ASTNode[]} declarations List of declarations\r\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\r\n         * @private\r\n         */\r\n        function countDeclarations(declarations) {\r\n            const counts = { uninitialized: 0, initialized: 0 };\r\n\r\n            for (let i = 0; i < declarations.length; i++) {\r\n                if (declarations[i].init === null) {\r\n                    counts.uninitialized++;\r\n                } else {\r\n                    counts.initialized++;\r\n                }\r\n            }\r\n            return counts;\r\n        }\r\n\r\n        /**\r\n         * Determines if there is more than one var statement in the current scope.\r\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\r\n         * @param {ASTNode[]} declarations List of declarations\r\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\r\n         * @private\r\n         */\r\n        function hasOnlyOneStatement(statementType, declarations) {\r\n\r\n            const declarationCounts = countDeclarations(declarations);\r\n            const currentOptions = options[statementType] || {};\r\n            const currentScope = getCurrentScope(statementType);\r\n            const hasRequires = declarations.some(isRequire);\r\n\r\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\r\n                if (currentScope.uninitialized || currentScope.initialized) {\r\n                    if (!hasRequires) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (declarationCounts.uninitialized > 0) {\r\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (declarationCounts.initialized > 0) {\r\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\r\n                    if (!hasRequires) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            if (currentScope.required && hasRequires) {\r\n                return false;\r\n            }\r\n            recordTypes(statementType, declarations, currentScope);\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * Fixer to join VariableDeclaration's into a single declaration\r\n         * @param {VariableDeclarator[]} declarations The `VariableDeclaration` to join\r\n         * @returns {Function} The fixer function\r\n         */\r\n        function joinDeclarations(declarations) {\r\n            const declaration = declarations[0];\r\n            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];\r\n            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);\r\n            const previousNode = body[currentIndex - 1];\r\n\r\n            return fixer => {\r\n                const type = sourceCode.getTokenBefore(declaration);\r\n                const prevSemi = sourceCode.getTokenBefore(type);\r\n                const res = [];\r\n\r\n                if (previousNode && previousNode.kind === sourceCode.getText(type)) {\r\n                    if (prevSemi.value === \";\") {\r\n                        res.push(fixer.replaceText(prevSemi, \",\"));\r\n                    } else {\r\n                        res.push(fixer.insertTextAfter(prevSemi, \",\"));\r\n                    }\r\n                    res.push(fixer.replaceText(type, \"\"));\r\n                }\r\n\r\n                return res;\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Fixer to split a VariableDeclaration into individual declarations\r\n         * @param {VariableDeclaration} declaration The `VariableDeclaration` to split\r\n         * @returns {Function|null} The fixer function\r\n         */\r\n        function splitDeclarations(declaration) {\r\n            const { parent } = declaration;\r\n\r\n            // don't autofix code such as: if (foo) var x, y;\r\n            if (!isInStatementList(parent.type === \"ExportNamedDeclaration\" ? parent : declaration)) {\r\n                return null;\r\n            }\r\n\r\n            return fixer => declaration.declarations.map(declarator => {\r\n                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);\r\n\r\n                if (tokenAfterDeclarator === null) {\r\n                    return null;\r\n                }\r\n\r\n                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, { includeComments: true });\r\n\r\n                if (tokenAfterDeclarator.value !== \",\") {\r\n                    return null;\r\n                }\r\n\r\n                const exportPlacement = declaration.parent.type === \"ExportNamedDeclaration\" ? \"export \" : \"\";\r\n\r\n                /*\r\n                 * `var x,y`\r\n                 * tokenAfterDeclarator ^^ afterComma\r\n                 */\r\n                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {\r\n                    return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);\r\n                }\r\n\r\n                /*\r\n                 * `var x,\r\n                 * tokenAfterDeclarator ^\r\n                 *      y`\r\n                 *      ^ afterComma\r\n                 */\r\n                if (\r\n                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||\r\n                    afterComma.type === \"Line\" ||\r\n                    afterComma.type === \"Block\"\r\n                ) {\r\n                    let lastComment = afterComma;\r\n\r\n                    while (lastComment.type === \"Line\" || lastComment.type === \"Block\") {\r\n                        lastComment = sourceCode.getTokenAfter(lastComment, { includeComments: true });\r\n                    }\r\n\r\n                    return fixer.replaceTextRange(\r\n                        [tokenAfterDeclarator.range[0], lastComment.range[0]],\r\n                        `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `\r\n                    );\r\n                }\r\n\r\n                return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);\r\n            }).filter(x => x);\r\n        }\r\n\r\n        /**\r\n         * Checks a given VariableDeclaration node for errors.\r\n         * @param {ASTNode} node The VariableDeclaration node to check\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkVariableDeclaration(node) {\r\n            const parent = node.parent;\r\n            const type = node.kind;\r\n\r\n            if (!options[type]) {\r\n                return;\r\n            }\r\n\r\n            const declarations = node.declarations;\r\n            const declarationCounts = countDeclarations(declarations);\r\n            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);\r\n\r\n            if (options[type].initialized === MODE_ALWAYS) {\r\n                if (options.separateRequires && mixedRequires) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"splitRequires\"\r\n                    });\r\n                }\r\n            }\r\n\r\n            // consecutive\r\n            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;\r\n\r\n            if (nodeIndex > 0) {\r\n                const previousNode = parent.body[nodeIndex - 1];\r\n                const isPreviousNodeDeclaration = previousNode.type === \"VariableDeclaration\";\r\n                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);\r\n\r\n                if (\r\n                    isPreviousNodeDeclaration &&\r\n                    previousNode.kind === type &&\r\n                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))\r\n                ) {\r\n                    const previousDeclCounts = countDeclarations(previousNode.declarations);\r\n\r\n                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"combine\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: joinDeclarations(declarations)\r\n                        });\r\n                    } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"combineInitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: joinDeclarations(declarations)\r\n                        });\r\n                    } else if (options[type].uninitialized === MODE_CONSECUTIVE &&\r\n                            declarationCounts.uninitialized > 0 &&\r\n                            previousDeclCounts.uninitialized > 0) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"combineUninitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: joinDeclarations(declarations)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // always\r\n            if (!hasOnlyOneStatement(type, declarations)) {\r\n                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"combine\",\r\n                        data: {\r\n                            type\r\n                        },\r\n                        fix: joinDeclarations(declarations)\r\n                    });\r\n                } else {\r\n                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"combineInitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: joinDeclarations(declarations)\r\n                        });\r\n                    }\r\n                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {\r\n                        if (node.parent.left === node && (node.parent.type === \"ForInStatement\" || node.parent.type === \"ForOfStatement\")) {\r\n                            return;\r\n                        }\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"combineUninitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: joinDeclarations(declarations)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // never\r\n            if (parent.type !== \"ForStatement\" || parent.init !== node) {\r\n                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\r\n\r\n                if (totalDeclarations > 1) {\r\n                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\r\n\r\n                        // both initialized and uninitialized\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"split\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: splitDeclarations(node)\r\n                        });\r\n                    } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\r\n\r\n                        // initialized\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"splitInitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: splitDeclarations(node)\r\n                        });\r\n                    } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\r\n\r\n                        // uninitialized\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"splitUninitialized\",\r\n                            data: {\r\n                                type\r\n                            },\r\n                            fix: splitDeclarations(node)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            Program: startFunction,\r\n            FunctionDeclaration: startFunction,\r\n            FunctionExpression: startFunction,\r\n            ArrowFunctionExpression: startFunction,\r\n            StaticBlock: startFunction, // StaticBlock creates a new scope for `var` variables\r\n\r\n            BlockStatement: startBlock,\r\n            ForStatement: startBlock,\r\n            ForInStatement: startBlock,\r\n            ForOfStatement: startBlock,\r\n            SwitchStatement: startBlock,\r\n            VariableDeclaration: checkVariableDeclaration,\r\n            \"ForStatement:exit\": endBlock,\r\n            \"ForOfStatement:exit\": endBlock,\r\n            \"ForInStatement:exit\": endBlock,\r\n            \"SwitchStatement:exit\": endBlock,\r\n            \"BlockStatement:exit\": endBlock,\r\n\r\n            \"Program:exit\": endFunction,\r\n            \"FunctionDeclaration:exit\": endFunction,\r\n            \"FunctionExpression:exit\": endFunction,\r\n            \"ArrowFunctionExpression:exit\": endFunction,\r\n            \"StaticBlock:exit\": endFunction\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}