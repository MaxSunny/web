{"ast":null,"code":"/**\r\n * @fileoverview Common utils for AST.\r\n * @author Gyandeep Singh\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst esutils = require(\"esutils\");\n\nconst espree = require(\"espree\");\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst {\n  breakableTypePattern,\n  createGlobalLinebreakMatcher,\n  lineBreakPattern,\n  shebangPattern\n} = require(\"../../shared/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\nconst arrayOrTypedArrayPattern = /Array$/u;\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\nconst thisTagPattern = /^[\\s*]*@this/mu;\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]); // A set of node types that can contain a list of statements\n\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"StaticBlock\", \"SwitchCase\"]);\nconst DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u; // Tests the presence of at least one LegacyOctalEscapeSequence or NonOctalDecimalEscapeSequence in a raw string\n\nconst OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su;\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\n/**\r\n * Checks reference if is non initializer and writable.\r\n * @param {Reference} reference A reference to check.\r\n * @param {int} index The index of the reference in the references.\r\n * @param {Reference[]} references The array that the reference belongs to.\r\n * @returns {boolean} Success/Failure\r\n * @private\r\n */\n\nfunction isModifyingReference(reference, index, references) {\n  const identifier = reference.identifier;\n  /*\r\n   * Destructuring assignments can have multiple default value, so\r\n   * possibly there are multiple writeable references for the same\r\n   * identifier.\r\n   */\n\n  const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;\n  return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;\n}\n/**\r\n * Checks whether the given string starts with uppercase or not.\r\n * @param {string} s The string to check.\r\n * @returns {boolean} `true` if the string starts with uppercase.\r\n */\n\n\nfunction startsWithUpperCase(s) {\n  return s[0] !== s[0].toLocaleLowerCase();\n}\n/**\r\n * Checks whether or not a node is a constructor.\r\n * @param {ASTNode} node A function node to check.\r\n * @returns {boolean} Whether or not a node is a constructor.\r\n */\n\n\nfunction isES5Constructor(node) {\n  return node.id && startsWithUpperCase(node.id.name);\n}\n/**\r\n * Finds a function node from ancestors of a node.\r\n * @param {ASTNode} node A start node to find.\r\n * @returns {Node|null} A found function node.\r\n */\n\n\nfunction getUpperFunction(node) {\n  for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\n    if (anyFunctionPattern.test(currentNode.type)) {\n      return currentNode;\n    }\n  }\n\n  return null;\n}\n/**\r\n * Checks whether a given node is a function node or not.\r\n * The following types are function nodes:\r\n *\r\n * - ArrowFunctionExpression\r\n * - FunctionDeclaration\r\n * - FunctionExpression\r\n * @param {ASTNode|null} node A node to check.\r\n * @returns {boolean} `true` if the node is a function node.\r\n */\n\n\nfunction isFunction(node) {\n  return Boolean(node && anyFunctionPattern.test(node.type));\n}\n/**\r\n * Checks whether a given node is a loop node or not.\r\n * The following types are loop nodes:\r\n *\r\n * - DoWhileStatement\r\n * - ForInStatement\r\n * - ForOfStatement\r\n * - ForStatement\r\n * - WhileStatement\r\n * @param {ASTNode|null} node A node to check.\r\n * @returns {boolean} `true` if the node is a loop node.\r\n */\n\n\nfunction isLoop(node) {\n  return Boolean(node && anyLoopPattern.test(node.type));\n}\n/**\r\n * Checks whether the given node is in a loop or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is in a loop.\r\n */\n\n\nfunction isInLoop(node) {\n  for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\n    if (isLoop(currentNode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * Determines whether the given node is a `null` literal.\r\n * @param {ASTNode} node The node to check\r\n * @returns {boolean} `true` if the node is a `null` literal\r\n */\n\n\nfunction isNullLiteral(node) {\n  /*\r\n   * Checking `node.value === null` does not guarantee that a literal is a null literal.\r\n   * When parsing values that cannot be represented in the current environment (e.g. unicode\r\n   * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\r\n   * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\r\n   * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\r\n   */\n  return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\n}\n/**\r\n * Checks whether or not a node is `null` or `undefined`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\r\n * @public\r\n */\n\n\nfunction isNullOrUndefined(node) {\n  return isNullLiteral(node) || node.type === \"Identifier\" && node.name === \"undefined\" || node.type === \"UnaryExpression\" && node.operator === \"void\";\n}\n/**\r\n * Checks whether or not a node is callee.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is callee.\r\n */\n\n\nfunction isCallee(node) {\n  return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n/**\r\n * Returns the result of the string conversion applied to the evaluated value of the given expression node,\r\n * if it can be determined statically.\r\n *\r\n * This function returns a `string` value for all `Literal` nodes and simple `TemplateLiteral` nodes only.\r\n * In all other cases, this function returns `null`.\r\n * @param {ASTNode} node Expression node.\r\n * @returns {string|null} String value if it can be determined. Otherwise, `null`.\r\n */\n\n\nfunction getStaticStringValue(node) {\n  switch (node.type) {\n    case \"Literal\":\n      if (node.value === null) {\n        if (isNullLiteral(node)) {\n          return String(node.value); // \"null\"\n        }\n\n        if (node.regex) {\n          return `/${node.regex.pattern}/${node.regex.flags}`;\n        }\n\n        if (node.bigint) {\n          return node.bigint;\n        } // Otherwise, this is an unknown literal. The function will return null.\n\n      } else {\n        return String(node.value);\n      }\n\n      break;\n\n    case \"TemplateLiteral\":\n      if (node.expressions.length === 0 && node.quasis.length === 1) {\n        return node.quasis[0].value.cooked;\n      }\n\n      break;\n    // no default\n  }\n\n  return null;\n}\n/**\r\n * Gets the property name of a given node.\r\n * The node can be a MemberExpression, a Property, or a MethodDefinition.\r\n *\r\n * If the name is dynamic, this returns `null`.\r\n *\r\n * For examples:\r\n *\r\n *     a.b           // => \"b\"\r\n *     a[\"b\"]        // => \"b\"\r\n *     a['b']        // => \"b\"\r\n *     a[`b`]        // => \"b\"\r\n *     a[100]        // => \"100\"\r\n *     a[b]          // => null\r\n *     a[\"a\" + \"b\"]  // => null\r\n *     a[tag`b`]     // => null\r\n *     a[`${b}`]     // => null\r\n *\r\n *     let a = {b: 1}            // => \"b\"\r\n *     let a = {[\"b\"]: 1}        // => \"b\"\r\n *     let a = {['b']: 1}        // => \"b\"\r\n *     let a = {[`b`]: 1}        // => \"b\"\r\n *     let a = {[100]: 1}        // => \"100\"\r\n *     let a = {[b]: 1}          // => null\r\n *     let a = {[\"a\" + \"b\"]: 1}  // => null\r\n *     let a = {[tag`b`]: 1}     // => null\r\n *     let a = {[`${b}`]: 1}     // => null\r\n * @param {ASTNode} node The node to get.\r\n * @returns {string|null} The property name if static. Otherwise, null.\r\n */\n\n\nfunction getStaticPropertyName(node) {\n  let prop;\n\n  switch (node && node.type) {\n    case \"ChainExpression\":\n      return getStaticPropertyName(node.expression);\n\n    case \"Property\":\n    case \"PropertyDefinition\":\n    case \"MethodDefinition\":\n      prop = node.key;\n      break;\n\n    case \"MemberExpression\":\n      prop = node.property;\n      break;\n    // no default\n  }\n\n  if (prop) {\n    if (prop.type === \"Identifier\" && !node.computed) {\n      return prop.name;\n    }\n\n    return getStaticStringValue(prop);\n  }\n\n  return null;\n}\n/**\r\n * Retrieve `ChainExpression#expression` value if the given node a `ChainExpression` node. Otherwise, pass through it.\r\n * @param {ASTNode} node The node to address.\r\n * @returns {ASTNode} The `ChainExpression#expression` value if the node is a `ChainExpression` node. Otherwise, the node.\r\n */\n\n\nfunction skipChainExpression(node) {\n  return node && node.type === \"ChainExpression\" ? node.expression : node;\n}\n/**\r\n * Check if the `actual` is an expected value.\r\n * @param {string} actual The string value to check.\r\n * @param {string | RegExp} expected The expected string value or pattern.\r\n * @returns {boolean} `true` if the `actual` is an expected value.\r\n */\n\n\nfunction checkText(actual, expected) {\n  return typeof expected === \"string\" ? actual === expected : expected.test(actual);\n}\n/**\r\n * Check if a given node is an Identifier node with a given name.\r\n * @param {ASTNode} node The node to check.\r\n * @param {string | RegExp} name The expected name or the expected pattern of the object name.\r\n * @returns {boolean} `true` if the node is an Identifier node with the name.\r\n */\n\n\nfunction isSpecificId(node, name) {\n  return node.type === \"Identifier\" && checkText(node.name, name);\n}\n/**\r\n * Check if a given node is member access with a given object name and property name pair.\r\n * This is regardless of optional or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {string | RegExp | null} objectName The expected name or the expected pattern of the object name. If this is nullish, this method doesn't check object.\r\n * @param {string | RegExp | null} propertyName The expected name or the expected pattern of the property name. If this is nullish, this method doesn't check property.\r\n * @returns {boolean} `true` if the node is member access with the object name and property name pair.\r\n * The node is a `MemberExpression` or `ChainExpression`.\r\n */\n\n\nfunction isSpecificMemberAccess(node, objectName, propertyName) {\n  const checkNode = skipChainExpression(node);\n\n  if (checkNode.type !== \"MemberExpression\") {\n    return false;\n  }\n\n  if (objectName && !isSpecificId(checkNode.object, objectName)) {\n    return false;\n  }\n\n  if (propertyName) {\n    const actualPropertyName = getStaticPropertyName(checkNode);\n\n    if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Check if two literal nodes are the same value.\r\n * @param {ASTNode} left The Literal node to compare.\r\n * @param {ASTNode} right The other Literal node to compare.\r\n * @returns {boolean} `true` if the two literal nodes are the same value.\r\n */\n\n\nfunction equalLiteralValue(left, right) {\n  // RegExp literal.\n  if (left.regex || right.regex) {\n    return Boolean(left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags);\n  } // BigInt literal.\n\n\n  if (left.bigint || right.bigint) {\n    return left.bigint === right.bigint;\n  }\n\n  return left.value === right.value;\n}\n/**\r\n * Check if two expressions reference the same value. For example:\r\n *     a = a\r\n *     a.b = a.b\r\n *     a[0] = a[0]\r\n *     a['b'] = a['b']\r\n * @param {ASTNode} left The left side of the comparison.\r\n * @param {ASTNode} right The right side of the comparison.\r\n * @param {boolean} [disableStaticComputedKey] Don't address `a.b` and `a[\"b\"]` are the same if `true`. For backward compatibility.\r\n * @returns {boolean} `true` if both sides match and reference the same value.\r\n */\n\n\nfunction isSameReference(left, right) {\n  let disableStaticComputedKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (left.type !== right.type) {\n    // Handle `a.b` and `a?.b` are samely.\n    if (left.type === \"ChainExpression\") {\n      return isSameReference(left.expression, right, disableStaticComputedKey);\n    }\n\n    if (right.type === \"ChainExpression\") {\n      return isSameReference(left, right.expression, disableStaticComputedKey);\n    }\n\n    return false;\n  }\n\n  switch (left.type) {\n    case \"Super\":\n    case \"ThisExpression\":\n      return true;\n\n    case \"Identifier\":\n    case \"PrivateIdentifier\":\n      return left.name === right.name;\n\n    case \"Literal\":\n      return equalLiteralValue(left, right);\n\n    case \"ChainExpression\":\n      return isSameReference(left.expression, right.expression, disableStaticComputedKey);\n\n    case \"MemberExpression\":\n      {\n        if (!disableStaticComputedKey) {\n          const nameA = getStaticPropertyName(left); // x.y = x[\"y\"]\n\n          if (nameA !== null) {\n            return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);\n          }\n        }\n        /*\r\n         * x[0] = x[0]\r\n         * x[y] = x[y]\r\n         * x.y = x.y\r\n         */\n\n\n        return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);\n      }\n\n    default:\n      return false;\n  }\n}\n/**\r\n * Checks whether or not a node is `Reflect.apply`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\r\n */\n\n\nfunction isReflectApply(node) {\n  return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\n}\n/**\r\n * Checks whether or not a node is `Array.from`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `Array.from`.\r\n */\n\n\nfunction isArrayFromMethod(node) {\n  return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, \"from\");\n}\n/**\r\n * Checks whether or not a node is a method which has `thisArg`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\r\n */\n\n\nfunction isMethodWhichHasThisArg(node) {\n  return isSpecificMemberAccess(node, null, arrayMethodPattern);\n}\n/**\r\n * Creates the negate function of the given function.\r\n * @param {Function} f The function to negate.\r\n * @returns {Function} Negated function.\r\n */\n\n\nfunction negate(f) {\n  return token => !f(token);\n}\n/**\r\n * Checks whether or not a node has a `@this` tag in its comments.\r\n * @param {ASTNode} node A node to check.\r\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\r\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\r\n */\n\n\nfunction hasJSDocThisTag(node, sourceCode) {\n  const jsdocComment = sourceCode.getJSDocComment(node);\n\n  if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n    return true;\n  } // Checks `@this` in its leading comments for callbacks,\n  // because callbacks don't have its JSDoc comment.\n  // e.g.\n  //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n\n\n  return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\n}\n/**\r\n * Determines if a node is surrounded by parentheses.\r\n * @param {SourceCode} sourceCode The ESLint source code object\r\n * @param {ASTNode} node The node to be checked.\r\n * @returns {boolean} True if the node is parenthesised.\r\n * @private\r\n */\n\n\nfunction isParenthesised(sourceCode, node) {\n  const previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n  return Boolean(previousToken && nextToken) && previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] && nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n/**\r\n * Checks if the given token is a `=` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `=` token.\r\n */\n\n\nfunction isEqToken(token) {\n  return token.value === \"=\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is an arrow token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an arrow token.\r\n */\n\n\nfunction isArrowToken(token) {\n  return token.value === \"=>\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a comma token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a comma token.\r\n */\n\n\nfunction isCommaToken(token) {\n  return token.value === \",\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a dot token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a dot token.\r\n */\n\n\nfunction isDotToken(token) {\n  return token.value === \".\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a `?.` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `?.` token.\r\n */\n\n\nfunction isQuestionDotToken(token) {\n  return token.value === \"?.\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a semicolon token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a semicolon token.\r\n */\n\n\nfunction isSemicolonToken(token) {\n  return token.value === \";\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a colon token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a colon token.\r\n */\n\n\nfunction isColonToken(token) {\n  return token.value === \":\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is an opening parenthesis token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening parenthesis token.\r\n */\n\n\nfunction isOpeningParenToken(token) {\n  return token.value === \"(\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a closing parenthesis token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing parenthesis token.\r\n */\n\n\nfunction isClosingParenToken(token) {\n  return token.value === \")\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is an opening square bracket token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening square bracket token.\r\n */\n\n\nfunction isOpeningBracketToken(token) {\n  return token.value === \"[\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a closing square bracket token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing square bracket token.\r\n */\n\n\nfunction isClosingBracketToken(token) {\n  return token.value === \"]\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is an opening brace token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening brace token.\r\n */\n\n\nfunction isOpeningBraceToken(token) {\n  return token.value === \"{\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a closing brace token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing brace token.\r\n */\n\n\nfunction isClosingBraceToken(token) {\n  return token.value === \"}\" && token.type === \"Punctuator\";\n}\n/**\r\n * Checks if the given token is a comment token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a comment token.\r\n */\n\n\nfunction isCommentToken(token) {\n  return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\n}\n/**\r\n * Checks if the given token is a keyword token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a keyword token.\r\n */\n\n\nfunction isKeywordToken(token) {\n  return token.type === \"Keyword\";\n}\n/**\r\n * Gets the `(` token of the given function node.\r\n * @param {ASTNode} node The function node to get.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token} `(` token.\r\n */\n\n\nfunction getOpeningParenOfParams(node, sourceCode) {\n  // If the node is an arrow function and doesn't have parens, this returns the identifier of the first param.\n  if (node.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    const argToken = sourceCode.getFirstToken(node.params[0]);\n    const maybeParenToken = sourceCode.getTokenBefore(argToken);\n    return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;\n  } // Otherwise, returns paren.\n\n\n  return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);\n}\n/**\r\n * Checks whether or not the tokens of two given nodes are same.\r\n * @param {ASTNode} left A node 1 to compare.\r\n * @param {ASTNode} right A node 2 to compare.\r\n * @param {SourceCode} sourceCode The ESLint source code object.\r\n * @returns {boolean} the source code for the given node.\r\n */\n\n\nfunction equalTokens(left, right, sourceCode) {\n  const tokensL = sourceCode.getTokens(left);\n  const tokensR = sourceCode.getTokens(right);\n\n  if (tokensL.length !== tokensR.length) {\n    return false;\n  }\n\n  for (let i = 0; i < tokensL.length; ++i) {\n    if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Check if the given node is a true logical expression or not.\r\n *\r\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\r\n * coalesce (`??`) are known as `ShortCircuitExpression`.\r\n * But ESTree represents those by `LogicalExpression` node.\r\n *\r\n * This function rejects coalesce expressions of `LogicalExpression` node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is `&&` or `||`.\r\n * @see https://tc39.es/ecma262/#prod-ShortCircuitExpression\r\n */\n\n\nfunction isLogicalExpression(node) {\n  return node.type === \"LogicalExpression\" && (node.operator === \"&&\" || node.operator === \"||\");\n}\n/**\r\n * Check if the given node is a nullish coalescing expression or not.\r\n *\r\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\r\n * coalesce (`??`) are known as `ShortCircuitExpression`.\r\n * But ESTree represents those by `LogicalExpression` node.\r\n *\r\n * This function finds only coalesce expressions of `LogicalExpression` node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is `??`.\r\n */\n\n\nfunction isCoalesceExpression(node) {\n  return node.type === \"LogicalExpression\" && node.operator === \"??\";\n}\n/**\r\n * Check if given two nodes are the pair of a logical expression and a coalesce expression.\r\n * @param {ASTNode} left A node to check.\r\n * @param {ASTNode} right Another node to check.\r\n * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.\r\n */\n\n\nfunction isMixedLogicalAndCoalesceExpressions(left, right) {\n  return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);\n}\n/**\r\n * Checks if the given operator is a logical assignment operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} `true` if the operator is a logical assignment operator.\r\n */\n\n\nfunction isLogicalAssignmentOperator(operator) {\n  return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\n}\n/**\r\n * Get the colon token of the given SwitchCase node.\r\n * @param {ASTNode} node The SwitchCase node to get.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token} The colon token of the node.\r\n */\n\n\nfunction getSwitchCaseColonToken(node, sourceCode) {\n  if (node.test) {\n    return sourceCode.getTokenAfter(node.test, isColonToken);\n  }\n\n  return sourceCode.getFirstToken(node, 1);\n}\n/**\r\n * Gets ESM module export name represented by the given node.\r\n * @param {ASTNode} node `Identifier` or string `Literal` node in a position\r\n * that represents a module export name:\r\n *   - `ImportSpecifier#imported`\r\n *   - `ExportSpecifier#local` (if it is a re-export from another module)\r\n *   - `ExportSpecifier#exported`\r\n *   - `ExportAllDeclaration#exported`\r\n * @returns {string} The module export name.\r\n */\n\n\nfunction getModuleExportName(node) {\n  if (node.type === \"Identifier\") {\n    return node.name;\n  } // string literal\n\n\n  return node.value;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  COMMENTS_IGNORE_PATTERN,\n  LINEBREAKS,\n  LINEBREAK_MATCHER: lineBreakPattern,\n  SHEBANG_MATCHER: shebangPattern,\n  STATEMENT_LIST_PARENTS,\n\n  /**\r\n   * Determines whether two adjacent tokens are on the same line.\r\n   * @param {Object} left The left token object.\r\n   * @param {Object} right The right token object.\r\n   * @returns {boolean} Whether or not the tokens are on the same line.\r\n   * @public\r\n   */\n  isTokenOnSameLine(left, right) {\n    return left.loc.end.line === right.loc.start.line;\n  },\n\n  isNullOrUndefined,\n  isCallee,\n  isES5Constructor,\n  getUpperFunction,\n  isFunction,\n  isLoop,\n  isInLoop,\n  isArrayFromMethod,\n  isParenthesised,\n  createGlobalLinebreakMatcher,\n  equalTokens,\n  isArrowToken,\n  isClosingBraceToken,\n  isClosingBracketToken,\n  isClosingParenToken,\n  isColonToken,\n  isCommaToken,\n  isCommentToken,\n  isDotToken,\n  isQuestionDotToken,\n  isKeywordToken,\n  isNotClosingBraceToken: negate(isClosingBraceToken),\n  isNotClosingBracketToken: negate(isClosingBracketToken),\n  isNotClosingParenToken: negate(isClosingParenToken),\n  isNotColonToken: negate(isColonToken),\n  isNotCommaToken: negate(isCommaToken),\n  isNotDotToken: negate(isDotToken),\n  isNotQuestionDotToken: negate(isQuestionDotToken),\n  isNotOpeningBraceToken: negate(isOpeningBraceToken),\n  isNotOpeningBracketToken: negate(isOpeningBracketToken),\n  isNotOpeningParenToken: negate(isOpeningParenToken),\n  isNotSemicolonToken: negate(isSemicolonToken),\n  isOpeningBraceToken,\n  isOpeningBracketToken,\n  isOpeningParenToken,\n  isSemicolonToken,\n  isEqToken,\n\n  /**\r\n   * Checks whether or not a given node is a string literal.\r\n   * @param {ASTNode} node A node to check.\r\n   * @returns {boolean} `true` if the node is a string literal.\r\n   */\n  isStringLiteral(node) {\n    return node.type === \"Literal\" && typeof node.value === \"string\" || node.type === \"TemplateLiteral\";\n  },\n\n  /**\r\n   * Checks whether a given node is a breakable statement or not.\r\n   * The node is breakable if the node is one of the following type:\r\n   *\r\n   * - DoWhileStatement\r\n   * - ForInStatement\r\n   * - ForOfStatement\r\n   * - ForStatement\r\n   * - SwitchStatement\r\n   * - WhileStatement\r\n   * @param {ASTNode} node A node to check.\r\n   * @returns {boolean} `true` if the node is breakable.\r\n   */\n  isBreakableStatement(node) {\n    return breakableTypePattern.test(node.type);\n  },\n\n  /**\r\n   * Gets references which are non initializer and writable.\r\n   * @param {Reference[]} references An array of references.\r\n   * @returns {Reference[]} An array of only references which are non initializer and writable.\r\n   * @public\r\n   */\n  getModifyingReferences(references) {\n    return references.filter(isModifyingReference);\n  },\n\n  /**\r\n   * Validate that a string passed in is surrounded by the specified character\r\n   * @param {string} val The text to check.\r\n   * @param {string} character The character to see if it's surrounded by.\r\n   * @returns {boolean} True if the text is surrounded by the character, false if not.\r\n   * @private\r\n   */\n  isSurroundedBy(val, character) {\n    return val[0] === character && val[val.length - 1] === character;\n  },\n\n  /**\r\n   * Returns whether the provided node is an ESLint directive comment or not\r\n   * @param {Line|Block} node The comment token to be checked\r\n   * @returns {boolean} `true` if the node is an ESLint directive comment\r\n   */\n  isDirectiveComment(node) {\n    const comment = node.value.trim();\n    return node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 || node.type === \"Block\" && (comment.indexOf(\"global \") === 0 || comment.indexOf(\"eslint \") === 0 || comment.indexOf(\"eslint-\") === 0);\n  },\n\n  /**\r\n   * Gets the trailing statement of a given node.\r\n   *\r\n   *     if (code)\r\n   *         consequent;\r\n   *\r\n   * When taking this `IfStatement`, returns `consequent;` statement.\r\n   * @param {ASTNode} A node to get.\r\n   * @returns {ASTNode|null} The trailing statement's node.\r\n   */\n  getTrailingStatement: esutils.ast.trailingStatement,\n\n  /**\r\n   * Finds the variable by a given name in a given scope and its upper scopes.\r\n   * @param {eslint-scope.Scope} initScope A scope to start find.\r\n   * @param {string} name A variable name to find.\r\n   * @returns {eslint-scope.Variable|null} A found variable or `null`.\r\n   */\n  getVariableByName(initScope, name) {\n    let scope = initScope;\n\n    while (scope) {\n      const variable = scope.set.get(name);\n\n      if (variable) {\n        return variable;\n      }\n\n      scope = scope.upper;\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Checks whether or not a given function node is the default `this` binding.\r\n   *\r\n   * First, this checks the node:\r\n   *\r\n   * - The given node is not in `PropertyDefinition#value` position.\r\n   * - The given node is not `StaticBlock`.\r\n   * - The function name does not start with uppercase. It's a convention to capitalize the names\r\n   *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\r\n   * - The function does not have a JSDoc comment that has a @this tag.\r\n   *\r\n   * Next, this checks the location of the node.\r\n   * If the location is below, this judges `this` is valid.\r\n   *\r\n   * - The location is not on an object literal.\r\n   * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\r\n   *   functions only, as the name of the variable is considered to be the name of the function in this case.\r\n   *   This check is not performed if `capIsConstructor` is set to `false`.\r\n   * - The location is not on an ES2015 class.\r\n   * - Its `bind`/`call`/`apply` method is not called directly.\r\n   * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\r\n   * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`\r\n   * or any expression that is `PropertyDefinition#value` node.\r\n   * @param {SourceCode} sourceCode A SourceCode instance to get comments.\r\n   * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\r\n   * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\r\n   * @returns {boolean} The function node is the default `this` binding.\r\n   */\n  isDefaultThisBinding(node, sourceCode) {\n    let {\n      capIsConstructor = true\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /*\r\n     * Class field initializers are implicit functions, but ESTree doesn't have the AST node of field initializers.\r\n     * Therefore, A expression node at `PropertyDefinition#value` is a function.\r\n     * In this case, `this` is always not default binding.\r\n     */\n    if (node.parent.type === \"PropertyDefinition\" && node.parent.value === node) {\n      return false;\n    } // Class static blocks are implicit functions. In this case, `this` is always not default binding.\n\n\n    if (node.type === \"StaticBlock\") {\n      return false;\n    }\n\n    if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n      return false;\n    }\n\n    const isAnonymous = node.id === null;\n    let currentNode = node;\n\n    while (currentNode) {\n      const parent = currentNode.parent;\n\n      switch (parent.type) {\n        /*\r\n         * Looks up the destination.\r\n         * e.g., obj.foo = nativeFoo || function foo() { ... };\r\n         */\n        case \"LogicalExpression\":\n        case \"ConditionalExpression\":\n        case \"ChainExpression\":\n          currentNode = parent;\n          break;\n\n        /*\r\n         * If the upper function is IIFE, checks the destination of the return value.\r\n         * e.g.\r\n         *   obj.foo = (function() {\r\n         *     // setup...\r\n         *     return function foo() { ... };\r\n         *   })();\r\n         *   obj.foo = (() =>\r\n         *     function foo() { ... }\r\n         *   )();\r\n         */\n\n        case \"ReturnStatement\":\n          {\n            const func = getUpperFunction(parent);\n\n            if (func === null || !isCallee(func)) {\n              return true;\n            }\n\n            currentNode = func.parent;\n            break;\n          }\n\n        case \"ArrowFunctionExpression\":\n          if (currentNode !== parent.body || !isCallee(parent)) {\n            return true;\n          }\n\n          currentNode = parent.parent;\n          break;\n\n        /*\r\n         * e.g.\r\n         *   var obj = { foo() { ... } };\r\n         *   var obj = { foo: function() { ... } };\r\n         *   class A { constructor() { ... } }\r\n         *   class A { foo() { ... } }\r\n         *   class A { get foo() { ... } }\r\n         *   class A { set foo() { ... } }\r\n         *   class A { static foo() { ... } }\r\n         *   class A { foo = function() { ... } }\r\n         */\n\n        case \"Property\":\n        case \"PropertyDefinition\":\n        case \"MethodDefinition\":\n          return parent.value !== currentNode;\n\n        /*\r\n         * e.g.\r\n         *   obj.foo = function foo() { ... };\r\n         *   Foo = function() { ... };\r\n         *   [obj.foo = function foo() { ... }] = a;\r\n         *   [Foo = function() { ... }] = a;\r\n         */\n\n        case \"AssignmentExpression\":\n        case \"AssignmentPattern\":\n          if (parent.left.type === \"MemberExpression\") {\n            return false;\n          }\n\n          if (capIsConstructor && isAnonymous && parent.left.type === \"Identifier\" && startsWithUpperCase(parent.left.name)) {\n            return false;\n          }\n\n          return true;\n\n        /*\r\n         * e.g.\r\n         *   var Foo = function() { ... };\r\n         */\n\n        case \"VariableDeclarator\":\n          return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === \"Identifier\" && startsWithUpperCase(parent.id.name));\n\n        /*\r\n         * e.g.\r\n         *   var foo = function foo() { ... }.bind(obj);\r\n         *   (function foo() { ... }).call(obj);\r\n         *   (function foo() { ... }).apply(obj, []);\r\n         */\n\n        case \"MemberExpression\":\n          if (parent.object === currentNode && isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)) {\n            const maybeCalleeNode = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n            return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));\n          }\n\n          return true;\n\n        /*\r\n         * e.g.\r\n         *   Reflect.apply(function() {}, obj, []);\r\n         *   Array.from([], function() {}, obj);\r\n         *   list.forEach(function() {}, obj);\r\n         */\n\n        case \"CallExpression\":\n          if (isReflectApply(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n\n          if (isArrayFromMethod(parent.callee)) {\n            return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);\n          }\n\n          if (isMethodWhichHasThisArg(parent.callee)) {\n            return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);\n          }\n\n          return true;\n        // Otherwise `this` is default.\n\n        default:\n          return true;\n      }\n    }\n    /* istanbul ignore next */\n\n\n    return true;\n  },\n\n  /**\r\n   * Get the precedence level based on the node type\r\n   * @param {ASTNode} node node to evaluate\r\n   * @returns {int} precedence level\r\n   * @private\r\n   */\n  getPrecedence(node) {\n    switch (node.type) {\n      case \"SequenceExpression\":\n        return 0;\n\n      case \"AssignmentExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"YieldExpression\":\n        return 1;\n\n      case \"ConditionalExpression\":\n        return 3;\n\n      case \"LogicalExpression\":\n        switch (node.operator) {\n          case \"||\":\n          case \"??\":\n            return 4;\n\n          case \"&&\":\n            return 5;\n          // no default\n        }\n\n      /* falls through */\n\n      case \"BinaryExpression\":\n        switch (node.operator) {\n          case \"|\":\n            return 6;\n\n          case \"^\":\n            return 7;\n\n          case \"&\":\n            return 8;\n\n          case \"==\":\n          case \"!=\":\n          case \"===\":\n          case \"!==\":\n            return 9;\n\n          case \"<\":\n          case \"<=\":\n          case \">\":\n          case \">=\":\n          case \"in\":\n          case \"instanceof\":\n            return 10;\n\n          case \"<<\":\n          case \">>\":\n          case \">>>\":\n            return 11;\n\n          case \"+\":\n          case \"-\":\n            return 12;\n\n          case \"*\":\n          case \"/\":\n          case \"%\":\n            return 13;\n\n          case \"**\":\n            return 15;\n          // no default\n        }\n\n      /* falls through */\n\n      case \"UnaryExpression\":\n      case \"AwaitExpression\":\n        return 16;\n\n      case \"UpdateExpression\":\n        return 17;\n\n      case \"CallExpression\":\n      case \"ChainExpression\":\n      case \"ImportExpression\":\n        return 18;\n\n      case \"NewExpression\":\n        return 19;\n\n      default:\n        return 20;\n    }\n  },\n\n  /**\r\n   * Checks whether the given node is an empty block node or not.\r\n   * @param {ASTNode|null} node The node to check.\r\n   * @returns {boolean} `true` if the node is an empty block.\r\n   */\n  isEmptyBlock(node) {\n    return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\n  },\n\n  /**\r\n   * Checks whether the given node is an empty function node or not.\r\n   * @param {ASTNode|null} node The node to check.\r\n   * @returns {boolean} `true` if the node is an empty function.\r\n   */\n  isEmptyFunction(node) {\n    return isFunction(node) && module.exports.isEmptyBlock(node.body);\n  },\n\n  /**\r\n   * Get directives from directive prologue of a Program or Function node.\r\n   * @param {ASTNode} node The node to check.\r\n   * @returns {ASTNode[]} The directives found in the directive prologue.\r\n   */\n  getDirectivePrologue(node) {\n    const directives = []; // Directive prologues only occur at the top of files or functions.\n\n    if (node.type === \"Program\" || node.type === \"FunctionDeclaration\" || node.type === \"FunctionExpression\" ||\n    /*\r\n     * Do not check arrow functions with implicit return.\r\n     * `() => \"use strict\";` returns the string `\"use strict\"`.\r\n     */\n    node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\") {\n      const statements = node.type === \"Program\" ? node.body : node.body.body;\n\n      for (const statement of statements) {\n        if (statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\") {\n          directives.push(statement);\n        } else {\n          break;\n        }\n      }\n    }\n\n    return directives;\n  },\n\n  /**\r\n   * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\r\n   * after the node will be parsed as a decimal point, rather than a property-access dot.\r\n   * @param {ASTNode} node The node to check.\r\n   * @returns {boolean} `true` if this node is a decimal integer.\r\n   * @example\r\n   *\r\n   * 0         // true\r\n   * 5         // true\r\n   * 50        // true\r\n   * 5_000     // true\r\n   * 1_234_56  // true\r\n   * 08        // true\r\n   * 0192      // true\r\n   * 5.        // false\r\n   * .5        // false\r\n   * 5.0       // false\r\n   * 5.00_00   // false\r\n   * 05        // false\r\n   * 0x5       // false\r\n   * 0b101     // false\r\n   * 0b11_01   // false\r\n   * 0o5       // false\r\n   * 5e0       // false\r\n   * 5e1_000   // false\r\n   * 5n        // false\r\n   * 1_000n    // false\r\n   * \"5\"       // false\r\n   *\r\n   */\n  isDecimalInteger(node) {\n    return node.type === \"Literal\" && typeof node.value === \"number\" && DECIMAL_INTEGER_PATTERN.test(node.raw);\n  },\n\n  /**\r\n   * Determines whether this token is a decimal integer numeric token.\r\n   * This is similar to isDecimalInteger(), but for tokens.\r\n   * @param {Token} token The token to check.\r\n   * @returns {boolean} `true` if this token is a decimal integer.\r\n   */\n  isDecimalIntegerNumericToken(token) {\n    return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\n  },\n\n  /**\r\n   * Gets the name and kind of the given function node.\r\n   *\r\n   * - `function foo() {}`  .................... `function 'foo'`\r\n   * - `(function foo() {})`  .................. `function 'foo'`\r\n   * - `(function() {})`  ...................... `function`\r\n   * - `function* foo() {}`  ................... `generator function 'foo'`\r\n   * - `(function* foo() {})`  ................. `generator function 'foo'`\r\n   * - `(function*() {})`  ..................... `generator function`\r\n   * - `() => {}`  ............................. `arrow function`\r\n   * - `async () => {}`  ....................... `async arrow function`\r\n   * - `({ foo: function foo() {} })`  ......... `method 'foo'`\r\n   * - `({ foo: function() {} })`  ............. `method 'foo'`\r\n   * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\r\n   * - `({ [foo]: function() {} })`  ........... `method`\r\n   * - `({ foo() {} })`  ....................... `method 'foo'`\r\n   * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\r\n   * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\r\n   * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\r\n   * - `({ [foo]: function*() {} })`  .......... `generator method`\r\n   * - `({ *foo() {} })`  ...................... `generator method 'foo'`\r\n   * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\r\n   * - `({ foo: async function() {} })`  ....... `async method 'foo'`\r\n   * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\r\n   * - `({ [foo]: async function() {} })`  ..... `async method`\r\n   * - `({ async foo() {} })`  ................. `async method 'foo'`\r\n   * - `({ get foo() {} })`  ................... `getter 'foo'`\r\n   * - `({ set foo(a) {} })`  .................. `setter 'foo'`\r\n   * - `class A { constructor() {} }`  ......... `constructor`\r\n   * - `class A { foo() {} }`  ................. `method 'foo'`\r\n   * - `class A { *foo() {} }`  ................ `generator method 'foo'`\r\n   * - `class A { async foo() {} }`  ........... `async method 'foo'`\r\n   * - `class A { ['foo']() {} }`  ............. `method 'foo'`\r\n   * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\r\n   * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\r\n   * - `class A { [foo]() {} }`  ............... `method`\r\n   * - `class A { *[foo]() {} }`  .............. `generator method`\r\n   * - `class A { async [foo]() {} }`  ......... `async method`\r\n   * - `class A { get foo() {} }`  ............. `getter 'foo'`\r\n   * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\r\n   * - `class A { static foo() {} }`  .......... `static method 'foo'`\r\n   * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\r\n   * - `class A { static async foo() {} }`  .... `static async method 'foo'`\r\n   * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\r\n   * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\r\n   * - `class A { foo = () => {}; }`  .......... `method 'foo'`\r\n   * - `class A { foo = function() {}; }`  ..... `method 'foo'`\r\n   * - `class A { foo = function bar() {}; }`  . `method 'foo'`\r\n   * - `class A { static foo = () => {}; }`  ... `static method 'foo'`\r\n   * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`\r\n   * - `class A { #foo = () => {}; }`  ......... `private method #foo`\r\n   * - `class A { static #foo = () => {}; }`  .. `static private method #foo`\r\n   * - `class A { '#foo'() {} }`  .............. `method '#foo'`\r\n   * - `class A { #foo() {} }`  ................ `private method #foo`\r\n   * - `class A { static #foo() {} }`  ......... `static private method #foo`\r\n   * @param {ASTNode} node The function node to get.\r\n   * @returns {string} The name and kind of the function node.\r\n   */\n  getFunctionNameWithKind(node) {\n    const parent = node.parent;\n    const tokens = [];\n\n    if (parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      // The proposal uses `static` word consistently before visibility words: https://github.com/tc39/proposal-static-class-features\n      if (parent.static) {\n        tokens.push(\"static\");\n      }\n\n      if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n        tokens.push(\"private\");\n      }\n    }\n\n    if (node.async) {\n      tokens.push(\"async\");\n    }\n\n    if (node.generator) {\n      tokens.push(\"generator\");\n    }\n\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\n      if (parent.kind === \"constructor\") {\n        return \"constructor\";\n      }\n\n      if (parent.kind === \"get\") {\n        tokens.push(\"getter\");\n      } else if (parent.kind === \"set\") {\n        tokens.push(\"setter\");\n      } else {\n        tokens.push(\"method\");\n      }\n    } else if (parent.type === \"PropertyDefinition\") {\n      tokens.push(\"method\");\n    } else {\n      if (node.type === \"ArrowFunctionExpression\") {\n        tokens.push(\"arrow\");\n      }\n\n      tokens.push(\"function\");\n    }\n\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\n        tokens.push(`#${parent.key.name}`);\n      } else {\n        const name = getStaticPropertyName(parent);\n\n        if (name !== null) {\n          tokens.push(`'${name}'`);\n        } else if (node.id) {\n          tokens.push(`'${node.id.name}'`);\n        }\n      }\n    } else if (node.id) {\n      tokens.push(`'${node.id.name}'`);\n    }\n\n    return tokens.join(\" \");\n  },\n\n  /**\r\n   * Gets the location of the given function node for reporting.\r\n   *\r\n   * - `function foo() {}`\r\n   *    ^^^^^^^^^^^^\r\n   * - `(function foo() {})`\r\n   *     ^^^^^^^^^^^^\r\n   * - `(function() {})`\r\n   *     ^^^^^^^^\r\n   * - `function* foo() {}`\r\n   *    ^^^^^^^^^^^^^\r\n   * - `(function* foo() {})`\r\n   *     ^^^^^^^^^^^^^\r\n   * - `(function*() {})`\r\n   *     ^^^^^^^^^\r\n   * - `() => {}`\r\n   *       ^^\r\n   * - `async () => {}`\r\n   *             ^^\r\n   * - `({ foo: function foo() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^\r\n   * - `({ foo: function() {} })`\r\n   *       ^^^^^^^^^^^^^\r\n   * - `({ ['foo']: function() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^\r\n   * - `({ [foo]: function() {} })`\r\n   *       ^^^^^^^^^^^^^^^\r\n   * - `({ foo() {} })`\r\n   *       ^^^\r\n   * - `({ foo: function* foo() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^\r\n   * - `({ foo: function*() {} })`\r\n   *       ^^^^^^^^^^^^^^\r\n   * - `({ ['foo']: function*() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^\r\n   * - `({ [foo]: function*() {} })`\r\n   *       ^^^^^^^^^^^^^^^^\r\n   * - `({ *foo() {} })`\r\n   *       ^^^^\r\n   * - `({ foo: async function foo() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\r\n   * - `({ foo: async function() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^^\r\n   * - `({ ['foo']: async function() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^^^^^^\r\n   * - `({ [foo]: async function() {} })`\r\n   *       ^^^^^^^^^^^^^^^^^^^^^\r\n   * - `({ async foo() {} })`\r\n   *       ^^^^^^^^^\r\n   * - `({ get foo() {} })`\r\n   *       ^^^^^^^\r\n   * - `({ set foo(a) {} })`\r\n   *       ^^^^^^^\r\n   * - `class A { constructor() {} }`\r\n   *              ^^^^^^^^^^^\r\n   * - `class A { foo() {} }`\r\n   *              ^^^\r\n   * - `class A { *foo() {} }`\r\n   *              ^^^^\r\n   * - `class A { async foo() {} }`\r\n   *              ^^^^^^^^^\r\n   * - `class A { ['foo']() {} }`\r\n   *              ^^^^^^^\r\n   * - `class A { *['foo']() {} }`\r\n   *              ^^^^^^^^\r\n   * - `class A { async ['foo']() {} }`\r\n   *              ^^^^^^^^^^^^^\r\n   * - `class A { [foo]() {} }`\r\n   *              ^^^^^\r\n   * - `class A { *[foo]() {} }`\r\n   *              ^^^^^^\r\n   * - `class A { async [foo]() {} }`\r\n   *              ^^^^^^^^^^^\r\n   * - `class A { get foo() {} }`\r\n   *              ^^^^^^^\r\n   * - `class A { set foo(a) {} }`\r\n   *              ^^^^^^^\r\n   * - `class A { static foo() {} }`\r\n   *              ^^^^^^^^^^\r\n   * - `class A { static *foo() {} }`\r\n   *              ^^^^^^^^^^^\r\n   * - `class A { static async foo() {} }`\r\n   *              ^^^^^^^^^^^^^^^^\r\n   * - `class A { static get foo() {} }`\r\n   *              ^^^^^^^^^^^^^^\r\n   * - `class A { static set foo(a) {} }`\r\n   *              ^^^^^^^^^^^^^^\r\n   * - `class A { foo = function() {} }`\r\n   *              ^^^^^^^^^^^^^^\r\n   * - `class A { static foo = function() {} }`\r\n   *              ^^^^^^^^^^^^^^^^^^^^^\r\n   * - `class A { foo = (a, b) => {} }`\r\n   *              ^^^^^^\r\n   * @param {ASTNode} node The function node to get.\r\n   * @param {SourceCode} sourceCode The source code object to get tokens.\r\n   * @returns {string} The location of the function node for reporting.\r\n   */\n  getFunctionHeadLoc(node, sourceCode) {\n    const parent = node.parent;\n    let start = null;\n    let end = null;\n\n    if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\n      start = parent.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    } else if (node.type === \"ArrowFunctionExpression\") {\n      const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\n      start = arrowToken.loc.start;\n      end = arrowToken.loc.end;\n    } else {\n      start = node.loc.start;\n      end = getOpeningParenOfParams(node, sourceCode).loc.start;\n    }\n\n    return {\n      start: Object.assign({}, start),\n      end: Object.assign({}, end)\n    };\n  },\n\n  /**\r\n   * Gets next location when the result is not out of bound, otherwise returns null.\r\n   *\r\n   * Assumptions:\r\n   *\r\n   * - The given location represents a valid location in the given source code.\r\n   * - Columns are 0-based.\r\n   * - Lines are 1-based.\r\n   * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.\r\n   * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.\r\n   *   The start (column 0) of that extra line is considered to be a valid location.\r\n   *\r\n   * Examples of successive locations (line, column):\r\n   *\r\n   * code: foo\r\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null\r\n   *\r\n   * code: foo<LF>\r\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\r\n   *\r\n   * code: foo<CR><LF>\r\n   * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\r\n   *\r\n   * code: a<LF>b\r\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null\r\n   *\r\n   * code: a<LF>b<LF>\r\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\r\n   *\r\n   * code: a<CR><LF>b<CR><LF>\r\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\r\n   *\r\n   * code: a<LF><LF>\r\n   * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null\r\n   *\r\n   * code: <LF>\r\n   * locations: (1, 0) -> (2, 0) -> null\r\n   *\r\n   * code:\r\n   * locations: (1, 0) -> null\r\n   * @param {SourceCode} sourceCode The sourceCode\r\n   * @param {{line: number, column: number}} location The location\r\n   * @returns {{line: number, column: number} | null} Next location\r\n   */\n  getNextLocation(sourceCode, _ref) {\n    let {\n      line,\n      column\n    } = _ref;\n\n    if (column < sourceCode.lines[line - 1].length) {\n      return {\n        line,\n        column: column + 1\n      };\n    }\n\n    if (line < sourceCode.lines.length) {\n      return {\n        line: line + 1,\n        column: 0\n      };\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\r\n   * surrounding the node.\r\n   * @param {SourceCode} sourceCode The source code object\r\n   * @param {ASTNode} node An expression node\r\n   * @returns {string} The text representing the node, with all surrounding parentheses included\r\n   */\n  getParenthesisedText(sourceCode, node) {\n    let leftToken = sourceCode.getFirstToken(node);\n    let rightToken = sourceCode.getLastToken(node);\n\n    while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" && sourceCode.getTokenBefore(leftToken).value === \"(\" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" && sourceCode.getTokenAfter(rightToken).value === \")\") {\n      leftToken = sourceCode.getTokenBefore(leftToken);\n      rightToken = sourceCode.getTokenAfter(rightToken);\n    }\n\n    return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\n  },\n\n  /**\r\n   * Determine if a node has a possibility to be an Error object\r\n   * @param {ASTNode} node ASTNode to check\r\n   * @returns {boolean} True if there is a chance it contains an Error obj\r\n   */\n  couldBeError(node) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"CallExpression\":\n      case \"NewExpression\":\n      case \"MemberExpression\":\n      case \"TaggedTemplateExpression\":\n      case \"YieldExpression\":\n      case \"AwaitExpression\":\n      case \"ChainExpression\":\n        return true;\n      // possibly an error object.\n\n      case \"AssignmentExpression\":\n        if ([\"=\", \"&&=\"].includes(node.operator)) {\n          return module.exports.couldBeError(node.right);\n        }\n\n        if ([\"||=\", \"??=\"].includes(node.operator)) {\n          return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n        }\n        /**\r\n         * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\r\n         * An assignment expression with a mathematical operator can either evaluate to a primitive value,\r\n         * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.\r\n         */\n\n\n        return false;\n\n      case \"SequenceExpression\":\n        {\n          const exprs = node.expressions;\n          return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\n        }\n\n      case \"LogicalExpression\":\n        /*\r\n         * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it\r\n         * doesn't short-circuit, it takes the value from the right side, so the right side must always be\r\n         * a plausible error. A future improvement could verify that the left side could be truthy by\r\n         * excluding falsy literals.\r\n         */\n        if (node.operator === \"&&\") {\n          return module.exports.couldBeError(node.right);\n        }\n\n        return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\n\n      case \"ConditionalExpression\":\n        return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a given node is a numeric literal or not.\r\n   * @param {ASTNode} node The node to check.\r\n   * @returns {boolean} `true` if the node is a number or bigint literal.\r\n   */\n  isNumericLiteral(node) {\n    return node.type === \"Literal\" && (typeof node.value === \"number\" || Boolean(node.bigint));\n  },\n\n  /**\r\n   * Determines whether two tokens can safely be placed next to each other without merging into a single token\r\n   * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\r\n   * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\r\n   * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\r\n   * next to each other, behavior is undefined (although it should return `true` in most cases).\r\n   */\n  canTokensBeAdjacent(leftValue, rightValue) {\n    const espreeOptions = {\n      ecmaVersion: espree.latestEcmaVersion,\n      comment: true,\n      range: true\n    };\n    let leftToken;\n\n    if (typeof leftValue === \"string\") {\n      let tokens;\n\n      try {\n        tokens = espree.tokenize(leftValue, espreeOptions);\n      } catch {\n        return false;\n      }\n\n      const comments = tokens.comments;\n      leftToken = tokens[tokens.length - 1];\n\n      if (comments.length) {\n        const lastComment = comments[comments.length - 1];\n\n        if (lastComment.range[0] > leftToken.range[0]) {\n          leftToken = lastComment;\n        }\n      }\n    } else {\n      leftToken = leftValue;\n    }\n\n    if (leftToken.type === \"Shebang\") {\n      return false;\n    }\n\n    let rightToken;\n\n    if (typeof rightValue === \"string\") {\n      let tokens;\n\n      try {\n        tokens = espree.tokenize(rightValue, espreeOptions);\n      } catch {\n        return false;\n      }\n\n      const comments = tokens.comments;\n      rightToken = tokens[0];\n\n      if (comments.length) {\n        const firstComment = comments[0];\n\n        if (firstComment.range[0] < rightToken.range[0]) {\n          rightToken = firstComment;\n        }\n      }\n    } else {\n      rightToken = rightValue;\n    }\n\n    if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\n      if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\n        const PLUS_TOKENS = new Set([\"+\", \"++\"]);\n        const MINUS_TOKENS = new Set([\"-\", \"--\"]);\n        return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));\n      }\n\n      if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\n        return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\n      }\n\n      return true;\n    }\n\n    if (leftToken.type === \"String\" || rightToken.type === \"String\" || leftToken.type === \"Template\" || rightToken.type === \"Template\") {\n      return true;\n    }\n\n    if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\n      return true;\n    }\n\n    if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\n      return true;\n    }\n\n    if (rightToken.type === \"PrivateIdentifier\") {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Get the `loc` object of a given name in a `/*globals` directive comment.\r\n   * @param {SourceCode} sourceCode The source code to convert index to loc.\r\n   * @param {Comment} comment The `/*globals` directive comment which include the name.\r\n   * @param {string} name The name to find.\r\n   * @returns {SourceLocation} The `loc` object.\r\n   */\n  getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\n    const namePattern = new RegExp(`[\\\\s,]${escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\"); // To ignore the first text \"global\".\n\n    namePattern.lastIndex = comment.value.indexOf(\"global\") + 6; // Search a given variable name.\n\n    const match = namePattern.exec(comment.value); // Convert the index to loc.\n\n    const start = sourceCode.getLocFromIndex(comment.range[0] + \"/*\".length + (match ? match.index + 1 : 0));\n    const end = {\n      line: start.line,\n      column: start.column + (match ? name.length : 1)\n    };\n    return {\n      start,\n      end\n    };\n  },\n\n  /**\r\n   * Determines whether the given raw string contains an octal escape sequence\r\n   * or a non-octal decimal escape sequence (\"\\8\", \"\\9\").\r\n   *\r\n   * \"\\1\", \"\\2\" ... \"\\7\", \"\\8\", \"\\9\"\r\n   * \"\\00\", \"\\01\" ... \"\\07\", \"\\08\", \"\\09\"\r\n   *\r\n   * \"\\0\", when not followed by a digit, is not an octal escape sequence.\r\n   * @param {string} rawString A string in its raw representation.\r\n   * @returns {boolean} `true` if the string contains at least one octal escape sequence\r\n   * or at least one non-octal decimal escape sequence.\r\n   */\n  hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\n    return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);\n  },\n\n  isLogicalExpression,\n  isCoalesceExpression,\n  isMixedLogicalAndCoalesceExpressions,\n  isNullLiteral,\n  getStaticStringValue,\n  getStaticPropertyName,\n  skipChainExpression,\n  isSpecificId,\n  isSpecificMemberAccess,\n  equalLiteralValue,\n  isSameReference,\n  isLogicalAssignmentOperator,\n  getSwitchCaseColonToken,\n  getModuleExportName\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/utils/ast-utils.js"],"names":["esutils","require","espree","escapeRegExp","breakableTypePattern","createGlobalLinebreakMatcher","lineBreakPattern","shebangPattern","anyFunctionPattern","anyLoopPattern","arrayOrTypedArrayPattern","arrayMethodPattern","bindOrCallOrApplyPattern","thisTagPattern","COMMENTS_IGNORE_PATTERN","LINEBREAKS","Set","STATEMENT_LIST_PARENTS","DECIMAL_INTEGER_PATTERN","OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN","LOGICAL_ASSIGNMENT_OPERATORS","isModifyingReference","reference","index","references","identifier","modifyingDifferentIdentifier","init","isWrite","startsWithUpperCase","s","toLocaleLowerCase","isES5Constructor","node","id","name","getUpperFunction","currentNode","parent","test","type","isFunction","Boolean","isLoop","isInLoop","isNullLiteral","value","regex","bigint","isNullOrUndefined","operator","isCallee","callee","getStaticStringValue","String","pattern","flags","expressions","length","quasis","cooked","getStaticPropertyName","prop","expression","key","property","computed","skipChainExpression","checkText","actual","expected","isSpecificId","isSpecificMemberAccess","objectName","propertyName","checkNode","object","actualPropertyName","equalLiteralValue","left","right","isSameReference","disableStaticComputedKey","nameA","isReflectApply","isArrayFromMethod","isMethodWhichHasThisArg","negate","f","token","hasJSDocThisTag","sourceCode","jsdocComment","getJSDocComment","getCommentsBefore","some","comment","isParenthesised","previousToken","getTokenBefore","nextToken","getTokenAfter","range","isEqToken","isArrowToken","isCommaToken","isDotToken","isQuestionDotToken","isSemicolonToken","isColonToken","isOpeningParenToken","isClosingParenToken","isOpeningBracketToken","isClosingBracketToken","isOpeningBraceToken","isClosingBraceToken","isCommentToken","isKeywordToken","getOpeningParenOfParams","params","argToken","getFirstToken","maybeParenToken","equalTokens","tokensL","getTokens","tokensR","i","isLogicalExpression","isCoalesceExpression","isMixedLogicalAndCoalesceExpressions","isLogicalAssignmentOperator","has","getSwitchCaseColonToken","getModuleExportName","module","exports","LINEBREAK_MATCHER","SHEBANG_MATCHER","isTokenOnSameLine","loc","end","line","start","isNotClosingBraceToken","isNotClosingBracketToken","isNotClosingParenToken","isNotColonToken","isNotCommaToken","isNotDotToken","isNotQuestionDotToken","isNotOpeningBraceToken","isNotOpeningBracketToken","isNotOpeningParenToken","isNotSemicolonToken","isStringLiteral","isBreakableStatement","getModifyingReferences","filter","isSurroundedBy","val","character","isDirectiveComment","trim","indexOf","getTrailingStatement","ast","trailingStatement","getVariableByName","initScope","scope","variable","set","get","upper","isDefaultThisBinding","capIsConstructor","isAnonymous","func","body","maybeCalleeNode","arguments","getPrecedence","isEmptyBlock","isEmptyFunction","getDirectivePrologue","directives","statements","statement","push","isDecimalInteger","raw","isDecimalIntegerNumericToken","getFunctionNameWithKind","tokens","static","async","generator","kind","join","getFunctionHeadLoc","arrowToken","Object","assign","getNextLocation","column","lines","getParenthesisedText","leftToken","rightToken","getLastToken","getText","slice","couldBeError","includes","exprs","consequent","alternate","isNumericLiteral","canTokensBeAdjacent","leftValue","rightValue","espreeOptions","ecmaVersion","latestEcmaVersion","tokenize","comments","lastComment","firstComment","PLUS_TOKENS","MINUS_TOKENS","startsWith","getNameLocationInGlobalDirectiveComment","namePattern","RegExp","lastIndex","match","exec","getLocFromIndex","hasOctalOrNonOctalDecimalEscapeSequence","rawString"],"mappings":"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,IAA/B,GAAsClJ,IAAI,CAACkJ,IAAL,CAAUA,IAAnE;;AAEA,WAAK,MAAMS,SAAX,IAAwBD,UAAxB,EAAoC;AAChC,YACIC,SAAS,CAACpJ,IAAV,KAAmB,qBAAnB,IACAoJ,SAAS,CAAC7H,UAAV,CAAqBvB,IAArB,KAA8B,SAFlC,EAGE;AACEkJ,UAAAA,UAAU,CAACG,IAAX,CAAgBD,SAAhB;AACH,SALD,MAKO;AACH;AACH;AACJ;AACJ;;AAED,WAAOF,UAAP;AACH,GAjgBY;;AAogBb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACII,EAAAA,gBAAgB,CAAC7J,IAAD,EAAO;AACnB,WAAOA,IAAI,CAACO,IAAL,KAAc,SAAd,IAA2B,OAAOP,IAAI,CAACa,KAAZ,KAAsB,QAAjD,IACH5B,uBAAuB,CAACqB,IAAxB,CAA6BN,IAAI,CAAC8J,GAAlC,CADJ;AAEH,GAriBY;;AAuiBb;AACJ;AACA;AACA;AACA;AACA;AACIC,EAAAA,4BAA4B,CAACvG,KAAD,EAAQ;AAChC,WAAOA,KAAK,CAACjD,IAAN,KAAe,SAAf,IAA4BtB,uBAAuB,CAACqB,IAAxB,CAA6BkD,KAAK,CAAC3C,KAAnC,CAAnC;AACH,GA/iBY;;AAijBb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACImJ,EAAAA,uBAAuB,CAAChK,IAAD,EAAO;AAC1B,UAAMK,MAAM,GAAGL,IAAI,CAACK,MAApB;AACA,UAAM4J,MAAM,GAAG,EAAf;;AAEA,QAAI5J,MAAM,CAACE,IAAP,KAAgB,kBAAhB,IAAsCF,MAAM,CAACE,IAAP,KAAgB,oBAA1D,EAAgF;AAE5E;AACA,UAAIF,MAAM,CAAC6J,MAAX,EAAmB;AACfD,QAAAA,MAAM,CAACL,IAAP,CAAY,QAAZ;AACH;;AACD,UAAI,CAACvJ,MAAM,CAAC4B,QAAR,IAAoB5B,MAAM,CAAC0B,GAAP,CAAWxB,IAAX,KAAoB,mBAA5C,EAAiE;AAC7D0J,QAAAA,MAAM,CAACL,IAAP,CAAY,SAAZ;AACH;AACJ;;AACD,QAAI5J,IAAI,CAACmK,KAAT,EAAgB;AACZF,MAAAA,MAAM,CAACL,IAAP,CAAY,OAAZ;AACH;;AACD,QAAI5J,IAAI,CAACoK,SAAT,EAAoB;AAChBH,MAAAA,MAAM,CAACL,IAAP,CAAY,WAAZ;AACH;;AAED,QAAIvJ,MAAM,CAACE,IAAP,KAAgB,UAAhB,IAA8BF,MAAM,CAACE,IAAP,KAAgB,kBAAlD,EAAsE;AAClE,UAAIF,MAAM,CAACgK,IAAP,KAAgB,aAApB,EAAmC;AAC/B,eAAO,aAAP;AACH;;AACD,UAAIhK,MAAM,CAACgK,IAAP,KAAgB,KAApB,EAA2B;AACvBJ,QAAAA,MAAM,CAACL,IAAP,CAAY,QAAZ;AACH,OAFD,MAEO,IAAIvJ,MAAM,CAACgK,IAAP,KAAgB,KAApB,EAA2B;AAC9BJ,QAAAA,MAAM,CAACL,IAAP,CAAY,QAAZ;AACH,OAFM,MAEA;AACHK,QAAAA,MAAM,CAACL,IAAP,CAAY,QAAZ;AACH;AACJ,KAXD,MAWO,IAAIvJ,MAAM,CAACE,IAAP,KAAgB,oBAApB,EAA0C;AAC7C0J,MAAAA,MAAM,CAACL,IAAP,CAAY,QAAZ;AACH,KAFM,MAEA;AACH,UAAI5J,IAAI,CAACO,IAAL,KAAc,yBAAlB,EAA6C;AACzC0J,QAAAA,MAAM,CAACL,IAAP,CAAY,OAAZ;AACH;;AACDK,MAAAA,MAAM,CAACL,IAAP,CAAY,UAAZ;AACH;;AAED,QAAIvJ,MAAM,CAACE,IAAP,KAAgB,UAAhB,IAA8BF,MAAM,CAACE,IAAP,KAAgB,kBAA9C,IAAoEF,MAAM,CAACE,IAAP,KAAgB,oBAAxF,EAA8G;AAC1G,UAAI,CAACF,MAAM,CAAC4B,QAAR,IAAoB5B,MAAM,CAAC0B,GAAP,CAAWxB,IAAX,KAAoB,mBAA5C,EAAiE;AAC7D0J,QAAAA,MAAM,CAACL,IAAP,CAAa,IAAGvJ,MAAM,CAAC0B,GAAP,CAAW7B,IAAK,EAAhC;AACH,OAFD,MAEO;AACH,cAAMA,IAAI,GAAG0B,qBAAqB,CAACvB,MAAD,CAAlC;;AAEA,YAAIH,IAAI,KAAK,IAAb,EAAmB;AACf+J,UAAAA,MAAM,CAACL,IAAP,CAAa,IAAG1J,IAAK,GAArB;AACH,SAFD,MAEO,IAAIF,IAAI,CAACC,EAAT,EAAa;AAChBgK,UAAAA,MAAM,CAACL,IAAP,CAAa,IAAG5J,IAAI,CAACC,EAAL,CAAQC,IAAK,GAA7B;AACH;AACJ;AACJ,KAZD,MAYO,IAAIF,IAAI,CAACC,EAAT,EAAa;AAChBgK,MAAAA,MAAM,CAACL,IAAP,CAAa,IAAG5J,IAAI,CAACC,EAAL,CAAQC,IAAK,GAA7B;AACH;;AAED,WAAO+J,MAAM,CAACK,IAAP,CAAY,GAAZ,CAAP;AACH,GArqBY;;AAuqBb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,kBAAkB,CAACvK,IAAD,EAAO0D,UAAP,EAAmB;AACjC,UAAMrD,MAAM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","sourcesContent":["/**\r\n * @fileoverview Common utils for AST.\r\n * @author Gyandeep Singh\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst esutils = require(\"esutils\");\r\nconst espree = require(\"espree\");\r\nconst escapeRegExp = require(\"escape-string-regexp\");\r\nconst {\r\n    breakableTypePattern,\r\n    createGlobalLinebreakMatcher,\r\n    lineBreakPattern,\r\n    shebangPattern\r\n} = require(\"../../shared/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;\r\nconst anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;\r\nconst arrayOrTypedArrayPattern = /Array$/u;\r\nconst arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;\r\nconst bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;\r\nconst thisTagPattern = /^[\\s*]*@this/mu;\r\n\r\n\r\nconst COMMENTS_IGNORE_PATTERN = /^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs)/u;\r\nconst LINEBREAKS = new Set([\"\\r\\n\", \"\\r\", \"\\n\", \"\\u2028\", \"\\u2029\"]);\r\n\r\n// A set of node types that can contain a list of statements\r\nconst STATEMENT_LIST_PARENTS = new Set([\"Program\", \"BlockStatement\", \"StaticBlock\", \"SwitchCase\"]);\r\n\r\nconst DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\\d*|[1-9](?:_?\\d)*)$/u;\r\n\r\n// Tests the presence of at least one LegacyOctalEscapeSequence or NonOctalDecimalEscapeSequence in a raw string\r\nconst OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\\\]|\\\\.)*\\\\(?:[1-9]|0[0-9])/su;\r\n\r\nconst LOGICAL_ASSIGNMENT_OPERATORS = new Set([\"&&=\", \"||=\", \"??=\"]);\r\n\r\n/**\r\n * Checks reference if is non initializer and writable.\r\n * @param {Reference} reference A reference to check.\r\n * @param {int} index The index of the reference in the references.\r\n * @param {Reference[]} references The array that the reference belongs to.\r\n * @returns {boolean} Success/Failure\r\n * @private\r\n */\r\nfunction isModifyingReference(reference, index, references) {\r\n    const identifier = reference.identifier;\r\n\r\n    /*\r\n     * Destructuring assignments can have multiple default value, so\r\n     * possibly there are multiple writeable references for the same\r\n     * identifier.\r\n     */\r\n    const modifyingDifferentIdentifier = index === 0 ||\r\n        references[index - 1].identifier !== identifier;\r\n\r\n    return (identifier &&\r\n        reference.init === false &&\r\n        reference.isWrite() &&\r\n        modifyingDifferentIdentifier\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether the given string starts with uppercase or not.\r\n * @param {string} s The string to check.\r\n * @returns {boolean} `true` if the string starts with uppercase.\r\n */\r\nfunction startsWithUpperCase(s) {\r\n    return s[0] !== s[0].toLocaleLowerCase();\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a constructor.\r\n * @param {ASTNode} node A function node to check.\r\n * @returns {boolean} Whether or not a node is a constructor.\r\n */\r\nfunction isES5Constructor(node) {\r\n    return (node.id && startsWithUpperCase(node.id.name));\r\n}\r\n\r\n/**\r\n * Finds a function node from ancestors of a node.\r\n * @param {ASTNode} node A start node to find.\r\n * @returns {Node|null} A found function node.\r\n */\r\nfunction getUpperFunction(node) {\r\n    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {\r\n        if (anyFunctionPattern.test(currentNode.type)) {\r\n            return currentNode;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a function node or not.\r\n * The following types are function nodes:\r\n *\r\n * - ArrowFunctionExpression\r\n * - FunctionDeclaration\r\n * - FunctionExpression\r\n * @param {ASTNode|null} node A node to check.\r\n * @returns {boolean} `true` if the node is a function node.\r\n */\r\nfunction isFunction(node) {\r\n    return Boolean(node && anyFunctionPattern.test(node.type));\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a loop node or not.\r\n * The following types are loop nodes:\r\n *\r\n * - DoWhileStatement\r\n * - ForInStatement\r\n * - ForOfStatement\r\n * - ForStatement\r\n * - WhileStatement\r\n * @param {ASTNode|null} node A node to check.\r\n * @returns {boolean} `true` if the node is a loop node.\r\n */\r\nfunction isLoop(node) {\r\n    return Boolean(node && anyLoopPattern.test(node.type));\r\n}\r\n\r\n/**\r\n * Checks whether the given node is in a loop or not.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is in a loop.\r\n */\r\nfunction isInLoop(node) {\r\n    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {\r\n        if (isLoop(currentNode)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Determines whether the given node is a `null` literal.\r\n * @param {ASTNode} node The node to check\r\n * @returns {boolean} `true` if the node is a `null` literal\r\n */\r\nfunction isNullLiteral(node) {\r\n\r\n    /*\r\n     * Checking `node.value === null` does not guarantee that a literal is a null literal.\r\n     * When parsing values that cannot be represented in the current environment (e.g. unicode\r\n     * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to\r\n     * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check\r\n     * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020\r\n     */\r\n    return node.type === \"Literal\" && node.value === null && !node.regex && !node.bigint;\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is `null` or `undefined`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\r\n * @public\r\n */\r\nfunction isNullOrUndefined(node) {\r\n    return (\r\n        isNullLiteral(node) ||\r\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\r\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is callee.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is callee.\r\n */\r\nfunction isCallee(node) {\r\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\r\n}\r\n\r\n/**\r\n * Returns the result of the string conversion applied to the evaluated value of the given expression node,\r\n * if it can be determined statically.\r\n *\r\n * This function returns a `string` value for all `Literal` nodes and simple `TemplateLiteral` nodes only.\r\n * In all other cases, this function returns `null`.\r\n * @param {ASTNode} node Expression node.\r\n * @returns {string|null} String value if it can be determined. Otherwise, `null`.\r\n */\r\nfunction getStaticStringValue(node) {\r\n    switch (node.type) {\r\n        case \"Literal\":\r\n            if (node.value === null) {\r\n                if (isNullLiteral(node)) {\r\n                    return String(node.value); // \"null\"\r\n                }\r\n                if (node.regex) {\r\n                    return `/${node.regex.pattern}/${node.regex.flags}`;\r\n                }\r\n                if (node.bigint) {\r\n                    return node.bigint;\r\n                }\r\n\r\n                // Otherwise, this is an unknown literal. The function will return null.\r\n\r\n            } else {\r\n                return String(node.value);\r\n            }\r\n            break;\r\n        case \"TemplateLiteral\":\r\n            if (node.expressions.length === 0 && node.quasis.length === 1) {\r\n                return node.quasis[0].value.cooked;\r\n            }\r\n            break;\r\n\r\n            // no default\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Gets the property name of a given node.\r\n * The node can be a MemberExpression, a Property, or a MethodDefinition.\r\n *\r\n * If the name is dynamic, this returns `null`.\r\n *\r\n * For examples:\r\n *\r\n *     a.b           // => \"b\"\r\n *     a[\"b\"]        // => \"b\"\r\n *     a['b']        // => \"b\"\r\n *     a[`b`]        // => \"b\"\r\n *     a[100]        // => \"100\"\r\n *     a[b]          // => null\r\n *     a[\"a\" + \"b\"]  // => null\r\n *     a[tag`b`]     // => null\r\n *     a[`${b}`]     // => null\r\n *\r\n *     let a = {b: 1}            // => \"b\"\r\n *     let a = {[\"b\"]: 1}        // => \"b\"\r\n *     let a = {['b']: 1}        // => \"b\"\r\n *     let a = {[`b`]: 1}        // => \"b\"\r\n *     let a = {[100]: 1}        // => \"100\"\r\n *     let a = {[b]: 1}          // => null\r\n *     let a = {[\"a\" + \"b\"]: 1}  // => null\r\n *     let a = {[tag`b`]: 1}     // => null\r\n *     let a = {[`${b}`]: 1}     // => null\r\n * @param {ASTNode} node The node to get.\r\n * @returns {string|null} The property name if static. Otherwise, null.\r\n */\r\nfunction getStaticPropertyName(node) {\r\n    let prop;\r\n\r\n    switch (node && node.type) {\r\n        case \"ChainExpression\":\r\n            return getStaticPropertyName(node.expression);\r\n\r\n        case \"Property\":\r\n        case \"PropertyDefinition\":\r\n        case \"MethodDefinition\":\r\n            prop = node.key;\r\n            break;\r\n\r\n        case \"MemberExpression\":\r\n            prop = node.property;\r\n            break;\r\n\r\n            // no default\r\n    }\r\n\r\n    if (prop) {\r\n        if (prop.type === \"Identifier\" && !node.computed) {\r\n            return prop.name;\r\n        }\r\n\r\n        return getStaticStringValue(prop);\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Retrieve `ChainExpression#expression` value if the given node a `ChainExpression` node. Otherwise, pass through it.\r\n * @param {ASTNode} node The node to address.\r\n * @returns {ASTNode} The `ChainExpression#expression` value if the node is a `ChainExpression` node. Otherwise, the node.\r\n */\r\nfunction skipChainExpression(node) {\r\n    return node && node.type === \"ChainExpression\" ? node.expression : node;\r\n}\r\n\r\n/**\r\n * Check if the `actual` is an expected value.\r\n * @param {string} actual The string value to check.\r\n * @param {string | RegExp} expected The expected string value or pattern.\r\n * @returns {boolean} `true` if the `actual` is an expected value.\r\n */\r\nfunction checkText(actual, expected) {\r\n    return typeof expected === \"string\"\r\n        ? actual === expected\r\n        : expected.test(actual);\r\n}\r\n\r\n/**\r\n * Check if a given node is an Identifier node with a given name.\r\n * @param {ASTNode} node The node to check.\r\n * @param {string | RegExp} name The expected name or the expected pattern of the object name.\r\n * @returns {boolean} `true` if the node is an Identifier node with the name.\r\n */\r\nfunction isSpecificId(node, name) {\r\n    return node.type === \"Identifier\" && checkText(node.name, name);\r\n}\r\n\r\n/**\r\n * Check if a given node is member access with a given object name and property name pair.\r\n * This is regardless of optional or not.\r\n * @param {ASTNode} node The node to check.\r\n * @param {string | RegExp | null} objectName The expected name or the expected pattern of the object name. If this is nullish, this method doesn't check object.\r\n * @param {string | RegExp | null} propertyName The expected name or the expected pattern of the property name. If this is nullish, this method doesn't check property.\r\n * @returns {boolean} `true` if the node is member access with the object name and property name pair.\r\n * The node is a `MemberExpression` or `ChainExpression`.\r\n */\r\nfunction isSpecificMemberAccess(node, objectName, propertyName) {\r\n    const checkNode = skipChainExpression(node);\r\n\r\n    if (checkNode.type !== \"MemberExpression\") {\r\n        return false;\r\n    }\r\n\r\n    if (objectName && !isSpecificId(checkNode.object, objectName)) {\r\n        return false;\r\n    }\r\n\r\n    if (propertyName) {\r\n        const actualPropertyName = getStaticPropertyName(checkNode);\r\n\r\n        if (typeof actualPropertyName !== \"string\" || !checkText(actualPropertyName, propertyName)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if two literal nodes are the same value.\r\n * @param {ASTNode} left The Literal node to compare.\r\n * @param {ASTNode} right The other Literal node to compare.\r\n * @returns {boolean} `true` if the two literal nodes are the same value.\r\n */\r\nfunction equalLiteralValue(left, right) {\r\n\r\n    // RegExp literal.\r\n    if (left.regex || right.regex) {\r\n        return Boolean(\r\n            left.regex &&\r\n            right.regex &&\r\n            left.regex.pattern === right.regex.pattern &&\r\n            left.regex.flags === right.regex.flags\r\n        );\r\n    }\r\n\r\n    // BigInt literal.\r\n    if (left.bigint || right.bigint) {\r\n        return left.bigint === right.bigint;\r\n    }\r\n\r\n    return left.value === right.value;\r\n}\r\n\r\n/**\r\n * Check if two expressions reference the same value. For example:\r\n *     a = a\r\n *     a.b = a.b\r\n *     a[0] = a[0]\r\n *     a['b'] = a['b']\r\n * @param {ASTNode} left The left side of the comparison.\r\n * @param {ASTNode} right The right side of the comparison.\r\n * @param {boolean} [disableStaticComputedKey] Don't address `a.b` and `a[\"b\"]` are the same if `true`. For backward compatibility.\r\n * @returns {boolean} `true` if both sides match and reference the same value.\r\n */\r\nfunction isSameReference(left, right, disableStaticComputedKey = false) {\r\n    if (left.type !== right.type) {\r\n\r\n        // Handle `a.b` and `a?.b` are samely.\r\n        if (left.type === \"ChainExpression\") {\r\n            return isSameReference(left.expression, right, disableStaticComputedKey);\r\n        }\r\n        if (right.type === \"ChainExpression\") {\r\n            return isSameReference(left, right.expression, disableStaticComputedKey);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    switch (left.type) {\r\n        case \"Super\":\r\n        case \"ThisExpression\":\r\n            return true;\r\n\r\n        case \"Identifier\":\r\n        case \"PrivateIdentifier\":\r\n            return left.name === right.name;\r\n        case \"Literal\":\r\n            return equalLiteralValue(left, right);\r\n\r\n        case \"ChainExpression\":\r\n            return isSameReference(left.expression, right.expression, disableStaticComputedKey);\r\n\r\n        case \"MemberExpression\": {\r\n            if (!disableStaticComputedKey) {\r\n                const nameA = getStaticPropertyName(left);\r\n\r\n                // x.y = x[\"y\"]\r\n                if (nameA !== null) {\r\n                    return (\r\n                        isSameReference(left.object, right.object, disableStaticComputedKey) &&\r\n                        nameA === getStaticPropertyName(right)\r\n                    );\r\n                }\r\n            }\r\n\r\n            /*\r\n             * x[0] = x[0]\r\n             * x[y] = x[y]\r\n             * x.y = x.y\r\n             */\r\n            return (\r\n                left.computed === right.computed &&\r\n                isSameReference(left.object, right.object, disableStaticComputedKey) &&\r\n                isSameReference(left.property, right.property, disableStaticComputedKey)\r\n            );\r\n        }\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is `Reflect.apply`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `Reflect.apply`.\r\n */\r\nfunction isReflectApply(node) {\r\n    return isSpecificMemberAccess(node, \"Reflect\", \"apply\");\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is `Array.from`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a `Array.from`.\r\n */\r\nfunction isArrayFromMethod(node) {\r\n    return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, \"from\");\r\n}\r\n\r\n/**\r\n * Checks whether or not a node is a method which has `thisArg`.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\r\n */\r\nfunction isMethodWhichHasThisArg(node) {\r\n    return isSpecificMemberAccess(node, null, arrayMethodPattern);\r\n}\r\n\r\n/**\r\n * Creates the negate function of the given function.\r\n * @param {Function} f The function to negate.\r\n * @returns {Function} Negated function.\r\n */\r\nfunction negate(f) {\r\n    return token => !f(token);\r\n}\r\n\r\n/**\r\n * Checks whether or not a node has a `@this` tag in its comments.\r\n * @param {ASTNode} node A node to check.\r\n * @param {SourceCode} sourceCode A SourceCode instance to get comments.\r\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\r\n */\r\nfunction hasJSDocThisTag(node, sourceCode) {\r\n    const jsdocComment = sourceCode.getJSDocComment(node);\r\n\r\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\r\n        return true;\r\n    }\r\n\r\n    // Checks `@this` in its leading comments for callbacks,\r\n    // because callbacks don't have its JSDoc comment.\r\n    // e.g.\r\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\r\n    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));\r\n}\r\n\r\n/**\r\n * Determines if a node is surrounded by parentheses.\r\n * @param {SourceCode} sourceCode The ESLint source code object\r\n * @param {ASTNode} node The node to be checked.\r\n * @returns {boolean} True if the node is parenthesised.\r\n * @private\r\n */\r\nfunction isParenthesised(sourceCode, node) {\r\n    const previousToken = sourceCode.getTokenBefore(node),\r\n        nextToken = sourceCode.getTokenAfter(node);\r\n\r\n    return Boolean(previousToken && nextToken) &&\r\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\r\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\r\n}\r\n\r\n/**\r\n * Checks if the given token is a `=` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `=` token.\r\n */\r\nfunction isEqToken(token) {\r\n    return token.value === \"=\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is an arrow token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an arrow token.\r\n */\r\nfunction isArrowToken(token) {\r\n    return token.value === \"=>\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a comma token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a comma token.\r\n */\r\nfunction isCommaToken(token) {\r\n    return token.value === \",\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a dot token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a dot token.\r\n */\r\nfunction isDotToken(token) {\r\n    return token.value === \".\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a `?.` token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a `?.` token.\r\n */\r\nfunction isQuestionDotToken(token) {\r\n    return token.value === \"?.\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a semicolon token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a semicolon token.\r\n */\r\nfunction isSemicolonToken(token) {\r\n    return token.value === \";\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a colon token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a colon token.\r\n */\r\nfunction isColonToken(token) {\r\n    return token.value === \":\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is an opening parenthesis token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening parenthesis token.\r\n */\r\nfunction isOpeningParenToken(token) {\r\n    return token.value === \"(\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a closing parenthesis token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing parenthesis token.\r\n */\r\nfunction isClosingParenToken(token) {\r\n    return token.value === \")\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is an opening square bracket token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening square bracket token.\r\n */\r\nfunction isOpeningBracketToken(token) {\r\n    return token.value === \"[\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a closing square bracket token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing square bracket token.\r\n */\r\nfunction isClosingBracketToken(token) {\r\n    return token.value === \"]\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is an opening brace token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is an opening brace token.\r\n */\r\nfunction isOpeningBraceToken(token) {\r\n    return token.value === \"{\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a closing brace token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a closing brace token.\r\n */\r\nfunction isClosingBraceToken(token) {\r\n    return token.value === \"}\" && token.type === \"Punctuator\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a comment token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a comment token.\r\n */\r\nfunction isCommentToken(token) {\r\n    return token.type === \"Line\" || token.type === \"Block\" || token.type === \"Shebang\";\r\n}\r\n\r\n/**\r\n * Checks if the given token is a keyword token or not.\r\n * @param {Token} token The token to check.\r\n * @returns {boolean} `true` if the token is a keyword token.\r\n */\r\nfunction isKeywordToken(token) {\r\n    return token.type === \"Keyword\";\r\n}\r\n\r\n/**\r\n * Gets the `(` token of the given function node.\r\n * @param {ASTNode} node The function node to get.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token} `(` token.\r\n */\r\nfunction getOpeningParenOfParams(node, sourceCode) {\r\n\r\n    // If the node is an arrow function and doesn't have parens, this returns the identifier of the first param.\r\n    if (node.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\r\n        const argToken = sourceCode.getFirstToken(node.params[0]);\r\n        const maybeParenToken = sourceCode.getTokenBefore(argToken);\r\n\r\n        return isOpeningParenToken(maybeParenToken) ? maybeParenToken : argToken;\r\n    }\r\n\r\n    // Otherwise, returns paren.\r\n    return node.id\r\n        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)\r\n        : sourceCode.getFirstToken(node, isOpeningParenToken);\r\n}\r\n\r\n/**\r\n * Checks whether or not the tokens of two given nodes are same.\r\n * @param {ASTNode} left A node 1 to compare.\r\n * @param {ASTNode} right A node 2 to compare.\r\n * @param {SourceCode} sourceCode The ESLint source code object.\r\n * @returns {boolean} the source code for the given node.\r\n */\r\nfunction equalTokens(left, right, sourceCode) {\r\n    const tokensL = sourceCode.getTokens(left);\r\n    const tokensR = sourceCode.getTokens(right);\r\n\r\n    if (tokensL.length !== tokensR.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < tokensL.length; ++i) {\r\n        if (tokensL[i].type !== tokensR[i].type ||\r\n            tokensL[i].value !== tokensR[i].value\r\n        ) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Check if the given node is a true logical expression or not.\r\n *\r\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\r\n * coalesce (`??`) are known as `ShortCircuitExpression`.\r\n * But ESTree represents those by `LogicalExpression` node.\r\n *\r\n * This function rejects coalesce expressions of `LogicalExpression` node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is `&&` or `||`.\r\n * @see https://tc39.es/ecma262/#prod-ShortCircuitExpression\r\n */\r\nfunction isLogicalExpression(node) {\r\n    return (\r\n        node.type === \"LogicalExpression\" &&\r\n            (node.operator === \"&&\" || node.operator === \"||\")\r\n    );\r\n}\r\n\r\n/**\r\n * Check if the given node is a nullish coalescing expression or not.\r\n *\r\n * The three binary expressions logical-or (`||`), logical-and (`&&`), and\r\n * coalesce (`??`) are known as `ShortCircuitExpression`.\r\n * But ESTree represents those by `LogicalExpression` node.\r\n *\r\n * This function finds only coalesce expressions of `LogicalExpression` node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is `??`.\r\n */\r\nfunction isCoalesceExpression(node) {\r\n    return node.type === \"LogicalExpression\" && node.operator === \"??\";\r\n}\r\n\r\n/**\r\n * Check if given two nodes are the pair of a logical expression and a coalesce expression.\r\n * @param {ASTNode} left A node to check.\r\n * @param {ASTNode} right Another node to check.\r\n * @returns {boolean} `true` if the two nodes are the pair of a logical expression and a coalesce expression.\r\n */\r\nfunction isMixedLogicalAndCoalesceExpressions(left, right) {\r\n    return (\r\n        (isLogicalExpression(left) && isCoalesceExpression(right)) ||\r\n            (isCoalesceExpression(left) && isLogicalExpression(right))\r\n    );\r\n}\r\n\r\n/**\r\n * Checks if the given operator is a logical assignment operator.\r\n * @param {string} operator The operator to check.\r\n * @returns {boolean} `true` if the operator is a logical assignment operator.\r\n */\r\nfunction isLogicalAssignmentOperator(operator) {\r\n    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);\r\n}\r\n\r\n/**\r\n * Get the colon token of the given SwitchCase node.\r\n * @param {ASTNode} node The SwitchCase node to get.\r\n * @param {SourceCode} sourceCode The source code object to get tokens.\r\n * @returns {Token} The colon token of the node.\r\n */\r\nfunction getSwitchCaseColonToken(node, sourceCode) {\r\n    if (node.test) {\r\n        return sourceCode.getTokenAfter(node.test, isColonToken);\r\n    }\r\n    return sourceCode.getFirstToken(node, 1);\r\n}\r\n\r\n/**\r\n * Gets ESM module export name represented by the given node.\r\n * @param {ASTNode} node `Identifier` or string `Literal` node in a position\r\n * that represents a module export name:\r\n *   - `ImportSpecifier#imported`\r\n *   - `ExportSpecifier#local` (if it is a re-export from another module)\r\n *   - `ExportSpecifier#exported`\r\n *   - `ExportAllDeclaration#exported`\r\n * @returns {string} The module export name.\r\n */\r\nfunction getModuleExportName(node) {\r\n    if (node.type === \"Identifier\") {\r\n        return node.name;\r\n    }\r\n\r\n    // string literal\r\n    return node.value;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nmodule.exports = {\r\n    COMMENTS_IGNORE_PATTERN,\r\n    LINEBREAKS,\r\n    LINEBREAK_MATCHER: lineBreakPattern,\r\n    SHEBANG_MATCHER: shebangPattern,\r\n    STATEMENT_LIST_PARENTS,\r\n\r\n    /**\r\n     * Determines whether two adjacent tokens are on the same line.\r\n     * @param {Object} left The left token object.\r\n     * @param {Object} right The right token object.\r\n     * @returns {boolean} Whether or not the tokens are on the same line.\r\n     * @public\r\n     */\r\n    isTokenOnSameLine(left, right) {\r\n        return left.loc.end.line === right.loc.start.line;\r\n    },\r\n\r\n    isNullOrUndefined,\r\n    isCallee,\r\n    isES5Constructor,\r\n    getUpperFunction,\r\n    isFunction,\r\n    isLoop,\r\n    isInLoop,\r\n    isArrayFromMethod,\r\n    isParenthesised,\r\n    createGlobalLinebreakMatcher,\r\n    equalTokens,\r\n\r\n    isArrowToken,\r\n    isClosingBraceToken,\r\n    isClosingBracketToken,\r\n    isClosingParenToken,\r\n    isColonToken,\r\n    isCommaToken,\r\n    isCommentToken,\r\n    isDotToken,\r\n    isQuestionDotToken,\r\n    isKeywordToken,\r\n    isNotClosingBraceToken: negate(isClosingBraceToken),\r\n    isNotClosingBracketToken: negate(isClosingBracketToken),\r\n    isNotClosingParenToken: negate(isClosingParenToken),\r\n    isNotColonToken: negate(isColonToken),\r\n    isNotCommaToken: negate(isCommaToken),\r\n    isNotDotToken: negate(isDotToken),\r\n    isNotQuestionDotToken: negate(isQuestionDotToken),\r\n    isNotOpeningBraceToken: negate(isOpeningBraceToken),\r\n    isNotOpeningBracketToken: negate(isOpeningBracketToken),\r\n    isNotOpeningParenToken: negate(isOpeningParenToken),\r\n    isNotSemicolonToken: negate(isSemicolonToken),\r\n    isOpeningBraceToken,\r\n    isOpeningBracketToken,\r\n    isOpeningParenToken,\r\n    isSemicolonToken,\r\n    isEqToken,\r\n\r\n    /**\r\n     * Checks whether or not a given node is a string literal.\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} `true` if the node is a string literal.\r\n     */\r\n    isStringLiteral(node) {\r\n        return (\r\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\r\n            node.type === \"TemplateLiteral\"\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Checks whether a given node is a breakable statement or not.\r\n     * The node is breakable if the node is one of the following type:\r\n     *\r\n     * - DoWhileStatement\r\n     * - ForInStatement\r\n     * - ForOfStatement\r\n     * - ForStatement\r\n     * - SwitchStatement\r\n     * - WhileStatement\r\n     * @param {ASTNode} node A node to check.\r\n     * @returns {boolean} `true` if the node is breakable.\r\n     */\r\n    isBreakableStatement(node) {\r\n        return breakableTypePattern.test(node.type);\r\n    },\r\n\r\n    /**\r\n     * Gets references which are non initializer and writable.\r\n     * @param {Reference[]} references An array of references.\r\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\r\n     * @public\r\n     */\r\n    getModifyingReferences(references) {\r\n        return references.filter(isModifyingReference);\r\n    },\r\n\r\n    /**\r\n     * Validate that a string passed in is surrounded by the specified character\r\n     * @param {string} val The text to check.\r\n     * @param {string} character The character to see if it's surrounded by.\r\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\r\n     * @private\r\n     */\r\n    isSurroundedBy(val, character) {\r\n        return val[0] === character && val[val.length - 1] === character;\r\n    },\r\n\r\n    /**\r\n     * Returns whether the provided node is an ESLint directive comment or not\r\n     * @param {Line|Block} node The comment token to be checked\r\n     * @returns {boolean} `true` if the node is an ESLint directive comment\r\n     */\r\n    isDirectiveComment(node) {\r\n        const comment = node.value.trim();\r\n\r\n        return (\r\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\r\n            node.type === \"Block\" && (\r\n                comment.indexOf(\"global \") === 0 ||\r\n                comment.indexOf(\"eslint \") === 0 ||\r\n                comment.indexOf(\"eslint-\") === 0\r\n            )\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Gets the trailing statement of a given node.\r\n     *\r\n     *     if (code)\r\n     *         consequent;\r\n     *\r\n     * When taking this `IfStatement`, returns `consequent;` statement.\r\n     * @param {ASTNode} A node to get.\r\n     * @returns {ASTNode|null} The trailing statement's node.\r\n     */\r\n    getTrailingStatement: esutils.ast.trailingStatement,\r\n\r\n    /**\r\n     * Finds the variable by a given name in a given scope and its upper scopes.\r\n     * @param {eslint-scope.Scope} initScope A scope to start find.\r\n     * @param {string} name A variable name to find.\r\n     * @returns {eslint-scope.Variable|null} A found variable or `null`.\r\n     */\r\n    getVariableByName(initScope, name) {\r\n        let scope = initScope;\r\n\r\n        while (scope) {\r\n            const variable = scope.set.get(name);\r\n\r\n            if (variable) {\r\n                return variable;\r\n            }\r\n\r\n            scope = scope.upper;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Checks whether or not a given function node is the default `this` binding.\r\n     *\r\n     * First, this checks the node:\r\n     *\r\n     * - The given node is not in `PropertyDefinition#value` position.\r\n     * - The given node is not `StaticBlock`.\r\n     * - The function name does not start with uppercase. It's a convention to capitalize the names\r\n     *   of constructor functions. This check is not performed if `capIsConstructor` is set to `false`.\r\n     * - The function does not have a JSDoc comment that has a @this tag.\r\n     *\r\n     * Next, this checks the location of the node.\r\n     * If the location is below, this judges `this` is valid.\r\n     *\r\n     * - The location is not on an object literal.\r\n     * - The location is not assigned to a variable which starts with an uppercase letter. Applies to anonymous\r\n     *   functions only, as the name of the variable is considered to be the name of the function in this case.\r\n     *   This check is not performed if `capIsConstructor` is set to `false`.\r\n     * - The location is not on an ES2015 class.\r\n     * - Its `bind`/`call`/`apply` method is not called directly.\r\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\r\n     * @param {ASTNode} node A function node to check. It also can be an implicit function, like `StaticBlock`\r\n     * or any expression that is `PropertyDefinition#value` node.\r\n     * @param {SourceCode} sourceCode A SourceCode instance to get comments.\r\n     * @param {boolean} [capIsConstructor = true] `false` disables the assumption that functions which name starts\r\n     * with an uppercase or are assigned to a variable which name starts with an uppercase are constructors.\r\n     * @returns {boolean} The function node is the default `this` binding.\r\n     */\r\n    isDefaultThisBinding(node, sourceCode, { capIsConstructor = true } = {}) {\r\n\r\n        /*\r\n         * Class field initializers are implicit functions, but ESTree doesn't have the AST node of field initializers.\r\n         * Therefore, A expression node at `PropertyDefinition#value` is a function.\r\n         * In this case, `this` is always not default binding.\r\n         */\r\n        if (node.parent.type === \"PropertyDefinition\" && node.parent.value === node) {\r\n            return false;\r\n        }\r\n\r\n        // Class static blocks are implicit functions. In this case, `this` is always not default binding.\r\n        if (node.type === \"StaticBlock\") {\r\n            return false;\r\n        }\r\n\r\n        if (\r\n            (capIsConstructor && isES5Constructor(node)) ||\r\n            hasJSDocThisTag(node, sourceCode)\r\n        ) {\r\n            return false;\r\n        }\r\n        const isAnonymous = node.id === null;\r\n        let currentNode = node;\r\n\r\n        while (currentNode) {\r\n            const parent = currentNode.parent;\r\n\r\n            switch (parent.type) {\r\n\r\n                /*\r\n                 * Looks up the destination.\r\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\r\n                 */\r\n                case \"LogicalExpression\":\r\n                case \"ConditionalExpression\":\r\n                case \"ChainExpression\":\r\n                    currentNode = parent;\r\n                    break;\r\n\r\n                /*\r\n                 * If the upper function is IIFE, checks the destination of the return value.\r\n                 * e.g.\r\n                 *   obj.foo = (function() {\r\n                 *     // setup...\r\n                 *     return function foo() { ... };\r\n                 *   })();\r\n                 *   obj.foo = (() =>\r\n                 *     function foo() { ... }\r\n                 *   )();\r\n                 */\r\n                case \"ReturnStatement\": {\r\n                    const func = getUpperFunction(parent);\r\n\r\n                    if (func === null || !isCallee(func)) {\r\n                        return true;\r\n                    }\r\n                    currentNode = func.parent;\r\n                    break;\r\n                }\r\n                case \"ArrowFunctionExpression\":\r\n                    if (currentNode !== parent.body || !isCallee(parent)) {\r\n                        return true;\r\n                    }\r\n                    currentNode = parent.parent;\r\n                    break;\r\n\r\n                /*\r\n                 * e.g.\r\n                 *   var obj = { foo() { ... } };\r\n                 *   var obj = { foo: function() { ... } };\r\n                 *   class A { constructor() { ... } }\r\n                 *   class A { foo() { ... } }\r\n                 *   class A { get foo() { ... } }\r\n                 *   class A { set foo() { ... } }\r\n                 *   class A { static foo() { ... } }\r\n                 *   class A { foo = function() { ... } }\r\n                 */\r\n                case \"Property\":\r\n                case \"PropertyDefinition\":\r\n                case \"MethodDefinition\":\r\n                    return parent.value !== currentNode;\r\n\r\n                /*\r\n                 * e.g.\r\n                 *   obj.foo = function foo() { ... };\r\n                 *   Foo = function() { ... };\r\n                 *   [obj.foo = function foo() { ... }] = a;\r\n                 *   [Foo = function() { ... }] = a;\r\n                 */\r\n                case \"AssignmentExpression\":\r\n                case \"AssignmentPattern\":\r\n                    if (parent.left.type === \"MemberExpression\") {\r\n                        return false;\r\n                    }\r\n                    if (\r\n                        capIsConstructor &&\r\n                        isAnonymous &&\r\n                        parent.left.type === \"Identifier\" &&\r\n                        startsWithUpperCase(parent.left.name)\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                    return true;\r\n\r\n                /*\r\n                 * e.g.\r\n                 *   var Foo = function() { ... };\r\n                 */\r\n                case \"VariableDeclarator\":\r\n                    return !(\r\n                        capIsConstructor &&\r\n                        isAnonymous &&\r\n                        parent.init === currentNode &&\r\n                        parent.id.type === \"Identifier\" &&\r\n                        startsWithUpperCase(parent.id.name)\r\n                    );\r\n\r\n                /*\r\n                 * e.g.\r\n                 *   var foo = function foo() { ... }.bind(obj);\r\n                 *   (function foo() { ... }).call(obj);\r\n                 *   (function foo() { ... }).apply(obj, []);\r\n                 */\r\n                case \"MemberExpression\":\r\n                    if (\r\n                        parent.object === currentNode &&\r\n                        isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)\r\n                    ) {\r\n                        const maybeCalleeNode = parent.parent.type === \"ChainExpression\"\r\n                            ? parent.parent\r\n                            : parent;\r\n\r\n                        return !(\r\n                            isCallee(maybeCalleeNode) &&\r\n                            maybeCalleeNode.parent.arguments.length >= 1 &&\r\n                            !isNullOrUndefined(maybeCalleeNode.parent.arguments[0])\r\n                        );\r\n                    }\r\n                    return true;\r\n\r\n                /*\r\n                 * e.g.\r\n                 *   Reflect.apply(function() {}, obj, []);\r\n                 *   Array.from([], function() {}, obj);\r\n                 *   list.forEach(function() {}, obj);\r\n                 */\r\n                case \"CallExpression\":\r\n                    if (isReflectApply(parent.callee)) {\r\n                        return (\r\n                            parent.arguments.length !== 3 ||\r\n                            parent.arguments[0] !== currentNode ||\r\n                            isNullOrUndefined(parent.arguments[1])\r\n                        );\r\n                    }\r\n                    if (isArrayFromMethod(parent.callee)) {\r\n                        return (\r\n                            parent.arguments.length !== 3 ||\r\n                            parent.arguments[1] !== currentNode ||\r\n                            isNullOrUndefined(parent.arguments[2])\r\n                        );\r\n                    }\r\n                    if (isMethodWhichHasThisArg(parent.callee)) {\r\n                        return (\r\n                            parent.arguments.length !== 2 ||\r\n                            parent.arguments[0] !== currentNode ||\r\n                            isNullOrUndefined(parent.arguments[1])\r\n                        );\r\n                    }\r\n                    return true;\r\n\r\n                // Otherwise `this` is default.\r\n                default:\r\n                    return true;\r\n            }\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        return true;\r\n    },\r\n\r\n    /**\r\n     * Get the precedence level based on the node type\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {int} precedence level\r\n     * @private\r\n     */\r\n    getPrecedence(node) {\r\n        switch (node.type) {\r\n            case \"SequenceExpression\":\r\n                return 0;\r\n\r\n            case \"AssignmentExpression\":\r\n            case \"ArrowFunctionExpression\":\r\n            case \"YieldExpression\":\r\n                return 1;\r\n\r\n            case \"ConditionalExpression\":\r\n                return 3;\r\n\r\n            case \"LogicalExpression\":\r\n                switch (node.operator) {\r\n                    case \"||\":\r\n                    case \"??\":\r\n                        return 4;\r\n                    case \"&&\":\r\n                        return 5;\r\n\r\n                    // no default\r\n                }\r\n\r\n                /* falls through */\r\n\r\n            case \"BinaryExpression\":\r\n\r\n                switch (node.operator) {\r\n                    case \"|\":\r\n                        return 6;\r\n                    case \"^\":\r\n                        return 7;\r\n                    case \"&\":\r\n                        return 8;\r\n                    case \"==\":\r\n                    case \"!=\":\r\n                    case \"===\":\r\n                    case \"!==\":\r\n                        return 9;\r\n                    case \"<\":\r\n                    case \"<=\":\r\n                    case \">\":\r\n                    case \">=\":\r\n                    case \"in\":\r\n                    case \"instanceof\":\r\n                        return 10;\r\n                    case \"<<\":\r\n                    case \">>\":\r\n                    case \">>>\":\r\n                        return 11;\r\n                    case \"+\":\r\n                    case \"-\":\r\n                        return 12;\r\n                    case \"*\":\r\n                    case \"/\":\r\n                    case \"%\":\r\n                        return 13;\r\n                    case \"**\":\r\n                        return 15;\r\n\r\n                    // no default\r\n                }\r\n\r\n                /* falls through */\r\n\r\n            case \"UnaryExpression\":\r\n            case \"AwaitExpression\":\r\n                return 16;\r\n\r\n            case \"UpdateExpression\":\r\n                return 17;\r\n\r\n            case \"CallExpression\":\r\n            case \"ChainExpression\":\r\n            case \"ImportExpression\":\r\n                return 18;\r\n\r\n            case \"NewExpression\":\r\n                return 19;\r\n\r\n            default:\r\n                return 20;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks whether the given node is an empty block node or not.\r\n     * @param {ASTNode|null} node The node to check.\r\n     * @returns {boolean} `true` if the node is an empty block.\r\n     */\r\n    isEmptyBlock(node) {\r\n        return Boolean(node && node.type === \"BlockStatement\" && node.body.length === 0);\r\n    },\r\n\r\n    /**\r\n     * Checks whether the given node is an empty function node or not.\r\n     * @param {ASTNode|null} node The node to check.\r\n     * @returns {boolean} `true` if the node is an empty function.\r\n     */\r\n    isEmptyFunction(node) {\r\n        return isFunction(node) && module.exports.isEmptyBlock(node.body);\r\n    },\r\n\r\n    /**\r\n     * Get directives from directive prologue of a Program or Function node.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {ASTNode[]} The directives found in the directive prologue.\r\n     */\r\n    getDirectivePrologue(node) {\r\n        const directives = [];\r\n\r\n        // Directive prologues only occur at the top of files or functions.\r\n        if (\r\n            node.type === \"Program\" ||\r\n            node.type === \"FunctionDeclaration\" ||\r\n            node.type === \"FunctionExpression\" ||\r\n\r\n            /*\r\n             * Do not check arrow functions with implicit return.\r\n             * `() => \"use strict\";` returns the string `\"use strict\"`.\r\n             */\r\n            (node.type === \"ArrowFunctionExpression\" && node.body.type === \"BlockStatement\")\r\n        ) {\r\n            const statements = node.type === \"Program\" ? node.body : node.body.body;\r\n\r\n            for (const statement of statements) {\r\n                if (\r\n                    statement.type === \"ExpressionStatement\" &&\r\n                    statement.expression.type === \"Literal\"\r\n                ) {\r\n                    directives.push(statement);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return directives;\r\n    },\r\n\r\n\r\n    /**\r\n     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added\r\n     * after the node will be parsed as a decimal point, rather than a property-access dot.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if this node is a decimal integer.\r\n     * @example\r\n     *\r\n     * 0         // true\r\n     * 5         // true\r\n     * 50        // true\r\n     * 5_000     // true\r\n     * 1_234_56  // true\r\n     * 08        // true\r\n     * 0192      // true\r\n     * 5.        // false\r\n     * .5        // false\r\n     * 5.0       // false\r\n     * 5.00_00   // false\r\n     * 05        // false\r\n     * 0x5       // false\r\n     * 0b101     // false\r\n     * 0b11_01   // false\r\n     * 0o5       // false\r\n     * 5e0       // false\r\n     * 5e1_000   // false\r\n     * 5n        // false\r\n     * 1_000n    // false\r\n     * \"5\"       // false\r\n     *\r\n     */\r\n    isDecimalInteger(node) {\r\n        return node.type === \"Literal\" && typeof node.value === \"number\" &&\r\n            DECIMAL_INTEGER_PATTERN.test(node.raw);\r\n    },\r\n\r\n    /**\r\n     * Determines whether this token is a decimal integer numeric token.\r\n     * This is similar to isDecimalInteger(), but for tokens.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} `true` if this token is a decimal integer.\r\n     */\r\n    isDecimalIntegerNumericToken(token) {\r\n        return token.type === \"Numeric\" && DECIMAL_INTEGER_PATTERN.test(token.value);\r\n    },\r\n\r\n    /**\r\n     * Gets the name and kind of the given function node.\r\n     *\r\n     * - `function foo() {}`  .................... `function 'foo'`\r\n     * - `(function foo() {})`  .................. `function 'foo'`\r\n     * - `(function() {})`  ...................... `function`\r\n     * - `function* foo() {}`  ................... `generator function 'foo'`\r\n     * - `(function* foo() {})`  ................. `generator function 'foo'`\r\n     * - `(function*() {})`  ..................... `generator function`\r\n     * - `() => {}`  ............................. `arrow function`\r\n     * - `async () => {}`  ....................... `async arrow function`\r\n     * - `({ foo: function foo() {} })`  ......... `method 'foo'`\r\n     * - `({ foo: function() {} })`  ............. `method 'foo'`\r\n     * - `({ ['foo']: function() {} })`  ......... `method 'foo'`\r\n     * - `({ [foo]: function() {} })`  ........... `method`\r\n     * - `({ foo() {} })`  ....................... `method 'foo'`\r\n     * - `({ foo: function* foo() {} })`  ........ `generator method 'foo'`\r\n     * - `({ foo: function*() {} })`  ............ `generator method 'foo'`\r\n     * - `({ ['foo']: function*() {} })`  ........ `generator method 'foo'`\r\n     * - `({ [foo]: function*() {} })`  .......... `generator method`\r\n     * - `({ *foo() {} })`  ...................... `generator method 'foo'`\r\n     * - `({ foo: async function foo() {} })`  ... `async method 'foo'`\r\n     * - `({ foo: async function() {} })`  ....... `async method 'foo'`\r\n     * - `({ ['foo']: async function() {} })`  ... `async method 'foo'`\r\n     * - `({ [foo]: async function() {} })`  ..... `async method`\r\n     * - `({ async foo() {} })`  ................. `async method 'foo'`\r\n     * - `({ get foo() {} })`  ................... `getter 'foo'`\r\n     * - `({ set foo(a) {} })`  .................. `setter 'foo'`\r\n     * - `class A { constructor() {} }`  ......... `constructor`\r\n     * - `class A { foo() {} }`  ................. `method 'foo'`\r\n     * - `class A { *foo() {} }`  ................ `generator method 'foo'`\r\n     * - `class A { async foo() {} }`  ........... `async method 'foo'`\r\n     * - `class A { ['foo']() {} }`  ............. `method 'foo'`\r\n     * - `class A { *['foo']() {} }`  ............ `generator method 'foo'`\r\n     * - `class A { async ['foo']() {} }`  ....... `async method 'foo'`\r\n     * - `class A { [foo]() {} }`  ............... `method`\r\n     * - `class A { *[foo]() {} }`  .............. `generator method`\r\n     * - `class A { async [foo]() {} }`  ......... `async method`\r\n     * - `class A { get foo() {} }`  ............. `getter 'foo'`\r\n     * - `class A { set foo(a) {} }`  ............ `setter 'foo'`\r\n     * - `class A { static foo() {} }`  .......... `static method 'foo'`\r\n     * - `class A { static *foo() {} }`  ......... `static generator method 'foo'`\r\n     * - `class A { static async foo() {} }`  .... `static async method 'foo'`\r\n     * - `class A { static get foo() {} }`  ...... `static getter 'foo'`\r\n     * - `class A { static set foo(a) {} }`  ..... `static setter 'foo'`\r\n     * - `class A { foo = () => {}; }`  .......... `method 'foo'`\r\n     * - `class A { foo = function() {}; }`  ..... `method 'foo'`\r\n     * - `class A { foo = function bar() {}; }`  . `method 'foo'`\r\n     * - `class A { static foo = () => {}; }`  ... `static method 'foo'`\r\n     * - `class A { '#foo' = () => {}; }`  ....... `method '#foo'`\r\n     * - `class A { #foo = () => {}; }`  ......... `private method #foo`\r\n     * - `class A { static #foo = () => {}; }`  .. `static private method #foo`\r\n     * - `class A { '#foo'() {} }`  .............. `method '#foo'`\r\n     * - `class A { #foo() {} }`  ................ `private method #foo`\r\n     * - `class A { static #foo() {} }`  ......... `static private method #foo`\r\n     * @param {ASTNode} node The function node to get.\r\n     * @returns {string} The name and kind of the function node.\r\n     */\r\n    getFunctionNameWithKind(node) {\r\n        const parent = node.parent;\r\n        const tokens = [];\r\n\r\n        if (parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\r\n\r\n            // The proposal uses `static` word consistently before visibility words: https://github.com/tc39/proposal-static-class-features\r\n            if (parent.static) {\r\n                tokens.push(\"static\");\r\n            }\r\n            if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\r\n                tokens.push(\"private\");\r\n            }\r\n        }\r\n        if (node.async) {\r\n            tokens.push(\"async\");\r\n        }\r\n        if (node.generator) {\r\n            tokens.push(\"generator\");\r\n        }\r\n\r\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\") {\r\n            if (parent.kind === \"constructor\") {\r\n                return \"constructor\";\r\n            }\r\n            if (parent.kind === \"get\") {\r\n                tokens.push(\"getter\");\r\n            } else if (parent.kind === \"set\") {\r\n                tokens.push(\"setter\");\r\n            } else {\r\n                tokens.push(\"method\");\r\n            }\r\n        } else if (parent.type === \"PropertyDefinition\") {\r\n            tokens.push(\"method\");\r\n        } else {\r\n            if (node.type === \"ArrowFunctionExpression\") {\r\n                tokens.push(\"arrow\");\r\n            }\r\n            tokens.push(\"function\");\r\n        }\r\n\r\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\r\n            if (!parent.computed && parent.key.type === \"PrivateIdentifier\") {\r\n                tokens.push(`#${parent.key.name}`);\r\n            } else {\r\n                const name = getStaticPropertyName(parent);\r\n\r\n                if (name !== null) {\r\n                    tokens.push(`'${name}'`);\r\n                } else if (node.id) {\r\n                    tokens.push(`'${node.id.name}'`);\r\n                }\r\n            }\r\n        } else if (node.id) {\r\n            tokens.push(`'${node.id.name}'`);\r\n        }\r\n\r\n        return tokens.join(\" \");\r\n    },\r\n\r\n    /**\r\n     * Gets the location of the given function node for reporting.\r\n     *\r\n     * - `function foo() {}`\r\n     *    ^^^^^^^^^^^^\r\n     * - `(function foo() {})`\r\n     *     ^^^^^^^^^^^^\r\n     * - `(function() {})`\r\n     *     ^^^^^^^^\r\n     * - `function* foo() {}`\r\n     *    ^^^^^^^^^^^^^\r\n     * - `(function* foo() {})`\r\n     *     ^^^^^^^^^^^^^\r\n     * - `(function*() {})`\r\n     *     ^^^^^^^^^\r\n     * - `() => {}`\r\n     *       ^^\r\n     * - `async () => {}`\r\n     *             ^^\r\n     * - `({ foo: function foo() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^\r\n     * - `({ foo: function() {} })`\r\n     *       ^^^^^^^^^^^^^\r\n     * - `({ ['foo']: function() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^\r\n     * - `({ [foo]: function() {} })`\r\n     *       ^^^^^^^^^^^^^^^\r\n     * - `({ foo() {} })`\r\n     *       ^^^\r\n     * - `({ foo: function* foo() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^\r\n     * - `({ foo: function*() {} })`\r\n     *       ^^^^^^^^^^^^^^\r\n     * - `({ ['foo']: function*() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^\r\n     * - `({ [foo]: function*() {} })`\r\n     *       ^^^^^^^^^^^^^^^^\r\n     * - `({ *foo() {} })`\r\n     *       ^^^^\r\n     * - `({ foo: async function foo() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\r\n     * - `({ foo: async function() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^^\r\n     * - `({ ['foo']: async function() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^^^^^^\r\n     * - `({ [foo]: async function() {} })`\r\n     *       ^^^^^^^^^^^^^^^^^^^^^\r\n     * - `({ async foo() {} })`\r\n     *       ^^^^^^^^^\r\n     * - `({ get foo() {} })`\r\n     *       ^^^^^^^\r\n     * - `({ set foo(a) {} })`\r\n     *       ^^^^^^^\r\n     * - `class A { constructor() {} }`\r\n     *              ^^^^^^^^^^^\r\n     * - `class A { foo() {} }`\r\n     *              ^^^\r\n     * - `class A { *foo() {} }`\r\n     *              ^^^^\r\n     * - `class A { async foo() {} }`\r\n     *              ^^^^^^^^^\r\n     * - `class A { ['foo']() {} }`\r\n     *              ^^^^^^^\r\n     * - `class A { *['foo']() {} }`\r\n     *              ^^^^^^^^\r\n     * - `class A { async ['foo']() {} }`\r\n     *              ^^^^^^^^^^^^^\r\n     * - `class A { [foo]() {} }`\r\n     *              ^^^^^\r\n     * - `class A { *[foo]() {} }`\r\n     *              ^^^^^^\r\n     * - `class A { async [foo]() {} }`\r\n     *              ^^^^^^^^^^^\r\n     * - `class A { get foo() {} }`\r\n     *              ^^^^^^^\r\n     * - `class A { set foo(a) {} }`\r\n     *              ^^^^^^^\r\n     * - `class A { static foo() {} }`\r\n     *              ^^^^^^^^^^\r\n     * - `class A { static *foo() {} }`\r\n     *              ^^^^^^^^^^^\r\n     * - `class A { static async foo() {} }`\r\n     *              ^^^^^^^^^^^^^^^^\r\n     * - `class A { static get foo() {} }`\r\n     *              ^^^^^^^^^^^^^^\r\n     * - `class A { static set foo(a) {} }`\r\n     *              ^^^^^^^^^^^^^^\r\n     * - `class A { foo = function() {} }`\r\n     *              ^^^^^^^^^^^^^^\r\n     * - `class A { static foo = function() {} }`\r\n     *              ^^^^^^^^^^^^^^^^^^^^^\r\n     * - `class A { foo = (a, b) => {} }`\r\n     *              ^^^^^^\r\n     * @param {ASTNode} node The function node to get.\r\n     * @param {SourceCode} sourceCode The source code object to get tokens.\r\n     * @returns {string} The location of the function node for reporting.\r\n     */\r\n    getFunctionHeadLoc(node, sourceCode) {\r\n        const parent = node.parent;\r\n        let start = null;\r\n        let end = null;\r\n\r\n        if (parent.type === \"Property\" || parent.type === \"MethodDefinition\" || parent.type === \"PropertyDefinition\") {\r\n            start = parent.loc.start;\r\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\r\n        } else if (node.type === \"ArrowFunctionExpression\") {\r\n            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);\r\n\r\n            start = arrowToken.loc.start;\r\n            end = arrowToken.loc.end;\r\n        } else {\r\n            start = node.loc.start;\r\n            end = getOpeningParenOfParams(node, sourceCode).loc.start;\r\n        }\r\n\r\n        return {\r\n            start: Object.assign({}, start),\r\n            end: Object.assign({}, end)\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Gets next location when the result is not out of bound, otherwise returns null.\r\n     *\r\n     * Assumptions:\r\n     *\r\n     * - The given location represents a valid location in the given source code.\r\n     * - Columns are 0-based.\r\n     * - Lines are 1-based.\r\n     * - Column immediately after the last character in a line (not incl. linebreaks) is considered to be a valid location.\r\n     * - If the source code ends with a linebreak, `sourceCode.lines` array will have an extra element (empty string) at the end.\r\n     *   The start (column 0) of that extra line is considered to be a valid location.\r\n     *\r\n     * Examples of successive locations (line, column):\r\n     *\r\n     * code: foo\r\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> null\r\n     *\r\n     * code: foo<LF>\r\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\r\n     *\r\n     * code: foo<CR><LF>\r\n     * locations: (1, 0) -> (1, 1) -> (1, 2) -> (1, 3) -> (2, 0) -> null\r\n     *\r\n     * code: a<LF>b\r\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> null\r\n     *\r\n     * code: a<LF>b<LF>\r\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\r\n     *\r\n     * code: a<CR><LF>b<CR><LF>\r\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (2, 1) -> (3, 0) -> null\r\n     *\r\n     * code: a<LF><LF>\r\n     * locations: (1, 0) -> (1, 1) -> (2, 0) -> (3, 0) -> null\r\n     *\r\n     * code: <LF>\r\n     * locations: (1, 0) -> (2, 0) -> null\r\n     *\r\n     * code:\r\n     * locations: (1, 0) -> null\r\n     * @param {SourceCode} sourceCode The sourceCode\r\n     * @param {{line: number, column: number}} location The location\r\n     * @returns {{line: number, column: number} | null} Next location\r\n     */\r\n    getNextLocation(sourceCode, { line, column }) {\r\n        if (column < sourceCode.lines[line - 1].length) {\r\n            return {\r\n                line,\r\n                column: column + 1\r\n            };\r\n        }\r\n\r\n        if (line < sourceCode.lines.length) {\r\n            return {\r\n                line: line + 1,\r\n                column: 0\r\n            };\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses\r\n     * surrounding the node.\r\n     * @param {SourceCode} sourceCode The source code object\r\n     * @param {ASTNode} node An expression node\r\n     * @returns {string} The text representing the node, with all surrounding parentheses included\r\n     */\r\n    getParenthesisedText(sourceCode, node) {\r\n        let leftToken = sourceCode.getFirstToken(node);\r\n        let rightToken = sourceCode.getLastToken(node);\r\n\r\n        while (\r\n            sourceCode.getTokenBefore(leftToken) &&\r\n            sourceCode.getTokenBefore(leftToken).type === \"Punctuator\" &&\r\n            sourceCode.getTokenBefore(leftToken).value === \"(\" &&\r\n            sourceCode.getTokenAfter(rightToken) &&\r\n            sourceCode.getTokenAfter(rightToken).type === \"Punctuator\" &&\r\n            sourceCode.getTokenAfter(rightToken).value === \")\"\r\n        ) {\r\n            leftToken = sourceCode.getTokenBefore(leftToken);\r\n            rightToken = sourceCode.getTokenAfter(rightToken);\r\n        }\r\n\r\n        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);\r\n    },\r\n\r\n    /**\r\n     * Determine if a node has a possibility to be an Error object\r\n     * @param {ASTNode} node ASTNode to check\r\n     * @returns {boolean} True if there is a chance it contains an Error obj\r\n     */\r\n    couldBeError(node) {\r\n        switch (node.type) {\r\n            case \"Identifier\":\r\n            case \"CallExpression\":\r\n            case \"NewExpression\":\r\n            case \"MemberExpression\":\r\n            case \"TaggedTemplateExpression\":\r\n            case \"YieldExpression\":\r\n            case \"AwaitExpression\":\r\n            case \"ChainExpression\":\r\n                return true; // possibly an error object.\r\n\r\n            case \"AssignmentExpression\":\r\n                if ([\"=\", \"&&=\"].includes(node.operator)) {\r\n                    return module.exports.couldBeError(node.right);\r\n                }\r\n\r\n                if ([\"||=\", \"??=\"].includes(node.operator)) {\r\n                    return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\r\n                }\r\n\r\n                /**\r\n                 * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\r\n                 * An assignment expression with a mathematical operator can either evaluate to a primitive value,\r\n                 * or throw, depending on the operands. Thus, it cannot evaluate to an `Error` object.\r\n                 */\r\n                return false;\r\n\r\n            case \"SequenceExpression\": {\r\n                const exprs = node.expressions;\r\n\r\n                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);\r\n            }\r\n\r\n            case \"LogicalExpression\":\r\n\r\n                /*\r\n                 * If the && operator short-circuits, the left side was falsy and therefore not an error, and if it\r\n                 * doesn't short-circuit, it takes the value from the right side, so the right side must always be\r\n                 * a plausible error. A future improvement could verify that the left side could be truthy by\r\n                 * excluding falsy literals.\r\n                 */\r\n                if (node.operator === \"&&\") {\r\n                    return module.exports.couldBeError(node.right);\r\n                }\r\n\r\n                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);\r\n\r\n            case \"ConditionalExpression\":\r\n                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);\r\n\r\n            default:\r\n                return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check if a given node is a numeric literal or not.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} `true` if the node is a number or bigint literal.\r\n     */\r\n    isNumericLiteral(node) {\r\n        return (\r\n            node.type === \"Literal\" &&\r\n            (typeof node.value === \"number\" || Boolean(node.bigint))\r\n        );\r\n    },\r\n\r\n    /**\r\n     * Determines whether two tokens can safely be placed next to each other without merging into a single token\r\n     * @param {Token|string} leftValue The left token. If this is a string, it will be tokenized and the last token will be used.\r\n     * @param {Token|string} rightValue The right token. If this is a string, it will be tokenized and the first token will be used.\r\n     * @returns {boolean} If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed\r\n     * next to each other, behavior is undefined (although it should return `true` in most cases).\r\n     */\r\n    canTokensBeAdjacent(leftValue, rightValue) {\r\n        const espreeOptions = {\r\n            ecmaVersion: espree.latestEcmaVersion,\r\n            comment: true,\r\n            range: true\r\n        };\r\n\r\n        let leftToken;\r\n\r\n        if (typeof leftValue === \"string\") {\r\n            let tokens;\r\n\r\n            try {\r\n                tokens = espree.tokenize(leftValue, espreeOptions);\r\n            } catch {\r\n                return false;\r\n            }\r\n\r\n            const comments = tokens.comments;\r\n\r\n            leftToken = tokens[tokens.length - 1];\r\n            if (comments.length) {\r\n                const lastComment = comments[comments.length - 1];\r\n\r\n                if (lastComment.range[0] > leftToken.range[0]) {\r\n                    leftToken = lastComment;\r\n                }\r\n            }\r\n        } else {\r\n            leftToken = leftValue;\r\n        }\r\n\r\n        if (leftToken.type === \"Shebang\") {\r\n            return false;\r\n        }\r\n\r\n        let rightToken;\r\n\r\n        if (typeof rightValue === \"string\") {\r\n            let tokens;\r\n\r\n            try {\r\n                tokens = espree.tokenize(rightValue, espreeOptions);\r\n            } catch {\r\n                return false;\r\n            }\r\n\r\n            const comments = tokens.comments;\r\n\r\n            rightToken = tokens[0];\r\n            if (comments.length) {\r\n                const firstComment = comments[0];\r\n\r\n                if (firstComment.range[0] < rightToken.range[0]) {\r\n                    rightToken = firstComment;\r\n                }\r\n            }\r\n        } else {\r\n            rightToken = rightValue;\r\n        }\r\n\r\n        if (leftToken.type === \"Punctuator\" || rightToken.type === \"Punctuator\") {\r\n            if (leftToken.type === \"Punctuator\" && rightToken.type === \"Punctuator\") {\r\n                const PLUS_TOKENS = new Set([\"+\", \"++\"]);\r\n                const MINUS_TOKENS = new Set([\"-\", \"--\"]);\r\n\r\n                return !(\r\n                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||\r\n                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)\r\n                );\r\n            }\r\n            if (leftToken.type === \"Punctuator\" && leftToken.value === \"/\") {\r\n                return ![\"Block\", \"Line\", \"RegularExpression\"].includes(rightToken.type);\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (\r\n            leftToken.type === \"String\" || rightToken.type === \"String\" ||\r\n            leftToken.type === \"Template\" || rightToken.type === \"Template\"\r\n        ) {\r\n            return true;\r\n        }\r\n\r\n        if (leftToken.type !== \"Numeric\" && rightToken.type === \"Numeric\" && rightToken.value.startsWith(\".\")) {\r\n            return true;\r\n        }\r\n\r\n        if (leftToken.type === \"Block\" || rightToken.type === \"Block\" || rightToken.type === \"Line\") {\r\n            return true;\r\n        }\r\n\r\n        if (rightToken.type === \"PrivateIdentifier\") {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Get the `loc` object of a given name in a `/*globals` directive comment.\r\n     * @param {SourceCode} sourceCode The source code to convert index to loc.\r\n     * @param {Comment} comment The `/*globals` directive comment which include the name.\r\n     * @param {string} name The name to find.\r\n     * @returns {SourceLocation} The `loc` object.\r\n     */\r\n    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {\r\n        const namePattern = new RegExp(`[\\\\s,]${escapeRegExp(name)}(?:$|[\\\\s,:])`, \"gu\");\r\n\r\n        // To ignore the first text \"global\".\r\n        namePattern.lastIndex = comment.value.indexOf(\"global\") + 6;\r\n\r\n        // Search a given variable name.\r\n        const match = namePattern.exec(comment.value);\r\n\r\n        // Convert the index to loc.\r\n        const start = sourceCode.getLocFromIndex(\r\n            comment.range[0] +\r\n            \"/*\".length +\r\n            (match ? match.index + 1 : 0)\r\n        );\r\n        const end = {\r\n            line: start.line,\r\n            column: start.column + (match ? name.length : 1)\r\n        };\r\n\r\n        return { start, end };\r\n    },\r\n\r\n    /**\r\n     * Determines whether the given raw string contains an octal escape sequence\r\n     * or a non-octal decimal escape sequence (\"\\8\", \"\\9\").\r\n     *\r\n     * \"\\1\", \"\\2\" ... \"\\7\", \"\\8\", \"\\9\"\r\n     * \"\\00\", \"\\01\" ... \"\\07\", \"\\08\", \"\\09\"\r\n     *\r\n     * \"\\0\", when not followed by a digit, is not an octal escape sequence.\r\n     * @param {string} rawString A string in its raw representation.\r\n     * @returns {boolean} `true` if the string contains at least one octal escape sequence\r\n     * or at least one non-octal decimal escape sequence.\r\n     */\r\n    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {\r\n        return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);\r\n    },\r\n\r\n    isLogicalExpression,\r\n    isCoalesceExpression,\r\n    isMixedLogicalAndCoalesceExpressions,\r\n    isNullLiteral,\r\n    getStaticStringValue,\r\n    getStaticPropertyName,\r\n    skipChainExpression,\r\n    isSpecificId,\r\n    isSpecificMemberAccess,\r\n    equalLiteralValue,\r\n    isSameReference,\r\n    isLogicalAssignmentOperator,\r\n    getSwitchCaseColonToken,\r\n    getModuleExportName\r\n};\r\n"]},"metadata":{},"sourceType":"script"}