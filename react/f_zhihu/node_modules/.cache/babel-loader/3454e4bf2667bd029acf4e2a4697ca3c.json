{"ast":null,"code":"/*\r\n * STOP!!! DO NOT MODIFY.\r\n *\r\n * This file is part of the ongoing work to move the eslintrc-style config\r\n * system into the @eslint/eslintrc package. This file needs to remain\r\n * unchanged in order for this work to proceed.\r\n *\r\n * If you think you need to change this file, please contact @nzakas first.\r\n *\r\n * Thanks in advance for your cooperation.\r\n */\n\n/**\r\n * @fileoverview Validates configs.\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst util = require(\"util\"),\n      configSchema = require(\"../../conf/config-schema\"),\n      BuiltInRules = require(\"../rules\"),\n      {\n  Legacy: {\n    ConfigOps,\n    environments: BuiltInEnvironments\n  }\n} = require(\"@eslint/eslintrc\"),\n      {\n  emitDeprecationWarning\n} = require(\"./deprecation-warnings\");\n\nconst ajv = require(\"./ajv\")();\n\nconst ruleValidators = new WeakMap();\nconst noop = Function.prototype; //------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nlet validateSchema;\nconst severityMap = {\n  error: 2,\n  warn: 1,\n  off: 0\n};\n/**\r\n * Gets a complete options schema for a rule.\r\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\r\n * @returns {Object} JSON Schema for the rule's options.\r\n */\n\nfunction getRuleOptionsSchema(rule) {\n  if (!rule) {\n    return null;\n  }\n\n  const schema = rule.schema || rule.meta && rule.meta.schema; // Given a tuple of schemas, insert warning level at the beginning\n\n  if (Array.isArray(schema)) {\n    if (schema.length) {\n      return {\n        type: \"array\",\n        items: schema,\n        minItems: 0,\n        maxItems: schema.length\n      };\n    }\n\n    return {\n      type: \"array\",\n      minItems: 0,\n      maxItems: 0\n    };\n  } // Given a full schema, leave it alone\n\n\n  return schema || null;\n}\n/**\r\n * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\r\n * @param {options} options The given options for the rule.\r\n * @throws {Error} Wrong severity value.\r\n * @returns {number|string} The rule's severity value\r\n */\n\n\nfunction validateRuleSeverity(options) {\n  const severity = Array.isArray(options) ? options[0] : options;\n  const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\n\n  if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\n    return normSeverity;\n  }\n\n  throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\n}\n/**\r\n * Validates the non-severity options passed to a rule, based on its schema.\r\n * @param {{create: Function}} rule The rule to validate\r\n * @param {Array} localOptions The options for the rule, excluding severity\r\n * @throws {Error} Any rule validation errors.\r\n * @returns {void}\r\n */\n\n\nfunction validateRuleSchema(rule, localOptions) {\n  if (!ruleValidators.has(rule)) {\n    const schema = getRuleOptionsSchema(rule);\n\n    if (schema) {\n      ruleValidators.set(rule, ajv.compile(schema));\n    }\n  }\n\n  const validateRule = ruleValidators.get(rule);\n\n  if (validateRule) {\n    validateRule(localOptions);\n\n    if (validateRule.errors) {\n      throw new Error(validateRule.errors.map(error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`).join(\"\"));\n    }\n  }\n}\n/**\r\n * Validates a rule's options against its schema.\r\n * @param {{create: Function}|null} rule The rule that the config is being validated for\r\n * @param {string} ruleId The rule's unique name.\r\n * @param {Array|number} options The given options for the rule.\r\n * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\r\n * no source is prepended to the message.\r\n * @throws {Error} Upon any bad rule configuration.\r\n * @returns {void}\r\n */\n\n\nfunction validateRuleOptions(rule, ruleId, options) {\n  let source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  try {\n    const severity = validateRuleSeverity(options);\n\n    if (severity !== 0) {\n      validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\n    }\n  } catch (err) {\n    const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\n\n    if (typeof source === \"string\") {\n      throw new Error(`${source}:\\n\\t${enhancedMessage}`);\n    } else {\n      throw new Error(enhancedMessage);\n    }\n  }\n}\n/**\r\n * Validates an environment object\r\n * @param {Object} environment The environment config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded environments.\r\n * @returns {void}\r\n */\n\n\nfunction validateEnvironment(environment, source) {\n  let getAdditionalEnv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n  // not having an environment is ok\n  if (!environment) {\n    return;\n  }\n\n  Object.keys(environment).forEach(id => {\n    const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\n\n    if (!env) {\n      const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\n      throw new Error(message);\n    }\n  });\n}\n/**\r\n * Validates a rules config object\r\n * @param {Object} rulesConfig The rules config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(ruleId:string) => Object} getAdditionalRule A map from strings to loaded rules\r\n * @returns {void}\r\n */\n\n\nfunction validateRules(rulesConfig, source) {\n  let getAdditionalRule = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n\n  if (!rulesConfig) {\n    return;\n  }\n\n  Object.keys(rulesConfig).forEach(id => {\n    const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;\n    validateRuleOptions(rule, id, rulesConfig[id], source);\n  });\n}\n/**\r\n * Validates a `globals` section of a config file\r\n * @param {Object} globalsConfig The `globals` section\r\n * @param {string|null} source The name of the configuration source to report in the event of an error.\r\n * @returns {void}\r\n */\n\n\nfunction validateGlobals(globalsConfig) {\n  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n  if (!globalsConfig) {\n    return;\n  }\n\n  Object.entries(globalsConfig).forEach(_ref => {\n    let [configuredGlobal, configuredValue] = _ref;\n\n    try {\n      ConfigOps.normalizeConfigGlobal(configuredValue);\n    } catch (err) {\n      throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\n    }\n  });\n}\n/**\r\n * Validate `processor` configuration.\r\n * @param {string|undefined} processorName The processor name.\r\n * @param {string} source The name of config file.\r\n * @param {(id:string) => Processor} getProcessor The getter of defined processors.\r\n * @throws {Error} For invalid processor configuration.\r\n * @returns {void}\r\n */\n\n\nfunction validateProcessor(processorName, source, getProcessor) {\n  if (processorName && !getProcessor(processorName)) {\n    throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\n  }\n}\n/**\r\n * Formats an array of schema validation errors.\r\n * @param {Array} errors An array of error messages to format.\r\n * @returns {string} Formatted error message\r\n */\n\n\nfunction formatErrors(errors) {\n  return errors.map(error => {\n    if (error.keyword === \"additionalProperties\") {\n      const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\n      return `Unexpected top-level property \"${formattedPropertyPath}\"`;\n    }\n\n    if (error.keyword === \"type\") {\n      const formattedField = error.dataPath.slice(1);\n      const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\n      const formattedValue = JSON.stringify(error.data);\n      return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\n    }\n\n    const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\n    return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\n  }).map(message => `\\t- ${message}.\\n`).join(\"\");\n}\n/**\r\n * Validates the top level properties of the config object.\r\n * @param {Object} config The config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @throws {Error} For any config invalid per the schema.\r\n * @returns {void}\r\n */\n\n\nfunction validateConfigSchema(config) {\n  let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  validateSchema = validateSchema || ajv.compile(configSchema);\n\n  if (!validateSchema(config)) {\n    throw new Error(`ESLint configuration in ${source} is invalid:\\n${formatErrors(validateSchema.errors)}`);\n  }\n\n  if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\n    emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\n  }\n}\n/**\r\n * Validates an entire config object.\r\n * @param {Object} config The config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(ruleId:string) => Object} [getAdditionalRule] A map from strings to loaded rules.\r\n * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded envs.\r\n * @returns {void}\r\n */\n\n\nfunction validate(config, source, getAdditionalRule, getAdditionalEnv) {\n  validateConfigSchema(config, source);\n  validateRules(config.rules, source, getAdditionalRule);\n  validateEnvironment(config.env, source, getAdditionalEnv);\n  validateGlobals(config.globals, source);\n\n  for (const override of config.overrides || []) {\n    validateRules(override.rules, source, getAdditionalRule);\n    validateEnvironment(override.env, source, getAdditionalEnv);\n    validateGlobals(config.globals, source);\n  }\n}\n\nconst validated = new WeakSet();\n/**\r\n * Validate config array object.\r\n * @param {ConfigArray} configArray The config array to validate.\r\n * @returns {void}\r\n */\n\nfunction validateConfigArray(configArray) {\n  const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\n  const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\n  const getPluginRule = Map.prototype.get.bind(configArray.pluginRules); // Validate.\n\n  for (const element of configArray) {\n    if (validated.has(element)) {\n      continue;\n    }\n\n    validated.add(element);\n    validateEnvironment(element.env, element.name, getPluginEnv);\n    validateGlobals(element.globals, element.name);\n    validateProcessor(element.processor, element.name, getPluginProcessor);\n    validateRules(element.rules, element.name, getPluginRule);\n  }\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n\nmodule.exports = {\n  getRuleOptionsSchema,\n  validate,\n  validateConfigArray,\n  validateConfigSchema,\n  validateRuleOptions\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/shared/config-validator.js"],"names":["util","require","configSchema","BuiltInRules","Legacy","ConfigOps","environments","BuiltInEnvironments","emitDeprecationWarning","ajv","ruleValidators","WeakMap","noop","Function","prototype","validateSchema","severityMap","error","warn","off","getRuleOptionsSchema","rule","schema","meta","Array","isArray","length","type","items","minItems","maxItems","validateRuleSeverity","options","severity","normSeverity","toLowerCase","Error","inspect","replace","validateRuleSchema","localOptions","has","set","compile","validateRule","get","errors","map","JSON","stringify","data","message","join","validateRuleOptions","ruleId","source","slice","err","enhancedMessage","validateEnvironment","environment","getAdditionalEnv","Object","keys","forEach","id","env","validateRules","rulesConfig","getAdditionalRule","validateGlobals","globalsConfig","entries","configuredGlobal","configuredValue","normalizeConfigGlobal","validateProcessor","processorName","getProcessor","formatErrors","keyword","formattedPropertyPath","dataPath","params","additionalProperty","formattedField","formattedExpectedType","formattedValue","field","validateConfigSchema","config","hasOwnProperty","call","validate","rules","globals","override","overrides","validated","WeakSet","validateConfigArray","configArray","getPluginEnv","Map","bind","pluginEnvironments","getPluginProcessor","pluginProcessors","getPluginRule","pluginRules","element","add","name","processor","module","exports"],"mappings":"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","sourcesContent":["/*\r\n * STOP!!! DO NOT MODIFY.\r\n *\r\n * This file is part of the ongoing work to move the eslintrc-style config\r\n * system into the @eslint/eslintrc package. This file needs to remain\r\n * unchanged in order for this work to proceed.\r\n *\r\n * If you think you need to change this file, please contact @nzakas first.\r\n *\r\n * Thanks in advance for your cooperation.\r\n */\r\n\r\n/**\r\n * @fileoverview Validates configs.\r\n * @author Brandon Mills\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst\r\n    util = require(\"util\"),\r\n    configSchema = require(\"../../conf/config-schema\"),\r\n    BuiltInRules = require(\"../rules\"),\r\n    {\r\n        Legacy: {\r\n            ConfigOps,\r\n            environments: BuiltInEnvironments\r\n        }\r\n    } = require(\"@eslint/eslintrc\"),\r\n    { emitDeprecationWarning } = require(\"./deprecation-warnings\");\r\n\r\nconst ajv = require(\"./ajv\")();\r\nconst ruleValidators = new WeakMap();\r\nconst noop = Function.prototype;\r\n\r\n//------------------------------------------------------------------------------\r\n// Private\r\n//------------------------------------------------------------------------------\r\nlet validateSchema;\r\nconst severityMap = {\r\n    error: 2,\r\n    warn: 1,\r\n    off: 0\r\n};\r\n\r\n/**\r\n * Gets a complete options schema for a rule.\r\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\r\n * @returns {Object} JSON Schema for the rule's options.\r\n */\r\nfunction getRuleOptionsSchema(rule) {\r\n    if (!rule) {\r\n        return null;\r\n    }\r\n\r\n    const schema = rule.schema || rule.meta && rule.meta.schema;\r\n\r\n    // Given a tuple of schemas, insert warning level at the beginning\r\n    if (Array.isArray(schema)) {\r\n        if (schema.length) {\r\n            return {\r\n                type: \"array\",\r\n                items: schema,\r\n                minItems: 0,\r\n                maxItems: schema.length\r\n            };\r\n        }\r\n        return {\r\n            type: \"array\",\r\n            minItems: 0,\r\n            maxItems: 0\r\n        };\r\n\r\n    }\r\n\r\n    // Given a full schema, leave it alone\r\n    return schema || null;\r\n}\r\n\r\n/**\r\n * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.\r\n * @param {options} options The given options for the rule.\r\n * @throws {Error} Wrong severity value.\r\n * @returns {number|string} The rule's severity value\r\n */\r\nfunction validateRuleSeverity(options) {\r\n    const severity = Array.isArray(options) ? options[0] : options;\r\n    const normSeverity = typeof severity === \"string\" ? severityMap[severity.toLowerCase()] : severity;\r\n\r\n    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {\r\n        return normSeverity;\r\n    }\r\n\r\n    throw new Error(`\\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, \"\\\"\").replace(/\\n/gu, \"\")}').\\n`);\r\n\r\n}\r\n\r\n/**\r\n * Validates the non-severity options passed to a rule, based on its schema.\r\n * @param {{create: Function}} rule The rule to validate\r\n * @param {Array} localOptions The options for the rule, excluding severity\r\n * @throws {Error} Any rule validation errors.\r\n * @returns {void}\r\n */\r\nfunction validateRuleSchema(rule, localOptions) {\r\n    if (!ruleValidators.has(rule)) {\r\n        const schema = getRuleOptionsSchema(rule);\r\n\r\n        if (schema) {\r\n            ruleValidators.set(rule, ajv.compile(schema));\r\n        }\r\n    }\r\n\r\n    const validateRule = ruleValidators.get(rule);\r\n\r\n    if (validateRule) {\r\n        validateRule(localOptions);\r\n        if (validateRule.errors) {\r\n            throw new Error(validateRule.errors.map(\r\n                error => `\\tValue ${JSON.stringify(error.data)} ${error.message}.\\n`\r\n            ).join(\"\"));\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Validates a rule's options against its schema.\r\n * @param {{create: Function}|null} rule The rule that the config is being validated for\r\n * @param {string} ruleId The rule's unique name.\r\n * @param {Array|number} options The given options for the rule.\r\n * @param {string|null} source The name of the configuration source to report in any errors. If null or undefined,\r\n * no source is prepended to the message.\r\n * @throws {Error} Upon any bad rule configuration.\r\n * @returns {void}\r\n */\r\nfunction validateRuleOptions(rule, ruleId, options, source = null) {\r\n    try {\r\n        const severity = validateRuleSeverity(options);\r\n\r\n        if (severity !== 0) {\r\n            validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);\r\n        }\r\n    } catch (err) {\r\n        const enhancedMessage = `Configuration for rule \"${ruleId}\" is invalid:\\n${err.message}`;\r\n\r\n        if (typeof source === \"string\") {\r\n            throw new Error(`${source}:\\n\\t${enhancedMessage}`);\r\n        } else {\r\n            throw new Error(enhancedMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Validates an environment object\r\n * @param {Object} environment The environment config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded environments.\r\n * @returns {void}\r\n */\r\nfunction validateEnvironment(\r\n    environment,\r\n    source,\r\n    getAdditionalEnv = noop\r\n) {\r\n\r\n    // not having an environment is ok\r\n    if (!environment) {\r\n        return;\r\n    }\r\n\r\n    Object.keys(environment).forEach(id => {\r\n        const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;\r\n\r\n        if (!env) {\r\n            const message = `${source}:\\n\\tEnvironment key \"${id}\" is unknown\\n`;\r\n\r\n            throw new Error(message);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Validates a rules config object\r\n * @param {Object} rulesConfig The rules config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(ruleId:string) => Object} getAdditionalRule A map from strings to loaded rules\r\n * @returns {void}\r\n */\r\nfunction validateRules(\r\n    rulesConfig,\r\n    source,\r\n    getAdditionalRule = noop\r\n) {\r\n    if (!rulesConfig) {\r\n        return;\r\n    }\r\n\r\n    Object.keys(rulesConfig).forEach(id => {\r\n        const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;\r\n\r\n        validateRuleOptions(rule, id, rulesConfig[id], source);\r\n    });\r\n}\r\n\r\n/**\r\n * Validates a `globals` section of a config file\r\n * @param {Object} globalsConfig The `globals` section\r\n * @param {string|null} source The name of the configuration source to report in the event of an error.\r\n * @returns {void}\r\n */\r\nfunction validateGlobals(globalsConfig, source = null) {\r\n    if (!globalsConfig) {\r\n        return;\r\n    }\r\n\r\n    Object.entries(globalsConfig)\r\n        .forEach(([configuredGlobal, configuredValue]) => {\r\n            try {\r\n                ConfigOps.normalizeConfigGlobal(configuredValue);\r\n            } catch (err) {\r\n                throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:\\n${err.message}`);\r\n            }\r\n        });\r\n}\r\n\r\n/**\r\n * Validate `processor` configuration.\r\n * @param {string|undefined} processorName The processor name.\r\n * @param {string} source The name of config file.\r\n * @param {(id:string) => Processor} getProcessor The getter of defined processors.\r\n * @throws {Error} For invalid processor configuration.\r\n * @returns {void}\r\n */\r\nfunction validateProcessor(processorName, source, getProcessor) {\r\n    if (processorName && !getProcessor(processorName)) {\r\n        throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);\r\n    }\r\n}\r\n\r\n/**\r\n * Formats an array of schema validation errors.\r\n * @param {Array} errors An array of error messages to format.\r\n * @returns {string} Formatted error message\r\n */\r\nfunction formatErrors(errors) {\r\n    return errors.map(error => {\r\n        if (error.keyword === \"additionalProperties\") {\r\n            const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)}.${error.params.additionalProperty}` : error.params.additionalProperty;\r\n\r\n            return `Unexpected top-level property \"${formattedPropertyPath}\"`;\r\n        }\r\n        if (error.keyword === \"type\") {\r\n            const formattedField = error.dataPath.slice(1);\r\n            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(\"/\") : error.schema;\r\n            const formattedValue = JSON.stringify(error.data);\r\n\r\n            return `Property \"${formattedField}\" is the wrong type (expected ${formattedExpectedType} but got \\`${formattedValue}\\`)`;\r\n        }\r\n\r\n        const field = error.dataPath[0] === \".\" ? error.dataPath.slice(1) : error.dataPath;\r\n\r\n        return `\"${field}\" ${error.message}. Value: ${JSON.stringify(error.data)}`;\r\n    }).map(message => `\\t- ${message}.\\n`).join(\"\");\r\n}\r\n\r\n/**\r\n * Validates the top level properties of the config object.\r\n * @param {Object} config The config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @throws {Error} For any config invalid per the schema.\r\n * @returns {void}\r\n */\r\nfunction validateConfigSchema(config, source = null) {\r\n    validateSchema = validateSchema || ajv.compile(configSchema);\r\n\r\n    if (!validateSchema(config)) {\r\n        throw new Error(`ESLint configuration in ${source} is invalid:\\n${formatErrors(validateSchema.errors)}`);\r\n    }\r\n\r\n    if (Object.hasOwnProperty.call(config, \"ecmaFeatures\")) {\r\n        emitDeprecationWarning(source, \"ESLINT_LEGACY_ECMAFEATURES\");\r\n    }\r\n}\r\n\r\n/**\r\n * Validates an entire config object.\r\n * @param {Object} config The config object to validate.\r\n * @param {string} source The name of the configuration source to report in any errors.\r\n * @param {(ruleId:string) => Object} [getAdditionalRule] A map from strings to loaded rules.\r\n * @param {(envId:string) => Object} [getAdditionalEnv] A map from strings to loaded envs.\r\n * @returns {void}\r\n */\r\nfunction validate(config, source, getAdditionalRule, getAdditionalEnv) {\r\n    validateConfigSchema(config, source);\r\n    validateRules(config.rules, source, getAdditionalRule);\r\n    validateEnvironment(config.env, source, getAdditionalEnv);\r\n    validateGlobals(config.globals, source);\r\n\r\n    for (const override of config.overrides || []) {\r\n        validateRules(override.rules, source, getAdditionalRule);\r\n        validateEnvironment(override.env, source, getAdditionalEnv);\r\n        validateGlobals(config.globals, source);\r\n    }\r\n}\r\n\r\nconst validated = new WeakSet();\r\n\r\n/**\r\n * Validate config array object.\r\n * @param {ConfigArray} configArray The config array to validate.\r\n * @returns {void}\r\n */\r\nfunction validateConfigArray(configArray) {\r\n    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);\r\n    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);\r\n    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);\r\n\r\n    // Validate.\r\n    for (const element of configArray) {\r\n        if (validated.has(element)) {\r\n            continue;\r\n        }\r\n        validated.add(element);\r\n\r\n        validateEnvironment(element.env, element.name, getPluginEnv);\r\n        validateGlobals(element.globals, element.name);\r\n        validateProcessor(element.processor, element.name, getPluginProcessor);\r\n        validateRules(element.rules, element.name, getPluginRule);\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\nmodule.exports = {\r\n    getRuleOptionsSchema,\r\n    validate,\r\n    validateConfigArray,\r\n    validateConfigSchema,\r\n    validateRuleOptions\r\n};\r\n"]},"metadata":{},"sourceType":"script"}