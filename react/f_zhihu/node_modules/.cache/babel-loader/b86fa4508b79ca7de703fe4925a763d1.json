{"ast":null,"code":"/**\r\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\r\n * @author Kai Cataldo\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow renaming import, export, and destructured assignments to the same name\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-useless-rename\"\n    },\n    fixable: \"code\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreDestructuring: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreImport: {\n          type: \"boolean\",\n          default: false\n        },\n        ignoreExport: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          options = context.options[0] || {},\n          ignoreDestructuring = options.ignoreDestructuring === true,\n          ignoreImport = options.ignoreImport === true,\n          ignoreExport = options.ignoreExport === true; //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Reports error for unnecessarily renamed assignments\r\n     * @param {ASTNode} node node to report\r\n     * @param {ASTNode} initial node with initial name value\r\n     * @param {string} type the type of the offending node\r\n     * @returns {void}\r\n     */\n\n    function reportError(node, initial, type) {\n      const name = initial.type === \"Identifier\" ? initial.name : initial.value;\n      return context.report({\n        node,\n        messageId: \"unnecessarilyRenamed\",\n        data: {\n          name,\n          type\n        },\n\n        fix(fixer) {\n          const replacementNode = node.type === \"Property\" ? node.value : node.local;\n\n          if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\n            return null;\n          } // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\n\n\n          if (replacementNode.type === \"AssignmentPattern\" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {\n            return null;\n          }\n\n          return fixer.replaceText(node, sourceCode.getText(replacementNode));\n        }\n\n      });\n    }\n    /**\r\n     * Checks whether a destructured assignment is unnecessarily renamed\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkDestructured(node) {\n      if (ignoreDestructuring) {\n        return;\n      }\n\n      for (const property of node.properties) {\n        /**\r\n         * Properties using shorthand syntax and rest elements can not be renamed.\r\n         * If the property is computed, we have no idea if a rename is useless or not.\r\n         */\n        if (property.type !== \"Property\" || property.shorthand || property.computed) {\n          continue;\n        }\n\n        const key = property.key.type === \"Identifier\" && property.key.name || property.key.type === \"Literal\" && property.key.value;\n        const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\n\n        if (key === renamedKey) {\n          reportError(property, property.key, \"Destructuring assignment\");\n        }\n      }\n    }\n    /**\r\n     * Checks whether an import is unnecessarily renamed\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkImport(node) {\n      if (ignoreImport) {\n        return;\n      }\n\n      if (node.imported.range[0] !== node.local.range[0] && astUtils.getModuleExportName(node.imported) === node.local.name) {\n        reportError(node, node.imported, \"Import\");\n      }\n    }\n    /**\r\n     * Checks whether an export is unnecessarily renamed\r\n     * @param {ASTNode} node node to check\r\n     * @returns {void}\r\n     */\n\n\n    function checkExport(node) {\n      if (ignoreExport) {\n        return;\n      }\n\n      if (node.local.range[0] !== node.exported.range[0] && astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)) {\n        reportError(node, node.local, \"Export\");\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ObjectPattern: checkDestructured,\n      ImportSpecifier: checkImport,\n      ExportSpecifier: checkExport\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-useless-rename.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","ignoreDestructuring","default","ignoreImport","ignoreExport","additionalProperties","messages","unnecessarilyRenamed","create","context","sourceCode","getSourceCode","options","reportError","node","initial","name","value","report","messageId","data","fix","fixer","replacementNode","local","getCommentsInside","length","isParenthesised","left","replaceText","getText","checkDestructured","property","shorthand","computed","key","renamedKey","checkImport","imported","range","getModuleExportName","checkExport","exported","ObjectPattern","ImportSpecifier","ExportSpecifier"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.\r\n * @author Kai Cataldo\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow renaming import, export, and destructured assignments to the same name\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-useless-rename\"\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignoreDestructuring: { type: \"boolean\", default: false },\r\n                    ignoreImport: { type: \"boolean\", default: false },\r\n                    ignoreExport: { type: \"boolean\", default: false }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unnecessarilyRenamed: \"{{type}} {{name}} unnecessarily renamed.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode(),\r\n            options = context.options[0] || {},\r\n            ignoreDestructuring = options.ignoreDestructuring === true,\r\n            ignoreImport = options.ignoreImport === true,\r\n            ignoreExport = options.ignoreExport === true;\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Reports error for unnecessarily renamed assignments\r\n         * @param {ASTNode} node node to report\r\n         * @param {ASTNode} initial node with initial name value\r\n         * @param {string} type the type of the offending node\r\n         * @returns {void}\r\n         */\r\n        function reportError(node, initial, type) {\r\n            const name = initial.type === \"Identifier\" ? initial.name : initial.value;\r\n\r\n            return context.report({\r\n                node,\r\n                messageId: \"unnecessarilyRenamed\",\r\n                data: {\r\n                    name,\r\n                    type\r\n                },\r\n                fix(fixer) {\r\n                    const replacementNode = node.type === \"Property\" ? node.value : node.local;\r\n\r\n                    if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {\r\n                        return null;\r\n                    }\r\n\r\n                    // Don't autofix code such as `({foo: (foo) = a} = obj);`, parens are not allowed in shorthand properties.\r\n                    if (\r\n                        replacementNode.type === \"AssignmentPattern\" &&\r\n                        astUtils.isParenthesised(sourceCode, replacementNode.left)\r\n                    ) {\r\n                        return null;\r\n                    }\r\n\r\n                    return fixer.replaceText(node, sourceCode.getText(replacementNode));\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Checks whether a destructured assignment is unnecessarily renamed\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkDestructured(node) {\r\n            if (ignoreDestructuring) {\r\n                return;\r\n            }\r\n\r\n            for (const property of node.properties) {\r\n\r\n                /**\r\n                 * Properties using shorthand syntax and rest elements can not be renamed.\r\n                 * If the property is computed, we have no idea if a rename is useless or not.\r\n                 */\r\n                if (property.type !== \"Property\" || property.shorthand || property.computed) {\r\n                    continue;\r\n                }\r\n\r\n                const key = (property.key.type === \"Identifier\" && property.key.name) || (property.key.type === \"Literal\" && property.key.value);\r\n                const renamedKey = property.value.type === \"AssignmentPattern\" ? property.value.left.name : property.value.name;\r\n\r\n                if (key === renamedKey) {\r\n                    reportError(property, property.key, \"Destructuring assignment\");\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether an import is unnecessarily renamed\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkImport(node) {\r\n            if (ignoreImport) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                node.imported.range[0] !== node.local.range[0] &&\r\n                astUtils.getModuleExportName(node.imported) === node.local.name\r\n            ) {\r\n                reportError(node, node.imported, \"Import\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks whether an export is unnecessarily renamed\r\n         * @param {ASTNode} node node to check\r\n         * @returns {void}\r\n         */\r\n        function checkExport(node) {\r\n            if (ignoreExport) {\r\n                return;\r\n            }\r\n\r\n            if (\r\n                node.local.range[0] !== node.exported.range[0] &&\r\n                astUtils.getModuleExportName(node.local) === astUtils.getModuleExportName(node.exported)\r\n            ) {\r\n                reportError(node, node.local, \"Export\");\r\n            }\r\n\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            ObjectPattern: checkDestructured,\r\n            ImportSpecifier: checkImport,\r\n            ExportSpecifier: checkExport\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}