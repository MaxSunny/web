{"ast":null,"code":"/**\r\n * @fileoverview Rule to ensure newline per method call when chaining calls\r\n * @author Rajendra Patil\r\n * @author Burak Yigit Kaya\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require a newline after each call in a method chain\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        ignoreChainWithDepth: {\n          type: \"integer\",\n          minimum: 1,\n          maximum: 10,\n          default: 2\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expected: \"Expected line break before `{{callee}}`.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {},\n          ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Get the prefix of a given MemberExpression node.\r\n     * If the MemberExpression node is a computed value it returns a\r\n     * left bracket. If not it returns a period.\r\n     * @param {ASTNode} node A MemberExpression node to get\r\n     * @returns {string} The prefix of the node.\r\n     */\n\n    function getPrefix(node) {\n      if (node.computed) {\n        if (node.optional) {\n          return \"?.[\";\n        }\n\n        return \"[\";\n      }\n\n      if (node.optional) {\n        return \"?.\";\n      }\n\n      return \".\";\n    }\n    /**\r\n     * Gets the property text of a given MemberExpression node.\r\n     * If the text is multiline, this returns only the first line.\r\n     * @param {ASTNode} node A MemberExpression node to get.\r\n     * @returns {string} The property text of the node.\r\n     */\n\n\n    function getPropertyText(node) {\n      const prefix = getPrefix(node);\n      const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\n      const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\n      return prefix + lines[0] + suffix;\n    }\n\n    return {\n      \"CallExpression:exit\"(node) {\n        const callee = astUtils.skipChainExpression(node.callee);\n\n        if (callee.type !== \"MemberExpression\") {\n          return;\n        }\n\n        let parent = astUtils.skipChainExpression(callee.object);\n        let depth = 1;\n\n        while (parent && parent.callee) {\n          depth += 1;\n          parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\n        }\n\n        if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\n          const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\n          context.report({\n            node: callee.property,\n            loc: {\n              start: firstTokenAfterObject.loc.start,\n              end: callee.loc.end\n            },\n            messageId: \"expected\",\n            data: {\n              callee: getPropertyText(callee)\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/newline-per-chained-call.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","ignoreChainWithDepth","minimum","maximum","default","additionalProperties","messages","expected","create","context","options","sourceCode","getSourceCode","getPrefix","node","computed","optional","getPropertyText","prefix","lines","getText","property","split","LINEBREAK_MATCHER","suffix","length","callee","skipChainExpression","parent","object","depth","isTokenOnSameLine","firstTokenAfterObject","getTokenAfter","isNotClosingParenToken","report","loc","start","end","messageId","data","fix","fixer","insertTextBefore"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to ensure newline per method call when chaining calls\r\n * @author Rajendra Patil\r\n * @author Burak Yigit Kaya\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require a newline after each call in a method chain\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/newline-per-chained-call\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [{\r\n            type: \"object\",\r\n            properties: {\r\n                ignoreChainWithDepth: {\r\n                    type: \"integer\",\r\n                    minimum: 1,\r\n                    maximum: 10,\r\n                    default: 2\r\n                }\r\n            },\r\n            additionalProperties: false\r\n        }],\r\n        messages: {\r\n            expected: \"Expected line break before `{{callee}}`.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const options = context.options[0] || {},\r\n            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Get the prefix of a given MemberExpression node.\r\n         * If the MemberExpression node is a computed value it returns a\r\n         * left bracket. If not it returns a period.\r\n         * @param {ASTNode} node A MemberExpression node to get\r\n         * @returns {string} The prefix of the node.\r\n         */\r\n        function getPrefix(node) {\r\n            if (node.computed) {\r\n                if (node.optional) {\r\n                    return \"?.[\";\r\n                }\r\n                return \"[\";\r\n            }\r\n            if (node.optional) {\r\n                return \"?.\";\r\n            }\r\n            return \".\";\r\n        }\r\n\r\n        /**\r\n         * Gets the property text of a given MemberExpression node.\r\n         * If the text is multiline, this returns only the first line.\r\n         * @param {ASTNode} node A MemberExpression node to get.\r\n         * @returns {string} The property text of the node.\r\n         */\r\n        function getPropertyText(node) {\r\n            const prefix = getPrefix(node);\r\n            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);\r\n            const suffix = node.computed && lines.length === 1 ? \"]\" : \"\";\r\n\r\n            return prefix + lines[0] + suffix;\r\n        }\r\n\r\n        return {\r\n            \"CallExpression:exit\"(node) {\r\n                const callee = astUtils.skipChainExpression(node.callee);\r\n\r\n                if (callee.type !== \"MemberExpression\") {\r\n                    return;\r\n                }\r\n\r\n                let parent = astUtils.skipChainExpression(callee.object);\r\n                let depth = 1;\r\n\r\n                while (parent && parent.callee) {\r\n                    depth += 1;\r\n                    parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);\r\n                }\r\n\r\n                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {\r\n                    const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);\r\n\r\n                    context.report({\r\n                        node: callee.property,\r\n                        loc: {\r\n                            start: firstTokenAfterObject.loc.start,\r\n                            end: callee.loc.end\r\n                        },\r\n                        messageId: \"expected\",\r\n                        data: {\r\n                            callee: getPropertyText(callee)\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.insertTextBefore(firstTokenAfterObject, \"\\n\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}