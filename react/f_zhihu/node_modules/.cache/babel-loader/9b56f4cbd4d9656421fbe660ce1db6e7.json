{"ast":null,"code":"/**\r\n * @fileoverview Rule to require newlines before `return` statement\r\n * @author Kai Cataldo\r\n * @deprecated in ESLint v4.0.0\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require an empty line before `return` statements\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/newline-before-return\"\n    },\n    fixable: \"whitespace\",\n    schema: [],\n    messages: {\n      expected: \"Expected newline before return statement.\"\n    },\n    deprecated: true,\n    replacedBy: [\"padding-line-between-statements\"]\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Tests whether node is preceded by supplied tokens\r\n     * @param {ASTNode} node node to check\r\n     * @param {Array} testTokens array of tokens to test against\r\n     * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\r\n     * @private\r\n     */\n\n    function isPrecededByTokens(node, testTokens) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      return testTokens.some(token => tokenBefore.value === token);\n    }\n    /**\r\n     * Checks whether node is the first node after statement or in block\r\n     * @param {ASTNode} node node to check\r\n     * @returns {boolean} Whether or not the node is the first node after statement or in block\r\n     * @private\r\n     */\n\n\n    function isFirstNode(node) {\n      const parentType = node.parent.type;\n\n      if (node.parent.body) {\n        return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;\n      }\n\n      if (parentType === \"IfStatement\") {\n        return isPrecededByTokens(node, [\"else\", \")\"]);\n      }\n\n      if (parentType === \"DoWhileStatement\") {\n        return isPrecededByTokens(node, [\"do\"]);\n      }\n\n      if (parentType === \"SwitchCase\") {\n        return isPrecededByTokens(node, [\":\"]);\n      }\n\n      return isPrecededByTokens(node, [\")\"]);\n    }\n    /**\r\n     * Returns the number of lines of comments that precede the node\r\n     * @param {ASTNode} node node to check for overlapping comments\r\n     * @param {number} lineNumTokenBefore line number of previous token, to check for overlapping comments\r\n     * @returns {number} Number of lines of comments that precede the node\r\n     * @private\r\n     */\n\n\n    function calcCommentLines(node, lineNumTokenBefore) {\n      const comments = sourceCode.getCommentsBefore(node);\n      let numLinesComments = 0;\n\n      if (!comments.length) {\n        return numLinesComments;\n      }\n\n      comments.forEach(comment => {\n        numLinesComments++;\n\n        if (comment.type === \"Block\") {\n          numLinesComments += comment.loc.end.line - comment.loc.start.line;\n        } // avoid counting lines with inline comments twice\n\n\n        if (comment.loc.start.line === lineNumTokenBefore) {\n          numLinesComments--;\n        }\n\n        if (comment.loc.end.line === node.loc.start.line) {\n          numLinesComments--;\n        }\n      });\n      return numLinesComments;\n    }\n    /**\r\n     * Returns the line number of the token before the node that is passed in as an argument\r\n     * @param {ASTNode} node The node to use as the start of the calculation\r\n     * @returns {number} Line number of the token before `node`\r\n     * @private\r\n     */\n\n\n    function getLineNumberOfTokenBefore(node) {\n      const tokenBefore = sourceCode.getTokenBefore(node);\n      let lineNumTokenBefore;\n      /**\r\n       * Global return (at the beginning of a script) is a special case.\r\n       * If there is no token before `return`, then we expect no line\r\n       * break before the return. Comments are allowed to occupy lines\r\n       * before the global return, just no blank lines.\r\n       * Setting lineNumTokenBefore to zero in that case results in the\r\n       * desired behavior.\r\n       */\n\n      if (tokenBefore) {\n        lineNumTokenBefore = tokenBefore.loc.end.line;\n      } else {\n        lineNumTokenBefore = 0; // global return at beginning of script\n      }\n\n      return lineNumTokenBefore;\n    }\n    /**\r\n     * Checks whether node is preceded by a newline\r\n     * @param {ASTNode} node node to check\r\n     * @returns {boolean} Whether or not the node is preceded by a newline\r\n     * @private\r\n     */\n\n\n    function hasNewlineBefore(node) {\n      const lineNumNode = node.loc.start.line;\n      const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\n      const commentLines = calcCommentLines(node, lineNumTokenBefore);\n      return lineNumNode - lineNumTokenBefore - commentLines > 1;\n    }\n    /**\r\n     * Checks whether it is safe to apply a fix to a given return statement.\r\n     *\r\n     * The fix is not considered safe if the given return statement has leading comments,\r\n     * as we cannot safely determine if the newline should be added before or after the comments.\r\n     * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\r\n     * @param {ASTNode} node The return statement node to check.\r\n     * @returns {boolean} `true` if it can fix the node.\r\n     * @private\r\n     */\n\n\n    function canFix(node) {\n      const leadingComments = sourceCode.getCommentsBefore(node);\n      const lastLeadingComment = leadingComments[leadingComments.length - 1];\n      const tokenBefore = sourceCode.getTokenBefore(node);\n\n      if (leadingComments.length === 0) {\n        return true;\n      }\n      /*\r\n       * if the last leading comment ends in the same line as the previous token and\r\n       * does not share a line with the `return` node, we can consider it safe to fix.\r\n       * Example:\r\n       * function a() {\r\n       *     var b; //comment\r\n       *     return;\r\n       * }\r\n       */\n\n\n      if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {\n        return true;\n      }\n\n      return false;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      ReturnStatement(node) {\n        if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n          context.report({\n            node,\n            messageId: \"expected\",\n\n            fix(fixer) {\n              if (canFix(node)) {\n                const tokenBefore = sourceCode.getTokenBefore(node);\n                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\n                return fixer.insertTextBefore(node, newlines);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/newline-before-return.js"],"names":["module","exports","meta","type","docs","description","recommended","url","fixable","schema","messages","expected","deprecated","replacedBy","create","context","sourceCode","getSourceCode","isPrecededByTokens","node","testTokens","tokenBefore","getTokenBefore","some","token","value","isFirstNode","parentType","parent","body","Array","isArray","calcCommentLines","lineNumTokenBefore","comments","getCommentsBefore","numLinesComments","length","forEach","comment","loc","end","line","start","getLineNumberOfTokenBefore","hasNewlineBefore","lineNumNode","commentLines","canFix","leadingComments","lastLeadingComment","ReturnStatement","report","messageId","fix","fixer","newlines","insertTextBefore"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to require newlines before `return` statement\r\n * @author Kai Cataldo\r\n * @deprecated in ESLint v4.0.0\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require an empty line before `return` statements\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/newline-before-return\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n        schema: [],\r\n        messages: {\r\n            expected: \"Expected newline before return statement.\"\r\n        },\r\n\r\n        deprecated: true,\r\n        replacedBy: [\"padding-line-between-statements\"]\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Tests whether node is preceded by supplied tokens\r\n         * @param {ASTNode} node node to check\r\n         * @param {Array} testTokens array of tokens to test against\r\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\r\n         * @private\r\n         */\r\n        function isPrecededByTokens(node, testTokens) {\r\n            const tokenBefore = sourceCode.getTokenBefore(node);\r\n\r\n            return testTokens.some(token => tokenBefore.value === token);\r\n        }\r\n\r\n        /**\r\n         * Checks whether node is the first node after statement or in block\r\n         * @param {ASTNode} node node to check\r\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\r\n         * @private\r\n         */\r\n        function isFirstNode(node) {\r\n            const parentType = node.parent.type;\r\n\r\n            if (node.parent.body) {\r\n                return Array.isArray(node.parent.body)\r\n                    ? node.parent.body[0] === node\r\n                    : node.parent.body === node;\r\n            }\r\n\r\n            if (parentType === \"IfStatement\") {\r\n                return isPrecededByTokens(node, [\"else\", \")\"]);\r\n            }\r\n            if (parentType === \"DoWhileStatement\") {\r\n                return isPrecededByTokens(node, [\"do\"]);\r\n            }\r\n            if (parentType === \"SwitchCase\") {\r\n                return isPrecededByTokens(node, [\":\"]);\r\n            }\r\n            return isPrecededByTokens(node, [\")\"]);\r\n\r\n        }\r\n\r\n        /**\r\n         * Returns the number of lines of comments that precede the node\r\n         * @param {ASTNode} node node to check for overlapping comments\r\n         * @param {number} lineNumTokenBefore line number of previous token, to check for overlapping comments\r\n         * @returns {number} Number of lines of comments that precede the node\r\n         * @private\r\n         */\r\n        function calcCommentLines(node, lineNumTokenBefore) {\r\n            const comments = sourceCode.getCommentsBefore(node);\r\n            let numLinesComments = 0;\r\n\r\n            if (!comments.length) {\r\n                return numLinesComments;\r\n            }\r\n\r\n            comments.forEach(comment => {\r\n                numLinesComments++;\r\n\r\n                if (comment.type === \"Block\") {\r\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\r\n                }\r\n\r\n                // avoid counting lines with inline comments twice\r\n                if (comment.loc.start.line === lineNumTokenBefore) {\r\n                    numLinesComments--;\r\n                }\r\n\r\n                if (comment.loc.end.line === node.loc.start.line) {\r\n                    numLinesComments--;\r\n                }\r\n            });\r\n\r\n            return numLinesComments;\r\n        }\r\n\r\n        /**\r\n         * Returns the line number of the token before the node that is passed in as an argument\r\n         * @param {ASTNode} node The node to use as the start of the calculation\r\n         * @returns {number} Line number of the token before `node`\r\n         * @private\r\n         */\r\n        function getLineNumberOfTokenBefore(node) {\r\n            const tokenBefore = sourceCode.getTokenBefore(node);\r\n            let lineNumTokenBefore;\r\n\r\n            /**\r\n             * Global return (at the beginning of a script) is a special case.\r\n             * If there is no token before `return`, then we expect no line\r\n             * break before the return. Comments are allowed to occupy lines\r\n             * before the global return, just no blank lines.\r\n             * Setting lineNumTokenBefore to zero in that case results in the\r\n             * desired behavior.\r\n             */\r\n            if (tokenBefore) {\r\n                lineNumTokenBefore = tokenBefore.loc.end.line;\r\n            } else {\r\n                lineNumTokenBefore = 0; // global return at beginning of script\r\n            }\r\n\r\n            return lineNumTokenBefore;\r\n        }\r\n\r\n        /**\r\n         * Checks whether node is preceded by a newline\r\n         * @param {ASTNode} node node to check\r\n         * @returns {boolean} Whether or not the node is preceded by a newline\r\n         * @private\r\n         */\r\n        function hasNewlineBefore(node) {\r\n            const lineNumNode = node.loc.start.line;\r\n            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);\r\n            const commentLines = calcCommentLines(node, lineNumTokenBefore);\r\n\r\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\r\n        }\r\n\r\n        /**\r\n         * Checks whether it is safe to apply a fix to a given return statement.\r\n         *\r\n         * The fix is not considered safe if the given return statement has leading comments,\r\n         * as we cannot safely determine if the newline should be added before or after the comments.\r\n         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211\r\n         * @param {ASTNode} node The return statement node to check.\r\n         * @returns {boolean} `true` if it can fix the node.\r\n         * @private\r\n         */\r\n        function canFix(node) {\r\n            const leadingComments = sourceCode.getCommentsBefore(node);\r\n            const lastLeadingComment = leadingComments[leadingComments.length - 1];\r\n            const tokenBefore = sourceCode.getTokenBefore(node);\r\n\r\n            if (leadingComments.length === 0) {\r\n                return true;\r\n            }\r\n\r\n            /*\r\n             * if the last leading comment ends in the same line as the previous token and\r\n             * does not share a line with the `return` node, we can consider it safe to fix.\r\n             * Example:\r\n             * function a() {\r\n             *     var b; //comment\r\n             *     return;\r\n             * }\r\n             */\r\n            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&\r\n                lastLeadingComment.loc.end.line !== node.loc.start.line) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            ReturnStatement(node) {\r\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"expected\",\r\n                        fix(fixer) {\r\n                            if (canFix(node)) {\r\n                                const tokenBefore = sourceCode.getTokenBefore(node);\r\n                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? \"\\n\\n\" : \"\\n\";\r\n\r\n                                return fixer.insertTextBefore(node, newlines);\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}