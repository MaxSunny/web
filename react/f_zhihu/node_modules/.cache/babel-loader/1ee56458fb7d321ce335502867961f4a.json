{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag use of parseInt without a radix argument\r\n * @author James Allardice\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst MODE_ALWAYS = \"always\",\n      MODE_AS_NEEDED = \"as-needed\";\nconst validRadixValues = new Set(Array.from({\n  length: 37 - 2\n}, (_, index) => index + 2));\n/**\r\n * Checks whether a given variable is shadowed or not.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is shadowed.\r\n */\n\nfunction isShadowed(variable) {\n  return variable.defs.length >= 1;\n}\n/**\r\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\r\n *      method.\r\n */\n\n\nfunction isParseIntMethod(node) {\n  return node.type === \"MemberExpression\" && !node.computed && node.property.type === \"Identifier\" && node.property.name === \"parseInt\";\n}\n/**\r\n * Checks whether a given node is a valid value of radix or not.\r\n *\r\n * The following values are invalid.\r\n *\r\n * - A literal except integers between 2 and 36.\r\n * - undefined.\r\n * @param {ASTNode} radix A node of radix to check.\r\n * @returns {boolean} `true` if the node is valid.\r\n */\n\n\nfunction isValidRadix(radix) {\n  return !(radix.type === \"Literal\" && !validRadixValues.has(radix.value) || radix.type === \"Identifier\" && radix.name === \"undefined\");\n}\n/**\r\n * Checks whether a given node is a default value of radix or not.\r\n * @param {ASTNode} radix A node of radix to check.\r\n * @returns {boolean} `true` if the node is the literal node of `10`.\r\n */\n\n\nfunction isDefaultRadix(radix) {\n  return radix.type === \"Literal\" && radix.value === 10;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/radix\"\n    },\n    hasSuggestions: true,\n    schema: [{\n      enum: [\"always\", \"as-needed\"]\n    }],\n    messages: {\n      missingParameters: \"Missing parameters.\",\n      redundantRadix: \"Redundant radix parameter.\",\n      missingRadix: \"Missing radix parameter.\",\n      invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\n      addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\n    }\n  },\n\n  create(context) {\n    const mode = context.options[0] || MODE_ALWAYS;\n    /**\r\n     * Checks the arguments of a given CallExpression node and reports it if it\r\n     * offends this rule.\r\n     * @param {ASTNode} node A CallExpression node to check.\r\n     * @returns {void}\r\n     */\n\n    function checkArguments(node) {\n      const args = node.arguments;\n\n      switch (args.length) {\n        case 0:\n          context.report({\n            node,\n            messageId: \"missingParameters\"\n          });\n          break;\n\n        case 1:\n          if (mode === MODE_ALWAYS) {\n            context.report({\n              node,\n              messageId: \"missingRadix\",\n              suggest: [{\n                messageId: \"addRadixParameter10\",\n\n                fix(fixer) {\n                  const sourceCode = context.getSourceCode();\n                  const tokens = sourceCode.getTokens(node);\n                  const lastToken = tokens[tokens.length - 1]; // Parenthesis.\n\n                  const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\n\n                  const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\n                  return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\n                }\n\n              }]\n            });\n          }\n\n          break;\n\n        default:\n          if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"redundantRadix\"\n            });\n          } else if (!isValidRadix(args[1])) {\n            context.report({\n              node,\n              messageId: \"invalidRadix\"\n            });\n          }\n\n          break;\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const scope = context.getScope();\n        let variable; // Check `parseInt()`\n\n        variable = astUtils.getVariableByName(scope, \"parseInt\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier;\n\n            if (astUtils.isCallee(node)) {\n              checkArguments(node.parent);\n            }\n          });\n        } // Check `Number.parseInt()`\n\n\n        variable = astUtils.getVariableByName(scope, \"Number\");\n\n        if (variable && !isShadowed(variable)) {\n          variable.references.forEach(reference => {\n            const node = reference.identifier.parent;\n            const maybeCallee = node.parent.type === \"ChainExpression\" ? node.parent : node;\n\n            if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\n              checkArguments(maybeCallee.parent);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/radix.js"],"names":["astUtils","require","MODE_ALWAYS","MODE_AS_NEEDED","validRadixValues","Set","Array","from","length","_","index","isShadowed","variable","defs","isParseIntMethod","node","type","computed","property","name","isValidRadix","radix","has","value","isDefaultRadix","module","exports","meta","docs","description","recommended","url","hasSuggestions","schema","enum","messages","missingParameters","redundantRadix","missingRadix","invalidRadix","addRadixParameter10","create","context","mode","options","checkArguments","args","arguments","report","messageId","suggest","fix","fixer","sourceCode","getSourceCode","tokens","getTokens","lastToken","secondToLastToken","hasTrailingComma","insertTextBefore","scope","getScope","getVariableByName","references","forEach","reference","identifier","isCallee","parent","maybeCallee"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag use of parseInt without a radix argument\r\n * @author James Allardice\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst MODE_ALWAYS = \"always\",\r\n    MODE_AS_NEEDED = \"as-needed\";\r\n\r\nconst validRadixValues = new Set(Array.from({ length: 37 - 2 }, (_, index) => index + 2));\r\n\r\n/**\r\n * Checks whether a given variable is shadowed or not.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is shadowed.\r\n */\r\nfunction isShadowed(variable) {\r\n    return variable.defs.length >= 1;\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a MemberExpression of `parseInt` method or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`\r\n *      method.\r\n */\r\nfunction isParseIntMethod(node) {\r\n    return (\r\n        node.type === \"MemberExpression\" &&\r\n        !node.computed &&\r\n        node.property.type === \"Identifier\" &&\r\n        node.property.name === \"parseInt\"\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a valid value of radix or not.\r\n *\r\n * The following values are invalid.\r\n *\r\n * - A literal except integers between 2 and 36.\r\n * - undefined.\r\n * @param {ASTNode} radix A node of radix to check.\r\n * @returns {boolean} `true` if the node is valid.\r\n */\r\nfunction isValidRadix(radix) {\r\n    return !(\r\n        (radix.type === \"Literal\" && !validRadixValues.has(radix.value)) ||\r\n        (radix.type === \"Identifier\" && radix.name === \"undefined\")\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether a given node is a default value of radix or not.\r\n * @param {ASTNode} radix A node of radix to check.\r\n * @returns {boolean} `true` if the node is the literal node of `10`.\r\n */\r\nfunction isDefaultRadix(radix) {\r\n    return radix.type === \"Literal\" && radix.value === 10;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce the consistent use of the radix argument when using `parseInt()`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/radix\"\r\n        },\r\n\r\n        hasSuggestions: true,\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"as-needed\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            missingParameters: \"Missing parameters.\",\r\n            redundantRadix: \"Redundant radix parameter.\",\r\n            missingRadix: \"Missing radix parameter.\",\r\n            invalidRadix: \"Invalid radix parameter, must be an integer between 2 and 36.\",\r\n            addRadixParameter10: \"Add radix parameter `10` for parsing decimal numbers.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const mode = context.options[0] || MODE_ALWAYS;\r\n\r\n        /**\r\n         * Checks the arguments of a given CallExpression node and reports it if it\r\n         * offends this rule.\r\n         * @param {ASTNode} node A CallExpression node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkArguments(node) {\r\n            const args = node.arguments;\r\n\r\n            switch (args.length) {\r\n                case 0:\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"missingParameters\"\r\n                    });\r\n                    break;\r\n\r\n                case 1:\r\n                    if (mode === MODE_ALWAYS) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"missingRadix\",\r\n                            suggest: [\r\n                                {\r\n                                    messageId: \"addRadixParameter10\",\r\n                                    fix(fixer) {\r\n                                        const sourceCode = context.getSourceCode();\r\n                                        const tokens = sourceCode.getTokens(node);\r\n                                        const lastToken = tokens[tokens.length - 1]; // Parenthesis.\r\n                                        const secondToLastToken = tokens[tokens.length - 2]; // May or may not be a comma.\r\n                                        const hasTrailingComma = secondToLastToken.type === \"Punctuator\" && secondToLastToken.value === \",\";\r\n\r\n                                        return fixer.insertTextBefore(lastToken, hasTrailingComma ? \" 10,\" : \", 10\");\r\n                                    }\r\n                                }\r\n                            ]\r\n                        });\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"redundantRadix\"\r\n                        });\r\n                    } else if (!isValidRadix(args[1])) {\r\n                        context.report({\r\n                            node,\r\n                            messageId: \"invalidRadix\"\r\n                        });\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return {\r\n            \"Program:exit\"() {\r\n                const scope = context.getScope();\r\n                let variable;\r\n\r\n                // Check `parseInt()`\r\n                variable = astUtils.getVariableByName(scope, \"parseInt\");\r\n                if (variable && !isShadowed(variable)) {\r\n                    variable.references.forEach(reference => {\r\n                        const node = reference.identifier;\r\n\r\n                        if (astUtils.isCallee(node)) {\r\n                            checkArguments(node.parent);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Check `Number.parseInt()`\r\n                variable = astUtils.getVariableByName(scope, \"Number\");\r\n                if (variable && !isShadowed(variable)) {\r\n                    variable.references.forEach(reference => {\r\n                        const node = reference.identifier.parent;\r\n                        const maybeCallee = node.parent.type === \"ChainExpression\"\r\n                            ? node.parent\r\n                            : node;\r\n\r\n                        if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {\r\n                            checkArguments(maybeCallee.parent);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}