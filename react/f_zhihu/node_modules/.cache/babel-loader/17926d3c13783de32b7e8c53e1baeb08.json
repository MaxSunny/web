{"ast":null,"code":"var path = require('path');\n\nvar fs = require('fs');\n\nvar utils = require('./utils');\n\nvar del = require('./del');\n\nvar writeJSON = utils.writeJSON;\nvar cache = {\n  /**\r\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\r\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\r\n   * then the cache module directory `./cache` will be used instead\r\n   *\r\n   * @method load\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   */\n  load: function (docId, cacheDir) {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n\n    if (fs.existsSync(me._pathToFile)) {\n      me._persisted = utils.tryParse(me._pathToFile, {});\n    }\n  },\n\n  /**\r\n   * Load the cache from the provided file\r\n   * @method loadFile\r\n   * @param  {String} pathToFile the path to the file containing the info for the cache\r\n   */\n  loadFile: function (pathToFile) {\n    var me = this;\n    var dir = path.dirname(pathToFile);\n    var fName = path.basename(pathToFile);\n    me.load(fName, dir);\n  },\n\n  /**\r\n   * Returns the entire persisted object\r\n   * @method all\r\n   * @returns {*}\r\n   */\n  all: function () {\n    return this._persisted;\n  },\n  keys: function () {\n    return Object.keys(this._persisted);\n  },\n\n  /**\r\n   * sets a key to a given value\r\n   * @method setKey\r\n   * @param key {string} the key to set\r\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\r\n   */\n  setKey: function (key, value) {\n    this._visited[key] = true;\n    this._persisted[key] = value;\n  },\n\n  /**\r\n   * remove a given key from the cache\r\n   * @method removeKey\r\n   * @param key {String} the key to remove from the object\r\n   */\n  removeKey: function (key) {\n    delete this._visited[key]; // esfmt-ignore-line\n\n    delete this._persisted[key]; // esfmt-ignore-line\n  },\n\n  /**\r\n   * Return the value of the provided key\r\n   * @method getKey\r\n   * @param key {String} the name of the key to retrieve\r\n   * @returns {*} the value from the key\r\n   */\n  getKey: function (key) {\n    this._visited[key] = true;\n    return this._persisted[key];\n  },\n\n  /**\r\n   * Remove keys that were not accessed/set since the\r\n   * last time the `prune` method was called.\r\n   * @method _prune\r\n   * @private\r\n   */\n  _prune: function () {\n    var me = this;\n    var obj = {};\n    var keys = Object.keys(me._visited); // no keys visited for either get or set value\n\n    if (keys.length === 0) {\n      return;\n    }\n\n    keys.forEach(function (key) {\n      obj[key] = me._persisted[key];\n    });\n    me._visited = {};\n    me._persisted = obj;\n  },\n\n  /**\r\n   * Save the state of the cache identified by the docId to disk\r\n   * as a JSON structure\r\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\r\n   * @method save\r\n   */\n  save: function (noPrune) {\n    var me = this;\n    !noPrune && me._prune();\n    writeJSON(me._pathToFile, me._persisted);\n  },\n\n  /**\r\n   * remove the file where the cache is persisted\r\n   * @method removeCacheFile\r\n   * @return {Boolean} true or false if the file was successfully deleted\r\n   */\n  removeCacheFile: function () {\n    return del(this._pathToFile);\n  },\n\n  /**\r\n   * Destroy the file cache and cache content.\r\n   * @method destroy\r\n   */\n  destroy: function () {\n    var me = this;\n    me._visited = {};\n    me._persisted = {};\n    me.removeCacheFile();\n  }\n};\nmodule.exports = {\n  /**\r\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\r\n   *\r\n   * @method load\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   * @returns {cache} cache instance\r\n   */\n  load: function (docId, cacheDir) {\n    return this.create(docId, cacheDir);\n  },\n\n  /**\r\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\r\n   * cache storage.\r\n   *\r\n   * @method create\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   * @returns {cache} cache instance\r\n   */\n  create: function (docId, cacheDir) {\n    var obj = Object.create(cache);\n    obj.load(docId, cacheDir);\n    return obj;\n  },\n  createFromFile: function (filePath) {\n    var obj = Object.create(cache);\n    obj.loadFile(filePath);\n    return obj;\n  },\n\n  /**\r\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\r\n   *\r\n   * @method clearCache\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param cacheDir {String} the directory where the cache file was written\r\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\r\n   */\n  clearCacheById: function (docId, cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\n    return del(filePath);\n  },\n\n  /**\r\n   * Remove all cache stored in the cache directory\r\n   * @method clearAll\r\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\r\n   */\n  clearAll: function (cacheDir) {\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\n    return del(filePath);\n  }\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/flat-cache/src/cache.js"],"names":["path","require","fs","utils","del","writeJSON","cache","load","docId","cacheDir","me","_visited","_persisted","_pathToFile","resolve","__dirname","existsSync","tryParse","loadFile","pathToFile","dir","dirname","fName","basename","all","keys","Object","setKey","key","value","removeKey","getKey","_prune","obj","length","forEach","save","noPrune","removeCacheFile","destroy","module","exports","create","createFromFile","filePath","clearCacheById","clearAll"],"mappings":"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","sourcesContent":["var path = require('path');\r\nvar fs = require('fs');\r\nvar utils = require('./utils');\r\nvar del = require('./del');\r\nvar writeJSON = utils.writeJSON;\r\n\r\nvar cache = {\r\n  /**\r\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\r\n   * cache storage. If specified `cacheDir` will be used as the directory to persist the data to. If omitted\r\n   * then the cache module directory `./cache` will be used instead\r\n   *\r\n   * @method load\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   */\r\n  load: function (docId, cacheDir) {\r\n    var me = this;\r\n\r\n    me._visited = {};\r\n    me._persisted = {};\r\n    me._pathToFile = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\r\n\r\n    if (fs.existsSync(me._pathToFile)) {\r\n      me._persisted = utils.tryParse(me._pathToFile, {});\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Load the cache from the provided file\r\n   * @method loadFile\r\n   * @param  {String} pathToFile the path to the file containing the info for the cache\r\n   */\r\n  loadFile: function (pathToFile) {\r\n    var me = this;\r\n    var dir = path.dirname(pathToFile);\r\n    var fName = path.basename(pathToFile);\r\n\r\n    me.load(fName, dir);\r\n  },\r\n\r\n  /**\r\n   * Returns the entire persisted object\r\n   * @method all\r\n   * @returns {*}\r\n   */\r\n  all: function () {\r\n    return this._persisted;\r\n  },\r\n\r\n  keys: function () {\r\n    return Object.keys(this._persisted);\r\n  },\r\n  /**\r\n   * sets a key to a given value\r\n   * @method setKey\r\n   * @param key {string} the key to set\r\n   * @param value {object} the value of the key. Could be any object that can be serialized with JSON.stringify\r\n   */\r\n  setKey: function (key, value) {\r\n    this._visited[key] = true;\r\n    this._persisted[key] = value;\r\n  },\r\n  /**\r\n   * remove a given key from the cache\r\n   * @method removeKey\r\n   * @param key {String} the key to remove from the object\r\n   */\r\n  removeKey: function (key) {\r\n    delete this._visited[key]; // esfmt-ignore-line\r\n    delete this._persisted[key]; // esfmt-ignore-line\r\n  },\r\n  /**\r\n   * Return the value of the provided key\r\n   * @method getKey\r\n   * @param key {String} the name of the key to retrieve\r\n   * @returns {*} the value from the key\r\n   */\r\n  getKey: function (key) {\r\n    this._visited[key] = true;\r\n    return this._persisted[key];\r\n  },\r\n\r\n  /**\r\n   * Remove keys that were not accessed/set since the\r\n   * last time the `prune` method was called.\r\n   * @method _prune\r\n   * @private\r\n   */\r\n  _prune: function () {\r\n    var me = this;\r\n    var obj = {};\r\n\r\n    var keys = Object.keys(me._visited);\r\n\r\n    // no keys visited for either get or set value\r\n    if (keys.length === 0) {\r\n      return;\r\n    }\r\n\r\n    keys.forEach(function (key) {\r\n      obj[key] = me._persisted[key];\r\n    });\r\n\r\n    me._visited = {};\r\n    me._persisted = obj;\r\n  },\r\n\r\n  /**\r\n   * Save the state of the cache identified by the docId to disk\r\n   * as a JSON structure\r\n   * @param [noPrune=false] {Boolean} whether to remove from cache the non visited files\r\n   * @method save\r\n   */\r\n  save: function (noPrune) {\r\n    var me = this;\r\n\r\n    !noPrune && me._prune();\r\n    writeJSON(me._pathToFile, me._persisted);\r\n  },\r\n\r\n  /**\r\n   * remove the file where the cache is persisted\r\n   * @method removeCacheFile\r\n   * @return {Boolean} true or false if the file was successfully deleted\r\n   */\r\n  removeCacheFile: function () {\r\n    return del(this._pathToFile);\r\n  },\r\n  /**\r\n   * Destroy the file cache and cache content.\r\n   * @method destroy\r\n   */\r\n  destroy: function () {\r\n    var me = this;\r\n    me._visited = {};\r\n    me._persisted = {};\r\n\r\n    me.removeCacheFile();\r\n  },\r\n};\r\n\r\nmodule.exports = {\r\n  /**\r\n   * Alias for create. Should be considered depreacted. Will be removed in next releases\r\n   *\r\n   * @method load\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   * @returns {cache} cache instance\r\n   */\r\n  load: function (docId, cacheDir) {\r\n    return this.create(docId, cacheDir);\r\n  },\r\n\r\n  /**\r\n   * Load a cache identified by the given Id. If the element does not exists, then initialize an empty\r\n   * cache storage.\r\n   *\r\n   * @method create\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param [cacheDir] {String} directory for the cache entry\r\n   * @returns {cache} cache instance\r\n   */\r\n  create: function (docId, cacheDir) {\r\n    var obj = Object.create(cache);\r\n    obj.load(docId, cacheDir);\r\n    return obj;\r\n  },\r\n\r\n  createFromFile: function (filePath) {\r\n    var obj = Object.create(cache);\r\n    obj.loadFile(filePath);\r\n    return obj;\r\n  },\r\n  /**\r\n   * Clear the cache identified by the given id. Caches stored in a different cache directory can be deleted directly\r\n   *\r\n   * @method clearCache\r\n   * @param docId {String} the id of the cache, would also be used as the name of the file cache\r\n   * @param cacheDir {String} the directory where the cache file was written\r\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\r\n   */\r\n  clearCacheById: function (docId, cacheDir) {\r\n    var filePath = cacheDir ? path.resolve(cacheDir, docId) : path.resolve(__dirname, '../.cache/', docId);\r\n    return del(filePath);\r\n  },\r\n  /**\r\n   * Remove all cache stored in the cache directory\r\n   * @method clearAll\r\n   * @returns {Boolean} true if the cache folder was deleted. False otherwise\r\n   */\r\n  clearAll: function (cacheDir) {\r\n    var filePath = cacheDir ? path.resolve(cacheDir) : path.resolve(__dirname, '../.cache/');\r\n    return del(filePath);\r\n  },\r\n};\r\n"]},"metadata":{},"sourceType":"script"}