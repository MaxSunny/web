{"ast":null,"code":"/**\r\n * @fileoverview Rule to check the spacing around the * in generator functions.\r\n * @author Jamund Ferguson\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst OVERRIDE_SCHEMA = {\n  oneOf: [{\n    enum: [\"before\", \"after\", \"both\", \"neither\"]\n  }, {\n    type: \"object\",\n    properties: {\n      before: {\n        type: \"boolean\"\n      },\n      after: {\n        type: \"boolean\"\n      }\n    },\n    additionalProperties: false\n  }]\n};\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing around `*` operators in generator functions\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/generator-star-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"before\", \"after\", \"both\", \"neither\"]\n      }, {\n        type: \"object\",\n        properties: {\n          before: {\n            type: \"boolean\"\n          },\n          after: {\n            type: \"boolean\"\n          },\n          named: OVERRIDE_SCHEMA,\n          anonymous: OVERRIDE_SCHEMA,\n          method: OVERRIDE_SCHEMA\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      missingBefore: \"Missing space before *.\",\n      missingAfter: \"Missing space after *.\",\n      unexpectedBefore: \"Unexpected space before *.\",\n      unexpectedAfter: \"Unexpected space after *.\"\n    }\n  },\n\n  create(context) {\n    const optionDefinitions = {\n      before: {\n        before: true,\n        after: false\n      },\n      after: {\n        before: false,\n        after: true\n      },\n      both: {\n        before: true,\n        after: true\n      },\n      neither: {\n        before: false,\n        after: false\n      }\n    };\n    /**\r\n     * Returns resolved option definitions based on an option and defaults\r\n     * @param {any} option The option object or string value\r\n     * @param {Object} defaults The defaults to use if options are not present\r\n     * @returns {Object} the resolved object definition\r\n     */\n\n    function optionToDefinition(option, defaults) {\n      if (!option) {\n        return defaults;\n      }\n\n      return typeof option === \"string\" ? optionDefinitions[option] : Object.assign({}, defaults, option);\n    }\n\n    const modes = function (option) {\n      const defaults = optionToDefinition(option, optionDefinitions.before);\n      return {\n        named: optionToDefinition(option.named, defaults),\n        anonymous: optionToDefinition(option.anonymous, defaults),\n        method: optionToDefinition(option.method, defaults)\n      };\n    }(context.options[0] || {});\n\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Checks if the given token is a star token or not.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} `true` if the token is a star token.\r\n     */\n\n    function isStarToken(token) {\n      return token.value === \"*\" && token.type === \"Punctuator\";\n    }\n    /**\r\n     * Gets the generator star token of the given function node.\r\n     * @param {ASTNode} node The function node to get.\r\n     * @returns {Token} Found star token.\r\n     */\n\n\n    function getStarToken(node) {\n      return sourceCode.getFirstToken(node.parent.method || node.parent.type === \"MethodDefinition\" ? node.parent : node, isStarToken);\n    }\n    /**\r\n     * capitalize a given string.\r\n     * @param {string} str the given string.\r\n     * @returns {string} the capitalized string.\r\n     */\n\n\n    function capitalize(str) {\n      return str[0].toUpperCase() + str.slice(1);\n    }\n    /**\r\n     * Checks the spacing between two tokens before or after the star token.\r\n     * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\r\n     * @param {string} side Either \"before\" or \"after\".\r\n     * @param {Token} leftToken `function` keyword token if side is \"before\", or\r\n     *     star token if side is \"after\".\r\n     * @param {Token} rightToken Star token if side is \"before\", or identifier\r\n     *     token if side is \"after\".\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacing(kind, side, leftToken, rightToken) {\n      if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\n        const after = leftToken.value === \"*\";\n        const spaceRequired = modes[kind][side];\n        const node = after ? leftToken : rightToken;\n        const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\n        context.report({\n          node,\n          messageId,\n\n          fix(fixer) {\n            if (spaceRequired) {\n              if (after) {\n                return fixer.insertTextAfter(node, \" \");\n              }\n\n              return fixer.insertTextBefore(node, \" \");\n            }\n\n            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Enforces the spacing around the star if node is a generator function.\r\n     * @param {ASTNode} node A function expression or declaration node.\r\n     * @returns {void}\r\n     */\n\n\n    function checkFunction(node) {\n      if (!node.generator) {\n        return;\n      }\n\n      const starToken = getStarToken(node);\n      const prevToken = sourceCode.getTokenBefore(starToken);\n      const nextToken = sourceCode.getTokenAfter(starToken);\n      let kind = \"named\";\n\n      if (node.parent.type === \"MethodDefinition\" || node.parent.type === \"Property\" && node.parent.method) {\n        kind = \"method\";\n      } else if (!node.id) {\n        kind = \"anonymous\";\n      } // Only check before when preceded by `function`|`static` keyword\n\n\n      if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\n        checkSpacing(kind, \"before\", prevToken, starToken);\n      }\n\n      checkSpacing(kind, \"after\", starToken, nextToken);\n    }\n\n    return {\n      FunctionDeclaration: checkFunction,\n      FunctionExpression: checkFunction\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/generator-star-spacing.js"],"names":["OVERRIDE_SCHEMA","oneOf","enum","type","properties","before","after","additionalProperties","module","exports","meta","docs","description","recommended","url","fixable","schema","named","anonymous","method","messages","missingBefore","missingAfter","unexpectedBefore","unexpectedAfter","create","context","optionDefinitions","both","neither","optionToDefinition","option","defaults","Object","assign","modes","options","sourceCode","getSourceCode","isStarToken","token","value","getStarToken","node","getFirstToken","parent","capitalize","str","toUpperCase","slice","checkSpacing","kind","side","leftToken","rightToken","range","spaceRequired","messageId","report","fix","fixer","insertTextAfter","insertTextBefore","removeRange","checkFunction","generator","starToken","prevToken","getTokenBefore","nextToken","getTokenAfter","id","FunctionDeclaration","FunctionExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check the spacing around the * in generator functions.\r\n * @author Jamund Ferguson\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst OVERRIDE_SCHEMA = {\r\n    oneOf: [\r\n        {\r\n            enum: [\"before\", \"after\", \"both\", \"neither\"]\r\n        },\r\n        {\r\n            type: \"object\",\r\n            properties: {\r\n                before: { type: \"boolean\" },\r\n                after: { type: \"boolean\" }\r\n            },\r\n            additionalProperties: false\r\n        }\r\n    ]\r\n};\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing around `*` operators in generator functions\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/generator-star-spacing\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"before\", \"after\", \"both\", \"neither\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            before: { type: \"boolean\" },\r\n                            after: { type: \"boolean\" },\r\n                            named: OVERRIDE_SCHEMA,\r\n                            anonymous: OVERRIDE_SCHEMA,\r\n                            method: OVERRIDE_SCHEMA\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            missingBefore: \"Missing space before *.\",\r\n            missingAfter: \"Missing space after *.\",\r\n            unexpectedBefore: \"Unexpected space before *.\",\r\n            unexpectedAfter: \"Unexpected space after *.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const optionDefinitions = {\r\n            before: { before: true, after: false },\r\n            after: { before: false, after: true },\r\n            both: { before: true, after: true },\r\n            neither: { before: false, after: false }\r\n        };\r\n\r\n        /**\r\n         * Returns resolved option definitions based on an option and defaults\r\n         * @param {any} option The option object or string value\r\n         * @param {Object} defaults The defaults to use if options are not present\r\n         * @returns {Object} the resolved object definition\r\n         */\r\n        function optionToDefinition(option, defaults) {\r\n            if (!option) {\r\n                return defaults;\r\n            }\r\n\r\n            return typeof option === \"string\"\r\n                ? optionDefinitions[option]\r\n                : Object.assign({}, defaults, option);\r\n        }\r\n\r\n        const modes = (function(option) {\r\n            const defaults = optionToDefinition(option, optionDefinitions.before);\r\n\r\n            return {\r\n                named: optionToDefinition(option.named, defaults),\r\n                anonymous: optionToDefinition(option.anonymous, defaults),\r\n                method: optionToDefinition(option.method, defaults)\r\n            };\r\n        }(context.options[0] || {}));\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Checks if the given token is a star token or not.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} `true` if the token is a star token.\r\n         */\r\n        function isStarToken(token) {\r\n            return token.value === \"*\" && token.type === \"Punctuator\";\r\n        }\r\n\r\n        /**\r\n         * Gets the generator star token of the given function node.\r\n         * @param {ASTNode} node The function node to get.\r\n         * @returns {Token} Found star token.\r\n         */\r\n        function getStarToken(node) {\r\n            return sourceCode.getFirstToken(\r\n                (node.parent.method || node.parent.type === \"MethodDefinition\") ? node.parent : node,\r\n                isStarToken\r\n            );\r\n        }\r\n\r\n        /**\r\n         * capitalize a given string.\r\n         * @param {string} str the given string.\r\n         * @returns {string} the capitalized string.\r\n         */\r\n        function capitalize(str) {\r\n            return str[0].toUpperCase() + str.slice(1);\r\n        }\r\n\r\n        /**\r\n         * Checks the spacing between two tokens before or after the star token.\r\n         * @param {string} kind Either \"named\", \"anonymous\", or \"method\"\r\n         * @param {string} side Either \"before\" or \"after\".\r\n         * @param {Token} leftToken `function` keyword token if side is \"before\", or\r\n         *     star token if side is \"after\".\r\n         * @param {Token} rightToken Star token if side is \"before\", or identifier\r\n         *     token if side is \"after\".\r\n         * @returns {void}\r\n         */\r\n        function checkSpacing(kind, side, leftToken, rightToken) {\r\n            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {\r\n                const after = leftToken.value === \"*\";\r\n                const spaceRequired = modes[kind][side];\r\n                const node = after ? leftToken : rightToken;\r\n                const messageId = `${spaceRequired ? \"missing\" : \"unexpected\"}${capitalize(side)}`;\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId,\r\n                    fix(fixer) {\r\n                        if (spaceRequired) {\r\n                            if (after) {\r\n                                return fixer.insertTextAfter(node, \" \");\r\n                            }\r\n                            return fixer.insertTextBefore(node, \" \");\r\n                        }\r\n                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Enforces the spacing around the star if node is a generator function.\r\n         * @param {ASTNode} node A function expression or declaration node.\r\n         * @returns {void}\r\n         */\r\n        function checkFunction(node) {\r\n            if (!node.generator) {\r\n                return;\r\n            }\r\n\r\n            const starToken = getStarToken(node);\r\n            const prevToken = sourceCode.getTokenBefore(starToken);\r\n            const nextToken = sourceCode.getTokenAfter(starToken);\r\n\r\n            let kind = \"named\";\r\n\r\n            if (node.parent.type === \"MethodDefinition\" || (node.parent.type === \"Property\" && node.parent.method)) {\r\n                kind = \"method\";\r\n            } else if (!node.id) {\r\n                kind = \"anonymous\";\r\n            }\r\n\r\n            // Only check before when preceded by `function`|`static` keyword\r\n            if (!(kind === \"method\" && starToken === sourceCode.getFirstToken(node.parent))) {\r\n                checkSpacing(kind, \"before\", prevToken, starToken);\r\n            }\r\n\r\n            checkSpacing(kind, \"after\", starToken, nextToken);\r\n        }\r\n\r\n        return {\r\n            FunctionDeclaration: checkFunction,\r\n            FunctionExpression: checkFunction\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}