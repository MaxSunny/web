{"ast":null,"code":"/**\r\n * @fileoverview An object that caches and applies source code fixes.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n\nconst BOM = \"\\uFEFF\";\n/**\r\n * Compares items in a messages array by range.\r\n * @param {Message} a The first message.\r\n * @param {Message} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\n\nfunction compareMessagesByFixRange(a, b) {\n  return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\n}\n/**\r\n * Compares items in a messages array by line and column.\r\n * @param {Message} a The first message.\r\n * @param {Message} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\n\n\nfunction compareMessagesByLocation(a, b) {\n  return a.line - b.line || a.column - b.column;\n} //------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\r\n * Utility for apply fixes to source code.\r\n * @constructor\r\n */\n\n\nfunction SourceCodeFixer() {\n  Object.freeze(this);\n}\n/**\r\n * Applies the fixes specified by the messages to the given text. Tries to be\r\n * smart about the fixes and won't apply fixes over the same area in the text.\r\n * @param {string} sourceText The text to apply the changes to.\r\n * @param {Message[]} messages The array of messages reported by ESLint.\r\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\r\n * @returns {Object} An object containing the fixed text and any unfixed messages.\r\n */\n\n\nSourceCodeFixer.applyFixes = function (sourceText, messages, shouldFix) {\n  debug(\"Applying fixes\");\n\n  if (shouldFix === false) {\n    debug(\"shouldFix parameter was false, not attempting fixes\");\n    return {\n      fixed: false,\n      messages,\n      output: sourceText\n    };\n  } // clone the array\n\n\n  const remainingMessages = [],\n        fixes = [],\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\n        text = bom ? sourceText.slice(1) : sourceText;\n  let lastPos = Number.NEGATIVE_INFINITY,\n      output = bom;\n  /**\r\n   * Try to use the 'fix' from a problem.\r\n   * @param {Message} problem The message object to apply fixes from\r\n   * @returns {boolean} Whether fix was successfully applied\r\n   */\n\n  function attemptFix(problem) {\n    const fix = problem.fix;\n    const start = fix.range[0];\n    const end = fix.range[1]; // Remain it as a problem if it's overlapped or it's a negative range\n\n    if (lastPos >= start || start > end) {\n      remainingMessages.push(problem);\n      return false;\n    } // Remove BOM.\n\n\n    if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {\n      output = \"\";\n    } // Make output to this fix.\n\n\n    output += text.slice(Math.max(0, lastPos), Math.max(0, start));\n    output += fix.text;\n    lastPos = end;\n    return true;\n  }\n\n  messages.forEach(problem => {\n    if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\n      fixes.push(problem);\n    } else {\n      remainingMessages.push(problem);\n    }\n  });\n\n  if (fixes.length) {\n    debug(\"Found fixes to apply\");\n    let fixesWereApplied = false;\n\n    for (const problem of fixes.sort(compareMessagesByFixRange)) {\n      if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\n        attemptFix(problem);\n        /*\r\n         * The only time attemptFix will fail is if a previous fix was\r\n         * applied which conflicts with it.  So we can mark this as true.\r\n         */\n\n        fixesWereApplied = true;\n      } else {\n        remainingMessages.push(problem);\n      }\n    }\n\n    output += text.slice(Math.max(0, lastPos));\n    return {\n      fixed: fixesWereApplied,\n      messages: remainingMessages.sort(compareMessagesByLocation),\n      output\n    };\n  }\n\n  debug(\"No fixes to apply\");\n  return {\n    fixed: false,\n    messages,\n    output: bom + text\n  };\n};\n\nmodule.exports = SourceCodeFixer;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/linter/source-code-fixer.js"],"names":["debug","require","BOM","compareMessagesByFixRange","a","b","fix","range","compareMessagesByLocation","line","column","SourceCodeFixer","Object","freeze","applyFixes","sourceText","messages","shouldFix","fixed","output","remainingMessages","fixes","bom","startsWith","text","slice","lastPos","Number","NEGATIVE_INFINITY","attemptFix","problem","start","end","push","Math","max","forEach","prototype","hasOwnProperty","call","length","fixesWereApplied","sort","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview An object that caches and applies source code fixes.\r\n * @author Nicholas C. Zakas\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst debug = require(\"debug\")(\"eslint:source-code-fixer\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst BOM = \"\\uFEFF\";\r\n\r\n/**\r\n * Compares items in a messages array by range.\r\n * @param {Message} a The first message.\r\n * @param {Message} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\r\nfunction compareMessagesByFixRange(a, b) {\r\n    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];\r\n}\r\n\r\n/**\r\n * Compares items in a messages array by line and column.\r\n * @param {Message} a The first message.\r\n * @param {Message} b The second message.\r\n * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.\r\n * @private\r\n */\r\nfunction compareMessagesByLocation(a, b) {\r\n    return a.line - b.line || a.column - b.column;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Public Interface\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Utility for apply fixes to source code.\r\n * @constructor\r\n */\r\nfunction SourceCodeFixer() {\r\n    Object.freeze(this);\r\n}\r\n\r\n/**\r\n * Applies the fixes specified by the messages to the given text. Tries to be\r\n * smart about the fixes and won't apply fixes over the same area in the text.\r\n * @param {string} sourceText The text to apply the changes to.\r\n * @param {Message[]} messages The array of messages reported by ESLint.\r\n * @param {boolean|Function} [shouldFix=true] Determines whether each message should be fixed\r\n * @returns {Object} An object containing the fixed text and any unfixed messages.\r\n */\r\nSourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {\r\n    debug(\"Applying fixes\");\r\n\r\n    if (shouldFix === false) {\r\n        debug(\"shouldFix parameter was false, not attempting fixes\");\r\n        return {\r\n            fixed: false,\r\n            messages,\r\n            output: sourceText\r\n        };\r\n    }\r\n\r\n    // clone the array\r\n    const remainingMessages = [],\r\n        fixes = [],\r\n        bom = sourceText.startsWith(BOM) ? BOM : \"\",\r\n        text = bom ? sourceText.slice(1) : sourceText;\r\n    let lastPos = Number.NEGATIVE_INFINITY,\r\n        output = bom;\r\n\r\n    /**\r\n     * Try to use the 'fix' from a problem.\r\n     * @param {Message} problem The message object to apply fixes from\r\n     * @returns {boolean} Whether fix was successfully applied\r\n     */\r\n    function attemptFix(problem) {\r\n        const fix = problem.fix;\r\n        const start = fix.range[0];\r\n        const end = fix.range[1];\r\n\r\n        // Remain it as a problem if it's overlapped or it's a negative range\r\n        if (lastPos >= start || start > end) {\r\n            remainingMessages.push(problem);\r\n            return false;\r\n        }\r\n\r\n        // Remove BOM.\r\n        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) {\r\n            output = \"\";\r\n        }\r\n\r\n        // Make output to this fix.\r\n        output += text.slice(Math.max(0, lastPos), Math.max(0, start));\r\n        output += fix.text;\r\n        lastPos = end;\r\n        return true;\r\n    }\r\n\r\n    messages.forEach(problem => {\r\n        if (Object.prototype.hasOwnProperty.call(problem, \"fix\")) {\r\n            fixes.push(problem);\r\n        } else {\r\n            remainingMessages.push(problem);\r\n        }\r\n    });\r\n\r\n    if (fixes.length) {\r\n        debug(\"Found fixes to apply\");\r\n        let fixesWereApplied = false;\r\n\r\n        for (const problem of fixes.sort(compareMessagesByFixRange)) {\r\n            if (typeof shouldFix !== \"function\" || shouldFix(problem)) {\r\n                attemptFix(problem);\r\n\r\n                /*\r\n                 * The only time attemptFix will fail is if a previous fix was\r\n                 * applied which conflicts with it.  So we can mark this as true.\r\n                 */\r\n                fixesWereApplied = true;\r\n            } else {\r\n                remainingMessages.push(problem);\r\n            }\r\n        }\r\n        output += text.slice(Math.max(0, lastPos));\r\n\r\n        return {\r\n            fixed: fixesWereApplied,\r\n            messages: remainingMessages.sort(compareMessagesByLocation),\r\n            output\r\n        };\r\n    }\r\n\r\n    debug(\"No fixes to apply\");\r\n    return {\r\n        fixed: false,\r\n        messages,\r\n        output: bom + text\r\n    };\r\n\r\n};\r\n\r\nmodule.exports = SourceCodeFixer;\r\n"]},"metadata":{},"sourceType":"script"}