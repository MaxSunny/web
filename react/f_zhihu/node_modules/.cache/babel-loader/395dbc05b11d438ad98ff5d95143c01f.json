{"ast":null,"code":"/**\r\n * @fileoverview Rule that warns about used warning comments\r\n * @author Alexander Schmidt <https://github.com/lxanders>\r\n */\n\"use strict\";\n\nconst escapeRegExp = require(\"escape-string-regexp\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst CHAR_LIMIT = 40; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified warning terms in comments\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-warning-comments\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        terms: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          }\n        },\n        location: {\n          enum: [\"start\", \"anywhere\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode(),\n          configuration = context.options[0] || {},\n          warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n          location = configuration.location || \"start\",\n          selfConfigRegEx = /\\bno-warning-comments\\b/u;\n    /**\r\n     * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\r\n     * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\r\n     * require word boundaries on that side.\r\n     * @param {string} term A term to convert to a RegExp\r\n     * @returns {RegExp} The term converted to a RegExp\r\n     */\n\n    function convertToRegExp(term) {\n      const escaped = escapeRegExp(term);\n      const wordBoundary = \"\\\\b\";\n      const eitherOrWordBoundary = `|${wordBoundary}`;\n      let prefix;\n      /*\r\n       * If the term ends in a word character (a-z0-9_), ensure a word\r\n       * boundary at the end, so that substrings do not get falsely\r\n       * matched. eg \"todo\" in a string such as \"mastodon\".\r\n       * If the term ends in a non-word character, then \\b won't match on\r\n       * the boundary to the next non-word character, which would likely\r\n       * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\r\n       * In these cases, use no bounding match. Same applies for the\r\n       * prefix, handled below.\r\n       */\n\n      const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\n\n      if (location === \"start\") {\n        /*\r\n         * When matching at the start, ignore leading whitespace, and\r\n         * there's no need to worry about word boundaries.\r\n         */\n        prefix = \"^\\\\s*\";\n      } else if (/^\\w/u.test(term)) {\n        prefix = wordBoundary;\n      } else {\n        prefix = \"\";\n      }\n\n      if (location === \"start\") {\n        /*\r\n         * For location \"start\" the regex should be\r\n         * ^\\s*TERM\\b.  This checks the word boundary\r\n         * at the beginning of the comment.\r\n         */\n        return new RegExp(prefix + escaped + suffix, \"iu\");\n      }\n      /*\r\n       * For location \"anywhere\" the regex should be\r\n       * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\r\n       * for the term.\r\n       */\n\n\n      return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, \"iu\");\n    }\n\n    const warningRegExps = warningTerms.map(convertToRegExp);\n    /**\r\n     * Checks the specified comment for matches of the configured warning terms and returns the matches.\r\n     * @param {string} comment The comment which is checked.\r\n     * @returns {Array} All matched warning terms for this comment.\r\n     */\n\n    function commentContainsWarningTerm(comment) {\n      const matches = [];\n      warningRegExps.forEach((regex, index) => {\n        if (regex.test(comment)) {\n          matches.push(warningTerms[index]);\n        }\n      });\n      return matches;\n    }\n    /**\r\n     * Checks the specified node for matching warning comments and reports them.\r\n     * @param {ASTNode} node The AST node being checked.\r\n     * @returns {void} undefined.\r\n     */\n\n\n    function checkComment(node) {\n      const comment = node.value;\n\n      if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {\n        return;\n      }\n\n      const matches = commentContainsWarningTerm(comment);\n      matches.forEach(matchedTerm => {\n        let commentToDisplay = \"\";\n        let truncated = false;\n\n        for (const c of comment.trim().split(/\\s+/u)) {\n          const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\n\n          if (tmp.length <= CHAR_LIMIT) {\n            commentToDisplay = tmp;\n          } else {\n            truncated = true;\n            break;\n          }\n        }\n\n        context.report({\n          node,\n          messageId: \"unexpectedComment\",\n          data: {\n            matchedTerm,\n            comment: `${commentToDisplay}${truncated ? \"...\" : \"\"}`\n          }\n        });\n      });\n    }\n\n    return {\n      Program() {\n        const comments = sourceCode.getAllComments();\n        comments.filter(token => token.type !== \"Shebang\").forEach(checkComment);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-warning-comments.js"],"names":["escapeRegExp","require","astUtils","CHAR_LIMIT","module","exports","meta","type","docs","description","recommended","url","schema","properties","terms","items","location","enum","additionalProperties","messages","unexpectedComment","create","context","sourceCode","getSourceCode","configuration","options","warningTerms","selfConfigRegEx","convertToRegExp","term","escaped","wordBoundary","eitherOrWordBoundary","prefix","suffix","test","RegExp","warningRegExps","map","commentContainsWarningTerm","comment","matches","forEach","regex","index","push","checkComment","node","value","isDirectiveComment","matchedTerm","commentToDisplay","truncated","c","trim","split","tmp","length","report","messageId","data","Program","comments","getAllComments","filter","token"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule that warns about used warning comments\r\n * @author Alexander Schmidt <https://github.com/lxanders>\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst escapeRegExp = require(\"escape-string-regexp\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\nconst CHAR_LIMIT = 40;\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow specified warning terms in comments\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-warning-comments\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    terms: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    location: {\r\n                        enum: [\"start\", \"anywhere\"]\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedComment: \"Unexpected '{{matchedTerm}}' comment: '{{comment}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode(),\r\n            configuration = context.options[0] || {},\r\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\r\n            location = configuration.location || \"start\",\r\n            selfConfigRegEx = /\\bno-warning-comments\\b/u;\r\n\r\n        /**\r\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\r\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\r\n         * require word boundaries on that side.\r\n         * @param {string} term A term to convert to a RegExp\r\n         * @returns {RegExp} The term converted to a RegExp\r\n         */\r\n        function convertToRegExp(term) {\r\n            const escaped = escapeRegExp(term);\r\n            const wordBoundary = \"\\\\b\";\r\n            const eitherOrWordBoundary = `|${wordBoundary}`;\r\n            let prefix;\r\n\r\n            /*\r\n             * If the term ends in a word character (a-z0-9_), ensure a word\r\n             * boundary at the end, so that substrings do not get falsely\r\n             * matched. eg \"todo\" in a string such as \"mastodon\".\r\n             * If the term ends in a non-word character, then \\b won't match on\r\n             * the boundary to the next non-word character, which would likely\r\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\r\n             * In these cases, use no bounding match. Same applies for the\r\n             * prefix, handled below.\r\n             */\r\n            const suffix = /\\w$/u.test(term) ? \"\\\\b\" : \"\";\r\n\r\n            if (location === \"start\") {\r\n\r\n                /*\r\n                 * When matching at the start, ignore leading whitespace, and\r\n                 * there's no need to worry about word boundaries.\r\n                 */\r\n                prefix = \"^\\\\s*\";\r\n            } else if (/^\\w/u.test(term)) {\r\n                prefix = wordBoundary;\r\n            } else {\r\n                prefix = \"\";\r\n            }\r\n\r\n            if (location === \"start\") {\r\n\r\n                /*\r\n                 * For location \"start\" the regex should be\r\n                 * ^\\s*TERM\\b.  This checks the word boundary\r\n                 * at the beginning of the comment.\r\n                 */\r\n                return new RegExp(prefix + escaped + suffix, \"iu\");\r\n            }\r\n\r\n            /*\r\n             * For location \"anywhere\" the regex should be\r\n             * \\bTERM\\b|\\bTERM\\b, this checks the entire comment\r\n             * for the term.\r\n             */\r\n            return new RegExp(\r\n                prefix +\r\n                    escaped +\r\n                    suffix +\r\n                    eitherOrWordBoundary +\r\n                    term +\r\n                    wordBoundary,\r\n                \"iu\"\r\n            );\r\n        }\r\n\r\n        const warningRegExps = warningTerms.map(convertToRegExp);\r\n\r\n        /**\r\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\r\n         * @param {string} comment The comment which is checked.\r\n         * @returns {Array} All matched warning terms for this comment.\r\n         */\r\n        function commentContainsWarningTerm(comment) {\r\n            const matches = [];\r\n\r\n            warningRegExps.forEach((regex, index) => {\r\n                if (regex.test(comment)) {\r\n                    matches.push(warningTerms[index]);\r\n                }\r\n            });\r\n\r\n            return matches;\r\n        }\r\n\r\n        /**\r\n         * Checks the specified node for matching warning comments and reports them.\r\n         * @param {ASTNode} node The AST node being checked.\r\n         * @returns {void} undefined.\r\n         */\r\n        function checkComment(node) {\r\n            const comment = node.value;\r\n\r\n            if (\r\n                astUtils.isDirectiveComment(node) &&\r\n                selfConfigRegEx.test(comment)\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            const matches = commentContainsWarningTerm(comment);\r\n\r\n            matches.forEach(matchedTerm => {\r\n                let commentToDisplay = \"\";\r\n                let truncated = false;\r\n\r\n                for (const c of comment.trim().split(/\\s+/u)) {\r\n                    const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;\r\n\r\n                    if (tmp.length <= CHAR_LIMIT) {\r\n                        commentToDisplay = tmp;\r\n                    } else {\r\n                        truncated = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: \"unexpectedComment\",\r\n                    data: {\r\n                        matchedTerm,\r\n                        comment: `${commentToDisplay}${\r\n                            truncated ? \"...\" : \"\"\r\n                        }`\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        return {\r\n            Program() {\r\n                const comments = sourceCode.getAllComments();\r\n\r\n                comments\r\n                    .filter(token => token.type !== \"Shebang\")\r\n                    .forEach(checkComment);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}