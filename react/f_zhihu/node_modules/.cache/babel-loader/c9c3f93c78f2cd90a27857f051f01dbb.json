{"ast":null,"code":"/**\r\n * @filedescription Object Schema\r\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Requirements\n//-----------------------------------------------------------------------------\n\nconst {\n  MergeStrategy\n} = require(\"./merge-strategy\");\n\nconst {\n  ValidationStrategy\n} = require(\"./validation-strategy\"); //-----------------------------------------------------------------------------\n// Private\n//-----------------------------------------------------------------------------\n\n\nconst strategies = Symbol(\"strategies\");\nconst requiredKeys = Symbol(\"requiredKeys\");\n/**\r\n * Validates a schema strategy.\r\n * @param {string} name The name of the key this strategy is for.\r\n * @param {Object} strategy The strategy for the object key.\r\n * @param {boolean} [strategy.required=true] Whether the key is required.\r\n * @param {string[]} [strategy.requires] Other keys that are required when\r\n *      this key is present.\r\n * @param {Function} strategy.merge A method to call when merging two objects\r\n *      with the same key.\r\n * @param {Function} strategy.validate A method to call when validating an\r\n *      object with the key.\r\n * @returns {void}\r\n * @throws {Error} When the strategy is missing a name.\r\n * @throws {Error} When the strategy is missing a merge() method.\r\n * @throws {Error} When the strategy is missing a validate() method.\r\n */\n\nfunction validateDefinition(name, strategy) {\n  let hasSchema = false;\n\n  if (strategy.schema) {\n    if (typeof strategy.schema === \"object\") {\n      hasSchema = true;\n    } else {\n      throw new TypeError(\"Schema must be an object.\");\n    }\n  }\n\n  if (typeof strategy.merge === \"string\") {\n    if (!(strategy.merge in MergeStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.merge !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\n  }\n\n  if (typeof strategy.validate === \"string\") {\n    if (!(strategy.validate in ValidationStrategy)) {\n      throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\n    }\n  } else if (!hasSchema && typeof strategy.validate !== \"function\") {\n    throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\n  }\n} //-----------------------------------------------------------------------------\n// Class\n//-----------------------------------------------------------------------------\n\n/**\r\n * Represents an object validation/merging schema.\r\n */\n\n\nclass ObjectSchema {\n  /**\r\n   * Creates a new instance.\r\n   */\n  constructor(definitions) {\n    if (!definitions) {\n      throw new Error(\"Schema definitions missing.\");\n    }\n    /**\r\n     * Track all strategies in the schema by key.\r\n     * @type {Map}\r\n     * @property strategies\r\n     */\n\n\n    this[strategies] = new Map();\n    /**\r\n     * Separately track any keys that are required for faster validation.\r\n     * @type {Map}\r\n     * @property requiredKeys\r\n     */\n\n    this[requiredKeys] = new Map(); // add in all strategies\n\n    for (const key of Object.keys(definitions)) {\n      validateDefinition(key, definitions[key]); // normalize merge and validate methods if subschema is present\n\n      if (typeof definitions[key].schema === \"object\") {\n        const schema = new ObjectSchema(definitions[key].schema);\n        definitions[key] = { ...definitions[key],\n\n          merge() {\n            let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            let second = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return schema.merge(first, second);\n          },\n\n          validate(value) {\n            ValidationStrategy.object(value);\n            schema.validate(value);\n          }\n\n        };\n      } // normalize the merge method in case there's a string\n\n\n      if (typeof definitions[key].merge === \"string\") {\n        definitions[key] = { ...definitions[key],\n          merge: MergeStrategy[definitions[key].merge]\n        };\n      }\n\n      ; // normalize the validate method in case there's a string\n\n      if (typeof definitions[key].validate === \"string\") {\n        definitions[key] = { ...definitions[key],\n          validate: ValidationStrategy[definitions[key].validate]\n        };\n      }\n\n      ;\n      this[strategies].set(key, definitions[key]);\n\n      if (definitions[key].required) {\n        this[requiredKeys].set(key, definitions[key]);\n      }\n    }\n  }\n  /**\r\n   * Determines if a strategy has been registered for the given object key.\r\n   * @param {string} key The object key to find a strategy for.\r\n   * @returns {boolean} True if the key has a strategy registered, false if not. \r\n   */\n\n\n  hasKey(key) {\n    return this[strategies].has(key);\n  }\n  /**\r\n   * Merges objects together to create a new object comprised of the keys\r\n   * of the all objects. Keys are merged based on the each key's merge\r\n   * strategy.\r\n   * @param {...Object} objects The objects to merge.\r\n   * @returns {Object} A new object with a mix of all objects' keys.\r\n   * @throws {Error} If any object is invalid.\r\n   */\n\n\n  merge() {\n    for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n      objects[_key] = arguments[_key];\n    }\n\n    // double check arguments\n    if (objects.length < 2) {\n      throw new Error(\"merge() requires at least two arguments.\");\n    }\n\n    if (objects.some(object => object == null || typeof object !== \"object\")) {\n      throw new Error(\"All arguments must be objects.\");\n    }\n\n    return objects.reduce((result, object) => {\n      this.validate(object);\n\n      for (const [key, strategy] of this[strategies]) {\n        try {\n          if (key in result || key in object) {\n            const value = strategy.merge.call(this, result[key], object[key]);\n\n            if (value !== undefined) {\n              result[key] = value;\n            }\n          }\n        } catch (ex) {\n          ex.message = `Key \"${key}\": ` + ex.message;\n          throw ex;\n        }\n      }\n\n      return result;\n    }, {});\n  }\n  /**\r\n   * Validates an object's keys based on the validate strategy for each key.\r\n   * @param {Object} object The object to validate.\r\n   * @returns {void}\r\n   * @throws {Error} When the object is invalid. \r\n   */\n\n\n  validate(object) {\n    // check existing keys first\n    for (const key of Object.keys(object)) {\n      // check to see if the key is defined\n      if (!this.hasKey(key)) {\n        throw new Error(`Unexpected key \"${key}\" found.`);\n      } // validate existing keys\n\n\n      const strategy = this[strategies].get(key); // first check to see if any other keys are required\n\n      if (Array.isArray(strategy.requires)) {\n        if (!strategy.requires.every(otherKey => otherKey in object)) {\n          throw new Error(`Key \"${key}\" requires keys \"${strategy.requires.join(\"\\\", \\\"\")}\".`);\n        }\n      } // now apply remaining validation strategy\n\n\n      try {\n        strategy.validate.call(strategy, object[key]);\n      } catch (ex) {\n        ex.message = `Key \"${key}\": ` + ex.message;\n        throw ex;\n      }\n    } // ensure required keys aren't missing\n\n\n    for (const [key] of this[requiredKeys]) {\n      if (!(key in object)) {\n        throw new Error(`Missing required key \"${key}\".`);\n      }\n    }\n  }\n\n}\n\nexports.ObjectSchema = ObjectSchema;","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/@humanwhocodes/object-schema/src/object-schema.js"],"names":["MergeStrategy","require","ValidationStrategy","strategies","Symbol","requiredKeys","validateDefinition","name","strategy","hasSchema","schema","TypeError","merge","validate","ObjectSchema","constructor","definitions","Error","Map","key","Object","keys","first","second","value","object","set","required","hasKey","has","objects","length","some","reduce","result","call","undefined","ex","message","get","Array","isArray","requires","every","otherKey","join","exports"],"mappings":"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","sourcesContent":["/**\r\n * @filedescription Object Schema\r\n */\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Requirements\r\n//-----------------------------------------------------------------------------\r\n\r\nconst { MergeStrategy } = require(\"./merge-strategy\");\r\nconst { ValidationStrategy } = require(\"./validation-strategy\");\r\n\r\n//-----------------------------------------------------------------------------\r\n// Private\r\n//-----------------------------------------------------------------------------\r\n\r\nconst strategies = Symbol(\"strategies\");\r\nconst requiredKeys = Symbol(\"requiredKeys\");\r\n\r\n/**\r\n * Validates a schema strategy.\r\n * @param {string} name The name of the key this strategy is for.\r\n * @param {Object} strategy The strategy for the object key.\r\n * @param {boolean} [strategy.required=true] Whether the key is required.\r\n * @param {string[]} [strategy.requires] Other keys that are required when\r\n *      this key is present.\r\n * @param {Function} strategy.merge A method to call when merging two objects\r\n *      with the same key.\r\n * @param {Function} strategy.validate A method to call when validating an\r\n *      object with the key.\r\n * @returns {void}\r\n * @throws {Error} When the strategy is missing a name.\r\n * @throws {Error} When the strategy is missing a merge() method.\r\n * @throws {Error} When the strategy is missing a validate() method.\r\n */\r\nfunction validateDefinition(name, strategy) {\r\n\r\n    let hasSchema = false;\r\n    if (strategy.schema) {\r\n        if (typeof strategy.schema === \"object\") {\r\n            hasSchema = true;\r\n        } else {\r\n            throw new TypeError(\"Schema must be an object.\");\r\n        }\r\n    }\r\n\r\n    if (typeof strategy.merge === \"string\") {\r\n        if (!(strategy.merge in MergeStrategy)) {\r\n            throw new TypeError(`Definition for key \"${name}\" missing valid merge strategy.`);\r\n        }\r\n    } else if (!hasSchema && typeof strategy.merge !== \"function\") {\r\n        throw new TypeError(`Definition for key \"${name}\" must have a merge property.`);\r\n    }\r\n\r\n    if (typeof strategy.validate === \"string\") {\r\n        if (!(strategy.validate in ValidationStrategy)) {\r\n            throw new TypeError(`Definition for key \"${name}\" missing valid validation strategy.`);\r\n        }\r\n    } else if (!hasSchema && typeof strategy.validate !== \"function\") {\r\n        throw new TypeError(`Definition for key \"${name}\" must have a validate() method.`);\r\n    }\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Class\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Represents an object validation/merging schema.\r\n */\r\nclass ObjectSchema {\r\n\r\n    /**\r\n     * Creates a new instance.\r\n     */\r\n    constructor(definitions) {\r\n\r\n        if (!definitions) {\r\n            throw new Error(\"Schema definitions missing.\");\r\n        }\r\n\r\n        /**\r\n         * Track all strategies in the schema by key.\r\n         * @type {Map}\r\n         * @property strategies\r\n         */\r\n        this[strategies] = new Map();\r\n\r\n        /**\r\n         * Separately track any keys that are required for faster validation.\r\n         * @type {Map}\r\n         * @property requiredKeys\r\n         */\r\n        this[requiredKeys] = new Map();\r\n\r\n        // add in all strategies\r\n        for (const key of Object.keys(definitions)) {\r\n            validateDefinition(key, definitions[key]);\r\n\r\n            // normalize merge and validate methods if subschema is present\r\n            if (typeof definitions[key].schema === \"object\") {\r\n                const schema = new ObjectSchema(definitions[key].schema);\r\n                definitions[key] = {\r\n                    ...definitions[key],\r\n                    merge(first = {}, second = {}) {\r\n                        return schema.merge(first, second);\r\n                    },\r\n                    validate(value) {\r\n                        ValidationStrategy.object(value);\r\n                        schema.validate(value);\r\n                    }\r\n                };\r\n            }\r\n\r\n            // normalize the merge method in case there's a string\r\n            if (typeof definitions[key].merge === \"string\") {\r\n                definitions[key] = {\r\n                    ...definitions[key],\r\n                    merge: MergeStrategy[definitions[key].merge]\r\n                };\r\n            };\r\n\r\n            // normalize the validate method in case there's a string\r\n            if (typeof definitions[key].validate === \"string\") {\r\n                definitions[key] = {\r\n                    ...definitions[key],\r\n                    validate: ValidationStrategy[definitions[key].validate]\r\n                };\r\n            };\r\n\r\n            this[strategies].set(key, definitions[key]);\r\n\r\n            if (definitions[key].required) {\r\n                this[requiredKeys].set(key, definitions[key]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines if a strategy has been registered for the given object key.\r\n     * @param {string} key The object key to find a strategy for.\r\n     * @returns {boolean} True if the key has a strategy registered, false if not. \r\n     */\r\n    hasKey(key) {\r\n        return this[strategies].has(key);\r\n    }\r\n\r\n    /**\r\n     * Merges objects together to create a new object comprised of the keys\r\n     * of the all objects. Keys are merged based on the each key's merge\r\n     * strategy.\r\n     * @param {...Object} objects The objects to merge.\r\n     * @returns {Object} A new object with a mix of all objects' keys.\r\n     * @throws {Error} If any object is invalid.\r\n     */\r\n    merge(...objects) {\r\n\r\n        // double check arguments\r\n        if (objects.length < 2) {\r\n            throw new Error(\"merge() requires at least two arguments.\");\r\n        }\r\n\r\n        if (objects.some(object => (object == null || typeof object !== \"object\"))) {\r\n            throw new Error(\"All arguments must be objects.\");\r\n        }\r\n\r\n        return objects.reduce((result, object) => {\r\n            \r\n            this.validate(object);\r\n            \r\n            for (const [key, strategy] of this[strategies]) {\r\n                try {\r\n                    if (key in result || key in object) {\r\n                        const value = strategy.merge.call(this, result[key], object[key]);\r\n                        if (value !== undefined) {\r\n                            result[key] = value;\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    ex.message = `Key \"${key}\": ` + ex.message;\r\n                    throw ex;\r\n                }\r\n            }\r\n            return result;\r\n        }, {});\r\n    }\r\n\r\n    /**\r\n     * Validates an object's keys based on the validate strategy for each key.\r\n     * @param {Object} object The object to validate.\r\n     * @returns {void}\r\n     * @throws {Error} When the object is invalid. \r\n     */\r\n    validate(object) {\r\n\r\n        // check existing keys first\r\n        for (const key of Object.keys(object)) {\r\n\r\n            // check to see if the key is defined\r\n            if (!this.hasKey(key)) {\r\n                throw new Error(`Unexpected key \"${key}\" found.`);\r\n            }\r\n\r\n            // validate existing keys\r\n            const strategy = this[strategies].get(key);\r\n\r\n            // first check to see if any other keys are required\r\n            if (Array.isArray(strategy.requires)) {\r\n                if (!strategy.requires.every(otherKey => otherKey in object)) {\r\n                    throw new Error(`Key \"${key}\" requires keys \"${strategy.requires.join(\"\\\", \\\"\")}\".`);\r\n                }\r\n            }\r\n\r\n            // now apply remaining validation strategy\r\n            try {\r\n                strategy.validate.call(strategy, object[key]);\r\n            } catch (ex) {\r\n                ex.message = `Key \"${key}\": ` + ex.message;\r\n                throw ex;\r\n            }\r\n        }\r\n\r\n        // ensure required keys aren't missing\r\n        for (const [key] of this[requiredKeys]) {\r\n            if (!(key in object)) {\r\n                throw new Error(`Missing required key \"${key}\".`);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\nexports.ObjectSchema = ObjectSchema;\r\n"]},"metadata":{},"sourceType":"script"}