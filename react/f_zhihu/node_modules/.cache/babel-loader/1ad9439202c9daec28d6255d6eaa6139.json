{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce line breaks between arguments of a function call\r\n * @author Alexey Gonchar <https://github.com/finico>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce line breaks between arguments of a function call\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      enum: [\"always\", \"never\", \"consistent\"]\n    }],\n    messages: {\n      unexpectedLineBreak: \"There should be no line break here.\",\n      missingLineBreak: \"There should be a line break after this argument.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const checkers = {\n      unexpected: {\n        messageId: \"unexpectedLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\n      },\n      missing: {\n        messageId: \"missingLineBreak\",\n        check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\n        createFix: (token, tokenBefore) => fixer => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\n      }\n    };\n    /**\r\n     * Check all arguments for line breaks in the CallExpression\r\n     * @param {CallExpression} node node to evaluate\r\n     * @param {{ messageId: string, check: Function }} checker selected checker\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n    function checkArguments(node, checker) {\n      for (let i = 1; i < node.arguments.length; i++) {\n        const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\n        const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\n\n        if (checker.check(prevArgToken, currentArgToken)) {\n          const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {\n            includeComments: true\n          });\n          const hasLineCommentBefore = tokenBefore.type === \"Line\";\n          context.report({\n            node,\n            loc: {\n              start: tokenBefore.loc.end,\n              end: currentArgToken.loc.start\n            },\n            messageId: checker.messageId,\n            fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\n          });\n        }\n      }\n    }\n    /**\r\n     * Check if open space is present in a function name\r\n     * @param {CallExpression} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function check(node) {\n      if (node.arguments.length < 2) {\n        return;\n      }\n\n      const option = context.options[0] || \"always\";\n\n      if (option === \"never\") {\n        checkArguments(node, checkers.unexpected);\n      } else if (option === \"always\") {\n        checkArguments(node, checkers.missing);\n      } else if (option === \"consistent\") {\n        const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\n        const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\n\n        if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\n          checkArguments(node, checkers.unexpected);\n        } else {\n          checkArguments(node, checkers.missing);\n        }\n      }\n    }\n\n    return {\n      CallExpression: check,\n      NewExpression: check\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/function-call-argument-newline.js"],"names":["module","exports","meta","type","docs","description","recommended","url","fixable","schema","enum","messages","unexpectedLineBreak","missingLineBreak","create","context","sourceCode","getSourceCode","checkers","unexpected","messageId","check","prevToken","currentToken","loc","end","line","start","createFix","token","tokenBefore","fixer","replaceTextRange","range","missing","checkArguments","node","checker","i","arguments","length","prevArgToken","getLastToken","currentArgToken","getFirstToken","getTokenBefore","includeComments","hasLineCommentBefore","report","fix","option","options","firstArgToken","secondArgToken","CallExpression","NewExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce line breaks between arguments of a function call\r\n * @author Alexey Gonchar <https://github.com/finico>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce line breaks between arguments of a function call\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/function-call-argument-newline\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"always\", \"never\", \"consistent\"]\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpectedLineBreak: \"There should be no line break here.\",\r\n            missingLineBreak: \"There should be a line break after this argument.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const checkers = {\r\n            unexpected: {\r\n                messageId: \"unexpectedLineBreak\",\r\n                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,\r\n                createFix: (token, tokenBefore) => fixer =>\r\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \" \")\r\n            },\r\n            missing: {\r\n                messageId: \"missingLineBreak\",\r\n                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,\r\n                createFix: (token, tokenBefore) => fixer =>\r\n                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], \"\\n\")\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Check all arguments for line breaks in the CallExpression\r\n         * @param {CallExpression} node node to evaluate\r\n         * @param {{ messageId: string, check: Function }} checker selected checker\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function checkArguments(node, checker) {\r\n            for (let i = 1; i < node.arguments.length; i++) {\r\n                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);\r\n                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);\r\n\r\n                if (checker.check(prevArgToken, currentArgToken)) {\r\n                    const tokenBefore = sourceCode.getTokenBefore(\r\n                        currentArgToken,\r\n                        { includeComments: true }\r\n                    );\r\n\r\n                    const hasLineCommentBefore = tokenBefore.type === \"Line\";\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            start: tokenBefore.loc.end,\r\n                            end: currentArgToken.loc.start\r\n                        },\r\n                        messageId: checker.messageId,\r\n                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check if open space is present in a function name\r\n         * @param {CallExpression} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function check(node) {\r\n            if (node.arguments.length < 2) {\r\n                return;\r\n            }\r\n\r\n            const option = context.options[0] || \"always\";\r\n\r\n            if (option === \"never\") {\r\n                checkArguments(node, checkers.unexpected);\r\n            } else if (option === \"always\") {\r\n                checkArguments(node, checkers.missing);\r\n            } else if (option === \"consistent\") {\r\n                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);\r\n                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);\r\n\r\n                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {\r\n                    checkArguments(node, checkers.unexpected);\r\n                } else {\r\n                    checkArguments(node, checkers.missing);\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            CallExpression: check,\r\n            NewExpression: check\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}