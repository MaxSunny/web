{"ast":null,"code":"/**\r\n * @fileoverview A rule to ensure blank lines within blocks.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"require or disallow padding within blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/padded-blocks\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      oneOf: [{\n        enum: [\"always\", \"never\"]\n      }, {\n        type: \"object\",\n        properties: {\n          blocks: {\n            enum: [\"always\", \"never\"]\n          },\n          switches: {\n            enum: [\"always\", \"never\"]\n          },\n          classes: {\n            enum: [\"always\", \"never\"]\n          }\n        },\n        additionalProperties: false,\n        minProperties: 1\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLineBlocks: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      alwaysPadBlock: \"Block must be padded by blank lines.\",\n      neverPadBlock: \"Block must not be padded by blank lines.\"\n    }\n  },\n\n  create(context) {\n    const options = {};\n    const typeOptions = context.options[0] || \"always\";\n    const exceptOptions = context.options[1] || {};\n\n    if (typeof typeOptions === \"string\") {\n      const shouldHavePadding = typeOptions === \"always\";\n      options.blocks = shouldHavePadding;\n      options.switches = shouldHavePadding;\n      options.classes = shouldHavePadding;\n    } else {\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\n        options.blocks = typeOptions.blocks === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\n        options.switches = typeOptions.switches === \"always\";\n      }\n\n      if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\n        options.classes = typeOptions.classes === \"always\";\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\n      options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\n    }\n\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Gets the open brace token from a given node.\r\n     * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\r\n     * @returns {Token} The token of the open brace.\r\n     */\n\n    function getOpenBrace(node) {\n      if (node.type === \"SwitchStatement\") {\n        return sourceCode.getTokenBefore(node.cases[0]);\n      }\n\n      if (node.type === \"StaticBlock\") {\n        return sourceCode.getFirstToken(node, {\n          skip: 1\n        }); // skip the `static` token\n      } // `BlockStatement` or `ClassBody`\n\n\n      return sourceCode.getFirstToken(node);\n    }\n    /**\r\n     * Checks if the given parameter is a comment node\r\n     * @param {ASTNode|Token} node An AST node or token\r\n     * @returns {boolean} True if node is a comment\r\n     */\n\n\n    function isComment(node) {\n      return node.type === \"Line\" || node.type === \"Block\";\n    }\n    /**\r\n     * Checks if there is padding between two tokens\r\n     * @param {Token} first The first token\r\n     * @param {Token} second The second token\r\n     * @returns {boolean} True if there is at least a line between the tokens\r\n     */\n\n\n    function isPaddingBetweenTokens(first, second) {\n      return second.loc.start.line - first.loc.end.line >= 2;\n    }\n    /**\r\n     * Checks if the given token has a blank line after it.\r\n     * @param {Token} token The token to check.\r\n     * @returns {boolean} Whether or not the token is followed by a blank line.\r\n     */\n\n\n    function getFirstBlockToken(token) {\n      let prev,\n          first = token;\n\n      do {\n        prev = first;\n        first = sourceCode.getTokenAfter(first, {\n          includeComments: true\n        });\n      } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\n\n      return first;\n    }\n    /**\r\n     * Checks if the given token is preceded by a blank line.\r\n     * @param {Token} token The token to check\r\n     * @returns {boolean} Whether or not the token is preceded by a blank line\r\n     */\n\n\n    function getLastBlockToken(token) {\n      let last = token,\n          next;\n\n      do {\n        next = last;\n        last = sourceCode.getTokenBefore(last, {\n          includeComments: true\n        });\n      } while (isComment(last) && last.loc.end.line === next.loc.start.line);\n\n      return last;\n    }\n    /**\r\n     * Checks if a node should be padded, according to the rule config.\r\n     * @param {ASTNode} node The AST node to check.\r\n     * @throws {Error} (Unreachable)\r\n     * @returns {boolean} True if the node should be padded, false otherwise.\r\n     */\n\n\n    function requirePaddingFor(node) {\n      switch (node.type) {\n        case \"BlockStatement\":\n        case \"StaticBlock\":\n          return options.blocks;\n\n        case \"SwitchStatement\":\n          return options.switches;\n\n        case \"ClassBody\":\n          return options.classes;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error(\"unreachable\");\n      }\n    }\n    /**\r\n     * Checks the given BlockStatement node to be padded if the block is not empty.\r\n     * @param {ASTNode} node The AST node of a BlockStatement.\r\n     * @returns {void} undefined.\r\n     */\n\n\n    function checkPadding(node) {\n      const openBrace = getOpenBrace(node),\n            firstBlockToken = getFirstBlockToken(openBrace),\n            tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {\n        includeComments: true\n      }),\n            closeBrace = sourceCode.getLastToken(node),\n            lastBlockToken = getLastBlockToken(closeBrace),\n            tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {\n        includeComments: true\n      }),\n            blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\n            blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\n\n      if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\n        return;\n      }\n\n      if (requirePaddingFor(node)) {\n        if (!blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n\n        if (!blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\n            },\n\n            messageId: \"alwaysPadBlock\"\n          });\n        }\n      } else {\n        if (blockHasTopPadding) {\n          context.report({\n            node,\n            loc: {\n              start: tokenBeforeFirst.loc.start,\n              end: firstBlockToken.loc.start\n            },\n\n            fix(fixer) {\n              return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\n            },\n\n            messageId: \"neverPadBlock\"\n          });\n        }\n\n        if (blockHasBottomPadding) {\n          context.report({\n            node,\n            loc: {\n              end: tokenAfterLast.loc.start,\n              start: lastBlockToken.loc.end\n            },\n            messageId: \"neverPadBlock\",\n\n            fix(fixer) {\n              return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\n            }\n\n          });\n        }\n      }\n    }\n\n    const rule = {};\n\n    if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\n      rule.SwitchStatement = function (node) {\n        if (node.cases.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\n      rule.BlockStatement = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n\n      rule.StaticBlock = rule.BlockStatement;\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\n      rule.ClassBody = function (node) {\n        if (node.body.length === 0) {\n          return;\n        }\n\n        checkPadding(node);\n      };\n    }\n\n    return rule;\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/padded-blocks.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","oneOf","enum","properties","blocks","switches","classes","additionalProperties","minProperties","allowSingleLineBlocks","messages","alwaysPadBlock","neverPadBlock","create","context","options","typeOptions","exceptOptions","shouldHavePadding","Object","prototype","hasOwnProperty","call","sourceCode","getSourceCode","getOpenBrace","node","getTokenBefore","cases","getFirstToken","skip","isComment","isPaddingBetweenTokens","first","second","loc","start","line","end","getFirstBlockToken","token","prev","getTokenAfter","includeComments","getLastBlockToken","last","next","requirePaddingFor","Error","checkPadding","openBrace","firstBlockToken","tokenBeforeFirst","closeBrace","getLastToken","lastBlockToken","tokenAfterLast","blockHasTopPadding","blockHasBottomPadding","isTokenOnSameLine","report","fix","fixer","insertTextAfter","messageId","insertTextBefore","replaceTextRange","range","column","rule","SwitchStatement","length","BlockStatement","body","StaticBlock","ClassBody"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to ensure blank lines within blocks.\r\n * @author Mathias Schreck <https://github.com/lo1tuma>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"require or disallow padding within blocks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/padded-blocks\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        enum: [\"always\", \"never\"]\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            blocks: {\r\n                                enum: [\"always\", \"never\"]\r\n                            },\r\n                            switches: {\r\n                                enum: [\"always\", \"never\"]\r\n                            },\r\n                            classes: {\r\n                                enum: [\"always\", \"never\"]\r\n                            }\r\n                        },\r\n                        additionalProperties: false,\r\n                        minProperties: 1\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowSingleLineBlocks: {\r\n                        type: \"boolean\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            alwaysPadBlock: \"Block must be padded by blank lines.\",\r\n            neverPadBlock: \"Block must not be padded by blank lines.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = {};\r\n        const typeOptions = context.options[0] || \"always\";\r\n        const exceptOptions = context.options[1] || {};\r\n\r\n        if (typeof typeOptions === \"string\") {\r\n            const shouldHavePadding = typeOptions === \"always\";\r\n\r\n            options.blocks = shouldHavePadding;\r\n            options.switches = shouldHavePadding;\r\n            options.classes = shouldHavePadding;\r\n        } else {\r\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"blocks\")) {\r\n                options.blocks = typeOptions.blocks === \"always\";\r\n            }\r\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"switches\")) {\r\n                options.switches = typeOptions.switches === \"always\";\r\n            }\r\n            if (Object.prototype.hasOwnProperty.call(typeOptions, \"classes\")) {\r\n                options.classes = typeOptions.classes === \"always\";\r\n            }\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(exceptOptions, \"allowSingleLineBlocks\")) {\r\n            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;\r\n        }\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Gets the open brace token from a given node.\r\n         * @param {ASTNode} node A BlockStatement or SwitchStatement node from which to get the open brace.\r\n         * @returns {Token} The token of the open brace.\r\n         */\r\n        function getOpenBrace(node) {\r\n            if (node.type === \"SwitchStatement\") {\r\n                return sourceCode.getTokenBefore(node.cases[0]);\r\n            }\r\n\r\n            if (node.type === \"StaticBlock\") {\r\n                return sourceCode.getFirstToken(node, { skip: 1 }); // skip the `static` token\r\n            }\r\n\r\n            // `BlockStatement` or `ClassBody`\r\n            return sourceCode.getFirstToken(node);\r\n        }\r\n\r\n        /**\r\n         * Checks if the given parameter is a comment node\r\n         * @param {ASTNode|Token} node An AST node or token\r\n         * @returns {boolean} True if node is a comment\r\n         */\r\n        function isComment(node) {\r\n            return node.type === \"Line\" || node.type === \"Block\";\r\n        }\r\n\r\n        /**\r\n         * Checks if there is padding between two tokens\r\n         * @param {Token} first The first token\r\n         * @param {Token} second The second token\r\n         * @returns {boolean} True if there is at least a line between the tokens\r\n         */\r\n        function isPaddingBetweenTokens(first, second) {\r\n            return second.loc.start.line - first.loc.end.line >= 2;\r\n        }\r\n\r\n\r\n        /**\r\n         * Checks if the given token has a blank line after it.\r\n         * @param {Token} token The token to check.\r\n         * @returns {boolean} Whether or not the token is followed by a blank line.\r\n         */\r\n        function getFirstBlockToken(token) {\r\n            let prev,\r\n                first = token;\r\n\r\n            do {\r\n                prev = first;\r\n                first = sourceCode.getTokenAfter(first, { includeComments: true });\r\n            } while (isComment(first) && first.loc.start.line === prev.loc.end.line);\r\n\r\n            return first;\r\n        }\r\n\r\n        /**\r\n         * Checks if the given token is preceded by a blank line.\r\n         * @param {Token} token The token to check\r\n         * @returns {boolean} Whether or not the token is preceded by a blank line\r\n         */\r\n        function getLastBlockToken(token) {\r\n            let last = token,\r\n                next;\r\n\r\n            do {\r\n                next = last;\r\n                last = sourceCode.getTokenBefore(last, { includeComments: true });\r\n            } while (isComment(last) && last.loc.end.line === next.loc.start.line);\r\n\r\n            return last;\r\n        }\r\n\r\n        /**\r\n         * Checks if a node should be padded, according to the rule config.\r\n         * @param {ASTNode} node The AST node to check.\r\n         * @throws {Error} (Unreachable)\r\n         * @returns {boolean} True if the node should be padded, false otherwise.\r\n         */\r\n        function requirePaddingFor(node) {\r\n            switch (node.type) {\r\n                case \"BlockStatement\":\r\n                case \"StaticBlock\":\r\n                    return options.blocks;\r\n                case \"SwitchStatement\":\r\n                    return options.switches;\r\n                case \"ClassBody\":\r\n                    return options.classes;\r\n\r\n                /* istanbul ignore next */\r\n                default:\r\n                    throw new Error(\"unreachable\");\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Checks the given BlockStatement node to be padded if the block is not empty.\r\n         * @param {ASTNode} node The AST node of a BlockStatement.\r\n         * @returns {void} undefined.\r\n         */\r\n        function checkPadding(node) {\r\n            const openBrace = getOpenBrace(node),\r\n                firstBlockToken = getFirstBlockToken(openBrace),\r\n                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, { includeComments: true }),\r\n                closeBrace = sourceCode.getLastToken(node),\r\n                lastBlockToken = getLastBlockToken(closeBrace),\r\n                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, { includeComments: true }),\r\n                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),\r\n                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);\r\n\r\n            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {\r\n                return;\r\n            }\r\n\r\n            if (requirePaddingFor(node)) {\r\n\r\n                if (!blockHasTopPadding) {\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            start: tokenBeforeFirst.loc.start,\r\n                            end: firstBlockToken.loc.start\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.insertTextAfter(tokenBeforeFirst, \"\\n\");\r\n                        },\r\n                        messageId: \"alwaysPadBlock\"\r\n                    });\r\n                }\r\n                if (!blockHasBottomPadding) {\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            end: tokenAfterLast.loc.start,\r\n                            start: lastBlockToken.loc.end\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.insertTextBefore(tokenAfterLast, \"\\n\");\r\n                        },\r\n                        messageId: \"alwaysPadBlock\"\r\n                    });\r\n                }\r\n            } else {\r\n                if (blockHasTopPadding) {\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            start: tokenBeforeFirst.loc.start,\r\n                            end: firstBlockToken.loc.start\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], \"\\n\");\r\n                        },\r\n                        messageId: \"neverPadBlock\"\r\n                    });\r\n                }\r\n\r\n                if (blockHasBottomPadding) {\r\n\r\n                    context.report({\r\n                        node,\r\n                        loc: {\r\n                            end: tokenAfterLast.loc.start,\r\n                            start: lastBlockToken.loc.end\r\n                        },\r\n                        messageId: \"neverPadBlock\",\r\n                        fix(fixer) {\r\n                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], \"\\n\");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        const rule = {};\r\n\r\n        if (Object.prototype.hasOwnProperty.call(options, \"switches\")) {\r\n            rule.SwitchStatement = function(node) {\r\n                if (node.cases.length === 0) {\r\n                    return;\r\n                }\r\n                checkPadding(node);\r\n            };\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(options, \"blocks\")) {\r\n            rule.BlockStatement = function(node) {\r\n                if (node.body.length === 0) {\r\n                    return;\r\n                }\r\n                checkPadding(node);\r\n            };\r\n            rule.StaticBlock = rule.BlockStatement;\r\n        }\r\n\r\n        if (Object.prototype.hasOwnProperty.call(options, \"classes\")) {\r\n            rule.ClassBody = function(node) {\r\n                if (node.body.length === 0) {\r\n                    return;\r\n                }\r\n                checkPadding(node);\r\n            };\r\n        }\r\n\r\n        return rule;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}