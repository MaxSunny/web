{"ast":null,"code":"/*\r\n * @fileoverview Main Doctrine object\r\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\r\n * @author Dan Tao <daniel.tao@gmail.com>\r\n * @author Andrew Eisenberg <andrew@eisenberg.as>\r\n */\n(function () {\n  'use strict';\n\n  var typed, utility, jsdoc, esutils, hasOwnProperty;\n  esutils = require('esutils');\n  typed = require('./typed');\n  utility = require('./utility');\n\n  function sliceSource(source, index, last) {\n    return source.slice(index, last);\n  }\n\n  hasOwnProperty = function () {\n    var func = Object.prototype.hasOwnProperty;\n    return function hasOwnProperty(obj, name) {\n      return func.call(obj, name);\n    };\n  }();\n\n  function shallowCopy(obj) {\n    var ret = {},\n        key;\n\n    for (key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        ret[key] = obj[key];\n      }\n    }\n\n    return ret;\n  }\n\n  function isASCIIAlphanumeric(ch) {\n    return ch >= 0x61\n    /* 'a' */\n    && ch <= 0x7A\n    /* 'z' */\n    || ch >= 0x41\n    /* 'A' */\n    && ch <= 0x5A\n    /* 'Z' */\n    || ch >= 0x30\n    /* '0' */\n    && ch <= 0x39\n    /* '9' */\n    ;\n  }\n\n  function isParamTitle(title) {\n    return title === 'param' || title === 'argument' || title === 'arg';\n  }\n\n  function isReturnTitle(title) {\n    return title === 'return' || title === 'returns';\n  }\n\n  function isProperty(title) {\n    return title === 'property' || title === 'prop';\n  }\n\n  function isNameParameterRequired(title) {\n    return isParamTitle(title) || isProperty(title) || title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\n  }\n\n  function isAllowedName(title) {\n    return isNameParameterRequired(title) || title === 'const' || title === 'constant';\n  }\n\n  function isAllowedNested(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n\n  function isAllowedOptional(title) {\n    return isProperty(title) || isParamTitle(title);\n  }\n\n  function isTypeParameterRequired(title) {\n    return isParamTitle(title) || isReturnTitle(title) || title === 'define' || title === 'enum' || title === 'implements' || title === 'this' || title === 'type' || title === 'typedef' || isProperty(title);\n  } // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\n  // This would require changes to 'parseType'\n\n\n  function isAllowedType(title) {\n    return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' || title === 'namespace' || title === 'member' || title === 'var' || title === 'module' || title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' || title === 'public' || title === 'private' || title === 'protected';\n  } // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\n\n\n  var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\n  var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\n\n  function unwrapComment(doc) {\n    // JSDoc comment is following form\n    //   /**\n    //    * .......\n    //    */\n    return doc. // remove /**\n    replace(/^\\/\\*\\*?/, ''). // remove */\n    replace(/\\*\\/$/, ''). // remove ' * ' at the beginning of a line\n    replace(new RegExp(STAR_MATCHER, 'g'), '$2'). // remove trailing whitespace\n    replace(/\\s*$/, '');\n  }\n  /**\r\n   * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\r\n   * @param {string} originalSource The original wrapped comment\r\n   * @param {number} unwrappedIndex The index of a character in the unwrapped string\r\n   * @returns {number} The index of the corresponding character in the original wrapped string\r\n   */\n\n\n  function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\n    var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\n    var numSkippedChars = 0;\n    var matcher = new RegExp(STAR_MATCHER, 'g');\n    var match;\n\n    while (match = matcher.exec(replacedSource)) {\n      numSkippedChars += match[1].length;\n\n      if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\n        return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\n      }\n    }\n\n    return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\n  } // JSDoc Tag Parser\n\n\n  (function (exports) {\n    var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;\n\n    function advance() {\n      var ch = source.charCodeAt(index);\n      index += 1;\n\n      if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D\n      /* '\\r' */\n      && source.charCodeAt(index) === 0x0A\n      /* '\\n' */\n      )) {\n        lineNumber += 1;\n      }\n\n      return String.fromCharCode(ch);\n    }\n\n    function scanTitle() {\n      var title = ''; // waste '@'\n\n      advance();\n\n      while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\n        title += advance();\n      }\n\n      return title;\n    }\n\n    function seekContent() {\n      var ch,\n          waiting,\n          last = index;\n      waiting = false;\n\n      while (last < length) {\n        ch = source.charCodeAt(last);\n\n        if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D\n        /* '\\r' */\n        && source.charCodeAt(last + 1) === 0x0A\n        /* '\\n' */\n        )) {\n          waiting = true;\n        } else if (waiting) {\n          if (ch === 0x40\n          /* '@' */\n          ) {\n            break;\n          }\n\n          if (!esutils.code.isWhiteSpace(ch)) {\n            waiting = false;\n          }\n        }\n\n        last += 1;\n      }\n\n      return last;\n    } // type expression may have nest brace, such as,\n    // { { ok: string } }\n    //\n    // therefore, scanning type expression with balancing braces.\n\n\n    function parseType(title, last, addRange) {\n      var ch,\n          brace,\n          type,\n          startIndex,\n          direct = false; // search '{'\n\n      while (index < last) {\n        ch = source.charCodeAt(index);\n\n        if (esutils.code.isWhiteSpace(ch)) {\n          advance();\n        } else if (ch === 0x7B\n        /* '{' */\n        ) {\n          advance();\n          break;\n        } else {\n          // this is direct pattern\n          direct = true;\n          break;\n        }\n      }\n\n      if (direct) {\n        return null;\n      } // type expression { is found\n\n\n      brace = 1;\n      type = '';\n\n      while (index < last) {\n        ch = source.charCodeAt(index);\n\n        if (esutils.code.isLineTerminator(ch)) {\n          advance();\n        } else {\n          if (ch === 0x7D\n          /* '}' */\n          ) {\n            brace -= 1;\n\n            if (brace === 0) {\n              advance();\n              break;\n            }\n          } else if (ch === 0x7B\n          /* '{' */\n          ) {\n            brace += 1;\n          }\n\n          if (type === '') {\n            startIndex = index;\n          }\n\n          type += advance();\n        }\n      }\n\n      if (brace !== 0) {\n        // braces is not balanced\n        return utility.throwError('Braces are not balanced');\n      }\n\n      if (isAllowedOptional(title)) {\n        return typed.parseParamType(type, {\n          startIndex: convertIndex(startIndex),\n          range: addRange\n        });\n      }\n\n      return typed.parseType(type, {\n        startIndex: convertIndex(startIndex),\n        range: addRange\n      });\n    }\n\n    function scanIdentifier(last) {\n      var identifier;\n\n      if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\n        return null;\n      }\n\n      identifier = advance();\n\n      while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\n        identifier += advance();\n      }\n\n      return identifier;\n    }\n\n    function skipWhiteSpace(last) {\n      while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\n        advance();\n      }\n    }\n\n    function parseName(last, allowBrackets, allowNestedParams) {\n      var name = '',\n          useBrackets,\n          insideString;\n      skipWhiteSpace(last);\n\n      if (index >= last) {\n        return null;\n      }\n\n      if (source.charCodeAt(index) === 0x5B\n      /* '[' */\n      ) {\n        if (allowBrackets) {\n          useBrackets = true;\n          name = advance();\n        } else {\n          return null;\n        }\n      }\n\n      name += scanIdentifier(last);\n\n      if (allowNestedParams) {\n        if (source.charCodeAt(index) === 0x3A\n        /* ':' */\n        && (name === 'module' || name === 'external' || name === 'event')) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n\n        if (source.charCodeAt(index) === 0x5B\n        /* '[' */\n        && source.charCodeAt(index + 1) === 0x5D\n        /* ']' */\n        ) {\n          name += advance();\n          name += advance();\n        }\n\n        while (source.charCodeAt(index) === 0x2E\n        /* '.' */\n        || source.charCodeAt(index) === 0x2F\n        /* '/' */\n        || source.charCodeAt(index) === 0x23\n        /* '#' */\n        || source.charCodeAt(index) === 0x2D\n        /* '-' */\n        || source.charCodeAt(index) === 0x7E\n        /* '~' */\n        ) {\n          name += advance();\n          name += scanIdentifier(last);\n        }\n      }\n\n      if (useBrackets) {\n        skipWhiteSpace(last); // do we have a default value for this?\n\n        if (source.charCodeAt(index) === 0x3D\n        /* '=' */\n        ) {\n          // consume the '='' symbol\n          name += advance();\n          skipWhiteSpace(last);\n          var ch;\n          var bracketDepth = 1; // scan in the default value\n\n          while (index < last) {\n            ch = source.charCodeAt(index);\n\n            if (esutils.code.isWhiteSpace(ch)) {\n              if (!insideString) {\n                skipWhiteSpace(last);\n                ch = source.charCodeAt(index);\n              }\n            }\n\n            if (ch === 0x27\n            /* ''' */\n            ) {\n              if (!insideString) {\n                insideString = '\\'';\n              } else {\n                if (insideString === '\\'') {\n                  insideString = '';\n                }\n              }\n            }\n\n            if (ch === 0x22\n            /* '\"' */\n            ) {\n              if (!insideString) {\n                insideString = '\"';\n              } else {\n                if (insideString === '\"') {\n                  insideString = '';\n                }\n              }\n            }\n\n            if (ch === 0x5B\n            /* '[' */\n            ) {\n              bracketDepth++;\n            } else if (ch === 0x5D\n            /* ']' */\n            && --bracketDepth === 0) {\n              break;\n            }\n\n            name += advance();\n          }\n        }\n\n        skipWhiteSpace(last);\n\n        if (index >= last || source.charCodeAt(index) !== 0x5D\n        /* ']' */\n        ) {\n          // we never found a closing ']'\n          return null;\n        } // collect the last ']'\n\n\n        name += advance();\n      }\n\n      return name;\n    }\n\n    function skipToTag() {\n      while (index < length && source.charCodeAt(index) !== 0x40\n      /* '@' */\n      ) {\n        advance();\n      }\n\n      if (index >= length) {\n        return false;\n      }\n\n      utility.assert(source.charCodeAt(index) === 0x40\n      /* '@' */\n      );\n      return true;\n    }\n\n    function convertIndex(rangeIndex) {\n      if (source === originalSource) {\n        return rangeIndex;\n      }\n\n      return convertUnwrappedCommentIndex(originalSource, rangeIndex);\n    }\n\n    function TagParser(options, title) {\n      this._options = options;\n      this._title = title.toLowerCase();\n      this._tag = {\n        title: title,\n        description: null\n      };\n\n      if (this._options.lineNumbers) {\n        this._tag.lineNumber = lineNumber;\n      }\n\n      this._first = index - title.length - 1;\n      this._last = 0; // space to save special information for title parsers.\n\n      this._extra = {};\n    } // addError(err, ...)\n\n\n    TagParser.prototype.addError = function addError(errorText) {\n      var args = Array.prototype.slice.call(arguments, 1),\n          msg = errorText.replace(/%(\\d)/g, function (whole, index) {\n        utility.assert(index < args.length, 'Message reference must be in range');\n        return args[index];\n      });\n\n      if (!this._tag.errors) {\n        this._tag.errors = [];\n      }\n\n      if (strict) {\n        utility.throwError(msg);\n      }\n\n      this._tag.errors.push(msg);\n\n      return recoverable;\n    };\n\n    TagParser.prototype.parseType = function () {\n      // type required titles\n      if (isTypeParameterRequired(this._title)) {\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n\n          if (!this._tag.type) {\n            if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\n              if (!this.addError('Missing or invalid tag type')) {\n                return false;\n              }\n            }\n          }\n        } catch (error) {\n          this._tag.type = null;\n\n          if (!this.addError(error.message)) {\n            return false;\n          }\n        }\n      } else if (isAllowedType(this._title)) {\n        // optional types\n        try {\n          this._tag.type = parseType(this._title, this._last, this._options.range);\n        } catch (e) {//For optional types, lets drop the thrown error when we hit the end of the file\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype._parseNamePath = function (optional) {\n      var name;\n      name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\n\n      if (!name) {\n        if (!optional) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n\n      this._tag.name = name;\n      return true;\n    };\n\n    TagParser.prototype.parseNamePath = function () {\n      return this._parseNamePath(false);\n    };\n\n    TagParser.prototype.parseNamePathOptional = function () {\n      return this._parseNamePath(true);\n    };\n\n    TagParser.prototype.parseName = function () {\n      var assign, name; // param, property requires name\n\n      if (isAllowedName(this._title)) {\n        this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\n\n        if (!this._tag.name) {\n          if (!isNameParameterRequired(this._title)) {\n            return true;\n          } // it's possible the name has already been parsed but interpreted as a type\n          // it's also possible this is a sloppy declaration, in which case it will be\n          // fixed at the end\n\n\n          if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\n            this._extra.name = this._tag.type;\n            this._tag.name = this._tag.type.name;\n            this._tag.type = null;\n          } else {\n            if (!this.addError('Missing or invalid tag name')) {\n              return false;\n            }\n          }\n        } else {\n          name = this._tag.name;\n\n          if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\n            // extract the default value if there is one\n            // example: @param {string} [somebody=John Doe] description\n            assign = name.substring(1, name.length - 1).split('=');\n\n            if (assign.length > 1) {\n              this._tag['default'] = assign.slice(1).join('=');\n            }\n\n            this._tag.name = assign[0]; // convert to an optional type\n\n            if (this._tag.type && this._tag.type.type !== 'OptionalType') {\n              this._tag.type = {\n                type: 'OptionalType',\n                expression: this._tag.type\n              };\n            }\n          }\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseDescription = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n\n      if (description) {\n        if (/^-\\s+/.test(description)) {\n          description = description.substring(2);\n        }\n\n        this._tag.description = description;\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseCaption = function parseDescription() {\n      var description = sliceSource(source, index, this._last).trim();\n      var captionStartTag = '<caption>';\n      var captionEndTag = '</caption>';\n      var captionStart = description.indexOf(captionStartTag);\n      var captionEnd = description.indexOf(captionEndTag);\n\n      if (captionStart >= 0 && captionEnd >= 0) {\n        this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();\n        this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\n      } else {\n        this._tag.description = description;\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseKind = function parseKind() {\n      var kind, kinds;\n      kinds = {\n        'class': true,\n        'constant': true,\n        'event': true,\n        'external': true,\n        'file': true,\n        'function': true,\n        'member': true,\n        'mixin': true,\n        'module': true,\n        'namespace': true,\n        'typedef': true\n      };\n      kind = sliceSource(source, index, this._last).trim();\n      this._tag.kind = kind;\n\n      if (!hasOwnProperty(kinds, kind)) {\n        if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseAccess = function parseAccess() {\n      var access;\n      access = sliceSource(source, index, this._last).trim();\n      this._tag.access = access;\n\n      if (access !== 'private' && access !== 'protected' && access !== 'public') {\n        if (!this.addError('Invalid access name \\'%0\\'', access)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.parseThis = function parseThis() {\n      // this name may be a name expression (e.g. {foo.bar}),\n      // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\n      var value = sliceSource(source, index, this._last).trim();\n\n      if (value && value.charAt(0) === '{') {\n        var gotType = this.parseType();\n\n        if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\n          this._tag.name = this._tag.type.name;\n          return true;\n        } else {\n          return this.addError('Invalid name for this');\n        }\n      } else {\n        return this.parseNamePath();\n      }\n    };\n\n    TagParser.prototype.parseVariation = function parseVariation() {\n      var variation, text;\n      text = sliceSource(source, index, this._last).trim();\n      variation = parseFloat(text, 10);\n      this._tag.variation = variation;\n\n      if (isNaN(variation)) {\n        if (!this.addError('Invalid variation \\'%0\\'', text)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.ensureEnd = function () {\n      var shouldBeEmpty = sliceSource(source, index, this._last).trim();\n\n      if (shouldBeEmpty) {\n        if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    TagParser.prototype.epilogue = function epilogue() {\n      var description;\n      description = this._tag.description; // un-fix potentially sloppy declaration\n\n      if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\n        this._tag.type = this._extra.name;\n\n        if (!this._tag.name) {\n          this._tag.name = undefined;\n        }\n\n        if (!sloppy) {\n          if (!this.addError('Missing or invalid tag name')) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    Rules = {\n      // http://usejsdoc.org/tags-access.html\n      'access': ['parseAccess'],\n      // http://usejsdoc.org/tags-alias.html\n      'alias': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-augments.html\n      'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-constructor.html\n      'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-constructor.html\n      'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-extends.html\n      'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-example.html\n      'example': ['parseCaption'],\n      // http://usejsdoc.org/tags-deprecated.html\n      'deprecated': ['parseDescription'],\n      // http://usejsdoc.org/tags-global.html\n      'global': ['ensureEnd'],\n      // http://usejsdoc.org/tags-inner.html\n      'inner': ['ensureEnd'],\n      // http://usejsdoc.org/tags-instance.html\n      'instance': ['ensureEnd'],\n      // http://usejsdoc.org/tags-kind.html\n      'kind': ['parseKind'],\n      // http://usejsdoc.org/tags-mixes.html\n      'mixes': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-mixin.html\n      'mixin': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-member.html\n      'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-method.html\n      'method': ['parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-module.html\n      'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'func': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-method.html\n      'function': ['parseNamePathOptional', 'ensureEnd'],\n      // Synonym: http://usejsdoc.org/tags-member.html\n      'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-name.html\n      'name': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-namespace.html\n      'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\n      // http://usejsdoc.org/tags-private.html\n      'private': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-protected.html\n      'protected': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-public.html\n      'public': ['parseType', 'parseDescription'],\n      // http://usejsdoc.org/tags-readonly.html\n      'readonly': ['ensureEnd'],\n      // http://usejsdoc.org/tags-requires.html\n      'requires': ['parseNamePath', 'ensureEnd'],\n      // http://usejsdoc.org/tags-since.html\n      'since': ['parseDescription'],\n      // http://usejsdoc.org/tags-static.html\n      'static': ['ensureEnd'],\n      // http://usejsdoc.org/tags-summary.html\n      'summary': ['parseDescription'],\n      // http://usejsdoc.org/tags-this.html\n      'this': ['parseThis', 'ensureEnd'],\n      // http://usejsdoc.org/tags-todo.html\n      'todo': ['parseDescription'],\n      // http://usejsdoc.org/tags-typedef.html\n      'typedef': ['parseType', 'parseNamePathOptional'],\n      // http://usejsdoc.org/tags-variation.html\n      'variation': ['parseVariation'],\n      // http://usejsdoc.org/tags-version.html\n      'version': ['parseDescription']\n    };\n\n    TagParser.prototype.parse = function parse() {\n      var i, iz, sequences, method; // empty title\n\n      if (!this._title) {\n        if (!this.addError('Missing or invalid title')) {\n          return null;\n        }\n      } // Seek to content last index.\n\n\n      this._last = seekContent(this._title);\n\n      if (this._options.range) {\n        this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\n      }\n\n      if (hasOwnProperty(Rules, this._title)) {\n        sequences = Rules[this._title];\n      } else {\n        // default sequences\n        sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\n      }\n\n      for (i = 0, iz = sequences.length; i < iz; ++i) {\n        method = sequences[i];\n\n        if (!this[method]()) {\n          return null;\n        }\n      }\n\n      return this._tag;\n    };\n\n    function parseTag(options) {\n      var title, parser, tag; // skip to tag\n\n      if (!skipToTag()) {\n        return null;\n      } // scan title\n\n\n      title = scanTitle(); // construct tag parser\n\n      parser = new TagParser(options, title);\n      tag = parser.parse(); // Seek global index to end of this tag.\n\n      while (index < parser._last) {\n        advance();\n      }\n\n      return tag;\n    } //\n    // Parse JSDoc\n    //\n\n\n    function scanJSDocDescription(preserveWhitespace) {\n      var description = '',\n          ch,\n          atAllowed;\n      atAllowed = true;\n\n      while (index < length) {\n        ch = source.charCodeAt(index);\n\n        if (atAllowed && ch === 0x40\n        /* '@' */\n        ) {\n          break;\n        }\n\n        if (esutils.code.isLineTerminator(ch)) {\n          atAllowed = true;\n        } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\n          atAllowed = false;\n        }\n\n        description += advance();\n      }\n\n      return preserveWhitespace ? description : description.trim();\n    }\n\n    function parse(comment, options) {\n      var tags = [],\n          tag,\n          description,\n          interestingTags,\n          i,\n          iz;\n\n      if (options === undefined) {\n        options = {};\n      }\n\n      if (typeof options.unwrap === 'boolean' && options.unwrap) {\n        source = unwrapComment(comment);\n      } else {\n        source = comment;\n      }\n\n      originalSource = comment; // array of relevant tags\n\n      if (options.tags) {\n        if (Array.isArray(options.tags)) {\n          interestingTags = {};\n\n          for (i = 0, iz = options.tags.length; i < iz; i++) {\n            if (typeof options.tags[i] === 'string') {\n              interestingTags[options.tags[i]] = true;\n            } else {\n              utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n            }\n          }\n        } else {\n          utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\n        }\n      }\n\n      length = source.length;\n      index = 0;\n      lineNumber = 0;\n      recoverable = options.recoverable;\n      sloppy = options.sloppy;\n      strict = options.strict;\n      description = scanJSDocDescription(options.preserveWhitespace);\n\n      while (true) {\n        tag = parseTag(options);\n\n        if (!tag) {\n          break;\n        }\n\n        if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\n          tags.push(tag);\n        }\n      }\n\n      return {\n        description: description,\n        tags: tags\n      };\n    }\n\n    exports.parse = parse;\n  })(jsdoc = {});\n\n  exports.version = utility.VERSION;\n  exports.parse = jsdoc.parse;\n  exports.parseType = typed.parseType;\n  exports.parseParamType = typed.parseParamType;\n  exports.unwrapComment = unwrapComment;\n  exports.Syntax = shallowCopy(typed.Syntax);\n  exports.Error = utility.DoctrineError;\n  exports.type = {\n    Syntax: exports.Syntax,\n    parseType: typed.parseType,\n    parseParamType: typed.parseParamType,\n    stringify: typed.stringify\n  };\n})();\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/doctrine/lib/doctrine.js"],"names":["typed","utility","jsdoc","esutils","hasOwnProperty","require","sliceSource","source","index","last","slice","func","Object","prototype","obj","name","call","shallowCopy","ret","key","isASCIIAlphanumeric","ch","isParamTitle","title","isReturnTitle","isProperty","isNameParameterRequired","isAllowedName","isAllowedNested","isAllowedOptional","isTypeParameterRequired","isAllowedType","WHITESPACE","STAR_MATCHER","unwrapComment","doc","replace","RegExp","convertUnwrappedCommentIndex","originalSource","unwrappedIndex","replacedSource","numSkippedChars","matcher","match","exec","length","exports","Rules","lineNumber","recoverable","sloppy","strict","advance","charCodeAt","code","isLineTerminator","String","fromCharCode","scanTitle","seekContent","waiting","isWhiteSpace","parseType","addRange","brace","type","startIndex","direct","throwError","parseParamType","convertIndex","range","scanIdentifier","identifier","isIdentifierStartES5","isIdentifierPartES5","skipWhiteSpace","parseName","allowBrackets","allowNestedParams","useBrackets","insideString","bracketDepth","skipToTag","assert","rangeIndex","TagParser","options","_options","_title","toLowerCase","_tag","description","lineNumbers","_first","_last","_extra","addError","errorText","args","Array","arguments","msg","whole","errors","push","error","message","e","_parseNamePath","optional","parseNamePath","parseNamePathOptional","assign","charAt","substring","split","join","expression","parseDescription","trim","test","parseCaption","captionStartTag","captionEndTag","captionStart","indexOf","captionEnd","caption","parseKind","kind","kinds","parseAccess","access","parseThis","value","gotType","parseVariation","variation","text","parseFloat","isNaN","ensureEnd","shouldBeEmpty","epilogue","undefined","parse","i","iz","sequences","method","map","parseTag","parser","tag","scanJSDocDescription","preserveWhitespace","atAllowed","comment","tags","interestingTags","unwrap","isArray","version","VERSION","Syntax","Error","DoctrineError","stringify"],"mappings":"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","sourcesContent":["/*\r\n * @fileoverview Main Doctrine object\r\n * @author Yusuke Suzuki <utatane.tea@gmail.com>\r\n * @author Dan Tao <daniel.tao@gmail.com>\r\n * @author Andrew Eisenberg <andrew@eisenberg.as>\r\n */\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    var typed,\r\n        utility,\r\n        jsdoc,\r\n        esutils,\r\n        hasOwnProperty;\r\n\r\n    esutils = require('esutils');\r\n    typed = require('./typed');\r\n    utility = require('./utility');\r\n\r\n    function sliceSource(source, index, last) {\r\n        return source.slice(index, last);\r\n    }\r\n\r\n    hasOwnProperty = (function () {\r\n        var func = Object.prototype.hasOwnProperty;\r\n        return function hasOwnProperty(obj, name) {\r\n            return func.call(obj, name);\r\n        };\r\n    }());\r\n    function shallowCopy(obj) {\r\n        var ret = {}, key;\r\n        for (key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                ret[key] = obj[key];\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function isASCIIAlphanumeric(ch) {\r\n        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||\r\n            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||\r\n            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);\r\n    }\r\n\r\n    function isParamTitle(title) {\r\n        return title === 'param' || title === 'argument' || title === 'arg';\r\n    }\r\n\r\n    function isReturnTitle(title) {\r\n        return title === 'return' || title === 'returns';\r\n    }\r\n\r\n    function isProperty(title) {\r\n        return title === 'property' || title === 'prop';\r\n    }\r\n\r\n    function isNameParameterRequired(title) {\r\n        return isParamTitle(title) || isProperty(title) ||\r\n            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';\r\n    }\r\n\r\n    function isAllowedName(title) {\r\n        return isNameParameterRequired(title) || title === 'const' || title === 'constant';\r\n    }\r\n\r\n    function isAllowedNested(title) {\r\n        return isProperty(title) || isParamTitle(title);\r\n    }\r\n\r\n    function isAllowedOptional(title) {\r\n        return isProperty(title) || isParamTitle(title);\r\n    }\r\n\r\n    function isTypeParameterRequired(title) {\r\n        return isParamTitle(title) || isReturnTitle(title) ||\r\n            title === 'define' || title === 'enum' ||\r\n            title === 'implements' || title === 'this' ||\r\n            title === 'type' || title === 'typedef' || isProperty(title);\r\n    }\r\n\r\n    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required\r\n    // This would require changes to 'parseType'\r\n    function isAllowedType(title) {\r\n        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||\r\n            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||\r\n            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||\r\n            title === 'public' || title === 'private' || title === 'protected';\r\n    }\r\n\r\n    // A regex character class that contains all whitespace except linebreak characters (\\r, \\n, \\u2028, \\u2029)\r\n    var WHITESPACE = '[ \\\\f\\\\t\\\\v\\\\u00a0\\\\u1680\\\\u180e\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]';\r\n\r\n    var STAR_MATCHER = '(' + WHITESPACE + '*(?:\\\\*' + WHITESPACE + '?)?)(.+|[\\r\\n\\u2028\\u2029])';\r\n\r\n    function unwrapComment(doc) {\r\n        // JSDoc comment is following form\r\n        //   /**\r\n        //    * .......\r\n        //    */\r\n\r\n        return doc.\r\n            // remove /**\r\n            replace(/^\\/\\*\\*?/, '').\r\n            // remove */\r\n            replace(/\\*\\/$/, '').\r\n            // remove ' * ' at the beginning of a line\r\n            replace(new RegExp(STAR_MATCHER, 'g'), '$2').\r\n            // remove trailing whitespace\r\n            replace(/\\s*$/, '');\r\n    }\r\n\r\n    /**\r\n     * Converts an index in an \"unwrapped\" JSDoc comment to the corresponding index in the original \"wrapped\" version\r\n     * @param {string} originalSource The original wrapped comment\r\n     * @param {number} unwrappedIndex The index of a character in the unwrapped string\r\n     * @returns {number} The index of the corresponding character in the original wrapped string\r\n     */\r\n    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {\r\n        var replacedSource = originalSource.replace(/^\\/\\*\\*?/, '');\r\n        var numSkippedChars = 0;\r\n        var matcher = new RegExp(STAR_MATCHER, 'g');\r\n        var match;\r\n\r\n        while ((match = matcher.exec(replacedSource))) {\r\n            numSkippedChars += match[1].length;\r\n\r\n            if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {\r\n                return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;\r\n            }\r\n        }\r\n\r\n        return originalSource.replace(/\\*\\/$/, '').replace(/\\s*$/, '').length;\r\n    }\r\n\r\n    // JSDoc Tag Parser\r\n\r\n    (function (exports) {\r\n        var Rules,\r\n            index,\r\n            lineNumber,\r\n            length,\r\n            source,\r\n            originalSource,\r\n            recoverable,\r\n            sloppy,\r\n            strict;\r\n\r\n        function advance() {\r\n            var ch = source.charCodeAt(index);\r\n            index += 1;\r\n            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(index) === 0x0A  /* '\\n' */)) {\r\n                lineNumber += 1;\r\n            }\r\n            return String.fromCharCode(ch);\r\n        }\r\n\r\n        function scanTitle() {\r\n            var title = '';\r\n            // waste '@'\r\n            advance();\r\n\r\n            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {\r\n                title += advance();\r\n            }\r\n\r\n            return title;\r\n        }\r\n\r\n        function seekContent() {\r\n            var ch, waiting, last = index;\r\n\r\n            waiting = false;\r\n            while (last < length) {\r\n                ch = source.charCodeAt(last);\r\n                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\\n' */)) {\r\n                    waiting = true;\r\n                } else if (waiting) {\r\n                    if (ch === 0x40  /* '@' */) {\r\n                        break;\r\n                    }\r\n                    if (!esutils.code.isWhiteSpace(ch)) {\r\n                        waiting = false;\r\n                    }\r\n                }\r\n                last += 1;\r\n            }\r\n            return last;\r\n        }\r\n\r\n        // type expression may have nest brace, such as,\r\n        // { { ok: string } }\r\n        //\r\n        // therefore, scanning type expression with balancing braces.\r\n        function parseType(title, last, addRange) {\r\n            var ch, brace, type, startIndex, direct = false;\r\n\r\n\r\n            // search '{'\r\n            while (index < last) {\r\n                ch = source.charCodeAt(index);\r\n                if (esutils.code.isWhiteSpace(ch)) {\r\n                    advance();\r\n                } else if (ch === 0x7B  /* '{' */) {\r\n                    advance();\r\n                    break;\r\n                } else {\r\n                    // this is direct pattern\r\n                    direct = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n            if (direct) {\r\n                return null;\r\n            }\r\n\r\n            // type expression { is found\r\n            brace = 1;\r\n            type = '';\r\n            while (index < last) {\r\n                ch = source.charCodeAt(index);\r\n                if (esutils.code.isLineTerminator(ch)) {\r\n                    advance();\r\n                } else {\r\n                    if (ch === 0x7D  /* '}' */) {\r\n                        brace -= 1;\r\n                        if (brace === 0) {\r\n                            advance();\r\n                            break;\r\n                        }\r\n                    } else if (ch === 0x7B  /* '{' */) {\r\n                        brace += 1;\r\n                    }\r\n                    if (type === '') {\r\n                        startIndex = index;\r\n                    }\r\n                    type += advance();\r\n                }\r\n            }\r\n\r\n            if (brace !== 0) {\r\n                // braces is not balanced\r\n                return utility.throwError('Braces are not balanced');\r\n            }\r\n\r\n            if (isAllowedOptional(title)) {\r\n                return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});\r\n            }\r\n\r\n            return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});\r\n        }\r\n\r\n        function scanIdentifier(last) {\r\n            var identifier;\r\n            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {\r\n                return null;\r\n            }\r\n            identifier = advance();\r\n            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {\r\n                identifier += advance();\r\n            }\r\n            return identifier;\r\n        }\r\n\r\n        function skipWhiteSpace(last) {\r\n            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {\r\n                advance();\r\n            }\r\n        }\r\n\r\n        function parseName(last, allowBrackets, allowNestedParams) {\r\n            var name = '',\r\n                useBrackets,\r\n                insideString;\r\n\r\n\r\n            skipWhiteSpace(last);\r\n\r\n            if (index >= last) {\r\n                return null;\r\n            }\r\n\r\n            if (source.charCodeAt(index) === 0x5B  /* '[' */) {\r\n                if (allowBrackets) {\r\n                    useBrackets = true;\r\n                    name = advance();\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            name += scanIdentifier(last);\r\n\r\n            if (allowNestedParams) {\r\n                if (source.charCodeAt(index) === 0x3A /* ':' */ && (\r\n                        name === 'module' ||\r\n                        name === 'external' ||\r\n                        name === 'event')) {\r\n                    name += advance();\r\n                    name += scanIdentifier(last);\r\n\r\n                }\r\n                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){\r\n                    name += advance();\r\n                    name += advance();\r\n                }\r\n                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||\r\n                        source.charCodeAt(index) === 0x2F  /* '/' */ ||\r\n                        source.charCodeAt(index) === 0x23  /* '#' */ ||\r\n                        source.charCodeAt(index) === 0x2D  /* '-' */ ||\r\n                        source.charCodeAt(index) === 0x7E  /* '~' */) {\r\n                    name += advance();\r\n                    name += scanIdentifier(last);\r\n                }\r\n            }\r\n\r\n            if (useBrackets) {\r\n                skipWhiteSpace(last);\r\n                // do we have a default value for this?\r\n                if (source.charCodeAt(index) === 0x3D  /* '=' */) {\r\n                    // consume the '='' symbol\r\n                    name += advance();\r\n                    skipWhiteSpace(last);\r\n\r\n                    var ch;\r\n                    var bracketDepth = 1;\r\n\r\n                    // scan in the default value\r\n                    while (index < last) {\r\n                        ch = source.charCodeAt(index);\r\n\r\n                        if (esutils.code.isWhiteSpace(ch)) {\r\n                            if (!insideString) {\r\n                                skipWhiteSpace(last);\r\n                                ch = source.charCodeAt(index);\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x27 /* ''' */) {\r\n                            if (!insideString) {\r\n                                insideString = '\\'';\r\n                            } else {\r\n                                if (insideString === '\\'') {\r\n                                    insideString = '';\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x22 /* '\"' */) {\r\n                            if (!insideString) {\r\n                                insideString = '\"';\r\n                            } else {\r\n                                if (insideString === '\"') {\r\n                                    insideString = '';\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (ch === 0x5B /* '[' */) {\r\n                            bracketDepth++;\r\n                        } else if (ch === 0x5D  /* ']' */ &&\r\n                            --bracketDepth === 0) {\r\n                            break;\r\n                        }\r\n\r\n                        name += advance();\r\n                    }\r\n                }\r\n\r\n                skipWhiteSpace(last);\r\n\r\n                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {\r\n                    // we never found a closing ']'\r\n                    return null;\r\n                }\r\n\r\n                // collect the last ']'\r\n                name += advance();\r\n            }\r\n\r\n            return name;\r\n        }\r\n\r\n        function skipToTag() {\r\n            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {\r\n                advance();\r\n            }\r\n            if (index >= length) {\r\n                return false;\r\n            }\r\n            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);\r\n            return true;\r\n        }\r\n\r\n        function convertIndex(rangeIndex) {\r\n            if (source === originalSource) {\r\n                return rangeIndex;\r\n            }\r\n            return convertUnwrappedCommentIndex(originalSource, rangeIndex);\r\n        }\r\n\r\n        function TagParser(options, title) {\r\n            this._options = options;\r\n            this._title = title.toLowerCase();\r\n            this._tag = {\r\n                title: title,\r\n                description: null\r\n            };\r\n            if (this._options.lineNumbers) {\r\n                this._tag.lineNumber = lineNumber;\r\n            }\r\n            this._first = index - title.length - 1;\r\n            this._last = 0;\r\n            // space to save special information for title parsers.\r\n            this._extra = { };\r\n        }\r\n\r\n        // addError(err, ...)\r\n        TagParser.prototype.addError = function addError(errorText) {\r\n            var args = Array.prototype.slice.call(arguments, 1),\r\n                msg = errorText.replace(\r\n                    /%(\\d)/g,\r\n                    function (whole, index) {\r\n                        utility.assert(index < args.length, 'Message reference must be in range');\r\n                        return args[index];\r\n                    }\r\n                );\r\n\r\n            if (!this._tag.errors) {\r\n                this._tag.errors = [];\r\n            }\r\n            if (strict) {\r\n                utility.throwError(msg);\r\n            }\r\n            this._tag.errors.push(msg);\r\n            return recoverable;\r\n        };\r\n\r\n        TagParser.prototype.parseType = function () {\r\n            // type required titles\r\n            if (isTypeParameterRequired(this._title)) {\r\n                try {\r\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\r\n                    if (!this._tag.type) {\r\n                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {\r\n                            if (!this.addError('Missing or invalid tag type')) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (error) {\r\n                    this._tag.type = null;\r\n                    if (!this.addError(error.message)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else if (isAllowedType(this._title)) {\r\n                // optional types\r\n                try {\r\n                    this._tag.type = parseType(this._title, this._last, this._options.range);\r\n                } catch (e) {\r\n                    //For optional types, lets drop the thrown error when we hit the end of the file\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype._parseNamePath = function (optional) {\r\n            var name;\r\n            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);\r\n            if (!name) {\r\n                if (!optional) {\r\n                    if (!this.addError('Missing or invalid tag name')) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            this._tag.name = name;\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseNamePath = function () {\r\n            return this._parseNamePath(false);\r\n        };\r\n\r\n        TagParser.prototype.parseNamePathOptional = function () {\r\n            return this._parseNamePath(true);\r\n        };\r\n\r\n\r\n        TagParser.prototype.parseName = function () {\r\n            var assign, name;\r\n\r\n            // param, property requires name\r\n            if (isAllowedName(this._title)) {\r\n                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));\r\n                if (!this._tag.name) {\r\n                    if (!isNameParameterRequired(this._title)) {\r\n                        return true;\r\n                    }\r\n\r\n                    // it's possible the name has already been parsed but interpreted as a type\r\n                    // it's also possible this is a sloppy declaration, in which case it will be\r\n                    // fixed at the end\r\n                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {\r\n                        this._extra.name = this._tag.type;\r\n                        this._tag.name = this._tag.type.name;\r\n                        this._tag.type = null;\r\n                    } else {\r\n                        if (!this.addError('Missing or invalid tag name')) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    name = this._tag.name;\r\n                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {\r\n                        // extract the default value if there is one\r\n                        // example: @param {string} [somebody=John Doe] description\r\n                        assign = name.substring(1, name.length - 1).split('=');\r\n                        if (assign.length > 1) {\r\n                            this._tag['default'] = assign.slice(1).join('=');\r\n                        }\r\n                        this._tag.name = assign[0];\r\n\r\n                        // convert to an optional type\r\n                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {\r\n                            this._tag.type = {\r\n                                type: 'OptionalType',\r\n                                expression: this._tag.type\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseDescription = function parseDescription() {\r\n            var description = sliceSource(source, index, this._last).trim();\r\n            if (description) {\r\n                if ((/^-\\s+/).test(description)) {\r\n                    description = description.substring(2);\r\n                }\r\n                this._tag.description = description;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseCaption = function parseDescription() {\r\n            var description = sliceSource(source, index, this._last).trim();\r\n            var captionStartTag = '<caption>';\r\n            var captionEndTag = '</caption>';\r\n            var captionStart = description.indexOf(captionStartTag);\r\n            var captionEnd = description.indexOf(captionEndTag);\r\n            if (captionStart >= 0 && captionEnd >= 0) {\r\n                this._tag.caption = description.substring(\r\n                    captionStart + captionStartTag.length, captionEnd).trim();\r\n                this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();\r\n            } else {\r\n                this._tag.description = description;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseKind = function parseKind() {\r\n            var kind, kinds;\r\n            kinds = {\r\n                'class': true,\r\n                'constant': true,\r\n                'event': true,\r\n                'external': true,\r\n                'file': true,\r\n                'function': true,\r\n                'member': true,\r\n                'mixin': true,\r\n                'module': true,\r\n                'namespace': true,\r\n                'typedef': true\r\n            };\r\n            kind = sliceSource(source, index, this._last).trim();\r\n            this._tag.kind = kind;\r\n            if (!hasOwnProperty(kinds, kind)) {\r\n                if (!this.addError('Invalid kind name \\'%0\\'', kind)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseAccess = function parseAccess() {\r\n            var access;\r\n            access = sliceSource(source, index, this._last).trim();\r\n            this._tag.access = access;\r\n            if (access !== 'private' && access !== 'protected' && access !== 'public') {\r\n                if (!this.addError('Invalid access name \\'%0\\'', access)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.parseThis = function parseThis() {\r\n            // this name may be a name expression (e.g. {foo.bar}),\r\n            // an union (e.g. {foo.bar|foo.baz}) or a name path (e.g. foo.bar)\r\n            var value = sliceSource(source, index, this._last).trim();\r\n            if (value && value.charAt(0) === '{') {\r\n                var gotType = this.parseType();\r\n                if (gotType && this._tag.type.type === 'NameExpression' || this._tag.type.type === 'UnionType') {\r\n                    this._tag.name = this._tag.type.name;\r\n                    return true;\r\n                } else {\r\n                    return this.addError('Invalid name for this');\r\n                }\r\n            } else {\r\n                return this.parseNamePath();\r\n            }\r\n        };\r\n\r\n        TagParser.prototype.parseVariation = function parseVariation() {\r\n            var variation, text;\r\n            text = sliceSource(source, index, this._last).trim();\r\n            variation = parseFloat(text, 10);\r\n            this._tag.variation = variation;\r\n            if (isNaN(variation)) {\r\n                if (!this.addError('Invalid variation \\'%0\\'', text)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.ensureEnd = function () {\r\n            var shouldBeEmpty = sliceSource(source, index, this._last).trim();\r\n            if (shouldBeEmpty) {\r\n                if (!this.addError('Unknown content \\'%0\\'', shouldBeEmpty)) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        TagParser.prototype.epilogue = function epilogue() {\r\n            var description;\r\n\r\n            description = this._tag.description;\r\n            // un-fix potentially sloppy declaration\r\n            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {\r\n                this._tag.type = this._extra.name;\r\n                if (!this._tag.name) {\r\n                    this._tag.name = undefined;\r\n                }\r\n\r\n                if (!sloppy) {\r\n                    if (!this.addError('Missing or invalid tag name')) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return true;\r\n        };\r\n\r\n        Rules = {\r\n            // http://usejsdoc.org/tags-access.html\r\n            'access': ['parseAccess'],\r\n            // http://usejsdoc.org/tags-alias.html\r\n            'alias': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-augments.html\r\n            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-constructor.html\r\n            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-constructor.html\r\n            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-extends.html\r\n            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-example.html\r\n            'example': ['parseCaption'],\r\n            // http://usejsdoc.org/tags-deprecated.html\r\n            'deprecated': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-global.html\r\n            'global': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-inner.html\r\n            'inner': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-instance.html\r\n            'instance': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-kind.html\r\n            'kind': ['parseKind'],\r\n            // http://usejsdoc.org/tags-mixes.html\r\n            'mixes': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-mixin.html\r\n            'mixin': ['parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-member.html\r\n            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-method.html\r\n            'method': ['parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-module.html\r\n            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-method.html\r\n            'func': ['parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-method.html\r\n            'function': ['parseNamePathOptional', 'ensureEnd'],\r\n            // Synonym: http://usejsdoc.org/tags-member.html\r\n            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-name.html\r\n            'name': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-namespace.html\r\n            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-private.html\r\n            'private': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-protected.html\r\n            'protected': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-public.html\r\n            'public': ['parseType', 'parseDescription'],\r\n            // http://usejsdoc.org/tags-readonly.html\r\n            'readonly': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-requires.html\r\n            'requires': ['parseNamePath', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-since.html\r\n            'since': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-static.html\r\n            'static': ['ensureEnd'],\r\n            // http://usejsdoc.org/tags-summary.html\r\n            'summary': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-this.html\r\n            'this': ['parseThis', 'ensureEnd'],\r\n            // http://usejsdoc.org/tags-todo.html\r\n            'todo': ['parseDescription'],\r\n            // http://usejsdoc.org/tags-typedef.html\r\n            'typedef': ['parseType', 'parseNamePathOptional'],\r\n            // http://usejsdoc.org/tags-variation.html\r\n            'variation': ['parseVariation'],\r\n            // http://usejsdoc.org/tags-version.html\r\n            'version': ['parseDescription']\r\n        };\r\n\r\n        TagParser.prototype.parse = function parse() {\r\n            var i, iz, sequences, method;\r\n\r\n\r\n            // empty title\r\n            if (!this._title) {\r\n                if (!this.addError('Missing or invalid title')) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // Seek to content last index.\r\n            this._last = seekContent(this._title);\r\n\r\n            if (this._options.range) {\r\n                this._tag.range = [this._first, source.slice(0, this._last).replace(/\\s*$/, '').length].map(convertIndex);\r\n            }\r\n\r\n            if (hasOwnProperty(Rules, this._title)) {\r\n                sequences = Rules[this._title];\r\n            } else {\r\n                // default sequences\r\n                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];\r\n            }\r\n\r\n            for (i = 0, iz = sequences.length; i < iz; ++i) {\r\n                method = sequences[i];\r\n                if (!this[method]()) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return this._tag;\r\n        };\r\n\r\n        function parseTag(options) {\r\n            var title, parser, tag;\r\n\r\n            // skip to tag\r\n            if (!skipToTag()) {\r\n                return null;\r\n            }\r\n\r\n            // scan title\r\n            title = scanTitle();\r\n\r\n            // construct tag parser\r\n            parser = new TagParser(options, title);\r\n            tag = parser.parse();\r\n\r\n            // Seek global index to end of this tag.\r\n            while (index < parser._last) {\r\n                advance();\r\n            }\r\n\r\n            return tag;\r\n        }\r\n\r\n        //\r\n        // Parse JSDoc\r\n        //\r\n\r\n        function scanJSDocDescription(preserveWhitespace) {\r\n            var description = '', ch, atAllowed;\r\n\r\n            atAllowed = true;\r\n            while (index < length) {\r\n                ch = source.charCodeAt(index);\r\n\r\n                if (atAllowed && ch === 0x40  /* '@' */) {\r\n                    break;\r\n                }\r\n\r\n                if (esutils.code.isLineTerminator(ch)) {\r\n                    atAllowed = true;\r\n                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {\r\n                    atAllowed = false;\r\n                }\r\n\r\n                description += advance();\r\n            }\r\n\r\n            return preserveWhitespace ? description : description.trim();\r\n        }\r\n\r\n        function parse(comment, options) {\r\n            var tags = [], tag, description, interestingTags, i, iz;\r\n\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n\r\n            if (typeof options.unwrap === 'boolean' && options.unwrap) {\r\n                source = unwrapComment(comment);\r\n            } else {\r\n                source = comment;\r\n            }\r\n\r\n            originalSource = comment;\r\n\r\n            // array of relevant tags\r\n            if (options.tags) {\r\n                if (Array.isArray(options.tags)) {\r\n                    interestingTags = { };\r\n                    for (i = 0, iz = options.tags.length; i < iz; i++) {\r\n                        if (typeof options.tags[i] === 'string') {\r\n                            interestingTags[options.tags[i]] = true;\r\n                        } else {\r\n                            utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\r\n                        }\r\n                    }\r\n                } else {\r\n                    utility.throwError('Invalid \"tags\" parameter: ' + options.tags);\r\n                }\r\n            }\r\n\r\n            length = source.length;\r\n            index = 0;\r\n            lineNumber = 0;\r\n            recoverable = options.recoverable;\r\n            sloppy = options.sloppy;\r\n            strict = options.strict;\r\n\r\n            description = scanJSDocDescription(options.preserveWhitespace);\r\n\r\n            while (true) {\r\n                tag = parseTag(options);\r\n                if (!tag) {\r\n                    break;\r\n                }\r\n                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {\r\n                    tags.push(tag);\r\n                }\r\n            }\r\n\r\n            return {\r\n                description: description,\r\n                tags: tags\r\n            };\r\n        }\r\n        exports.parse = parse;\r\n    }(jsdoc = {}));\r\n\r\n    exports.version = utility.VERSION;\r\n    exports.parse = jsdoc.parse;\r\n    exports.parseType = typed.parseType;\r\n    exports.parseParamType = typed.parseParamType;\r\n    exports.unwrapComment = unwrapComment;\r\n    exports.Syntax = shallowCopy(typed.Syntax);\r\n    exports.Error = utility.DoctrineError;\r\n    exports.type = {\r\n        Syntax: exports.Syntax,\r\n        parseType: typed.parseType,\r\n        parseParamType: typed.parseParamType,\r\n        stringify: typed.stringify\r\n    };\r\n}());\r\n/* vim: set sw=4 ts=4 et tw=80 : */\r\n"]},"metadata":{},"sourceType":"script"}