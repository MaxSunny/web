{"ast":null,"code":"/**\r\n * @fileoverview A rule to verify `super()` callings in constructor.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether a given code path segment is reachable or not.\r\n * @param {CodePathSegment} segment A code path segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\n\nfunction isReachable(segment) {\n  return segment.reachable;\n}\n/**\r\n * Checks whether or not a given node is a constructor.\r\n * @param {ASTNode} node A node to check. This node type is one of\r\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\r\n *   `ArrowFunctionExpression`.\r\n * @returns {boolean} `true` if the node is a constructor.\r\n */\n\n\nfunction isConstructorFunction(node) {\n  return node.type === \"FunctionExpression\" && node.parent.type === \"MethodDefinition\" && node.parent.kind === \"constructor\";\n}\n/**\r\n * Checks whether a given node can be a constructor or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node can be a constructor.\r\n */\n\n\nfunction isPossibleConstructor(node) {\n  if (!node) {\n    return false;\n  }\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"FunctionExpression\":\n    case \"ThisExpression\":\n    case \"MemberExpression\":\n    case \"CallExpression\":\n    case \"NewExpression\":\n    case \"ChainExpression\":\n    case \"YieldExpression\":\n    case \"TaggedTemplateExpression\":\n    case \"MetaProperty\":\n      return true;\n\n    case \"Identifier\":\n      return node.name !== \"undefined\";\n\n    case \"AssignmentExpression\":\n      if ([\"=\", \"&&=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.right);\n      }\n\n      if ([\"||=\", \"??=\"].includes(node.operator)) {\n        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n      }\n      /**\r\n       * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\r\n       * An assignment expression with a mathematical operator can either evaluate to a primitive value,\r\n       * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\r\n       */\n\n\n      return false;\n\n    case \"LogicalExpression\":\n      /*\r\n       * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\r\n       * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\r\n       * possible constructor. A future improvement could verify that the left side could be truthy by\r\n       * excluding falsy literals.\r\n       */\n      if (node.operator === \"&&\") {\n        return isPossibleConstructor(node.right);\n      }\n\n      return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);\n\n    case \"ConditionalExpression\":\n      return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);\n\n    case \"SequenceExpression\":\n      {\n        const lastExpression = node.expressions[node.expressions.length - 1];\n        return isPossibleConstructor(lastExpression);\n      }\n\n    default:\n      return false;\n  }\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"require `super()` calls in constructors\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/constructor-super\"\n    },\n    schema: [],\n    messages: {\n      missingSome: \"Lacked a call of 'super()' in some code paths.\",\n      missingAll: \"Expected to call 'super()'.\",\n      duplicate: \"Unexpected duplicate 'super()'.\",\n      badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\n      unexpected: \"Unexpected 'super()'.\"\n    }\n  },\n\n  create(context) {\n    /*\r\n     * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\r\n     * Information for each constructor.\r\n     * - upper:      Information of the upper constructor.\r\n     * - hasExtends: A flag which shows whether own class has a valid `extends`\r\n     *               part.\r\n     * - scope:      The scope of own class.\r\n     * - codePath:   The code path object of the constructor.\r\n     */\n    let funcInfo = null;\n    /*\r\n     * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\r\n     * Information for each code path segment.\r\n     * - calledInSomePaths:  A flag of be called `super()` in some code paths.\r\n     * - calledInEveryPaths: A flag of be called `super()` in all code paths.\r\n     * - validNodes:\r\n     */\n\n    let segInfoMap = Object.create(null);\n    /**\r\n     * Gets the flag which shows `super()` is called in some paths.\r\n     * @param {CodePathSegment} segment A code path segment to get.\r\n     * @returns {boolean} The flag which shows `super()` is called in some paths\r\n     */\n\n    function isCalledInSomePath(segment) {\n      return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n    }\n    /**\r\n     * Gets the flag which shows `super()` is called in all paths.\r\n     * @param {CodePathSegment} segment A code path segment to get.\r\n     * @returns {boolean} The flag which shows `super()` is called in all paths.\r\n     */\n\n\n    function isCalledInEveryPath(segment) {\n      /*\r\n       * If specific segment is the looped segment of the current segment,\r\n       * skip the segment.\r\n       * If not skipped, this never becomes true after a loop.\r\n       */\n      if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {\n        return true;\n      }\n\n      return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n    }\n\n    return {\n      /**\r\n       * Stacks a constructor information.\r\n       * @param {CodePath} codePath A code path which was started.\r\n       * @param {ASTNode} node The current node.\r\n       * @returns {void}\r\n       */\n      onCodePathStart(codePath, node) {\n        if (isConstructorFunction(node)) {\n          // Class > ClassBody > MethodDefinition > FunctionExpression\n          const classNode = node.parent.parent.parent;\n          const superClass = classNode.superClass;\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: true,\n            hasExtends: Boolean(superClass),\n            superIsConstructor: isPossibleConstructor(superClass),\n            codePath\n          };\n        } else {\n          funcInfo = {\n            upper: funcInfo,\n            isConstructor: false,\n            hasExtends: false,\n            superIsConstructor: false,\n            codePath\n          };\n        }\n      },\n\n      /**\r\n       * Pops a constructor information.\r\n       * And reports if `super()` lacked.\r\n       * @param {CodePath} codePath A code path which was ended.\r\n       * @param {ASTNode} node The current node.\r\n       * @returns {void}\r\n       */\n      onCodePathEnd(codePath, node) {\n        const hasExtends = funcInfo.hasExtends; // Pop.\n\n        funcInfo = funcInfo.upper;\n\n        if (!hasExtends) {\n          return;\n        } // Reports if `super()` lacked.\n\n\n        const segments = codePath.returnedSegments;\n        const calledInEveryPaths = segments.every(isCalledInEveryPath);\n        const calledInSomePaths = segments.some(isCalledInSomePath);\n\n        if (!calledInEveryPaths) {\n          context.report({\n            messageId: calledInSomePaths ? \"missingSome\" : \"missingAll\",\n            node: node.parent\n          });\n        }\n      },\n\n      /**\r\n       * Initialize information of a given code path segment.\r\n       * @param {CodePathSegment} segment A code path segment to initialize.\r\n       * @returns {void}\r\n       */\n      onCodePathSegmentStart(segment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Initialize info.\n\n\n        const info = segInfoMap[segment.id] = {\n          calledInSomePaths: false,\n          calledInEveryPaths: false,\n          validNodes: []\n        }; // When there are previous segments, aggregates these.\n\n        const prevSegments = segment.prevSegments;\n\n        if (prevSegments.length > 0) {\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n        }\n      },\n\n      /**\r\n       * Update information of the code path segment when a code path was\r\n       * looped.\r\n       * @param {CodePathSegment} fromSegment The code path segment of the\r\n       *      end of a loop.\r\n       * @param {CodePathSegment} toSegment A code path segment of the head\r\n       *      of a loop.\r\n       * @returns {void}\r\n       */\n      onCodePathSegmentLoop(fromSegment, toSegment) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Update information inside of the loop.\n\n\n        const isRealLoop = toSegment.prevSegments.length >= 2;\n        funcInfo.codePath.traverseSegments({\n          first: toSegment,\n          last: fromSegment\n        }, segment => {\n          const info = segInfoMap[segment.id];\n          const prevSegments = segment.prevSegments; // Updates flags.\n\n          info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n          info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath); // If flags become true anew, reports the valid nodes.\n\n          if (info.calledInSomePaths || isRealLoop) {\n            const nodes = info.validNodes;\n            info.validNodes = [];\n\n            for (let i = 0; i < nodes.length; ++i) {\n              const node = nodes[i];\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            }\n          }\n        });\n      },\n\n      /**\r\n       * Checks for a call of `super()`.\r\n       * @param {ASTNode} node A CallExpression node to check.\r\n       * @returns {void}\r\n       */\n      \"CallExpression:exit\"(node) {\n        if (!(funcInfo && funcInfo.isConstructor)) {\n          return;\n        } // Skips except `super()`.\n\n\n        if (node.callee.type !== \"Super\") {\n          return;\n        } // Reports if needed.\n\n\n        if (funcInfo.hasExtends) {\n          const segments = funcInfo.codePath.currentSegments;\n          let duplicate = false;\n          let info = null;\n\n          for (let i = 0; i < segments.length; ++i) {\n            const segment = segments[i];\n\n            if (segment.reachable) {\n              info = segInfoMap[segment.id];\n              duplicate = duplicate || info.calledInSomePaths;\n              info.calledInSomePaths = info.calledInEveryPaths = true;\n            }\n          }\n\n          if (info) {\n            if (duplicate) {\n              context.report({\n                messageId: \"duplicate\",\n                node\n              });\n            } else if (!funcInfo.superIsConstructor) {\n              context.report({\n                messageId: \"badSuper\",\n                node\n              });\n            } else {\n              info.validNodes.push(node);\n            }\n          }\n        } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n          context.report({\n            messageId: \"unexpected\",\n            node\n          });\n        }\n      },\n\n      /**\r\n       * Set the mark to the returned path as `super()` was called.\r\n       * @param {ASTNode} node A ReturnStatement node to check.\r\n       * @returns {void}\r\n       */\n      ReturnStatement(node) {\n        if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n          return;\n        } // Skips if no argument.\n\n\n        if (!node.argument) {\n          return;\n        } // Returning argument is a substitute of 'super()'.\n\n\n        const segments = funcInfo.codePath.currentSegments;\n\n        for (let i = 0; i < segments.length; ++i) {\n          const segment = segments[i];\n\n          if (segment.reachable) {\n            const info = segInfoMap[segment.id];\n            info.calledInSomePaths = info.calledInEveryPaths = true;\n          }\n        }\n      },\n\n      /**\r\n       * Resets state.\r\n       * @returns {void}\r\n       */\n      \"Program:exit\"() {\n        segInfoMap = Object.create(null);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/constructor-super.js"],"names":["isReachable","segment","reachable","isConstructorFunction","node","type","parent","kind","isPossibleConstructor","name","includes","operator","right","left","alternate","consequent","lastExpression","expressions","length","module","exports","meta","docs","description","recommended","url","schema","messages","missingSome","missingAll","duplicate","badSuper","unexpected","create","context","funcInfo","segInfoMap","Object","isCalledInSomePath","id","calledInSomePaths","isCalledInEveryPath","nextSegments","isLoopedPrevSegment","calledInEveryPaths","onCodePathStart","codePath","classNode","superClass","upper","isConstructor","hasExtends","Boolean","superIsConstructor","onCodePathEnd","segments","returnedSegments","every","some","report","messageId","onCodePathSegmentStart","info","validNodes","prevSegments","onCodePathSegmentLoop","fromSegment","toSegment","isRealLoop","traverseSegments","first","last","nodes","i","callee","currentSegments","push","ReturnStatement","argument"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to verify `super()` callings in constructor.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether a given code path segment is reachable or not.\r\n * @param {CodePathSegment} segment A code path segment to check.\r\n * @returns {boolean} `true` if the segment is reachable.\r\n */\r\nfunction isReachable(segment) {\r\n    return segment.reachable;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is a constructor.\r\n * @param {ASTNode} node A node to check. This node type is one of\r\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\r\n *   `ArrowFunctionExpression`.\r\n * @returns {boolean} `true` if the node is a constructor.\r\n */\r\nfunction isConstructorFunction(node) {\r\n    return (\r\n        node.type === \"FunctionExpression\" &&\r\n        node.parent.type === \"MethodDefinition\" &&\r\n        node.parent.kind === \"constructor\"\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether a given node can be a constructor or not.\r\n * @param {ASTNode} node A node to check.\r\n * @returns {boolean} `true` if the node can be a constructor.\r\n */\r\nfunction isPossibleConstructor(node) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n\r\n    switch (node.type) {\r\n        case \"ClassExpression\":\r\n        case \"FunctionExpression\":\r\n        case \"ThisExpression\":\r\n        case \"MemberExpression\":\r\n        case \"CallExpression\":\r\n        case \"NewExpression\":\r\n        case \"ChainExpression\":\r\n        case \"YieldExpression\":\r\n        case \"TaggedTemplateExpression\":\r\n        case \"MetaProperty\":\r\n            return true;\r\n\r\n        case \"Identifier\":\r\n            return node.name !== \"undefined\";\r\n\r\n        case \"AssignmentExpression\":\r\n            if ([\"=\", \"&&=\"].includes(node.operator)) {\r\n                return isPossibleConstructor(node.right);\r\n            }\r\n\r\n            if ([\"||=\", \"??=\"].includes(node.operator)) {\r\n                return (\r\n                    isPossibleConstructor(node.left) ||\r\n                    isPossibleConstructor(node.right)\r\n                );\r\n            }\r\n\r\n            /**\r\n             * All other assignment operators are mathematical assignment operators (arithmetic or bitwise).\r\n             * An assignment expression with a mathematical operator can either evaluate to a primitive value,\r\n             * or throw, depending on the operands. Thus, it cannot evaluate to a constructor function.\r\n             */\r\n            return false;\r\n\r\n        case \"LogicalExpression\":\r\n\r\n            /*\r\n             * If the && operator short-circuits, the left side was falsy and therefore not a constructor, and if\r\n             * it doesn't short-circuit, it takes the value from the right side, so the right side must always be a\r\n             * possible constructor. A future improvement could verify that the left side could be truthy by\r\n             * excluding falsy literals.\r\n             */\r\n            if (node.operator === \"&&\") {\r\n                return isPossibleConstructor(node.right);\r\n            }\r\n\r\n            return (\r\n                isPossibleConstructor(node.left) ||\r\n                isPossibleConstructor(node.right)\r\n            );\r\n\r\n        case \"ConditionalExpression\":\r\n            return (\r\n                isPossibleConstructor(node.alternate) ||\r\n                isPossibleConstructor(node.consequent)\r\n            );\r\n\r\n        case \"SequenceExpression\": {\r\n            const lastExpression = node.expressions[node.expressions.length - 1];\r\n\r\n            return isPossibleConstructor(lastExpression);\r\n        }\r\n\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"require `super()` calls in constructors\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/constructor-super\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            missingSome: \"Lacked a call of 'super()' in some code paths.\",\r\n            missingAll: \"Expected to call 'super()'.\",\r\n\r\n            duplicate: \"Unexpected duplicate 'super()'.\",\r\n            badSuper: \"Unexpected 'super()' because 'super' is not a constructor.\",\r\n            unexpected: \"Unexpected 'super()'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /*\r\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\r\n         * Information for each constructor.\r\n         * - upper:      Information of the upper constructor.\r\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\r\n         *               part.\r\n         * - scope:      The scope of own class.\r\n         * - codePath:   The code path object of the constructor.\r\n         */\r\n        let funcInfo = null;\r\n\r\n        /*\r\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\r\n         * Information for each code path segment.\r\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\r\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\r\n         * - validNodes:\r\n         */\r\n        let segInfoMap = Object.create(null);\r\n\r\n        /**\r\n         * Gets the flag which shows `super()` is called in some paths.\r\n         * @param {CodePathSegment} segment A code path segment to get.\r\n         * @returns {boolean} The flag which shows `super()` is called in some paths\r\n         */\r\n        function isCalledInSomePath(segment) {\r\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\r\n        }\r\n\r\n        /**\r\n         * Gets the flag which shows `super()` is called in all paths.\r\n         * @param {CodePathSegment} segment A code path segment to get.\r\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\r\n         */\r\n        function isCalledInEveryPath(segment) {\r\n\r\n            /*\r\n             * If specific segment is the looped segment of the current segment,\r\n             * skip the segment.\r\n             * If not skipped, this never becomes true after a loop.\r\n             */\r\n            if (segment.nextSegments.length === 1 &&\r\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\r\n            ) {\r\n                return true;\r\n            }\r\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\r\n        }\r\n\r\n        return {\r\n\r\n            /**\r\n             * Stacks a constructor information.\r\n             * @param {CodePath} codePath A code path which was started.\r\n             * @param {ASTNode} node The current node.\r\n             * @returns {void}\r\n             */\r\n            onCodePathStart(codePath, node) {\r\n                if (isConstructorFunction(node)) {\r\n\r\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\r\n                    const classNode = node.parent.parent.parent;\r\n                    const superClass = classNode.superClass;\r\n\r\n                    funcInfo = {\r\n                        upper: funcInfo,\r\n                        isConstructor: true,\r\n                        hasExtends: Boolean(superClass),\r\n                        superIsConstructor: isPossibleConstructor(superClass),\r\n                        codePath\r\n                    };\r\n                } else {\r\n                    funcInfo = {\r\n                        upper: funcInfo,\r\n                        isConstructor: false,\r\n                        hasExtends: false,\r\n                        superIsConstructor: false,\r\n                        codePath\r\n                    };\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Pops a constructor information.\r\n             * And reports if `super()` lacked.\r\n             * @param {CodePath} codePath A code path which was ended.\r\n             * @param {ASTNode} node The current node.\r\n             * @returns {void}\r\n             */\r\n            onCodePathEnd(codePath, node) {\r\n                const hasExtends = funcInfo.hasExtends;\r\n\r\n                // Pop.\r\n                funcInfo = funcInfo.upper;\r\n\r\n                if (!hasExtends) {\r\n                    return;\r\n                }\r\n\r\n                // Reports if `super()` lacked.\r\n                const segments = codePath.returnedSegments;\r\n                const calledInEveryPaths = segments.every(isCalledInEveryPath);\r\n                const calledInSomePaths = segments.some(isCalledInSomePath);\r\n\r\n                if (!calledInEveryPaths) {\r\n                    context.report({\r\n                        messageId: calledInSomePaths\r\n                            ? \"missingSome\"\r\n                            : \"missingAll\",\r\n                        node: node.parent\r\n                    });\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Initialize information of a given code path segment.\r\n             * @param {CodePathSegment} segment A code path segment to initialize.\r\n             * @returns {void}\r\n             */\r\n            onCodePathSegmentStart(segment) {\r\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\r\n                    return;\r\n                }\r\n\r\n                // Initialize info.\r\n                const info = segInfoMap[segment.id] = {\r\n                    calledInSomePaths: false,\r\n                    calledInEveryPaths: false,\r\n                    validNodes: []\r\n                };\r\n\r\n                // When there are previous segments, aggregates these.\r\n                const prevSegments = segment.prevSegments;\r\n\r\n                if (prevSegments.length > 0) {\r\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\r\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Update information of the code path segment when a code path was\r\n             * looped.\r\n             * @param {CodePathSegment} fromSegment The code path segment of the\r\n             *      end of a loop.\r\n             * @param {CodePathSegment} toSegment A code path segment of the head\r\n             *      of a loop.\r\n             * @returns {void}\r\n             */\r\n            onCodePathSegmentLoop(fromSegment, toSegment) {\r\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\r\n                    return;\r\n                }\r\n\r\n                // Update information inside of the loop.\r\n                const isRealLoop = toSegment.prevSegments.length >= 2;\r\n\r\n                funcInfo.codePath.traverseSegments(\r\n                    { first: toSegment, last: fromSegment },\r\n                    segment => {\r\n                        const info = segInfoMap[segment.id];\r\n                        const prevSegments = segment.prevSegments;\r\n\r\n                        // Updates flags.\r\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\r\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\r\n\r\n                        // If flags become true anew, reports the valid nodes.\r\n                        if (info.calledInSomePaths || isRealLoop) {\r\n                            const nodes = info.validNodes;\r\n\r\n                            info.validNodes = [];\r\n\r\n                            for (let i = 0; i < nodes.length; ++i) {\r\n                                const node = nodes[i];\r\n\r\n                                context.report({\r\n                                    messageId: \"duplicate\",\r\n                                    node\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n                );\r\n            },\r\n\r\n            /**\r\n             * Checks for a call of `super()`.\r\n             * @param {ASTNode} node A CallExpression node to check.\r\n             * @returns {void}\r\n             */\r\n            \"CallExpression:exit\"(node) {\r\n                if (!(funcInfo && funcInfo.isConstructor)) {\r\n                    return;\r\n                }\r\n\r\n                // Skips except `super()`.\r\n                if (node.callee.type !== \"Super\") {\r\n                    return;\r\n                }\r\n\r\n                // Reports if needed.\r\n                if (funcInfo.hasExtends) {\r\n                    const segments = funcInfo.codePath.currentSegments;\r\n                    let duplicate = false;\r\n                    let info = null;\r\n\r\n                    for (let i = 0; i < segments.length; ++i) {\r\n                        const segment = segments[i];\r\n\r\n                        if (segment.reachable) {\r\n                            info = segInfoMap[segment.id];\r\n\r\n                            duplicate = duplicate || info.calledInSomePaths;\r\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\r\n                        }\r\n                    }\r\n\r\n                    if (info) {\r\n                        if (duplicate) {\r\n                            context.report({\r\n                                messageId: \"duplicate\",\r\n                                node\r\n                            });\r\n                        } else if (!funcInfo.superIsConstructor) {\r\n                            context.report({\r\n                                messageId: \"badSuper\",\r\n                                node\r\n                            });\r\n                        } else {\r\n                            info.validNodes.push(node);\r\n                        }\r\n                    }\r\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\r\n                    context.report({\r\n                        messageId: \"unexpected\",\r\n                        node\r\n                    });\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Set the mark to the returned path as `super()` was called.\r\n             * @param {ASTNode} node A ReturnStatement node to check.\r\n             * @returns {void}\r\n             */\r\n            ReturnStatement(node) {\r\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\r\n                    return;\r\n                }\r\n\r\n                // Skips if no argument.\r\n                if (!node.argument) {\r\n                    return;\r\n                }\r\n\r\n                // Returning argument is a substitute of 'super()'.\r\n                const segments = funcInfo.codePath.currentSegments;\r\n\r\n                for (let i = 0; i < segments.length; ++i) {\r\n                    const segment = segments[i];\r\n\r\n                    if (segment.reachable) {\r\n                        const info = segInfoMap[segment.id];\r\n\r\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Resets state.\r\n             * @returns {void}\r\n             */\r\n            \"Program:exit\"() {\r\n                segInfoMap = Object.create(null);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}