{"ast":null,"code":"/**\r\n * @fileoverview Rule to specify spacing of object literal keys and values\r\n * @author Brandon Mills\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether a string contains a line terminator as defined in\r\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\r\n * @param {string} str String to test.\r\n * @returns {boolean} True if str contains a line terminator.\r\n */\n\n\nfunction containsLineTerminator(str) {\n  return astUtils.LINEBREAK_MATCHER.test(str);\n}\n/**\r\n * Gets the last element of an array.\r\n * @param {Array} arr An array.\r\n * @returns {any} Last element of arr.\r\n */\n\n\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\n/**\r\n * Checks whether a node is contained on a single line.\r\n * @param {ASTNode} node AST Node being evaluated.\r\n * @returns {boolean} True if the node is a single line.\r\n */\n\n\nfunction isSingleLine(node) {\n  return node.loc.end.line === node.loc.start.line;\n}\n/**\r\n * Checks whether the properties on a single line.\r\n * @param {ASTNode[]} properties List of Property AST nodes.\r\n * @returns {boolean} True if all properties is on a single line.\r\n */\n\n\nfunction isSingleLineProperties(properties) {\n  const [firstProp] = properties,\n        lastProp = last(properties);\n  return firstProp.loc.start.line === lastProp.loc.end.line;\n}\n/**\r\n * Initializes a single option property from the configuration with defaults for undefined values\r\n * @param {Object} toOptions Object to be initialized\r\n * @param {Object} fromOptions Object to be initialized from\r\n * @returns {Object} The object with correctly initialized options and values\r\n */\n\n\nfunction initOptionProperty(toOptions, fromOptions) {\n  toOptions.mode = fromOptions.mode || \"strict\"; // Set value of beforeColon\n\n  if (typeof fromOptions.beforeColon !== \"undefined\") {\n    toOptions.beforeColon = +fromOptions.beforeColon;\n  } else {\n    toOptions.beforeColon = 0;\n  } // Set value of afterColon\n\n\n  if (typeof fromOptions.afterColon !== \"undefined\") {\n    toOptions.afterColon = +fromOptions.afterColon;\n  } else {\n    toOptions.afterColon = 1;\n  } // Set align if exists\n\n\n  if (typeof fromOptions.align !== \"undefined\") {\n    if (typeof fromOptions.align === \"object\") {\n      toOptions.align = fromOptions.align;\n    } else {\n      // \"string\"\n      toOptions.align = {\n        on: fromOptions.align,\n        mode: toOptions.mode,\n        beforeColon: toOptions.beforeColon,\n        afterColon: toOptions.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n}\n/**\r\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\r\n * @param {Object} toOptions Object to be initialized\r\n * @param {Object} fromOptions Object to be initialized from\r\n * @returns {Object} The object with correctly initialized options and values\r\n */\n\n\nfunction initOptions(toOptions, fromOptions) {\n  if (typeof fromOptions.align === \"object\") {\n    // Initialize the alignment configuration\n    toOptions.align = initOptionProperty({}, fromOptions.align);\n    toOptions.align.on = fromOptions.align.on || \"colon\";\n    toOptions.align.mode = fromOptions.align.mode || \"strict\";\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);\n  } else {\n    // string or undefined\n    toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);\n    toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions); // If alignment options are defined in multiLine, pull them out into the general align configuration\n\n    if (toOptions.multiLine.align) {\n      toOptions.align = {\n        on: toOptions.multiLine.align.on,\n        mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\n        beforeColon: toOptions.multiLine.align.beforeColon,\n        afterColon: toOptions.multiLine.align.afterColon\n      };\n    }\n  }\n\n  return toOptions;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing between keys and values in object literal properties\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/key-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      anyOf: [{\n        type: \"object\",\n        properties: {\n          align: {\n            anyOf: [{\n              enum: [\"colon\", \"value\"]\n            }, {\n              type: \"object\",\n              properties: {\n                mode: {\n                  enum: [\"strict\", \"minimum\"]\n                },\n                on: {\n                  enum: [\"colon\", \"value\"]\n                },\n                beforeColon: {\n                  type: \"boolean\"\n                },\n                afterColon: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            }]\n          },\n          mode: {\n            enum: [\"strict\", \"minimum\"]\n          },\n          beforeColon: {\n            type: \"boolean\"\n          },\n          afterColon: {\n            type: \"boolean\"\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              align: {\n                anyOf: [{\n                  enum: [\"colon\", \"value\"]\n                }, {\n                  type: \"object\",\n                  properties: {\n                    mode: {\n                      enum: [\"strict\", \"minimum\"]\n                    },\n                    on: {\n                      enum: [\"colon\", \"value\"]\n                    },\n                    beforeColon: {\n                      type: \"boolean\"\n                    },\n                    afterColon: {\n                      type: \"boolean\"\n                    }\n                  },\n                  additionalProperties: false\n                }]\n              },\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }, {\n        type: \"object\",\n        properties: {\n          singleLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          multiLine: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          },\n          align: {\n            type: \"object\",\n            properties: {\n              mode: {\n                enum: [\"strict\", \"minimum\"]\n              },\n              on: {\n                enum: [\"colon\", \"value\"]\n              },\n              beforeColon: {\n                type: \"boolean\"\n              },\n              afterColon: {\n                type: \"boolean\"\n              }\n            },\n            additionalProperties: false\n          }\n        },\n        additionalProperties: false\n      }]\n    }],\n    messages: {\n      extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\n      extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\n      missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\n      missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\n    }\n  },\n\n  create(context) {\n    /**\r\n     * OPTIONS\r\n     * \"key-spacing\": [2, {\r\n     *     beforeColon: false,\r\n     *     afterColon: true,\r\n     *     align: \"colon\" // Optional, or \"value\"\r\n     * }\r\n     */\n    const options = context.options[0] || {},\n          ruleOptions = initOptions({}, options),\n          multiLineOptions = ruleOptions.multiLine,\n          singleLineOptions = ruleOptions.singleLine,\n          alignmentOptions = ruleOptions.align || null;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Checks whether a property is a member of the property group it follows.\r\n     * @param {ASTNode} lastMember The last Property known to be in the group.\r\n     * @param {ASTNode} candidate The next Property that might be in the group.\r\n     * @returns {boolean} True if the candidate property is part of the group.\r\n     */\n\n    function continuesPropertyGroup(lastMember, candidate) {\n      const groupEndLine = lastMember.loc.start.line,\n            candidateStartLine = candidate.loc.start.line;\n\n      if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n      }\n      /*\r\n       * Check that the first comment is adjacent to the end of the group, the\r\n       * last comment is adjacent to the candidate property, and that successive\r\n       * comments are adjacent to each other.\r\n       */\n\n\n      const leadingComments = sourceCode.getCommentsBefore(candidate);\n\n      if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {\n        for (let i = 1; i < leadingComments.length; i++) {\n          if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Determines if the given property is key-value property.\r\n     * @param {ASTNode} property Property node to check.\r\n     * @returns {boolean} Whether the property is a key-value property.\r\n     */\n\n\n    function isKeyValueProperty(property) {\n      return !(property.method || property.shorthand || property.kind !== \"init\" || property.type !== \"Property\" // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\n      );\n    }\n    /**\r\n     * Starting from the given a node (a property.key node here) looks forward\r\n     * until it finds the last token before a colon punctuator and returns it.\r\n     * @param {ASTNode} node The node to start looking from.\r\n     * @returns {ASTNode} The last token before a colon punctuator.\r\n     */\n\n\n    function getLastTokenBeforeColon(node) {\n      const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\n      return sourceCode.getTokenBefore(colonToken);\n    }\n    /**\r\n     * Starting from the given a node (a property.key node here) looks forward\r\n     * until it finds the colon punctuator and returns it.\r\n     * @param {ASTNode} node The node to start looking from.\r\n     * @returns {ASTNode} The colon punctuator.\r\n     */\n\n\n    function getNextColon(node) {\n      return sourceCode.getTokenAfter(node, astUtils.isColonToken);\n    }\n    /**\r\n     * Gets an object literal property's key as the identifier name or string value.\r\n     * @param {ASTNode} property Property node whose key to retrieve.\r\n     * @returns {string} The property's key.\r\n     */\n\n\n    function getKey(property) {\n      const key = property.key;\n\n      if (property.computed) {\n        return sourceCode.getText().slice(key.range[0], key.range[1]);\n      }\n\n      return astUtils.getStaticPropertyName(property);\n    }\n    /**\r\n     * Reports an appropriately-formatted error if spacing is incorrect on one\r\n     * side of the colon.\r\n     * @param {ASTNode} property Key-value pair in an object literal.\r\n     * @param {string} side Side being verified - either \"key\" or \"value\".\r\n     * @param {string} whitespace Actual whitespace string.\r\n     * @param {int} expected Expected whitespace length.\r\n     * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\r\n     * @returns {void}\r\n     */\n\n\n    function report(property, side, whitespace, expected, mode) {\n      const diff = whitespace.length - expected;\n\n      if ((diff && mode === \"strict\" || diff < 0 && mode === \"minimum\" || diff > 0 && !expected && mode === \"minimum\") && !(expected && containsLineTerminator(whitespace))) {\n        const nextColon = getNextColon(property.key),\n              tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {\n          includeComments: true\n        }),\n              tokenAfterColon = sourceCode.getTokenAfter(nextColon, {\n          includeComments: true\n        }),\n              isKeySide = side === \"key\",\n              isExtra = diff > 0,\n              diffAbs = Math.abs(diff),\n              spaces = Array(diffAbs + 1).join(\" \");\n        const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\n        const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\n        const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\n        const loc = isExtra ? {\n          start: locStart,\n          end: locEnd\n        } : missingLoc;\n        let fix;\n\n        if (isExtra) {\n          let range; // Remove whitespace\n\n          if (isKeySide) {\n            range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\n          } else {\n            range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\n          }\n\n          fix = function (fixer) {\n            return fixer.removeRange(range);\n          };\n        } else {\n          // Add whitespace\n          if (isKeySide) {\n            fix = function (fixer) {\n              return fixer.insertTextAfter(tokenBeforeColon, spaces);\n            };\n          } else {\n            fix = function (fixer) {\n              return fixer.insertTextBefore(tokenAfterColon, spaces);\n            };\n          }\n        }\n\n        let messageId = \"\";\n\n        if (isExtra) {\n          messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\n        } else {\n          messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\n        }\n\n        context.report({\n          node: property[side],\n          loc,\n          messageId,\n          data: {\n            computed: property.computed ? \"computed \" : \"\",\n            key: getKey(property)\n          },\n          fix\n        });\n      }\n    }\n    /**\r\n     * Gets the number of characters in a key, including quotes around string\r\n     * keys and braces around computed property keys.\r\n     * @param {ASTNode} property Property of on object literal.\r\n     * @returns {int} Width of the key.\r\n     */\n\n\n    function getKeyWidth(property) {\n      const startToken = sourceCode.getFirstToken(property);\n      const endToken = getLastTokenBeforeColon(property.key);\n      return endToken.range[1] - startToken.range[0];\n    }\n    /**\r\n     * Gets the whitespace around the colon in an object literal property.\r\n     * @param {ASTNode} property Property node from an object literal.\r\n     * @returns {Object} Whitespace before and after the property's colon.\r\n     */\n\n\n    function getPropertyWhitespace(property) {\n      const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));\n\n      if (whitespace) {\n        return {\n          beforeColon: whitespace[1],\n          afterColon: whitespace[2]\n        };\n      }\n\n      return null;\n    }\n    /**\r\n     * Creates groups of properties.\r\n     * @param {ASTNode} node ObjectExpression node being evaluated.\r\n     * @returns {Array<ASTNode[]>} Groups of property AST node lists.\r\n     */\n\n\n    function createGroups(node) {\n      if (node.properties.length === 1) {\n        return [node.properties];\n      }\n\n      return node.properties.reduce((groups, property) => {\n        const currentGroup = last(groups),\n              prev = last(currentGroup);\n\n        if (!prev || continuesPropertyGroup(prev, property)) {\n          currentGroup.push(property);\n        } else {\n          groups.push([property]);\n        }\n\n        return groups;\n      }, [[]]);\n    }\n    /**\r\n     * Verifies correct vertical alignment of a group of properties.\r\n     * @param {ASTNode[]} properties List of Property AST nodes.\r\n     * @returns {void}\r\n     */\n\n\n    function verifyGroupAlignment(properties) {\n      const length = properties.length,\n            widths = properties.map(getKeyWidth),\n            // Width of keys, including quotes\n      align = alignmentOptions.on; // \"value\" or \"colon\"\n\n      let targetWidth = Math.max(...widths),\n          beforeColon,\n          afterColon,\n          mode;\n\n      if (alignmentOptions && length > 1) {\n        // When aligning values within a group, use the alignment configuration.\n        beforeColon = alignmentOptions.beforeColon;\n        afterColon = alignmentOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } else {\n        beforeColon = multiLineOptions.beforeColon;\n        afterColon = multiLineOptions.afterColon;\n        mode = alignmentOptions.mode;\n      } // Conditionally include one space before or after colon\n\n\n      targetWidth += align === \"colon\" ? beforeColon : afterColon;\n\n      for (let i = 0; i < length; i++) {\n        const property = properties[i];\n        const whitespace = getPropertyWhitespace(property);\n\n        if (whitespace) {\n          // Object literal getters/setters lack a colon\n          const width = widths[i];\n\n          if (align === \"value\") {\n            report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n            report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n          } else {\n            // align = \"colon\"\n            report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n            report(property, \"value\", whitespace.afterColon, afterColon, mode);\n          }\n        }\n      }\n    }\n    /**\r\n     * Verifies spacing of property conforms to specified options.\r\n     * @param {ASTNode} node Property node being evaluated.\r\n     * @param {Object} lineOptions Configured singleLine or multiLine options\r\n     * @returns {void}\r\n     */\n\n\n    function verifySpacing(node, lineOptions) {\n      const actual = getPropertyWhitespace(node);\n\n      if (actual) {\n        // Object literal getters/setters lack colons\n        report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n        report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n      }\n    }\n    /**\r\n     * Verifies spacing of each property in a list.\r\n     * @param {ASTNode[]} properties List of Property AST nodes.\r\n     * @param {Object} lineOptions Configured singleLine or multiLine options\r\n     * @returns {void}\r\n     */\n\n\n    function verifyListSpacing(properties, lineOptions) {\n      const length = properties.length;\n\n      for (let i = 0; i < length; i++) {\n        verifySpacing(properties[i], lineOptions);\n      }\n    }\n    /**\r\n     * Verifies vertical alignment, taking into account groups of properties.\r\n     * @param {ASTNode} node ObjectExpression node being evaluated.\r\n     * @returns {void}\r\n     */\n\n\n    function verifyAlignment(node) {\n      createGroups(node).forEach(group => {\n        const properties = group.filter(isKeyValueProperty);\n\n        if (properties.length > 0 && isSingleLineProperties(properties)) {\n          verifyListSpacing(properties, multiLineOptions);\n        } else {\n          verifyGroupAlignment(properties);\n        }\n      });\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    if (alignmentOptions) {\n      // Verify vertical alignment\n      return {\n        ObjectExpression(node) {\n          if (isSingleLine(node)) {\n            verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\n          } else {\n            verifyAlignment(node);\n          }\n        }\n\n      };\n    } // Obey beforeColon and afterColon in each property as configured\n\n\n    return {\n      Property(node) {\n        verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/key-spacing.js"],"names":["astUtils","require","containsLineTerminator","str","LINEBREAK_MATCHER","test","last","arr","length","isSingleLine","node","loc","end","line","start","isSingleLineProperties","properties","firstProp","lastProp","initOptionProperty","toOptions","fromOptions","mode","beforeColon","afterColon","align","on","initOptions","multiLine","singleLine","module","exports","meta","type","docs","description","recommended","url","fixable","schema","anyOf","enum","additionalProperties","messages","extraKey","extraValue","missingKey","missingValue","create","context","options","ruleOptions","multiLineOptions","singleLineOptions","alignmentOptions","sourceCode","getSourceCode","continuesPropertyGroup","lastMember","candidate","groupEndLine","candidateStartLine","leadingComments","getCommentsBefore","i","isKeyValueProperty","property","method","shorthand","kind","getLastTokenBeforeColon","colonToken","getTokenAfter","isColonToken","getTokenBefore","getNextColon","getKey","key","computed","getText","slice","range","getStaticPropertyName","report","side","whitespace","expected","diff","nextColon","tokenBeforeColon","includeComments","tokenAfterColon","isKeySide","isExtra","diffAbs","Math","abs","spaces","Array","join","locStart","locEnd","missingLoc","fix","fixer","removeRange","insertTextAfter","insertTextBefore","messageId","data","getKeyWidth","startToken","getFirstToken","endToken","getPropertyWhitespace","exec","value","createGroups","reduce","groups","currentGroup","prev","push","verifyGroupAlignment","widths","map","targetWidth","max","width","verifySpacing","lineOptions","actual","verifyListSpacing","verifyAlignment","forEach","group","filter","ObjectExpression","Property","parent"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to specify spacing of object literal keys and values\r\n * @author Brandon Mills\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether a string contains a line terminator as defined in\r\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\r\n * @param {string} str String to test.\r\n * @returns {boolean} True if str contains a line terminator.\r\n */\r\nfunction containsLineTerminator(str) {\r\n    return astUtils.LINEBREAK_MATCHER.test(str);\r\n}\r\n\r\n/**\r\n * Gets the last element of an array.\r\n * @param {Array} arr An array.\r\n * @returns {any} Last element of arr.\r\n */\r\nfunction last(arr) {\r\n    return arr[arr.length - 1];\r\n}\r\n\r\n/**\r\n * Checks whether a node is contained on a single line.\r\n * @param {ASTNode} node AST Node being evaluated.\r\n * @returns {boolean} True if the node is a single line.\r\n */\r\nfunction isSingleLine(node) {\r\n    return (node.loc.end.line === node.loc.start.line);\r\n}\r\n\r\n/**\r\n * Checks whether the properties on a single line.\r\n * @param {ASTNode[]} properties List of Property AST nodes.\r\n * @returns {boolean} True if all properties is on a single line.\r\n */\r\nfunction isSingleLineProperties(properties) {\r\n    const [firstProp] = properties,\r\n        lastProp = last(properties);\r\n\r\n    return firstProp.loc.start.line === lastProp.loc.end.line;\r\n}\r\n\r\n/**\r\n * Initializes a single option property from the configuration with defaults for undefined values\r\n * @param {Object} toOptions Object to be initialized\r\n * @param {Object} fromOptions Object to be initialized from\r\n * @returns {Object} The object with correctly initialized options and values\r\n */\r\nfunction initOptionProperty(toOptions, fromOptions) {\r\n    toOptions.mode = fromOptions.mode || \"strict\";\r\n\r\n    // Set value of beforeColon\r\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\r\n        toOptions.beforeColon = +fromOptions.beforeColon;\r\n    } else {\r\n        toOptions.beforeColon = 0;\r\n    }\r\n\r\n    // Set value of afterColon\r\n    if (typeof fromOptions.afterColon !== \"undefined\") {\r\n        toOptions.afterColon = +fromOptions.afterColon;\r\n    } else {\r\n        toOptions.afterColon = 1;\r\n    }\r\n\r\n    // Set align if exists\r\n    if (typeof fromOptions.align !== \"undefined\") {\r\n        if (typeof fromOptions.align === \"object\") {\r\n            toOptions.align = fromOptions.align;\r\n        } else { // \"string\"\r\n            toOptions.align = {\r\n                on: fromOptions.align,\r\n                mode: toOptions.mode,\r\n                beforeColon: toOptions.beforeColon,\r\n                afterColon: toOptions.afterColon\r\n            };\r\n        }\r\n    }\r\n\r\n    return toOptions;\r\n}\r\n\r\n/**\r\n * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values\r\n * @param {Object} toOptions Object to be initialized\r\n * @param {Object} fromOptions Object to be initialized from\r\n * @returns {Object} The object with correctly initialized options and values\r\n */\r\nfunction initOptions(toOptions, fromOptions) {\r\n    if (typeof fromOptions.align === \"object\") {\r\n\r\n        // Initialize the alignment configuration\r\n        toOptions.align = initOptionProperty({}, fromOptions.align);\r\n        toOptions.align.on = fromOptions.align.on || \"colon\";\r\n        toOptions.align.mode = fromOptions.align.mode || \"strict\";\r\n\r\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\r\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\r\n\r\n    } else { // string or undefined\r\n        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));\r\n        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));\r\n\r\n        // If alignment options are defined in multiLine, pull them out into the general align configuration\r\n        if (toOptions.multiLine.align) {\r\n            toOptions.align = {\r\n                on: toOptions.multiLine.align.on,\r\n                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,\r\n                beforeColon: toOptions.multiLine.align.beforeColon,\r\n                afterColon: toOptions.multiLine.align.afterColon\r\n            };\r\n        }\r\n    }\r\n\r\n    return toOptions;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/key-spacing\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [{\r\n            anyOf: [\r\n                {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        align: {\r\n                            anyOf: [\r\n                                {\r\n                                    enum: [\"colon\", \"value\"]\r\n                                },\r\n                                {\r\n                                    type: \"object\",\r\n                                    properties: {\r\n                                        mode: {\r\n                                            enum: [\"strict\", \"minimum\"]\r\n                                        },\r\n                                        on: {\r\n                                            enum: [\"colon\", \"value\"]\r\n                                        },\r\n                                        beforeColon: {\r\n                                            type: \"boolean\"\r\n                                        },\r\n                                        afterColon: {\r\n                                            type: \"boolean\"\r\n                                        }\r\n                                    },\r\n                                    additionalProperties: false\r\n                                }\r\n                            ]\r\n                        },\r\n                        mode: {\r\n                            enum: [\"strict\", \"minimum\"]\r\n                        },\r\n                        beforeColon: {\r\n                            type: \"boolean\"\r\n                        },\r\n                        afterColon: {\r\n                            type: \"boolean\"\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                },\r\n                {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        singleLine: {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                mode: {\r\n                                    enum: [\"strict\", \"minimum\"]\r\n                                },\r\n                                beforeColon: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                afterColon: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        },\r\n                        multiLine: {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                align: {\r\n                                    anyOf: [\r\n                                        {\r\n                                            enum: [\"colon\", \"value\"]\r\n                                        },\r\n                                        {\r\n                                            type: \"object\",\r\n                                            properties: {\r\n                                                mode: {\r\n                                                    enum: [\"strict\", \"minimum\"]\r\n                                                },\r\n                                                on: {\r\n                                                    enum: [\"colon\", \"value\"]\r\n                                                },\r\n                                                beforeColon: {\r\n                                                    type: \"boolean\"\r\n                                                },\r\n                                                afterColon: {\r\n                                                    type: \"boolean\"\r\n                                                }\r\n                                            },\r\n                                            additionalProperties: false\r\n                                        }\r\n                                    ]\r\n                                },\r\n                                mode: {\r\n                                    enum: [\"strict\", \"minimum\"]\r\n                                },\r\n                                beforeColon: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                afterColon: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                },\r\n                {\r\n                    type: \"object\",\r\n                    properties: {\r\n                        singleLine: {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                mode: {\r\n                                    enum: [\"strict\", \"minimum\"]\r\n                                },\r\n                                beforeColon: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                afterColon: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        },\r\n                        multiLine: {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                mode: {\r\n                                    enum: [\"strict\", \"minimum\"]\r\n                                },\r\n                                beforeColon: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                afterColon: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        },\r\n                        align: {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                mode: {\r\n                                    enum: [\"strict\", \"minimum\"]\r\n                                },\r\n                                on: {\r\n                                    enum: [\"colon\", \"value\"]\r\n                                },\r\n                                beforeColon: {\r\n                                    type: \"boolean\"\r\n                                },\r\n                                afterColon: {\r\n                                    type: \"boolean\"\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    },\r\n                    additionalProperties: false\r\n                }\r\n            ]\r\n        }],\r\n        messages: {\r\n            extraKey: \"Extra space after {{computed}}key '{{key}}'.\",\r\n            extraValue: \"Extra space before value for {{computed}}key '{{key}}'.\",\r\n            missingKey: \"Missing space after {{computed}}key '{{key}}'.\",\r\n            missingValue: \"Missing space before value for {{computed}}key '{{key}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        /**\r\n         * OPTIONS\r\n         * \"key-spacing\": [2, {\r\n         *     beforeColon: false,\r\n         *     afterColon: true,\r\n         *     align: \"colon\" // Optional, or \"value\"\r\n         * }\r\n         */\r\n        const options = context.options[0] || {},\r\n            ruleOptions = initOptions({}, options),\r\n            multiLineOptions = ruleOptions.multiLine,\r\n            singleLineOptions = ruleOptions.singleLine,\r\n            alignmentOptions = ruleOptions.align || null;\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Checks whether a property is a member of the property group it follows.\r\n         * @param {ASTNode} lastMember The last Property known to be in the group.\r\n         * @param {ASTNode} candidate The next Property that might be in the group.\r\n         * @returns {boolean} True if the candidate property is part of the group.\r\n         */\r\n        function continuesPropertyGroup(lastMember, candidate) {\r\n            const groupEndLine = lastMember.loc.start.line,\r\n                candidateStartLine = candidate.loc.start.line;\r\n\r\n            if (candidateStartLine - groupEndLine <= 1) {\r\n                return true;\r\n            }\r\n\r\n            /*\r\n             * Check that the first comment is adjacent to the end of the group, the\r\n             * last comment is adjacent to the candidate property, and that successive\r\n             * comments are adjacent to each other.\r\n             */\r\n            const leadingComments = sourceCode.getCommentsBefore(candidate);\r\n\r\n            if (\r\n                leadingComments.length &&\r\n                leadingComments[0].loc.start.line - groupEndLine <= 1 &&\r\n                candidateStartLine - last(leadingComments).loc.end.line <= 1\r\n            ) {\r\n                for (let i = 1; i < leadingComments.length; i++) {\r\n                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if the given property is key-value property.\r\n         * @param {ASTNode} property Property node to check.\r\n         * @returns {boolean} Whether the property is a key-value property.\r\n         */\r\n        function isKeyValueProperty(property) {\r\n            return !(\r\n                (property.method ||\r\n                property.shorthand ||\r\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadElement\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Starting from the given a node (a property.key node here) looks forward\r\n         * until it finds the last token before a colon punctuator and returns it.\r\n         * @param {ASTNode} node The node to start looking from.\r\n         * @returns {ASTNode} The last token before a colon punctuator.\r\n         */\r\n        function getLastTokenBeforeColon(node) {\r\n            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);\r\n\r\n            return sourceCode.getTokenBefore(colonToken);\r\n        }\r\n\r\n        /**\r\n         * Starting from the given a node (a property.key node here) looks forward\r\n         * until it finds the colon punctuator and returns it.\r\n         * @param {ASTNode} node The node to start looking from.\r\n         * @returns {ASTNode} The colon punctuator.\r\n         */\r\n        function getNextColon(node) {\r\n            return sourceCode.getTokenAfter(node, astUtils.isColonToken);\r\n        }\r\n\r\n        /**\r\n         * Gets an object literal property's key as the identifier name or string value.\r\n         * @param {ASTNode} property Property node whose key to retrieve.\r\n         * @returns {string} The property's key.\r\n         */\r\n        function getKey(property) {\r\n            const key = property.key;\r\n\r\n            if (property.computed) {\r\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\r\n            }\r\n            return astUtils.getStaticPropertyName(property);\r\n        }\r\n\r\n        /**\r\n         * Reports an appropriately-formatted error if spacing is incorrect on one\r\n         * side of the colon.\r\n         * @param {ASTNode} property Key-value pair in an object literal.\r\n         * @param {string} side Side being verified - either \"key\" or \"value\".\r\n         * @param {string} whitespace Actual whitespace string.\r\n         * @param {int} expected Expected whitespace length.\r\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\r\n         * @returns {void}\r\n         */\r\n        function report(property, side, whitespace, expected, mode) {\r\n            const diff = whitespace.length - expected;\r\n\r\n            if ((\r\n                diff && mode === \"strict\" ||\r\n                diff < 0 && mode === \"minimum\" ||\r\n                diff > 0 && !expected && mode === \"minimum\") &&\r\n                !(expected && containsLineTerminator(whitespace))\r\n            ) {\r\n                const nextColon = getNextColon(property.key),\r\n                    tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true }),\r\n                    tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true }),\r\n                    isKeySide = side === \"key\",\r\n                    isExtra = diff > 0,\r\n                    diffAbs = Math.abs(diff),\r\n                    spaces = Array(diffAbs + 1).join(\" \");\r\n\r\n                const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;\r\n                const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;\r\n                const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;\r\n                const loc = isExtra ? { start: locStart, end: locEnd } : missingLoc;\r\n\r\n                let fix;\r\n\r\n                if (isExtra) {\r\n                    let range;\r\n\r\n                    // Remove whitespace\r\n                    if (isKeySide) {\r\n                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];\r\n                    } else {\r\n                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];\r\n                    }\r\n                    fix = function(fixer) {\r\n                        return fixer.removeRange(range);\r\n                    };\r\n                } else {\r\n\r\n                    // Add whitespace\r\n                    if (isKeySide) {\r\n                        fix = function(fixer) {\r\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\r\n                        };\r\n                    } else {\r\n                        fix = function(fixer) {\r\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\r\n                        };\r\n                    }\r\n                }\r\n\r\n                let messageId = \"\";\r\n\r\n                if (isExtra) {\r\n                    messageId = side === \"key\" ? \"extraKey\" : \"extraValue\";\r\n                } else {\r\n                    messageId = side === \"key\" ? \"missingKey\" : \"missingValue\";\r\n                }\r\n\r\n                context.report({\r\n                    node: property[side],\r\n                    loc,\r\n                    messageId,\r\n                    data: {\r\n                        computed: property.computed ? \"computed \" : \"\",\r\n                        key: getKey(property)\r\n                    },\r\n                    fix\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the number of characters in a key, including quotes around string\r\n         * keys and braces around computed property keys.\r\n         * @param {ASTNode} property Property of on object literal.\r\n         * @returns {int} Width of the key.\r\n         */\r\n        function getKeyWidth(property) {\r\n            const startToken = sourceCode.getFirstToken(property);\r\n            const endToken = getLastTokenBeforeColon(property.key);\r\n\r\n            return endToken.range[1] - startToken.range[0];\r\n        }\r\n\r\n        /**\r\n         * Gets the whitespace around the colon in an object literal property.\r\n         * @param {ASTNode} property Property node from an object literal.\r\n         * @returns {Object} Whitespace before and after the property's colon.\r\n         */\r\n        function getPropertyWhitespace(property) {\r\n            const whitespace = /(\\s*):(\\s*)/u.exec(sourceCode.getText().slice(\r\n                property.key.range[1], property.value.range[0]\r\n            ));\r\n\r\n            if (whitespace) {\r\n                return {\r\n                    beforeColon: whitespace[1],\r\n                    afterColon: whitespace[2]\r\n                };\r\n            }\r\n            return null;\r\n        }\r\n\r\n        /**\r\n         * Creates groups of properties.\r\n         * @param {ASTNode} node ObjectExpression node being evaluated.\r\n         * @returns {Array<ASTNode[]>} Groups of property AST node lists.\r\n         */\r\n        function createGroups(node) {\r\n            if (node.properties.length === 1) {\r\n                return [node.properties];\r\n            }\r\n\r\n            return node.properties.reduce((groups, property) => {\r\n                const currentGroup = last(groups),\r\n                    prev = last(currentGroup);\r\n\r\n                if (!prev || continuesPropertyGroup(prev, property)) {\r\n                    currentGroup.push(property);\r\n                } else {\r\n                    groups.push([property]);\r\n                }\r\n\r\n                return groups;\r\n            }, [\r\n                []\r\n            ]);\r\n        }\r\n\r\n        /**\r\n         * Verifies correct vertical alignment of a group of properties.\r\n         * @param {ASTNode[]} properties List of Property AST nodes.\r\n         * @returns {void}\r\n         */\r\n        function verifyGroupAlignment(properties) {\r\n            const length = properties.length,\r\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\r\n                align = alignmentOptions.on; // \"value\" or \"colon\"\r\n            let targetWidth = Math.max(...widths),\r\n                beforeColon, afterColon, mode;\r\n\r\n            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.\r\n                beforeColon = alignmentOptions.beforeColon;\r\n                afterColon = alignmentOptions.afterColon;\r\n                mode = alignmentOptions.mode;\r\n            } else {\r\n                beforeColon = multiLineOptions.beforeColon;\r\n                afterColon = multiLineOptions.afterColon;\r\n                mode = alignmentOptions.mode;\r\n            }\r\n\r\n            // Conditionally include one space before or after colon\r\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                const property = properties[i];\r\n                const whitespace = getPropertyWhitespace(property);\r\n\r\n                if (whitespace) { // Object literal getters/setters lack a colon\r\n                    const width = widths[i];\r\n\r\n                    if (align === \"value\") {\r\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\r\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\r\n                    } else { // align = \"colon\"\r\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\r\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies spacing of property conforms to specified options.\r\n         * @param {ASTNode} node Property node being evaluated.\r\n         * @param {Object} lineOptions Configured singleLine or multiLine options\r\n         * @returns {void}\r\n         */\r\n        function verifySpacing(node, lineOptions) {\r\n            const actual = getPropertyWhitespace(node);\r\n\r\n            if (actual) { // Object literal getters/setters lack colons\r\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\r\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies spacing of each property in a list.\r\n         * @param {ASTNode[]} properties List of Property AST nodes.\r\n         * @param {Object} lineOptions Configured singleLine or multiLine options\r\n         * @returns {void}\r\n         */\r\n        function verifyListSpacing(properties, lineOptions) {\r\n            const length = properties.length;\r\n\r\n            for (let i = 0; i < length; i++) {\r\n                verifySpacing(properties[i], lineOptions);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies vertical alignment, taking into account groups of properties.\r\n         * @param {ASTNode} node ObjectExpression node being evaluated.\r\n         * @returns {void}\r\n         */\r\n        function verifyAlignment(node) {\r\n            createGroups(node).forEach(group => {\r\n                const properties = group.filter(isKeyValueProperty);\r\n\r\n                if (properties.length > 0 && isSingleLineProperties(properties)) {\r\n                    verifyListSpacing(properties, multiLineOptions);\r\n                } else {\r\n                    verifyGroupAlignment(properties);\r\n                }\r\n            });\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        if (alignmentOptions) { // Verify vertical alignment\r\n\r\n            return {\r\n                ObjectExpression(node) {\r\n                    if (isSingleLine(node)) {\r\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);\r\n                    } else {\r\n                        verifyAlignment(node);\r\n                    }\r\n                }\r\n            };\r\n\r\n        }\r\n\r\n        // Obey beforeColon and afterColon in each property as configured\r\n        return {\r\n            Property(node) {\r\n                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\r\n            }\r\n        };\r\n\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}