{"ast":null,"code":"/**\r\n * @fileoverview `Map` to load rules lazily.\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\n\"use strict\";\n\nconst debug = require(\"debug\")(\"eslint:rules\");\n/** @typedef {import(\"./types\").Rule} Rule */\n\n/**\r\n * The `Map` object that loads each rule when it's accessed.\r\n * @example\r\n * const rules = new LazyLoadingRuleMap([\r\n *     [\"eqeqeq\", () => require(\"eqeqeq\")],\r\n *     [\"semi\", () => require(\"semi\")],\r\n *     [\"no-unused-vars\", () => require(\"no-unused-vars\")]\r\n * ]);\r\n *\r\n * rules.get(\"semi\"); // call `() => require(\"semi\")` here.\r\n *\r\n * @extends {Map<string, () => Rule>}\r\n */\n\n\nclass LazyLoadingRuleMap extends Map {\n  /**\r\n   * Initialize this map.\r\n   * @param {Array<[string, function(): Rule]>} loaders The rule loaders.\r\n   */\n  constructor(loaders) {\n    let remaining = loaders.length;\n    super(debug.enabled ? loaders.map(_ref => {\n      let [ruleId, load] = _ref;\n      let cache = null;\n      return [ruleId, () => {\n        if (!cache) {\n          debug(\"Loading rule %o (remaining=%d)\", ruleId, --remaining);\n          cache = load();\n        }\n\n        return cache;\n      }];\n    }) : loaders); // `super(...iterable)` uses `this.set()`, so disable it here.\n\n    Object.defineProperty(LazyLoadingRuleMap.prototype, \"set\", {\n      configurable: true,\n      value: void 0\n    });\n  }\n  /**\r\n   * Get a rule.\r\n   * Each rule will be loaded on the first access.\r\n   * @param {string} ruleId The rule ID to get.\r\n   * @returns {Rule|undefined} The rule.\r\n   */\n\n\n  get(ruleId) {\n    const load = super.get(ruleId);\n    return load && load();\n  }\n  /**\r\n   * Iterate rules.\r\n   * @returns {IterableIterator<Rule>} Rules.\r\n   */\n\n\n  *values() {\n    for (const load of super.values()) {\n      yield load();\n    }\n  }\n  /**\r\n   * Iterate rules.\r\n   * @returns {IterableIterator<[string, Rule]>} Rules.\r\n   */\n\n\n  *entries() {\n    for (const [ruleId, load] of super.entries()) {\n      yield [ruleId, load()];\n    }\n  }\n  /**\r\n   * Call a function with each rule.\r\n   * @param {Function} callbackFn The callback function.\r\n   * @param {any} [thisArg] The object to pass to `this` of the callback function.\r\n   * @returns {void}\r\n   */\n\n\n  forEach(callbackFn, thisArg) {\n    for (const [ruleId, load] of super.entries()) {\n      callbackFn.call(thisArg, load(), ruleId, this);\n    }\n  }\n\n} // Forbid mutation.\n\n\nObject.defineProperties(LazyLoadingRuleMap.prototype, {\n  clear: {\n    configurable: true,\n    value: void 0\n  },\n  delete: {\n    configurable: true,\n    value: void 0\n  },\n  [Symbol.iterator]: {\n    configurable: true,\n    writable: true,\n    value: LazyLoadingRuleMap.prototype.entries\n  }\n});\nmodule.exports = {\n  LazyLoadingRuleMap\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js"],"names":["debug","require","LazyLoadingRuleMap","Map","constructor","loaders","remaining","length","enabled","map","ruleId","load","cache","Object","defineProperty","prototype","configurable","value","get","values","entries","forEach","callbackFn","thisArg","call","defineProperties","clear","delete","Symbol","iterator","writable","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,cAAjB,CAAd;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,kBAAN,SAAiCC,GAAjC,CAAqC;AAEjC;AACJ;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,QAAIC,SAAS,GAAGD,OAAO,CAACE,MAAxB;AAEA,UACIP,KAAK,CAACQ,OAAN,GACMH,OAAO,CAACI,GAAR,CAAY,QAAoB;AAAA,UAAnB,CAACC,MAAD,EAASC,IAAT,CAAmB;AAC9B,UAAIC,KAAK,GAAG,IAAZ;AAEA,aAAO,CACHF,MADG,EAEH,MAAM;AACF,YAAI,CAACE,KAAL,EAAY;AACRZ,UAAAA,KAAK,CAAC,gCAAD,EAAmCU,MAAnC,EAA2C,EAAEJ,SAA7C,CAAL;AACAM,UAAAA,KAAK,GAAGD,IAAI,EAAZ;AACH;;AACD,eAAOC,KAAP;AACH,OARE,CAAP;AAUH,KAbC,CADN,GAeMP,OAhBV,EAHiB,CAsBjB;;AACAQ,IAAAA,MAAM,CAACC,cAAP,CAAsBZ,kBAAkB,CAACa,SAAzC,EAAoD,KAApD,EAA2D;AACvDC,MAAAA,YAAY,EAAE,IADyC;AAEvDC,MAAAA,KAAK,EAAE,KAAK;AAF2C,KAA3D;AAIH;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIC,EAAAA,GAAG,CAACR,MAAD,EAAS;AACR,UAAMC,IAAI,GAAG,MAAMO,GAAN,CAAUR,MAAV,CAAb;AAEA,WAAOC,IAAI,IAAIA,IAAI,EAAnB;AACH;AAED;AACJ;AACA;AACA;;;AACW,GAANQ,MAAM,GAAG;AACN,SAAK,MAAMR,IAAX,IAAmB,MAAMQ,MAAN,EAAnB,EAAmC;AAC/B,YAAMR,IAAI,EAAV;AACH;AACJ;AAED;AACJ;AACA;AACA;;;AACY,GAAPS,OAAO,GAAG;AACP,SAAK,MAAM,CAACV,MAAD,EAASC,IAAT,CAAX,IAA6B,MAAMS,OAAN,EAA7B,EAA8C;AAC1C,YAAM,CAACV,MAAD,EAASC,IAAI,EAAb,CAAN;AACH;AACJ;AAED;AACJ;AACA;AACA;AACA;AACA;;;AACIU,EAAAA,OAAO,CAACC,UAAD,EAAaC,OAAb,EAAsB;AACzB,SAAK,MAAM,CAACb,MAAD,EAASC,IAAT,CAAX,IAA6B,MAAMS,OAAN,EAA7B,EAA8C;AAC1CE,MAAAA,UAAU,CAACE,IAAX,CAAgBD,OAAhB,EAAyBZ,IAAI,EAA7B,EAAiCD,MAAjC,EAAyC,IAAzC;AACH;AACJ;;AA7EgC,C,CAgFrC;;;AACAG,MAAM,CAACY,gBAAP,CAAwBvB,kBAAkB,CAACa,SAA3C,EAAsD;AAClDW,EAAAA,KAAK,EAAE;AAAEV,IAAAA,YAAY,EAAE,IAAhB;AAAsBC,IAAAA,KAAK,EAAE,KAAK;AAAlC,GAD2C;AAElDU,EAAAA,MAAM,EAAE;AAAEX,IAAAA,YAAY,EAAE,IAAhB;AAAsBC,IAAAA,KAAK,EAAE,KAAK;AAAlC,GAF0C;AAGlD,GAACW,MAAM,CAACC,QAAR,GAAmB;AACfb,IAAAA,YAAY,EAAE,IADC;AAEfc,IAAAA,QAAQ,EAAE,IAFK;AAGfb,IAAAA,KAAK,EAAEf,kBAAkB,CAACa,SAAnB,CAA6BK;AAHrB;AAH+B,CAAtD;AAUAW,MAAM,CAACC,OAAP,GAAiB;AAAE9B,EAAAA;AAAF,CAAjB","sourcesContent":["/**\r\n * @fileoverview `Map` to load rules lazily.\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\r\n\"use strict\";\r\n\r\nconst debug = require(\"debug\")(\"eslint:rules\");\r\n\r\n/** @typedef {import(\"./types\").Rule} Rule */\r\n\r\n/**\r\n * The `Map` object that loads each rule when it's accessed.\r\n * @example\r\n * const rules = new LazyLoadingRuleMap([\r\n *     [\"eqeqeq\", () => require(\"eqeqeq\")],\r\n *     [\"semi\", () => require(\"semi\")],\r\n *     [\"no-unused-vars\", () => require(\"no-unused-vars\")]\r\n * ]);\r\n *\r\n * rules.get(\"semi\"); // call `() => require(\"semi\")` here.\r\n *\r\n * @extends {Map<string, () => Rule>}\r\n */\r\nclass LazyLoadingRuleMap extends Map {\r\n\r\n    /**\r\n     * Initialize this map.\r\n     * @param {Array<[string, function(): Rule]>} loaders The rule loaders.\r\n     */\r\n    constructor(loaders) {\r\n        let remaining = loaders.length;\r\n\r\n        super(\r\n            debug.enabled\r\n                ? loaders.map(([ruleId, load]) => {\r\n                    let cache = null;\r\n\r\n                    return [\r\n                        ruleId,\r\n                        () => {\r\n                            if (!cache) {\r\n                                debug(\"Loading rule %o (remaining=%d)\", ruleId, --remaining);\r\n                                cache = load();\r\n                            }\r\n                            return cache;\r\n                        }\r\n                    ];\r\n                })\r\n                : loaders\r\n        );\r\n\r\n        // `super(...iterable)` uses `this.set()`, so disable it here.\r\n        Object.defineProperty(LazyLoadingRuleMap.prototype, \"set\", {\r\n            configurable: true,\r\n            value: void 0\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get a rule.\r\n     * Each rule will be loaded on the first access.\r\n     * @param {string} ruleId The rule ID to get.\r\n     * @returns {Rule|undefined} The rule.\r\n     */\r\n    get(ruleId) {\r\n        const load = super.get(ruleId);\r\n\r\n        return load && load();\r\n    }\r\n\r\n    /**\r\n     * Iterate rules.\r\n     * @returns {IterableIterator<Rule>} Rules.\r\n     */\r\n    *values() {\r\n        for (const load of super.values()) {\r\n            yield load();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate rules.\r\n     * @returns {IterableIterator<[string, Rule]>} Rules.\r\n     */\r\n    *entries() {\r\n        for (const [ruleId, load] of super.entries()) {\r\n            yield [ruleId, load()];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call a function with each rule.\r\n     * @param {Function} callbackFn The callback function.\r\n     * @param {any} [thisArg] The object to pass to `this` of the callback function.\r\n     * @returns {void}\r\n     */\r\n    forEach(callbackFn, thisArg) {\r\n        for (const [ruleId, load] of super.entries()) {\r\n            callbackFn.call(thisArg, load(), ruleId, this);\r\n        }\r\n    }\r\n}\r\n\r\n// Forbid mutation.\r\nObject.defineProperties(LazyLoadingRuleMap.prototype, {\r\n    clear: { configurable: true, value: void 0 },\r\n    delete: { configurable: true, value: void 0 },\r\n    [Symbol.iterator]: {\r\n        configurable: true,\r\n        writable: true,\r\n        value: LazyLoadingRuleMap.prototype.entries\r\n    }\r\n});\r\n\r\nmodule.exports = { LazyLoadingRuleMap };\r\n"]},"metadata":{},"sourceType":"script"}