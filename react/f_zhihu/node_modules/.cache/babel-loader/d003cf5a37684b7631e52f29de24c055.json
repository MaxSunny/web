{"ast":null,"code":"/**\r\n * @fileoverview A rule to set the maximum number of statements in a function.\r\n * @author Ian Christian Myers\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst {\n  upperCaseFirst\n} = require(\"../shared/string-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce a maximum number of statements allowed in function blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/max-statements\"\n    },\n    schema: [{\n      oneOf: [{\n        type: \"integer\",\n        minimum: 0\n      }, {\n        type: \"object\",\n        properties: {\n          maximum: {\n            type: \"integer\",\n            minimum: 0\n          },\n          max: {\n            type: \"integer\",\n            minimum: 0\n          }\n        },\n        additionalProperties: false\n      }]\n    }, {\n      type: \"object\",\n      properties: {\n        ignoreTopLevelFunctions: {\n          type: \"boolean\"\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      exceed: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\"\n    }\n  },\n\n  create(context) {\n    //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n    const functionStack = [],\n          option = context.options[0],\n          ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\n          topLevelFunctions = [];\n    let maxStatements = 10;\n\n    if (typeof option === \"object\" && (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))) {\n      maxStatements = option.maximum || option.max;\n    } else if (typeof option === \"number\") {\n      maxStatements = option;\n    }\n    /**\r\n     * Reports a node if it has too many statements\r\n     * @param {ASTNode} node node to evaluate\r\n     * @param {int} count Number of statements in node\r\n     * @param {int} max Maximum number of statements allowed\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function reportIfTooManyStatements(node, count, max) {\n      if (count > max) {\n        const name = upperCaseFirst(astUtils.getFunctionNameWithKind(node));\n        context.report({\n          node,\n          messageId: \"exceed\",\n          data: {\n            name,\n            count,\n            max\n          }\n        });\n      }\n    }\n    /**\r\n     * When parsing a new function, store it in our function stack\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function startFunction() {\n      functionStack.push(0);\n    }\n    /**\r\n     * Evaluate the node at the end of function\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function endFunction(node) {\n      const count = functionStack.pop();\n      /*\r\n       * This rule does not apply to class static blocks, but we have to track them so\r\n       * that stataments in them do not count as statements in the enclosing function.\r\n       */\n\n      if (node.type === \"StaticBlock\") {\n        return;\n      }\n\n      if (ignoreTopLevelFunctions && functionStack.length === 0) {\n        topLevelFunctions.push({\n          node,\n          count\n        });\n      } else {\n        reportIfTooManyStatements(node, count, maxStatements);\n      }\n    }\n    /**\r\n     * Increment the count of the functions\r\n     * @param {ASTNode} node node to evaluate\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function countStatements(node) {\n      functionStack[functionStack.length - 1] += node.body.length;\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      FunctionDeclaration: startFunction,\n      FunctionExpression: startFunction,\n      ArrowFunctionExpression: startFunction,\n      StaticBlock: startFunction,\n      BlockStatement: countStatements,\n      \"FunctionDeclaration:exit\": endFunction,\n      \"FunctionExpression:exit\": endFunction,\n      \"ArrowFunctionExpression:exit\": endFunction,\n      \"StaticBlock:exit\": endFunction,\n\n      \"Program:exit\"() {\n        if (topLevelFunctions.length === 1) {\n          return;\n        }\n\n        topLevelFunctions.forEach(element => {\n          const count = element.count;\n          const node = element.node;\n          reportIfTooManyStatements(node, count, maxStatements);\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/max-statements.js"],"names":["astUtils","require","upperCaseFirst","module","exports","meta","type","docs","description","recommended","url","schema","oneOf","minimum","properties","maximum","max","additionalProperties","ignoreTopLevelFunctions","messages","exceed","create","context","functionStack","option","options","topLevelFunctions","maxStatements","Object","prototype","hasOwnProperty","call","reportIfTooManyStatements","node","count","name","getFunctionNameWithKind","report","messageId","data","startFunction","push","endFunction","pop","length","countStatements","body","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","StaticBlock","BlockStatement","forEach","element"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to set the maximum number of statements in a function.\r\n * @author Ian Christian Myers\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst { upperCaseFirst } = require(\"../shared/string-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce a maximum number of statements allowed in function blocks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/max-statements\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                oneOf: [\r\n                    {\r\n                        type: \"integer\",\r\n                        minimum: 0\r\n                    },\r\n                    {\r\n                        type: \"object\",\r\n                        properties: {\r\n                            maximum: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            },\r\n                            max: {\r\n                                type: \"integer\",\r\n                                minimum: 0\r\n                            }\r\n                        },\r\n                        additionalProperties: false\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    ignoreTopLevelFunctions: {\r\n                        type: \"boolean\"\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            exceed: \"{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        const functionStack = [],\r\n            option = context.options[0],\r\n            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,\r\n            topLevelFunctions = [];\r\n        let maxStatements = 10;\r\n\r\n        if (\r\n            typeof option === \"object\" &&\r\n            (Object.prototype.hasOwnProperty.call(option, \"maximum\") || Object.prototype.hasOwnProperty.call(option, \"max\"))\r\n        ) {\r\n            maxStatements = option.maximum || option.max;\r\n        } else if (typeof option === \"number\") {\r\n            maxStatements = option;\r\n        }\r\n\r\n        /**\r\n         * Reports a node if it has too many statements\r\n         * @param {ASTNode} node node to evaluate\r\n         * @param {int} count Number of statements in node\r\n         * @param {int} max Maximum number of statements allowed\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function reportIfTooManyStatements(node, count, max) {\r\n            if (count > max) {\r\n                const name = upperCaseFirst(astUtils.getFunctionNameWithKind(node));\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: \"exceed\",\r\n                    data: { name, count, max }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * When parsing a new function, store it in our function stack\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function startFunction() {\r\n            functionStack.push(0);\r\n        }\r\n\r\n        /**\r\n         * Evaluate the node at the end of function\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function endFunction(node) {\r\n            const count = functionStack.pop();\r\n\r\n            /*\r\n             * This rule does not apply to class static blocks, but we have to track them so\r\n             * that stataments in them do not count as statements in the enclosing function.\r\n             */\r\n            if (node.type === \"StaticBlock\") {\r\n                return;\r\n            }\r\n\r\n            if (ignoreTopLevelFunctions && functionStack.length === 0) {\r\n                topLevelFunctions.push({ node, count });\r\n            } else {\r\n                reportIfTooManyStatements(node, count, maxStatements);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Increment the count of the functions\r\n         * @param {ASTNode} node node to evaluate\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function countStatements(node) {\r\n            functionStack[functionStack.length - 1] += node.body.length;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            FunctionDeclaration: startFunction,\r\n            FunctionExpression: startFunction,\r\n            ArrowFunctionExpression: startFunction,\r\n            StaticBlock: startFunction,\r\n\r\n            BlockStatement: countStatements,\r\n\r\n            \"FunctionDeclaration:exit\": endFunction,\r\n            \"FunctionExpression:exit\": endFunction,\r\n            \"ArrowFunctionExpression:exit\": endFunction,\r\n            \"StaticBlock:exit\": endFunction,\r\n\r\n            \"Program:exit\"() {\r\n                if (topLevelFunctions.length === 1) {\r\n                    return;\r\n                }\r\n\r\n                topLevelFunctions.forEach(element => {\r\n                    const count = element.count;\r\n                    const node = element.node;\r\n\r\n                    reportIfTooManyStatements(node, count, maxStatements);\r\n                });\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}