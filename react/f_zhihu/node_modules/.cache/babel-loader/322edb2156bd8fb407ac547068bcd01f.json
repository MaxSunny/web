{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag declared but unused private class members\r\n * @author Tim van der Lippe\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow unused private class members\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unused-private-class-members\"\n    },\n    schema: [],\n    messages: {\n      unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\n    }\n  },\n\n  create(context) {\n    const trackedClasses = [];\n    /**\r\n     * Check whether the current node is in a write only assignment.\r\n     * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\r\n     * @returns {boolean} Whether the node is in a write only assignment\r\n     * @private\r\n     */\n\n    function isWriteOnlyAssignment(privateIdentifierNode) {\n      const parentStatement = privateIdentifierNode.parent.parent;\n      const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\n\n      if (!isAssignmentExpression && parentStatement.type !== \"ForInStatement\" && parentStatement.type !== \"ForOfStatement\" && parentStatement.type !== \"AssignmentPattern\") {\n        return false;\n      } // It is a write-only usage, since we still allow usages on the right for reads\n\n\n      if (parentStatement.left !== privateIdentifierNode.parent) {\n        return false;\n      } // For any other operator (such as '+=') we still consider it a read operation\n\n\n      if (isAssignmentExpression && parentStatement.operator !== \"=\") {\n        /*\r\n         * However, if the read operation is \"discarded\" in an empty statement, then\r\n         * we consider it write only.\r\n         */\n        return parentStatement.parent.type === \"ExpressionStatement\";\n      }\n\n      return true;\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      // Collect all declared members up front and assume they are all unused\n      ClassBody(classBodyNode) {\n        const privateMembers = new Map();\n        trackedClasses.unshift(privateMembers);\n\n        for (const bodyMember of classBodyNode.body) {\n          if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\n            if (bodyMember.key.type === \"PrivateIdentifier\") {\n              privateMembers.set(bodyMember.key.name, {\n                declaredNode: bodyMember,\n                isAccessor: bodyMember.type === \"MethodDefinition\" && (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\n              });\n            }\n          }\n        }\n      },\n\n      /*\r\n       * Process all usages of the private identifier and remove a member from\r\n       * `declaredAndUnusedPrivateMembers` if we deem it used.\r\n       */\n      PrivateIdentifier(privateIdentifierNode) {\n        const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name)); // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\n\n        if (!classBody) {\n          return;\n        } // In case any other usage was already detected, we can short circuit the logic here.\n\n\n        const memberDefinition = classBody.get(privateIdentifierNode.name);\n\n        if (memberDefinition.isUsed) {\n          return;\n        } // The definition of the class member itself\n\n\n        if (privateIdentifierNode.parent.type === \"PropertyDefinition\" || privateIdentifierNode.parent.type === \"MethodDefinition\") {\n          return;\n        }\n        /*\r\n         * Any usage of an accessor is considered a read, as the getter/setter can have\r\n         * side-effects in its definition.\r\n         */\n\n\n        if (memberDefinition.isAccessor) {\n          memberDefinition.isUsed = true;\n          return;\n        } // Any assignments to this member, except for assignments that also read\n\n\n        if (isWriteOnlyAssignment(privateIdentifierNode)) {\n          return;\n        }\n\n        const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\n        const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type; // A statement which only increments (`this.#x++;`)\n\n        if (wrappingExpressionType === \"UpdateExpression\" && parentOfWrappingExpressionType === \"ExpressionStatement\") {\n          return;\n        }\n        /*\r\n         * ({ x: this.#usedInDestructuring } = bar);\r\n         *\r\n         * But should treat the following as a read:\r\n         * ({ [this.#x]: a } = foo);\r\n         */\n\n\n        if (wrappingExpressionType === \"Property\" && parentOfWrappingExpressionType === \"ObjectPattern\" && privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\n          return;\n        } // [...this.#unusedInRestPattern] = bar;\n\n\n        if (wrappingExpressionType === \"RestElement\") {\n          return;\n        } // [this.#unusedInAssignmentPattern] = bar;\n\n\n        if (wrappingExpressionType === \"ArrayPattern\") {\n          return;\n        }\n        /*\r\n         * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\r\n         * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\r\n         * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\r\n         * as used, which is incorrect.\r\n         */\n\n\n        memberDefinition.isUsed = true;\n      },\n\n      /*\r\n       * Post-process the class members and report any remaining members.\r\n       * Since private members can only be accessed in the current class context,\r\n       * we can safely assume that all usages are within the current class body.\r\n       */\n      \"ClassBody:exit\"() {\n        const unusedPrivateMembers = trackedClasses.shift();\n\n        for (const [classMemberName, {\n          declaredNode,\n          isUsed\n        }] of unusedPrivateMembers.entries()) {\n          if (isUsed) {\n            continue;\n          }\n\n          context.report({\n            node: declaredNode,\n            loc: declaredNode.key.loc,\n            messageId: \"unusedPrivateClassMember\",\n            data: {\n              classMemberName: `#${classMemberName}`\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unused-private-class-members.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","unusedPrivateClassMember","create","context","trackedClasses","isWriteOnlyAssignment","privateIdentifierNode","parentStatement","parent","isAssignmentExpression","left","operator","ClassBody","classBodyNode","privateMembers","Map","unshift","bodyMember","body","key","set","name","declaredNode","isAccessor","kind","PrivateIdentifier","classBody","find","classProperties","has","memberDefinition","get","isUsed","wrappingExpressionType","parentOfWrappingExpressionType","value","unusedPrivateMembers","shift","classMemberName","entries","report","node","loc","messageId","data"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag declared but unused private class members\r\n * @author Tim van der Lippe\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow unused private class members\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-unused-private-class-members\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            unusedPrivateClassMember: \"'{{classMemberName}}' is defined but never used.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const trackedClasses = [];\r\n\r\n        /**\r\n         * Check whether the current node is in a write only assignment.\r\n         * @param {ASTNode} privateIdentifierNode Node referring to a private identifier\r\n         * @returns {boolean} Whether the node is in a write only assignment\r\n         * @private\r\n         */\r\n        function isWriteOnlyAssignment(privateIdentifierNode) {\r\n            const parentStatement = privateIdentifierNode.parent.parent;\r\n            const isAssignmentExpression = parentStatement.type === \"AssignmentExpression\";\r\n\r\n            if (!isAssignmentExpression &&\r\n                parentStatement.type !== \"ForInStatement\" &&\r\n                parentStatement.type !== \"ForOfStatement\" &&\r\n                parentStatement.type !== \"AssignmentPattern\") {\r\n                return false;\r\n            }\r\n\r\n            // It is a write-only usage, since we still allow usages on the right for reads\r\n            if (parentStatement.left !== privateIdentifierNode.parent) {\r\n                return false;\r\n            }\r\n\r\n            // For any other operator (such as '+=') we still consider it a read operation\r\n            if (isAssignmentExpression && parentStatement.operator !== \"=\") {\r\n\r\n                /*\r\n                 * However, if the read operation is \"discarded\" in an empty statement, then\r\n                 * we consider it write only.\r\n                 */\r\n                return parentStatement.parent.type === \"ExpressionStatement\";\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n\r\n            // Collect all declared members up front and assume they are all unused\r\n            ClassBody(classBodyNode) {\r\n                const privateMembers = new Map();\r\n\r\n                trackedClasses.unshift(privateMembers);\r\n                for (const bodyMember of classBodyNode.body) {\r\n                    if (bodyMember.type === \"PropertyDefinition\" || bodyMember.type === \"MethodDefinition\") {\r\n                        if (bodyMember.key.type === \"PrivateIdentifier\") {\r\n                            privateMembers.set(bodyMember.key.name, {\r\n                                declaredNode: bodyMember,\r\n                                isAccessor: bodyMember.type === \"MethodDefinition\" &&\r\n                                    (bodyMember.kind === \"set\" || bodyMember.kind === \"get\")\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            /*\r\n             * Process all usages of the private identifier and remove a member from\r\n             * `declaredAndUnusedPrivateMembers` if we deem it used.\r\n             */\r\n            PrivateIdentifier(privateIdentifierNode) {\r\n                const classBody = trackedClasses.find(classProperties => classProperties.has(privateIdentifierNode.name));\r\n\r\n                // Can't happen, as it is a parser to have a missing class body, but let's code defensively here.\r\n                if (!classBody) {\r\n                    return;\r\n                }\r\n\r\n                // In case any other usage was already detected, we can short circuit the logic here.\r\n                const memberDefinition = classBody.get(privateIdentifierNode.name);\r\n\r\n                if (memberDefinition.isUsed) {\r\n                    return;\r\n                }\r\n\r\n                // The definition of the class member itself\r\n                if (privateIdentifierNode.parent.type === \"PropertyDefinition\" ||\r\n                    privateIdentifierNode.parent.type === \"MethodDefinition\") {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * Any usage of an accessor is considered a read, as the getter/setter can have\r\n                 * side-effects in its definition.\r\n                 */\r\n                if (memberDefinition.isAccessor) {\r\n                    memberDefinition.isUsed = true;\r\n                    return;\r\n                }\r\n\r\n                // Any assignments to this member, except for assignments that also read\r\n                if (isWriteOnlyAssignment(privateIdentifierNode)) {\r\n                    return;\r\n                }\r\n\r\n                const wrappingExpressionType = privateIdentifierNode.parent.parent.type;\r\n                const parentOfWrappingExpressionType = privateIdentifierNode.parent.parent.parent.type;\r\n\r\n                // A statement which only increments (`this.#x++;`)\r\n                if (wrappingExpressionType === \"UpdateExpression\" &&\r\n                    parentOfWrappingExpressionType === \"ExpressionStatement\") {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * ({ x: this.#usedInDestructuring } = bar);\r\n                 *\r\n                 * But should treat the following as a read:\r\n                 * ({ [this.#x]: a } = foo);\r\n                 */\r\n                if (wrappingExpressionType === \"Property\" &&\r\n                    parentOfWrappingExpressionType === \"ObjectPattern\" &&\r\n                    privateIdentifierNode.parent.parent.value === privateIdentifierNode.parent) {\r\n                    return;\r\n                }\r\n\r\n                // [...this.#unusedInRestPattern] = bar;\r\n                if (wrappingExpressionType === \"RestElement\") {\r\n                    return;\r\n                }\r\n\r\n                // [this.#unusedInAssignmentPattern] = bar;\r\n                if (wrappingExpressionType === \"ArrayPattern\") {\r\n                    return;\r\n                }\r\n\r\n                /*\r\n                 * We can't delete the memberDefinition, as we need to keep track of which member we are marking as used.\r\n                 * In the case of nested classes, we only mark the first member we encounter as used. If you were to delete\r\n                 * the member, then any subsequent usage could incorrectly mark the member of an encapsulating parent class\r\n                 * as used, which is incorrect.\r\n                 */\r\n                memberDefinition.isUsed = true;\r\n            },\r\n\r\n            /*\r\n             * Post-process the class members and report any remaining members.\r\n             * Since private members can only be accessed in the current class context,\r\n             * we can safely assume that all usages are within the current class body.\r\n             */\r\n            \"ClassBody:exit\"() {\r\n                const unusedPrivateMembers = trackedClasses.shift();\r\n\r\n                for (const [classMemberName, { declaredNode, isUsed }] of unusedPrivateMembers.entries()) {\r\n                    if (isUsed) {\r\n                        continue;\r\n                    }\r\n                    context.report({\r\n                        node: declaredNode,\r\n                        loc: declaredNode.key.loc,\r\n                        messageId: \"unusedPrivateClassMember\",\r\n                        data: {\r\n                            classMemberName: `#${classMemberName}`\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}