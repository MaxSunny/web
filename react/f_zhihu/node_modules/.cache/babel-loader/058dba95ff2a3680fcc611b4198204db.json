{"ast":null,"code":"/**\r\n * @fileoverview Define utility functions for token store.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Gets `token.range[0]` from the given token.\r\n * @param {Node|Token|Comment} token The token to get.\r\n * @returns {number} The start location.\r\n * @private\r\n */\n\nfunction getStartLocation(token) {\n  return token.range[0];\n} //------------------------------------------------------------------------------\n// Exports\n//------------------------------------------------------------------------------\n\n/**\r\n * Finds the index of the first token which is after the given location.\r\n * If it was not found, this returns `tokens.length`.\r\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\r\n * @param {number} location The location to search.\r\n * @returns {number} The found index or `tokens.length`.\r\n */\n\n\nexports.search = function search(tokens, location) {\n  const index = tokens.findIndex(el => location <= getStartLocation(el));\n  return index === -1 ? tokens.length : index;\n};\n/**\r\n * Gets the index of the `startLoc` in `tokens`.\r\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\r\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\r\n * @param {Object} indexMap The map from locations to indices.\r\n * @param {number} startLoc The location to get an index.\r\n * @returns {number} The index.\r\n */\n\n\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\n  if (startLoc in indexMap) {\n    return indexMap[startLoc];\n  }\n\n  if (startLoc - 1 in indexMap) {\n    const index = indexMap[startLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n    /*\r\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\r\n     * In that case, +1 is unnecessary.\r\n     */\n\n    if (token && token.range[0] >= startLoc) {\n      return index;\n    }\n\n    return index + 1;\n  }\n\n  return 0;\n};\n/**\r\n * Gets the index of the `endLoc` in `tokens`.\r\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\r\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\r\n * @param {Object} indexMap The map from locations to indices.\r\n * @param {number} endLoc The location to get an index.\r\n * @returns {number} The index.\r\n */\n\n\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\n  if (endLoc in indexMap) {\n    return indexMap[endLoc] - 1;\n  }\n\n  if (endLoc - 1 in indexMap) {\n    const index = indexMap[endLoc - 1];\n    const token = index >= 0 && index < tokens.length ? tokens[index] : null;\n    /*\r\n     * For the map of \"comment's location -> token's index\", it points the next token of a comment.\r\n     * In that case, -1 is necessary.\r\n     */\n\n    if (token && token.range[1] > endLoc) {\n      return index - 1;\n    }\n\n    return index;\n  }\n\n  return tokens.length - 1;\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/source-code/token-store/utils.js"],"names":["getStartLocation","token","range","exports","search","tokens","location","index","findIndex","el","length","getFirstIndex","indexMap","startLoc","getLastIndex","endLoc"],"mappings":"AAAA;AACA;AACA;AACA;AACA,a,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,gBAAT,CAA0BC,KAA1B,EAAiC;AAC7B,SAAOA,KAAK,CAACC,KAAN,CAAY,CAAZ,CAAP;AACH,C,CAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,OAAO,CAACC,MAAR,GAAiB,SAASA,MAAT,CAAgBC,MAAhB,EAAwBC,QAAxB,EAAkC;AAC/C,QAAMC,KAAK,GAAGF,MAAM,CAACG,SAAP,CAAiBC,EAAE,IAAIH,QAAQ,IAAIN,gBAAgB,CAACS,EAAD,CAAnD,CAAd;AAEA,SAAOF,KAAK,KAAK,CAAC,CAAX,GAAeF,MAAM,CAACK,MAAtB,GAA+BH,KAAtC;AACH,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,OAAO,CAACQ,aAAR,GAAwB,SAASA,aAAT,CAAuBN,MAAvB,EAA+BO,QAA/B,EAAyCC,QAAzC,EAAmD;AACvE,MAAIA,QAAQ,IAAID,QAAhB,EAA0B;AACtB,WAAOA,QAAQ,CAACC,QAAD,CAAf;AACH;;AACD,MAAKA,QAAQ,GAAG,CAAZ,IAAkBD,QAAtB,EAAgC;AAC5B,UAAML,KAAK,GAAGK,QAAQ,CAACC,QAAQ,GAAG,CAAZ,CAAtB;AACA,UAAMZ,KAAK,GAAIM,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAGF,MAAM,CAACK,MAA9B,GAAwCL,MAAM,CAACE,KAAD,CAA9C,GAAwD,IAAtE;AAEA;AACR;AACA;AACA;;AACQ,QAAIN,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAY,CAAZ,KAAkBW,QAA/B,EAAyC;AACrC,aAAON,KAAP;AACH;;AACD,WAAOA,KAAK,GAAG,CAAf;AACH;;AACD,SAAO,CAAP;AACH,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,OAAO,CAACW,YAAR,GAAuB,SAASA,YAAT,CAAsBT,MAAtB,EAA8BO,QAA9B,EAAwCG,MAAxC,EAAgD;AACnE,MAAIA,MAAM,IAAIH,QAAd,EAAwB;AACpB,WAAOA,QAAQ,CAACG,MAAD,CAAR,GAAmB,CAA1B;AACH;;AACD,MAAKA,MAAM,GAAG,CAAV,IAAgBH,QAApB,EAA8B;AAC1B,UAAML,KAAK,GAAGK,QAAQ,CAACG,MAAM,GAAG,CAAV,CAAtB;AACA,UAAMd,KAAK,GAAIM,KAAK,IAAI,CAAT,IAAcA,KAAK,GAAGF,MAAM,CAACK,MAA9B,GAAwCL,MAAM,CAACE,KAAD,CAA9C,GAAwD,IAAtE;AAEA;AACR;AACA;AACA;;AACQ,QAAIN,KAAK,IAAIA,KAAK,CAACC,KAAN,CAAY,CAAZ,IAAiBa,MAA9B,EAAsC;AAClC,aAAOR,KAAK,GAAG,CAAf;AACH;;AACD,WAAOA,KAAP;AACH;;AACD,SAAOF,MAAM,CAACK,MAAP,GAAgB,CAAvB;AACH,CAlBD","sourcesContent":["/**\r\n * @fileoverview Define utility functions for token store.\r\n * @author Toru Nagashima\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Gets `token.range[0]` from the given token.\r\n * @param {Node|Token|Comment} token The token to get.\r\n * @returns {number} The start location.\r\n * @private\r\n */\r\nfunction getStartLocation(token) {\r\n    return token.range[0];\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Exports\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Finds the index of the first token which is after the given location.\r\n * If it was not found, this returns `tokens.length`.\r\n * @param {(Token|Comment)[]} tokens It searches the token in this list.\r\n * @param {number} location The location to search.\r\n * @returns {number} The found index or `tokens.length`.\r\n */\r\nexports.search = function search(tokens, location) {\r\n    const index = tokens.findIndex(el => location <= getStartLocation(el));\r\n\r\n    return index === -1 ? tokens.length : index;\r\n};\r\n\r\n/**\r\n * Gets the index of the `startLoc` in `tokens`.\r\n * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.\r\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\r\n * @param {Object} indexMap The map from locations to indices.\r\n * @param {number} startLoc The location to get an index.\r\n * @returns {number} The index.\r\n */\r\nexports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {\r\n    if (startLoc in indexMap) {\r\n        return indexMap[startLoc];\r\n    }\r\n    if ((startLoc - 1) in indexMap) {\r\n        const index = indexMap[startLoc - 1];\r\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\r\n\r\n        /*\r\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\r\n         * In that case, +1 is unnecessary.\r\n         */\r\n        if (token && token.range[0] >= startLoc) {\r\n            return index;\r\n        }\r\n        return index + 1;\r\n    }\r\n    return 0;\r\n};\r\n\r\n/**\r\n * Gets the index of the `endLoc` in `tokens`.\r\n * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.\r\n * @param {(Token|Comment)[]} tokens The tokens to find an index.\r\n * @param {Object} indexMap The map from locations to indices.\r\n * @param {number} endLoc The location to get an index.\r\n * @returns {number} The index.\r\n */\r\nexports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {\r\n    if (endLoc in indexMap) {\r\n        return indexMap[endLoc] - 1;\r\n    }\r\n    if ((endLoc - 1) in indexMap) {\r\n        const index = indexMap[endLoc - 1];\r\n        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;\r\n\r\n        /*\r\n         * For the map of \"comment's location -> token's index\", it points the next token of a comment.\r\n         * In that case, -1 is necessary.\r\n         */\r\n        if (token && token.range[1] > endLoc) {\r\n            return index - 1;\r\n        }\r\n        return index;\r\n    }\r\n    return tokens.length - 1;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}