{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require the use of `===` and `!==`\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/eqeqeq\"\n    },\n    schema: {\n      anyOf: [{\n        type: \"array\",\n        items: [{\n          enum: [\"always\"]\n        }, {\n          type: \"object\",\n          properties: {\n            null: {\n              enum: [\"always\", \"never\", \"ignore\"]\n            }\n          },\n          additionalProperties: false\n        }],\n        additionalItems: false\n      }, {\n        type: \"array\",\n        items: [{\n          enum: [\"smart\", \"allow-null\"]\n        }],\n        additionalItems: false\n      }]\n    },\n    fixable: \"code\",\n    messages: {\n      unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || \"always\";\n    const options = context.options[1] || {};\n    const sourceCode = context.getSourceCode();\n    const nullOption = config === \"always\" ? options.null || \"always\" : \"ignore\";\n    const enforceRuleForNull = nullOption === \"always\";\n    const enforceInverseRuleForNull = nullOption === \"never\";\n    /**\r\n     * Checks if an expression is a typeof expression\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} if the node is a typeof expression\r\n     */\n\n    function isTypeOf(node) {\n      return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n    }\n    /**\r\n     * Checks if either operand of a binary expression is a typeof operation\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} if one of the operands is typeof\r\n     * @private\r\n     */\n\n\n    function isTypeOfBinary(node) {\n      return isTypeOf(node.left) || isTypeOf(node.right);\n    }\n    /**\r\n     * Checks if operands are literals of the same type (via typeof)\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} if operands are of same type\r\n     * @private\r\n     */\n\n\n    function areLiteralsAndSameType(node) {\n      return node.left.type === \"Literal\" && node.right.type === \"Literal\" && typeof node.left.value === typeof node.right.value;\n    }\n    /**\r\n     * Checks if one of the operands is a literal null\r\n     * @param {ASTNode} node The node to check\r\n     * @returns {boolean} if operands are null\r\n     * @private\r\n     */\n\n\n    function isNullCheck(node) {\n      return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\n    }\n    /**\r\n     * Reports a message for this rule.\r\n     * @param {ASTNode} node The binary expression node that was checked\r\n     * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(node, expectedOperator) {\n      const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n      context.report({\n        node,\n        loc: operatorToken.loc,\n        messageId: \"unexpected\",\n        data: {\n          expectedOperator,\n          actualOperator: node.operator\n        },\n\n        fix(fixer) {\n          // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\n          if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\n            return fixer.replaceText(operatorToken, expectedOperator);\n          }\n\n          return null;\n        }\n\n      });\n    }\n\n    return {\n      BinaryExpression(node) {\n        const isNull = isNullCheck(node);\n\n        if (node.operator !== \"==\" && node.operator !== \"!=\") {\n          if (enforceInverseRuleForNull && isNull) {\n            report(node, node.operator.slice(0, -1));\n          }\n\n          return;\n        }\n\n        if (config === \"smart\" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {\n          return;\n        }\n\n        if (!enforceRuleForNull && isNull) {\n          return;\n        }\n\n        report(node, `${node.operator}=`);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/eqeqeq.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","anyOf","items","enum","properties","null","additionalProperties","additionalItems","fixable","messages","unexpected","create","context","config","options","sourceCode","getSourceCode","nullOption","enforceRuleForNull","enforceInverseRuleForNull","isTypeOf","node","operator","isTypeOfBinary","left","right","areLiteralsAndSameType","value","isNullCheck","isNullLiteral","report","expectedOperator","operatorToken","getFirstTokenBetween","token","loc","messageId","data","actualOperator","fix","fixer","replaceText","BinaryExpression","isNull","slice"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require the use of `===` and `!==`\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/eqeqeq\"\r\n        },\r\n\r\n        schema: {\r\n            anyOf: [\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"always\"]\r\n                        },\r\n                        {\r\n                            type: \"object\",\r\n                            properties: {\r\n                                null: {\r\n                                    enum: [\"always\", \"never\", \"ignore\"]\r\n                                }\r\n                            },\r\n                            additionalProperties: false\r\n                        }\r\n                    ],\r\n                    additionalItems: false\r\n                },\r\n                {\r\n                    type: \"array\",\r\n                    items: [\r\n                        {\r\n                            enum: [\"smart\", \"allow-null\"]\r\n                        }\r\n                    ],\r\n                    additionalItems: false\r\n                }\r\n            ]\r\n        },\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unexpected: \"Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const config = context.options[0] || \"always\";\r\n        const options = context.options[1] || {};\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const nullOption = (config === \"always\")\r\n            ? options.null || \"always\"\r\n            : \"ignore\";\r\n        const enforceRuleForNull = (nullOption === \"always\");\r\n        const enforceInverseRuleForNull = (nullOption === \"never\");\r\n\r\n        /**\r\n         * Checks if an expression is a typeof expression\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} if the node is a typeof expression\r\n         */\r\n        function isTypeOf(node) {\r\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\r\n        }\r\n\r\n        /**\r\n         * Checks if either operand of a binary expression is a typeof operation\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} if one of the operands is typeof\r\n         * @private\r\n         */\r\n        function isTypeOfBinary(node) {\r\n            return isTypeOf(node.left) || isTypeOf(node.right);\r\n        }\r\n\r\n        /**\r\n         * Checks if operands are literals of the same type (via typeof)\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} if operands are of same type\r\n         * @private\r\n         */\r\n        function areLiteralsAndSameType(node) {\r\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\r\n                    typeof node.left.value === typeof node.right.value;\r\n        }\r\n\r\n        /**\r\n         * Checks if one of the operands is a literal null\r\n         * @param {ASTNode} node The node to check\r\n         * @returns {boolean} if operands are null\r\n         * @private\r\n         */\r\n        function isNullCheck(node) {\r\n            return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);\r\n        }\r\n\r\n        /**\r\n         * Reports a message for this rule.\r\n         * @param {ASTNode} node The binary expression node that was checked\r\n         * @param {string} expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node, expectedOperator) {\r\n            const operatorToken = sourceCode.getFirstTokenBetween(\r\n                node.left,\r\n                node.right,\r\n                token => token.value === node.operator\r\n            );\r\n\r\n            context.report({\r\n                node,\r\n                loc: operatorToken.loc,\r\n                messageId: \"unexpected\",\r\n                data: { expectedOperator, actualOperator: node.operator },\r\n                fix(fixer) {\r\n\r\n                    // If the comparison is a `typeof` comparison or both sides are literals with the same type, then it's safe to fix.\r\n                    if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {\r\n                        return fixer.replaceText(operatorToken, expectedOperator);\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n\r\n        return {\r\n            BinaryExpression(node) {\r\n                const isNull = isNullCheck(node);\r\n\r\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\r\n                    if (enforceInverseRuleForNull && isNull) {\r\n                        report(node, node.operator.slice(0, -1));\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                if (config === \"smart\" && (isTypeOfBinary(node) ||\r\n                        areLiteralsAndSameType(node) || isNull)) {\r\n                    return;\r\n                }\r\n\r\n                if (!enforceRuleForNull && isNull) {\r\n                    return;\r\n                }\r\n\r\n                report(node, `${node.operator}=`);\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}