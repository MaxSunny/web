{"ast":null,"code":"/**\r\n * @fileoverview A rule to suggest using arrow functions as callbacks.\r\n * @author Toru Nagashima\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given variable is a function name.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is a function name.\r\n */\n\n\nfunction isFunctionName(variable) {\n  return variable && variable.defs[0].type === \"FunctionName\";\n}\n/**\r\n * Checks whether or not a given MetaProperty node equals to a given value.\r\n * @param {ASTNode} node A MetaProperty node to check.\r\n * @param {string} metaName The name of `MetaProperty.meta`.\r\n * @param {string} propertyName The name of `MetaProperty.property`.\r\n * @returns {boolean} `true` if the node is the specific value.\r\n */\n\n\nfunction checkMetaProperty(node, metaName, propertyName) {\n  return node.meta.name === metaName && node.property.name === propertyName;\n}\n/**\r\n * Gets the variable object of `arguments` which is defined implicitly.\r\n * @param {eslint-scope.Scope} scope A scope to get.\r\n * @returns {eslint-scope.Variable} The found variable object.\r\n */\n\n\nfunction getVariableOfArguments(scope) {\n  const variables = scope.variables;\n\n  for (let i = 0; i < variables.length; ++i) {\n    const variable = variables[i];\n\n    if (variable.name === \"arguments\") {\n      /*\r\n       * If there was a parameter which is named \"arguments\", the\r\n       * implicit \"arguments\" is not defined.\r\n       * So does fast return with null.\r\n       */\n      return variable.identifiers.length === 0 ? variable : null;\n    }\n  }\n  /* istanbul ignore next */\n\n\n  return null;\n}\n/**\r\n * Checks whether or not a given node is a callback.\r\n * @param {ASTNode} node A node to check.\r\n * @throws {Error} (Unreachable.)\r\n * @returns {Object}\r\n *   {boolean} retv.isCallback - `true` if the node is a callback.\r\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\r\n */\n\n\nfunction getCallbackInfo(node) {\n  const retv = {\n    isCallback: false,\n    isLexicalThis: false\n  };\n  let currentNode = node;\n  let parent = node.parent;\n  let bound = false;\n\n  while (currentNode) {\n    switch (parent.type) {\n      // Checks parents recursively.\n      case \"LogicalExpression\":\n      case \"ChainExpression\":\n      case \"ConditionalExpression\":\n        break;\n      // Checks whether the parent node is `.bind(this)` call.\n\n      case \"MemberExpression\":\n        if (parent.object === currentNode && !parent.property.computed && parent.property.type === \"Identifier\" && parent.property.name === \"bind\") {\n          const maybeCallee = parent.parent.type === \"ChainExpression\" ? parent.parent : parent;\n\n          if (astUtils.isCallee(maybeCallee)) {\n            if (!bound) {\n              bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\n\n              retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === \"ThisExpression\";\n            }\n\n            parent = maybeCallee.parent;\n          } else {\n            return retv;\n          }\n        } else {\n          return retv;\n        }\n\n        break;\n      // Checks whether the node is a callback.\n\n      case \"CallExpression\":\n      case \"NewExpression\":\n        if (parent.callee !== currentNode) {\n          retv.isCallback = true;\n        }\n\n        return retv;\n\n      default:\n        return retv;\n    }\n\n    currentNode = parent;\n    parent = parent.parent;\n  }\n  /* istanbul ignore next */\n\n\n  throw new Error(\"unreachable\");\n}\n/**\r\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\r\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\r\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\r\n * @param {ASTNode[]} paramsList The list of parameters for a function\r\n * @returns {boolean} `true` if the list of parameters contains any duplicates\r\n */\n\n\nfunction hasDuplicateParams(paramsList) {\n  return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"require using arrow functions for callbacks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        allowNamedFunctions: {\n          type: \"boolean\",\n          default: false\n        },\n        allowUnboundThis: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      preferArrowCallback: \"Unexpected function expression.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const allowUnboundThis = options.allowUnboundThis !== false; // default to true\n\n    const allowNamedFunctions = options.allowNamedFunctions;\n    const sourceCode = context.getSourceCode();\n    /*\r\n     * {Array<{this: boolean, super: boolean, meta: boolean}>}\r\n     * - this - A flag which shows there are one or more ThisExpression.\r\n     * - super - A flag which shows there are one or more Super.\r\n     * - meta - A flag which shows there are one or more MethProperty.\r\n     */\n\n    let stack = [];\n    /**\r\n     * Pushes new function scope with all `false` flags.\r\n     * @returns {void}\r\n     */\n\n    function enterScope() {\n      stack.push({\n        this: false,\n        super: false,\n        meta: false\n      });\n    }\n    /**\r\n     * Pops a function scope from the stack.\r\n     * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\r\n     */\n\n\n    function exitScope() {\n      return stack.pop();\n    }\n\n    return {\n      // Reset internal state.\n      Program() {\n        stack = [];\n      },\n\n      // If there are below, it cannot replace with arrow functions merely.\n      ThisExpression() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.this = true;\n        }\n      },\n\n      Super() {\n        const info = stack[stack.length - 1];\n\n        if (info) {\n          info.super = true;\n        }\n      },\n\n      MetaProperty(node) {\n        const info = stack[stack.length - 1];\n\n        if (info && checkMetaProperty(node, \"new\", \"target\")) {\n          info.meta = true;\n        }\n      },\n\n      // To skip nested scopes.\n      FunctionDeclaration: enterScope,\n      \"FunctionDeclaration:exit\": exitScope,\n      // Main.\n      FunctionExpression: enterScope,\n\n      \"FunctionExpression:exit\"(node) {\n        const scopeInfo = exitScope(); // Skip named function expressions\n\n        if (allowNamedFunctions && node.id && node.id.name) {\n          return;\n        } // Skip generators.\n\n\n        if (node.generator) {\n          return;\n        } // Skip recursive functions.\n\n\n        const nameVar = context.getDeclaredVariables(node)[0];\n\n        if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n          return;\n        } // Skip if it's using arguments.\n\n\n        const variable = getVariableOfArguments(context.getScope());\n\n        if (variable && variable.references.length > 0) {\n          return;\n        } // Reports if it's a callback which can replace with arrows.\n\n\n        const callbackInfo = getCallbackInfo(node);\n\n        if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {\n          context.report({\n            node,\n            messageId: \"preferArrowCallback\",\n\n            *fix(fixer) {\n              if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {\n                /*\r\n                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\r\n                 * is no way to determine what `this` should be, so don't perform any fixes.\r\n                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\r\n                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\r\n                 */\n                return;\n              } // Remove `.bind(this)` if exists.\n\n\n              if (callbackInfo.isLexicalThis) {\n                const memberNode = node.parent;\n                /*\r\n                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\r\n                 * E.g. `(foo || function(){}).bind(this)`\r\n                 */\n\n                if (memberNode.type !== \"MemberExpression\") {\n                  return;\n                }\n\n                const callNode = memberNode.parent;\n                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\n                const lastTokenToRemove = sourceCode.getLastToken(callNode);\n                /*\r\n                 * If the member expression is parenthesized, don't remove the right paren.\r\n                 * E.g. `(function(){}.bind)(this)`\r\n                 *                    ^^^^^^^^^^^^\r\n                 */\n\n                if (astUtils.isParenthesised(sourceCode, memberNode)) {\n                  return;\n                } // If comments exist in the `.bind(this)`, don't remove those.\n\n\n                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\n                  return;\n                }\n\n                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\n              } // Convert the function expression to an arrow function.\n\n\n              const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\n              const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\n\n              if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\n                // Remove only extra tokens to keep comments.\n                yield fixer.remove(functionToken);\n\n                if (node.id) {\n                  yield fixer.remove(node.id);\n                }\n              } else {\n                // Remove extra tokens and spaces.\n                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\n              }\n\n              yield fixer.insertTextBefore(node.body, \"=> \"); // Get the node that will become the new arrow function.\n\n              let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\n\n              if (replacedNode.type === \"ChainExpression\") {\n                replacedNode = replacedNode.parent;\n              }\n              /*\r\n               * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\r\n               * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\r\n               * though `foo || function() {}` is valid.\r\n               */\n\n\n              if (replacedNode.parent.type !== \"CallExpression\" && replacedNode.parent.type !== \"ConditionalExpression\" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {\n                yield fixer.insertTextBefore(replacedNode, \"(\");\n                yield fixer.insertTextAfter(replacedNode, \")\");\n              }\n            }\n\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/prefer-arrow-callback.js"],"names":["astUtils","require","isFunctionName","variable","defs","type","checkMetaProperty","node","metaName","propertyName","meta","name","property","getVariableOfArguments","scope","variables","i","length","identifiers","getCallbackInfo","retv","isCallback","isLexicalThis","currentNode","parent","bound","object","computed","maybeCallee","isCallee","arguments","callee","Error","hasDuplicateParams","paramsList","every","param","Set","map","size","module","exports","docs","description","recommended","url","schema","properties","allowNamedFunctions","default","allowUnboundThis","additionalProperties","fixable","messages","preferArrowCallback","create","context","options","sourceCode","getSourceCode","stack","enterScope","push","this","super","exitScope","pop","Program","ThisExpression","info","Super","MetaProperty","FunctionDeclaration","FunctionExpression","scopeInfo","id","generator","nameVar","getDeclaredVariables","references","getScope","callbackInfo","report","messageId","fix","fixer","params","memberNode","callNode","firstTokenToRemove","getTokenAfter","isNotClosingParenToken","lastTokenToRemove","getLastToken","isParenthesised","commentsExistBetween","removeRange","range","functionToken","getFirstToken","async","leftParenToken","isOpeningParenToken","remove","insertTextBefore","body","replacedNode","insertTextAfter"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview A rule to suggest using arrow functions as callbacks.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given variable is a function name.\r\n * @param {eslint-scope.Variable} variable A variable to check.\r\n * @returns {boolean} `true` if the variable is a function name.\r\n */\r\nfunction isFunctionName(variable) {\r\n    return variable && variable.defs[0].type === \"FunctionName\";\r\n}\r\n\r\n/**\r\n * Checks whether or not a given MetaProperty node equals to a given value.\r\n * @param {ASTNode} node A MetaProperty node to check.\r\n * @param {string} metaName The name of `MetaProperty.meta`.\r\n * @param {string} propertyName The name of `MetaProperty.property`.\r\n * @returns {boolean} `true` if the node is the specific value.\r\n */\r\nfunction checkMetaProperty(node, metaName, propertyName) {\r\n    return node.meta.name === metaName && node.property.name === propertyName;\r\n}\r\n\r\n/**\r\n * Gets the variable object of `arguments` which is defined implicitly.\r\n * @param {eslint-scope.Scope} scope A scope to get.\r\n * @returns {eslint-scope.Variable} The found variable object.\r\n */\r\nfunction getVariableOfArguments(scope) {\r\n    const variables = scope.variables;\r\n\r\n    for (let i = 0; i < variables.length; ++i) {\r\n        const variable = variables[i];\r\n\r\n        if (variable.name === \"arguments\") {\r\n\r\n            /*\r\n             * If there was a parameter which is named \"arguments\", the\r\n             * implicit \"arguments\" is not defined.\r\n             * So does fast return with null.\r\n             */\r\n            return (variable.identifiers.length === 0) ? variable : null;\r\n        }\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    return null;\r\n}\r\n\r\n/**\r\n * Checks whether or not a given node is a callback.\r\n * @param {ASTNode} node A node to check.\r\n * @throws {Error} (Unreachable.)\r\n * @returns {Object}\r\n *   {boolean} retv.isCallback - `true` if the node is a callback.\r\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\r\n */\r\nfunction getCallbackInfo(node) {\r\n    const retv = { isCallback: false, isLexicalThis: false };\r\n    let currentNode = node;\r\n    let parent = node.parent;\r\n    let bound = false;\r\n\r\n    while (currentNode) {\r\n        switch (parent.type) {\r\n\r\n            // Checks parents recursively.\r\n\r\n            case \"LogicalExpression\":\r\n            case \"ChainExpression\":\r\n            case \"ConditionalExpression\":\r\n                break;\r\n\r\n            // Checks whether the parent node is `.bind(this)` call.\r\n            case \"MemberExpression\":\r\n                if (\r\n                    parent.object === currentNode &&\r\n                    !parent.property.computed &&\r\n                    parent.property.type === \"Identifier\" &&\r\n                    parent.property.name === \"bind\"\r\n                ) {\r\n                    const maybeCallee = parent.parent.type === \"ChainExpression\"\r\n                        ? parent.parent\r\n                        : parent;\r\n\r\n                    if (astUtils.isCallee(maybeCallee)) {\r\n                        if (!bound) {\r\n                            bound = true; // Use only the first `.bind()` to make `isLexicalThis` value.\r\n                            retv.isLexicalThis = (\r\n                                maybeCallee.parent.arguments.length === 1 &&\r\n                                maybeCallee.parent.arguments[0].type === \"ThisExpression\"\r\n                            );\r\n                        }\r\n                        parent = maybeCallee.parent;\r\n                    } else {\r\n                        return retv;\r\n                    }\r\n                } else {\r\n                    return retv;\r\n                }\r\n                break;\r\n\r\n            // Checks whether the node is a callback.\r\n            case \"CallExpression\":\r\n            case \"NewExpression\":\r\n                if (parent.callee !== currentNode) {\r\n                    retv.isCallback = true;\r\n                }\r\n                return retv;\r\n\r\n            default:\r\n                return retv;\r\n        }\r\n\r\n        currentNode = parent;\r\n        parent = parent.parent;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    throw new Error(\"unreachable\");\r\n}\r\n\r\n/**\r\n * Checks whether a simple list of parameters contains any duplicates. This does not handle complex\r\n * parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate\r\n * parameter names anyway. Instead, it always returns `false` for complex parameter lists.\r\n * @param {ASTNode[]} paramsList The list of parameters for a function\r\n * @returns {boolean} `true` if the list of parameters contains any duplicates\r\n */\r\nfunction hasDuplicateParams(paramsList) {\r\n    return paramsList.every(param => param.type === \"Identifier\") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"require using arrow functions for callbacks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/prefer-arrow-callback\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowNamedFunctions: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    allowUnboundThis: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            preferArrowCallback: \"Unexpected function expression.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n\r\n        const allowUnboundThis = options.allowUnboundThis !== false; // default to true\r\n        const allowNamedFunctions = options.allowNamedFunctions;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /*\r\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\r\n         * - this - A flag which shows there are one or more ThisExpression.\r\n         * - super - A flag which shows there are one or more Super.\r\n         * - meta - A flag which shows there are one or more MethProperty.\r\n         */\r\n        let stack = [];\r\n\r\n        /**\r\n         * Pushes new function scope with all `false` flags.\r\n         * @returns {void}\r\n         */\r\n        function enterScope() {\r\n            stack.push({ this: false, super: false, meta: false });\r\n        }\r\n\r\n        /**\r\n         * Pops a function scope from the stack.\r\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\r\n         */\r\n        function exitScope() {\r\n            return stack.pop();\r\n        }\r\n\r\n        return {\r\n\r\n            // Reset internal state.\r\n            Program() {\r\n                stack = [];\r\n            },\r\n\r\n            // If there are below, it cannot replace with arrow functions merely.\r\n            ThisExpression() {\r\n                const info = stack[stack.length - 1];\r\n\r\n                if (info) {\r\n                    info.this = true;\r\n                }\r\n            },\r\n\r\n            Super() {\r\n                const info = stack[stack.length - 1];\r\n\r\n                if (info) {\r\n                    info.super = true;\r\n                }\r\n            },\r\n\r\n            MetaProperty(node) {\r\n                const info = stack[stack.length - 1];\r\n\r\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\r\n                    info.meta = true;\r\n                }\r\n            },\r\n\r\n            // To skip nested scopes.\r\n            FunctionDeclaration: enterScope,\r\n            \"FunctionDeclaration:exit\": exitScope,\r\n\r\n            // Main.\r\n            FunctionExpression: enterScope,\r\n            \"FunctionExpression:exit\"(node) {\r\n                const scopeInfo = exitScope();\r\n\r\n                // Skip named function expressions\r\n                if (allowNamedFunctions && node.id && node.id.name) {\r\n                    return;\r\n                }\r\n\r\n                // Skip generators.\r\n                if (node.generator) {\r\n                    return;\r\n                }\r\n\r\n                // Skip recursive functions.\r\n                const nameVar = context.getDeclaredVariables(node)[0];\r\n\r\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\r\n                    return;\r\n                }\r\n\r\n                // Skip if it's using arguments.\r\n                const variable = getVariableOfArguments(context.getScope());\r\n\r\n                if (variable && variable.references.length > 0) {\r\n                    return;\r\n                }\r\n\r\n                // Reports if it's a callback which can replace with arrows.\r\n                const callbackInfo = getCallbackInfo(node);\r\n\r\n                if (callbackInfo.isCallback &&\r\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\r\n                    !scopeInfo.super &&\r\n                    !scopeInfo.meta\r\n                ) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"preferArrowCallback\",\r\n                        *fix(fixer) {\r\n                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {\r\n\r\n                                /*\r\n                                 * If the callback function does not have .bind(this) and contains a reference to `this`, there\r\n                                 * is no way to determine what `this` should be, so don't perform any fixes.\r\n                                 * If the callback function has duplicates in its list of parameters (possible in sloppy mode),\r\n                                 * don't replace it with an arrow function, because this is a SyntaxError with arrow functions.\r\n                                 */\r\n                                return;\r\n                            }\r\n\r\n                            // Remove `.bind(this)` if exists.\r\n                            if (callbackInfo.isLexicalThis) {\r\n                                const memberNode = node.parent;\r\n\r\n                                /*\r\n                                 * If `.bind(this)` exists but the parent is not `.bind(this)`, don't remove it automatically.\r\n                                 * E.g. `(foo || function(){}).bind(this)`\r\n                                 */\r\n                                if (memberNode.type !== \"MemberExpression\") {\r\n                                    return;\r\n                                }\r\n\r\n                                const callNode = memberNode.parent;\r\n                                const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);\r\n                                const lastTokenToRemove = sourceCode.getLastToken(callNode);\r\n\r\n                                /*\r\n                                 * If the member expression is parenthesized, don't remove the right paren.\r\n                                 * E.g. `(function(){}.bind)(this)`\r\n                                 *                    ^^^^^^^^^^^^\r\n                                 */\r\n                                if (astUtils.isParenthesised(sourceCode, memberNode)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // If comments exist in the `.bind(this)`, don't remove those.\r\n                                if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {\r\n                                    return;\r\n                                }\r\n\r\n                                yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);\r\n                            }\r\n\r\n                            // Convert the function expression to an arrow function.\r\n                            const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);\r\n                            const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);\r\n\r\n                            if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {\r\n\r\n                                // Remove only extra tokens to keep comments.\r\n                                yield fixer.remove(functionToken);\r\n                                if (node.id) {\r\n                                    yield fixer.remove(node.id);\r\n                                }\r\n                            } else {\r\n\r\n                                // Remove extra tokens and spaces.\r\n                                yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);\r\n                            }\r\n                            yield fixer.insertTextBefore(node.body, \"=> \");\r\n\r\n                            // Get the node that will become the new arrow function.\r\n                            let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;\r\n\r\n                            if (replacedNode.type === \"ChainExpression\") {\r\n                                replacedNode = replacedNode.parent;\r\n                            }\r\n\r\n                            /*\r\n                             * If the replaced node is part of a BinaryExpression, LogicalExpression, or MemberExpression, then\r\n                             * the arrow function needs to be parenthesized, because `foo || () => {}` is invalid syntax even\r\n                             * though `foo || function() {}` is valid.\r\n                             */\r\n                            if (\r\n                                replacedNode.parent.type !== \"CallExpression\" &&\r\n                                replacedNode.parent.type !== \"ConditionalExpression\" &&\r\n                                !astUtils.isParenthesised(sourceCode, replacedNode) &&\r\n                                !astUtils.isParenthesised(sourceCode, node)\r\n                            ) {\r\n                                yield fixer.insertTextBefore(replacedNode, \"(\");\r\n                                yield fixer.insertTextAfter(replacedNode, \")\");\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}