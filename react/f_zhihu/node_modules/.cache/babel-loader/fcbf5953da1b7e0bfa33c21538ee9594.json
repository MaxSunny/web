{"ast":null,"code":"/**\r\n * @fileoverview Shared functions to work with configs.\r\n * @author Nicholas C. Zakas\r\n */\n\"use strict\"; //-----------------------------------------------------------------------------\n// Functions\n//-----------------------------------------------------------------------------\n\n/**\r\n * Parses a ruleId into its plugin and rule parts.\r\n * @param {string} ruleId The rule ID to parse.\r\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\r\n *      parts of the ruleId;\r\n */\n\nfunction parseRuleId(ruleId) {\n  let pluginName, ruleName; // distinguish between core rules and plugin rules\n\n  if (ruleId.includes(\"/\")) {\n    pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\n    ruleName = ruleId.slice(pluginName.length + 1);\n  } else {\n    pluginName = \"@\";\n    ruleName = ruleId;\n  }\n\n  return {\n    pluginName,\n    ruleName\n  };\n}\n/**\r\n * Retrieves a rule instance from a given config based on the ruleId.\r\n * @param {string} ruleId The rule ID to look for.\r\n * @param {FlatConfig} config The config to search.\r\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\r\n *      or undefined if not.\r\n */\n\n\nfunction getRuleFromConfig(ruleId, config) {\n  const {\n    pluginName,\n    ruleName\n  } = parseRuleId(ruleId);\n  const plugin = config.plugins && config.plugins[pluginName];\n  let rule = plugin && plugin.rules && plugin.rules[ruleName]; // normalize function rules into objects\n\n  if (rule && typeof rule === \"function\") {\n    rule = {\n      create: rule\n    };\n  }\n\n  return rule;\n}\n/**\r\n * Gets a complete options schema for a rule.\r\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\r\n * @returns {Object} JSON Schema for the rule's options.\r\n */\n\n\nfunction getRuleOptionsSchema(rule) {\n  if (!rule) {\n    return null;\n  }\n\n  const schema = rule.schema || rule.meta && rule.meta.schema;\n\n  if (Array.isArray(schema)) {\n    if (schema.length) {\n      return {\n        type: \"array\",\n        items: schema,\n        minItems: 0,\n        maxItems: schema.length\n      };\n    }\n\n    return {\n      type: \"array\",\n      minItems: 0,\n      maxItems: 0\n    };\n  } // Given a full schema, leave it alone\n\n\n  return schema || null;\n} //-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n\nmodule.exports = {\n  parseRuleId,\n  getRuleFromConfig,\n  getRuleOptionsSchema\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/config/flat-config-helpers.js"],"names":["parseRuleId","ruleId","pluginName","ruleName","includes","slice","lastIndexOf","length","getRuleFromConfig","config","plugin","plugins","rule","rules","create","getRuleOptionsSchema","schema","meta","Array","isArray","type","items","minItems","maxItems","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,WAAT,CAAqBC,MAArB,EAA6B;AACzB,MAAIC,UAAJ,EAAgBC,QAAhB,CADyB,CAGzB;;AACA,MAAIF,MAAM,CAACG,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;AACtBF,IAAAA,UAAU,GAAGD,MAAM,CAACI,KAAP,CAAa,CAAb,EAAgBJ,MAAM,CAACK,WAAP,CAAmB,GAAnB,CAAhB,CAAb;AACAH,IAAAA,QAAQ,GAAGF,MAAM,CAACI,KAAP,CAAaH,UAAU,CAACK,MAAX,GAAoB,CAAjC,CAAX;AACH,GAHD,MAGO;AACHL,IAAAA,UAAU,GAAG,GAAb;AACAC,IAAAA,QAAQ,GAAGF,MAAX;AACH;;AAED,SAAO;AACHC,IAAAA,UADG;AAEHC,IAAAA;AAFG,GAAP;AAIH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASK,iBAAT,CAA2BP,MAA3B,EAAmCQ,MAAnC,EAA2C;AAEvC,QAAM;AAAEP,IAAAA,UAAF;AAAcC,IAAAA;AAAd,MAA2BH,WAAW,CAACC,MAAD,CAA5C;AAEA,QAAMS,MAAM,GAAGD,MAAM,CAACE,OAAP,IAAkBF,MAAM,CAACE,OAAP,CAAeT,UAAf,CAAjC;AACA,MAAIU,IAAI,GAAGF,MAAM,IAAIA,MAAM,CAACG,KAAjB,IAA0BH,MAAM,CAACG,KAAP,CAAaV,QAAb,CAArC,CALuC,CAOvC;;AACA,MAAIS,IAAI,IAAI,OAAOA,IAAP,KAAgB,UAA5B,EAAwC;AACpCA,IAAAA,IAAI,GAAG;AACHE,MAAAA,MAAM,EAAEF;AADL,KAAP;AAGH;;AAED,SAAOA,IAAP;AACH;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASG,oBAAT,CAA8BH,IAA9B,EAAoC;AAEhC,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,IAAP;AACH;;AAED,QAAMI,MAAM,GAAGJ,IAAI,CAACI,MAAL,IAAeJ,IAAI,CAACK,IAAL,IAAaL,IAAI,CAACK,IAAL,CAAUD,MAArD;;AAEA,MAAIE,KAAK,CAACC,OAAN,CAAcH,MAAd,CAAJ,EAA2B;AACvB,QAAIA,MAAM,CAACT,MAAX,EAAmB;AACf,aAAO;AACHa,QAAAA,IAAI,EAAE,OADH;AAEHC,QAAAA,KAAK,EAAEL,MAFJ;AAGHM,QAAAA,QAAQ,EAAE,CAHP;AAIHC,QAAAA,QAAQ,EAAEP,MAAM,CAACT;AAJd,OAAP;AAMH;;AACD,WAAO;AACHa,MAAAA,IAAI,EAAE,OADH;AAEHE,MAAAA,QAAQ,EAAE,CAFP;AAGHC,MAAAA,QAAQ,EAAE;AAHP,KAAP;AAMH,GAvB+B,CAyBhC;;;AACA,SAAOP,MAAM,IAAI,IAAjB;AACH,C,CAGD;AACA;AACA;;;AAEAQ,MAAM,CAACC,OAAP,GAAiB;AACbzB,EAAAA,WADa;AAEbQ,EAAAA,iBAFa;AAGbO,EAAAA;AAHa,CAAjB","sourcesContent":["/**\r\n * @fileoverview Shared functions to work with configs.\r\n * @author Nicholas C. Zakas\r\n */\r\n\r\n\"use strict\";\r\n\r\n//-----------------------------------------------------------------------------\r\n// Functions\r\n//-----------------------------------------------------------------------------\r\n\r\n/**\r\n * Parses a ruleId into its plugin and rule parts.\r\n * @param {string} ruleId The rule ID to parse.\r\n * @returns {{pluginName:string,ruleName:string}} The plugin and rule\r\n *      parts of the ruleId;\r\n */\r\nfunction parseRuleId(ruleId) {\r\n    let pluginName, ruleName;\r\n\r\n    // distinguish between core rules and plugin rules\r\n    if (ruleId.includes(\"/\")) {\r\n        pluginName = ruleId.slice(0, ruleId.lastIndexOf(\"/\"));\r\n        ruleName = ruleId.slice(pluginName.length + 1);\r\n    } else {\r\n        pluginName = \"@\";\r\n        ruleName = ruleId;\r\n    }\r\n\r\n    return {\r\n        pluginName,\r\n        ruleName\r\n    };\r\n}\r\n\r\n/**\r\n * Retrieves a rule instance from a given config based on the ruleId.\r\n * @param {string} ruleId The rule ID to look for.\r\n * @param {FlatConfig} config The config to search.\r\n * @returns {import(\"../shared/types\").Rule|undefined} The rule if found\r\n *      or undefined if not.\r\n */\r\nfunction getRuleFromConfig(ruleId, config) {\r\n\r\n    const { pluginName, ruleName } = parseRuleId(ruleId);\r\n\r\n    const plugin = config.plugins && config.plugins[pluginName];\r\n    let rule = plugin && plugin.rules && plugin.rules[ruleName];\r\n\r\n    // normalize function rules into objects\r\n    if (rule && typeof rule === \"function\") {\r\n        rule = {\r\n            create: rule\r\n        };\r\n    }\r\n\r\n    return rule;\r\n}\r\n\r\n/**\r\n * Gets a complete options schema for a rule.\r\n * @param {{create: Function, schema: (Array|null)}} rule A new-style rule object\r\n * @returns {Object} JSON Schema for the rule's options.\r\n */\r\nfunction getRuleOptionsSchema(rule) {\r\n\r\n    if (!rule) {\r\n        return null;\r\n    }\r\n\r\n    const schema = rule.schema || rule.meta && rule.meta.schema;\r\n\r\n    if (Array.isArray(schema)) {\r\n        if (schema.length) {\r\n            return {\r\n                type: \"array\",\r\n                items: schema,\r\n                minItems: 0,\r\n                maxItems: schema.length\r\n            };\r\n        }\r\n        return {\r\n            type: \"array\",\r\n            minItems: 0,\r\n            maxItems: 0\r\n        };\r\n\r\n    }\r\n\r\n    // Given a full schema, leave it alone\r\n    return schema || null;\r\n}\r\n\r\n\r\n//-----------------------------------------------------------------------------\r\n// Exports\r\n//-----------------------------------------------------------------------------\r\n\r\nmodule.exports = {\r\n    parseRuleId,\r\n    getRuleFromConfig,\r\n    getRuleOptionsSchema\r\n};\r\n"]},"metadata":{},"sourceType":"script"}