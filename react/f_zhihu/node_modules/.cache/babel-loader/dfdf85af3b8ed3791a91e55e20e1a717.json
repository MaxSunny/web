{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag block statements that do not use the one true brace style\r\n * @author Ian Christian Myers\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent brace style for blocks\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/brace-style\"\n    },\n    schema: [{\n      enum: [\"1tbs\", \"stroustrup\", \"allman\"]\n    }, {\n      type: \"object\",\n      properties: {\n        allowSingleLine: {\n          type: \"boolean\",\n          default: false\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\n      sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\n      blockSameLine: \"Statement inside of curly braces should be on next line.\",\n      nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\n      singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\n      sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\n    }\n  },\n\n  create(context) {\n    const style = context.options[0] || \"1tbs\",\n          params = context.options[1] || {},\n          sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Fixes a place where a newline unexpectedly appears\r\n     * @param {Token} firstToken The token before the unexpected newline\r\n     * @param {Token} secondToken The token after the unexpected newline\r\n     * @returns {Function} A fixer function to remove the newlines between the tokens\r\n     */\n\n    function removeNewlineBetween(firstToken, secondToken) {\n      const textRange = [firstToken.range[1], secondToken.range[0]];\n      const textBetween = sourceCode.text.slice(textRange[0], textRange[1]); // Don't do a fix if there is a comment between the tokens\n\n      if (textBetween.trim()) {\n        return null;\n      }\n\n      return fixer => fixer.replaceTextRange(textRange, \" \");\n    }\n    /**\r\n     * Validates a pair of curly brackets based on the user's config\r\n     * @param {Token} openingCurly The opening curly bracket\r\n     * @param {Token} closingCurly The closing curly bracket\r\n     * @returns {void}\r\n     */\n\n\n    function validateCurlyPair(openingCurly, closingCurly) {\n      const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\n      const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\n      const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\n      const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\n\n      if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\n        context.report({\n          node: openingCurly,\n          messageId: \"nextLineOpen\",\n          fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\n        });\n      }\n\n      if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"sameLineOpen\",\n          fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\n        });\n      }\n\n      if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\n        context.report({\n          node: openingCurly,\n          messageId: \"blockSameLine\",\n          fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\n        });\n      }\n\n      if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\n        context.report({\n          node: closingCurly,\n          messageId: \"singleLineClose\",\n          fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\n        });\n      }\n    }\n    /**\r\n     * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\r\n     * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\r\n     * @returns {void}\r\n     */\n\n\n    function validateCurlyBeforeKeyword(curlyToken) {\n      const keywordToken = sourceCode.getTokenAfter(curlyToken);\n\n      if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"nextLineClose\",\n          fix: removeNewlineBetween(curlyToken, keywordToken)\n        });\n      }\n\n      if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\n        context.report({\n          node: curlyToken,\n          messageId: \"sameLineClose\",\n          fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\n        });\n      }\n    } //--------------------------------------------------------------------------\n    // Public API\n    //--------------------------------------------------------------------------\n\n\n    return {\n      BlockStatement(node) {\n        if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\n          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n        }\n      },\n\n      StaticBlock(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node, {\n          skip: 1\n        }), // skip the `static` token\n        sourceCode.getLastToken(node));\n      },\n\n      ClassBody(node) {\n        validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\n      },\n\n      SwitchStatement(node) {\n        const closingCurly = sourceCode.getLastToken(node);\n        const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\n        validateCurlyPair(openingCurly, closingCurly);\n      },\n\n      IfStatement(node) {\n        if (node.consequent.type === \"BlockStatement\" && node.alternate) {\n          // Handle the keyword after the `if` block (before `else`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\n        }\n      },\n\n      TryStatement(node) {\n        // Handle the keyword after the `try` block (before `catch` or `finally`)\n        validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\n\n        if (node.handler && node.finalizer) {\n          // Handle the keyword after the `catch` block (before `finally`)\n          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/brace-style.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","schema","enum","properties","allowSingleLine","default","additionalProperties","fixable","messages","nextLineOpen","sameLineOpen","blockSameLine","nextLineClose","singleLineClose","sameLineClose","create","context","style","options","params","sourceCode","getSourceCode","removeNewlineBetween","firstToken","secondToken","textRange","range","textBetween","text","slice","trim","fixer","replaceTextRange","validateCurlyPair","openingCurly","closingCurly","tokenBeforeOpeningCurly","getTokenBefore","tokenAfterOpeningCurly","getTokenAfter","tokenBeforeClosingCurly","singleLineException","isTokenOnSameLine","report","node","messageId","fix","insertTextBefore","insertTextAfter","validateCurlyBeforeKeyword","curlyToken","keywordToken","BlockStatement","STATEMENT_LIST_PARENTS","has","parent","getFirstToken","getLastToken","StaticBlock","skip","ClassBody","SwitchStatement","cases","length","IfStatement","consequent","alternate","TryStatement","block","handler","finalizer","body"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag block statements that do not use the one true brace style\r\n * @author Ian Christian Myers\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent brace style for blocks\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/brace-style\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                enum: [\"1tbs\", \"stroustrup\", \"allman\"]\r\n            },\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    allowSingleLine: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        messages: {\r\n            nextLineOpen: \"Opening curly brace does not appear on the same line as controlling statement.\",\r\n            sameLineOpen: \"Opening curly brace appears on the same line as controlling statement.\",\r\n            blockSameLine: \"Statement inside of curly braces should be on next line.\",\r\n            nextLineClose: \"Closing curly brace does not appear on the same line as the subsequent block.\",\r\n            singleLineClose: \"Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.\",\r\n            sameLineClose: \"Closing curly brace appears on the same line as the subsequent block.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const style = context.options[0] || \"1tbs\",\r\n            params = context.options[1] || {},\r\n            sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Fixes a place where a newline unexpectedly appears\r\n         * @param {Token} firstToken The token before the unexpected newline\r\n         * @param {Token} secondToken The token after the unexpected newline\r\n         * @returns {Function} A fixer function to remove the newlines between the tokens\r\n         */\r\n        function removeNewlineBetween(firstToken, secondToken) {\r\n            const textRange = [firstToken.range[1], secondToken.range[0]];\r\n            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);\r\n\r\n            // Don't do a fix if there is a comment between the tokens\r\n            if (textBetween.trim()) {\r\n                return null;\r\n            }\r\n            return fixer => fixer.replaceTextRange(textRange, \" \");\r\n        }\r\n\r\n        /**\r\n         * Validates a pair of curly brackets based on the user's config\r\n         * @param {Token} openingCurly The opening curly bracket\r\n         * @param {Token} closingCurly The closing curly bracket\r\n         * @returns {void}\r\n         */\r\n        function validateCurlyPair(openingCurly, closingCurly) {\r\n            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);\r\n            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);\r\n            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);\r\n            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);\r\n\r\n            if (style !== \"allman\" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {\r\n                context.report({\r\n                    node: openingCurly,\r\n                    messageId: \"nextLineOpen\",\r\n                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)\r\n                });\r\n            }\r\n\r\n            if (style === \"allman\" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {\r\n                context.report({\r\n                    node: openingCurly,\r\n                    messageId: \"sameLineOpen\",\r\n                    fix: fixer => fixer.insertTextBefore(openingCurly, \"\\n\")\r\n                });\r\n            }\r\n\r\n            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {\r\n                context.report({\r\n                    node: openingCurly,\r\n                    messageId: \"blockSameLine\",\r\n                    fix: fixer => fixer.insertTextAfter(openingCurly, \"\\n\")\r\n                });\r\n            }\r\n\r\n            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {\r\n                context.report({\r\n                    node: closingCurly,\r\n                    messageId: \"singleLineClose\",\r\n                    fix: fixer => fixer.insertTextBefore(closingCurly, \"\\n\")\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)\r\n         * @param {Token} curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).\r\n         * @returns {void}\r\n         */\r\n        function validateCurlyBeforeKeyword(curlyToken) {\r\n            const keywordToken = sourceCode.getTokenAfter(curlyToken);\r\n\r\n            if (style === \"1tbs\" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\r\n                context.report({\r\n                    node: curlyToken,\r\n                    messageId: \"nextLineClose\",\r\n                    fix: removeNewlineBetween(curlyToken, keywordToken)\r\n                });\r\n            }\r\n\r\n            if (style !== \"1tbs\" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {\r\n                context.report({\r\n                    node: curlyToken,\r\n                    messageId: \"sameLineClose\",\r\n                    fix: fixer => fixer.insertTextAfter(curlyToken, \"\\n\")\r\n                });\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public API\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            BlockStatement(node) {\r\n                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {\r\n                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\r\n                }\r\n            },\r\n            StaticBlock(node) {\r\n                validateCurlyPair(\r\n                    sourceCode.getFirstToken(node, { skip: 1 }), // skip the `static` token\r\n                    sourceCode.getLastToken(node)\r\n                );\r\n            },\r\n            ClassBody(node) {\r\n                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));\r\n            },\r\n            SwitchStatement(node) {\r\n                const closingCurly = sourceCode.getLastToken(node);\r\n                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);\r\n\r\n                validateCurlyPair(openingCurly, closingCurly);\r\n            },\r\n            IfStatement(node) {\r\n                if (node.consequent.type === \"BlockStatement\" && node.alternate) {\r\n\r\n                    // Handle the keyword after the `if` block (before `else`)\r\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));\r\n                }\r\n            },\r\n            TryStatement(node) {\r\n\r\n                // Handle the keyword after the `try` block (before `catch` or `finally`)\r\n                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));\r\n\r\n                if (node.handler && node.finalizer) {\r\n\r\n                    // Handle the keyword after the `catch` block (before `finally`)\r\n                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}