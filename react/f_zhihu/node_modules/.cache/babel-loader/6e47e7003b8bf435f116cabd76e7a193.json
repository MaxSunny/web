{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce location of semicolons.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n\nconst SELECTOR = [\"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\", \"DoWhileStatement\", \"ExportAllDeclaration\", \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\", \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\", \"ThrowStatement\", \"VariableDeclaration\", \"PropertyDefinition\"].join(\",\");\n/**\r\n * Get the child node list of a given node.\r\n * This returns `BlockStatement#body`, `StaticBlock#body`, `Program#body`,\r\n * `ClassBody#body`, or `SwitchCase#consequent`.\r\n * This is used to check whether a node is the first/last child.\r\n * @param {Node} node A node to get child node list.\r\n * @returns {Node[]|null} The child node list.\r\n */\n\nfunction getChildren(node) {\n  const t = node.type;\n\n  if (t === \"BlockStatement\" || t === \"StaticBlock\" || t === \"Program\" || t === \"ClassBody\") {\n    return node.body;\n  }\n\n  if (t === \"SwitchCase\") {\n    return node.consequent;\n  }\n\n  return null;\n}\n/**\r\n * Check whether a given node is the last statement in the parent block.\r\n * @param {Node} node A node to check.\r\n * @returns {boolean} `true` if the node is the last statement in the parent block.\r\n */\n\n\nfunction isLastChild(node) {\n  const t = node.parent.type;\n\n  if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) {\n    // before `else` keyword.\n    return true;\n  }\n\n  if (t === \"DoWhileStatement\") {\n    // before `while` keyword.\n    return true;\n  }\n\n  const nodeList = getChildren(node.parent);\n  return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\n}\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce location of semicolons\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/semi-style\"\n    },\n    schema: [{\n      enum: [\"last\", \"first\"]\n    }],\n    fixable: \"whitespace\",\n    messages: {\n      expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const option = context.options[0] || \"last\";\n    /**\r\n     * Check the given semicolon token.\r\n     * @param {Token} semiToken The semicolon token to check.\r\n     * @param {\"first\"|\"last\"} expected The expected location to check.\r\n     * @returns {void}\r\n     */\n\n    function check(semiToken, expected) {\n      const prevToken = sourceCode.getTokenBefore(semiToken);\n      const nextToken = sourceCode.getTokenAfter(semiToken);\n      const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\n      const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\n\n      if (expected === \"last\" && !prevIsSameLine || expected === \"first\" && !nextIsSameLine) {\n        context.report({\n          loc: semiToken.loc,\n          messageId: \"expectedSemiColon\",\n          data: {\n            pos: expected === \"last\" ? \"the end of the previous line\" : \"the beginning of the next line\"\n          },\n\n          fix(fixer) {\n            if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\n              return null;\n            }\n\n            const start = prevToken ? prevToken.range[1] : semiToken.range[0];\n            const end = nextToken ? nextToken.range[0] : semiToken.range[1];\n            const text = expected === \"last\" ? \";\\n\" : \"\\n;\";\n            return fixer.replaceTextRange([start, end], text);\n          }\n\n        });\n      }\n    }\n\n    return {\n      [SELECTOR](node) {\n        if (option === \"first\" && isLastChild(node)) {\n          return;\n        }\n\n        const lastToken = sourceCode.getLastToken(node);\n\n        if (astUtils.isSemicolonToken(lastToken)) {\n          check(lastToken, option);\n        }\n      },\n\n      ForStatement(node) {\n        const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\n        const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\n\n        if (firstSemi) {\n          check(firstSemi, \"last\");\n        }\n\n        if (secondSemi) {\n          check(secondSemi, \"last\");\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/semi-style.js"],"names":["astUtils","require","SELECTOR","join","getChildren","node","t","type","body","consequent","isLastChild","parent","alternate","nodeList","length","module","exports","meta","docs","description","recommended","url","schema","enum","fixable","messages","expectedSemiColon","create","context","sourceCode","getSourceCode","option","options","check","semiToken","expected","prevToken","getTokenBefore","nextToken","getTokenAfter","prevIsSameLine","isTokenOnSameLine","nextIsSameLine","report","loc","messageId","data","pos","fix","fixer","commentsExistBetween","start","range","end","text","replaceTextRange","lastToken","getLastToken","isSemicolonToken","ForStatement","firstSemi","init","secondSemi","test"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce location of semicolons.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\nconst SELECTOR = [\r\n    \"BreakStatement\", \"ContinueStatement\", \"DebuggerStatement\",\r\n    \"DoWhileStatement\", \"ExportAllDeclaration\",\r\n    \"ExportDefaultDeclaration\", \"ExportNamedDeclaration\",\r\n    \"ExpressionStatement\", \"ImportDeclaration\", \"ReturnStatement\",\r\n    \"ThrowStatement\", \"VariableDeclaration\", \"PropertyDefinition\"\r\n].join(\",\");\r\n\r\n/**\r\n * Get the child node list of a given node.\r\n * This returns `BlockStatement#body`, `StaticBlock#body`, `Program#body`,\r\n * `ClassBody#body`, or `SwitchCase#consequent`.\r\n * This is used to check whether a node is the first/last child.\r\n * @param {Node} node A node to get child node list.\r\n * @returns {Node[]|null} The child node list.\r\n */\r\nfunction getChildren(node) {\r\n    const t = node.type;\r\n\r\n    if (\r\n        t === \"BlockStatement\" ||\r\n        t === \"StaticBlock\" ||\r\n        t === \"Program\" ||\r\n        t === \"ClassBody\"\r\n    ) {\r\n        return node.body;\r\n    }\r\n    if (t === \"SwitchCase\") {\r\n        return node.consequent;\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * Check whether a given node is the last statement in the parent block.\r\n * @param {Node} node A node to check.\r\n * @returns {boolean} `true` if the node is the last statement in the parent block.\r\n */\r\nfunction isLastChild(node) {\r\n    const t = node.parent.type;\r\n\r\n    if (t === \"IfStatement\" && node.parent.consequent === node && node.parent.alternate) { // before `else` keyword.\r\n        return true;\r\n    }\r\n    if (t === \"DoWhileStatement\") { // before `while` keyword.\r\n        return true;\r\n    }\r\n    const nodeList = getChildren(node.parent);\r\n\r\n    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.\r\n}\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce location of semicolons\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/semi-style\"\r\n        },\r\n\r\n        schema: [{ enum: [\"last\", \"first\"] }],\r\n        fixable: \"whitespace\",\r\n\r\n        messages: {\r\n            expectedSemiColon: \"Expected this semicolon to be at {{pos}}.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n        const option = context.options[0] || \"last\";\r\n\r\n        /**\r\n         * Check the given semicolon token.\r\n         * @param {Token} semiToken The semicolon token to check.\r\n         * @param {\"first\"|\"last\"} expected The expected location to check.\r\n         * @returns {void}\r\n         */\r\n        function check(semiToken, expected) {\r\n            const prevToken = sourceCode.getTokenBefore(semiToken);\r\n            const nextToken = sourceCode.getTokenAfter(semiToken);\r\n            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);\r\n            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);\r\n\r\n            if ((expected === \"last\" && !prevIsSameLine) || (expected === \"first\" && !nextIsSameLine)) {\r\n                context.report({\r\n                    loc: semiToken.loc,\r\n                    messageId: \"expectedSemiColon\",\r\n                    data: {\r\n                        pos: (expected === \"last\")\r\n                            ? \"the end of the previous line\"\r\n                            : \"the beginning of the next line\"\r\n                    },\r\n                    fix(fixer) {\r\n                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {\r\n                            return null;\r\n                        }\r\n\r\n                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];\r\n                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];\r\n                        const text = (expected === \"last\") ? \";\\n\" : \"\\n;\";\r\n\r\n                        return fixer.replaceTextRange([start, end], text);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return {\r\n            [SELECTOR](node) {\r\n                if (option === \"first\" && isLastChild(node)) {\r\n                    return;\r\n                }\r\n\r\n                const lastToken = sourceCode.getLastToken(node);\r\n\r\n                if (astUtils.isSemicolonToken(lastToken)) {\r\n                    check(lastToken, option);\r\n                }\r\n            },\r\n\r\n            ForStatement(node) {\r\n                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);\r\n                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);\r\n\r\n                if (firstSemi) {\r\n                    check(firstSemi, \"last\");\r\n                }\r\n                if (secondSemi) {\r\n                    check(secondSemi, \"last\");\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}