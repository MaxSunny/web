{"ast":null,"code":"/**\r\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\r\n * @author Marcin Kumorek\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before or after unary operators\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/space-unary-ops\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        words: {\n          type: \"boolean\",\n          default: true\n        },\n        nonwords: {\n          type: \"boolean\",\n          default: false\n        },\n        overrides: {\n          type: \"object\",\n          additionalProperties: {\n            type: \"boolean\"\n          }\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\n      unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\n      unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\n      wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\n      operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\n      beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {\n      words: true,\n      nonwords: false\n    };\n    const sourceCode = context.getSourceCode(); //--------------------------------------------------------------------------\n    // Helpers\n    //--------------------------------------------------------------------------\n\n    /**\r\n     * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\r\n     * @param {ASTnode} node AST node\r\n     * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\r\n     */\n\n    function isFirstBangInBangBangExpression(node) {\n      return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" && node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n    }\n    /**\r\n     * Checks if an override exists for a given operator.\r\n     * @param {string} operator Operator\r\n     * @returns {boolean} Whether or not an override has been provided for the operator\r\n     */\n\n\n    function overrideExistsForOperator(operator) {\n      return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\n    }\n    /**\r\n     * Gets the value that the override was set to for this operator\r\n     * @param {string} operator Operator\r\n     * @returns {boolean} Whether or not an override enforces a space with this operator\r\n     */\n\n\n    function overrideEnforcesSpaces(operator) {\n      return options.overrides[operator];\n    }\n    /**\r\n     * Verify Unary Word Operator has spaces after the word operator\r\n     * @param {ASTnode} node AST node\r\n     * @param {Object} firstToken first token from the AST node\r\n     * @param {Object} secondToken second token from the AST node\r\n     * @param {string} word The word to be used for reporting\r\n     * @returns {void}\r\n     */\n\n\n    function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n      if (secondToken.range[0] === firstToken.range[1]) {\n        context.report({\n          node,\n          messageId: \"wordOperator\",\n          data: {\n            word\n          },\n\n          fix(fixer) {\n            return fixer.insertTextAfter(firstToken, \" \");\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Verify Unary Word Operator doesn't have spaces after the word operator\r\n     * @param {ASTnode} node AST node\r\n     * @param {Object} firstToken first token from the AST node\r\n     * @param {Object} secondToken second token from the AST node\r\n     * @param {string} word The word to be used for reporting\r\n     * @returns {void}\r\n     */\n\n\n    function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n      if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfterWord\",\n            data: {\n              word\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\r\n     * Check Unary Word Operators for spaces after the word operator\r\n     * @param {ASTnode} node AST node\r\n     * @param {Object} firstToken first token from the AST node\r\n     * @param {Object} secondToken second token from the AST node\r\n     * @param {string} word The word to be used for reporting\r\n     * @returns {void}\r\n     */\n\n\n    function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n      if (overrideExistsForOperator(word)) {\n        if (overrideEnforcesSpaces(word)) {\n          verifyWordHasSpaces(node, firstToken, secondToken, word);\n        } else {\n          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n        }\n      } else if (options.words) {\n        verifyWordHasSpaces(node, firstToken, secondToken, word);\n      } else {\n        verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n      }\n    }\n    /**\r\n     * Verifies YieldExpressions satisfy spacing requirements\r\n     * @param {ASTnode} node AST node\r\n     * @returns {void}\r\n     */\n\n\n    function checkForSpacesAfterYield(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3),\n            word = \"yield\";\n\n      if (!node.argument || node.delegate) {\n        return;\n      }\n\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n    }\n    /**\r\n     * Verifies AwaitExpressions satisfy spacing requirements\r\n     * @param {ASTNode} node AwaitExpression AST node\r\n     * @returns {void}\r\n     */\n\n\n    function checkForSpacesAfterAwait(node) {\n      const tokens = sourceCode.getFirstTokens(node, 3);\n      checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\n    }\n    /**\r\n     * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\r\n     * @param {ASTnode} node AST node\r\n     * @param {Object} firstToken First token in the expression\r\n     * @param {Object} secondToken Second token in the expression\r\n     * @returns {void}\r\n     */\n\n\n    function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (isFirstBangInBangBangExpression(node)) {\n          return;\n        }\n\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"operator\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextAfter(firstToken, \" \");\n            }\n\n          });\n        }\n      } else {\n        if (firstToken.range[1] === secondToken.range[0]) {\n          context.report({\n            node,\n            messageId: \"beforeUnaryExpressions\",\n            data: {\n              token: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.insertTextBefore(secondToken, \" \");\n            }\n\n          });\n        }\n      }\n    }\n    /**\r\n     * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\r\n     * @param {ASTnode} node AST node\r\n     * @param {Object} firstToken First token in the expression\r\n     * @param {Object} secondToken Second token in the expression\r\n     * @returns {void}\r\n     */\n\n\n    function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n      if (node.prefix) {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedAfter\",\n            data: {\n              operator: firstToken.value\n            },\n\n            fix(fixer) {\n              if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\n                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n              }\n\n              return null;\n            }\n\n          });\n        }\n      } else {\n        if (secondToken.range[0] > firstToken.range[1]) {\n          context.report({\n            node,\n            messageId: \"unexpectedBefore\",\n            data: {\n              operator: secondToken.value\n            },\n\n            fix(fixer) {\n              return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n            }\n\n          });\n        }\n      }\n    }\n    /**\r\n     * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\r\n     * @param {ASTnode} node AST node\r\n     * @returns {void}\r\n     */\n\n\n    function checkForSpaces(node) {\n      const tokens = node.type === \"UpdateExpression\" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);\n      const firstToken = tokens[0];\n      const secondToken = tokens[1];\n\n      if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n        checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\n        return;\n      }\n\n      const operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n      if (overrideExistsForOperator(operator)) {\n        if (overrideEnforcesSpaces(operator)) {\n          verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n        } else {\n          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n        }\n      } else if (options.nonwords) {\n        verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n      } else {\n        verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n      }\n    } //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n\n    return {\n      UnaryExpression: checkForSpaces,\n      UpdateExpression: checkForSpaces,\n      NewExpression: checkForSpaces,\n      YieldExpression: checkForSpacesAfterYield,\n      AwaitExpression: checkForSpacesAfterAwait\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/space-unary-ops.js"],"names":["astUtils","require","module","exports","meta","type","docs","description","recommended","url","fixable","schema","properties","words","default","nonwords","overrides","additionalProperties","messages","unexpectedBefore","unexpectedAfter","unexpectedAfterWord","wordOperator","operator","beforeUnaryExpressions","create","context","options","sourceCode","getSourceCode","isFirstBangInBangBangExpression","node","argument","overrideExistsForOperator","Object","prototype","hasOwnProperty","call","overrideEnforcesSpaces","verifyWordHasSpaces","firstToken","secondToken","word","range","report","messageId","data","fix","fixer","insertTextAfter","verifyWordDoesntHaveSpaces","canTokensBeAdjacent","removeRange","checkUnaryWordOperatorForSpaces","checkForSpacesAfterYield","tokens","getFirstTokens","delegate","checkForSpacesAfterAwait","verifyNonWordsHaveSpaces","prefix","value","token","insertTextBefore","verifyNonWordsDontHaveSpaces","checkForSpaces","getLastTokens","UnaryExpression","UpdateExpression","NewExpression","YieldExpression","AwaitExpression"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview This rule should require or disallow spaces before or after unary operations.\r\n * @author Marcin Kumorek\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing before or after unary operators\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/space-unary-ops\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    words: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    },\r\n                    nonwords: {\r\n                        type: \"boolean\",\r\n                        default: false\r\n                    },\r\n                    overrides: {\r\n                        type: \"object\",\r\n                        additionalProperties: {\r\n                            type: \"boolean\"\r\n                        }\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            unexpectedBefore: \"Unexpected space before unary operator '{{operator}}'.\",\r\n            unexpectedAfter: \"Unexpected space after unary operator '{{operator}}'.\",\r\n            unexpectedAfterWord: \"Unexpected space after unary word operator '{{word}}'.\",\r\n            wordOperator: \"Unary word operator '{{word}}' must be followed by whitespace.\",\r\n            operator: \"Unary operator '{{operator}}' must be followed by whitespace.\",\r\n            beforeUnaryExpressions: \"Space is required before unary expressions '{{token}}'.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || { words: true, nonwords: false };\r\n\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Helpers\r\n        //--------------------------------------------------------------------------\r\n\r\n        /**\r\n         * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\r\n         * @param {ASTnode} node AST node\r\n         * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\r\n         */\r\n        function isFirstBangInBangBangExpression(node) {\r\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\r\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\r\n        }\r\n\r\n        /**\r\n         * Checks if an override exists for a given operator.\r\n         * @param {string} operator Operator\r\n         * @returns {boolean} Whether or not an override has been provided for the operator\r\n         */\r\n        function overrideExistsForOperator(operator) {\r\n            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);\r\n        }\r\n\r\n        /**\r\n         * Gets the value that the override was set to for this operator\r\n         * @param {string} operator Operator\r\n         * @returns {boolean} Whether or not an override enforces a space with this operator\r\n         */\r\n        function overrideEnforcesSpaces(operator) {\r\n            return options.overrides[operator];\r\n        }\r\n\r\n        /**\r\n         * Verify Unary Word Operator has spaces after the word operator\r\n         * @param {ASTnode} node AST node\r\n         * @param {Object} firstToken first token from the AST node\r\n         * @param {Object} secondToken second token from the AST node\r\n         * @param {string} word The word to be used for reporting\r\n         * @returns {void}\r\n         */\r\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\r\n            if (secondToken.range[0] === firstToken.range[1]) {\r\n                context.report({\r\n                    node,\r\n                    messageId: \"wordOperator\",\r\n                    data: {\r\n                        word\r\n                    },\r\n                    fix(fixer) {\r\n                        return fixer.insertTextAfter(firstToken, \" \");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verify Unary Word Operator doesn't have spaces after the word operator\r\n         * @param {ASTnode} node AST node\r\n         * @param {Object} firstToken first token from the AST node\r\n         * @param {Object} secondToken second token from the AST node\r\n         * @param {string} word The word to be used for reporting\r\n         * @returns {void}\r\n         */\r\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\r\n            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\r\n                if (secondToken.range[0] > firstToken.range[1]) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedAfterWord\",\r\n                        data: {\r\n                            word\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Check Unary Word Operators for spaces after the word operator\r\n         * @param {ASTnode} node AST node\r\n         * @param {Object} firstToken first token from the AST node\r\n         * @param {Object} secondToken second token from the AST node\r\n         * @param {string} word The word to be used for reporting\r\n         * @returns {void}\r\n         */\r\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\r\n            if (overrideExistsForOperator(word)) {\r\n                if (overrideEnforcesSpaces(word)) {\r\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\r\n                } else {\r\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\r\n                }\r\n            } else if (options.words) {\r\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\r\n            } else {\r\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies YieldExpressions satisfy spacing requirements\r\n         * @param {ASTnode} node AST node\r\n         * @returns {void}\r\n         */\r\n        function checkForSpacesAfterYield(node) {\r\n            const tokens = sourceCode.getFirstTokens(node, 3),\r\n                word = \"yield\";\r\n\r\n            if (!node.argument || node.delegate) {\r\n                return;\r\n            }\r\n\r\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\r\n        }\r\n\r\n        /**\r\n         * Verifies AwaitExpressions satisfy spacing requirements\r\n         * @param {ASTNode} node AwaitExpression AST node\r\n         * @returns {void}\r\n         */\r\n        function checkForSpacesAfterAwait(node) {\r\n            const tokens = sourceCode.getFirstTokens(node, 3);\r\n\r\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], \"await\");\r\n        }\r\n\r\n        /**\r\n         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\r\n         * @param {ASTnode} node AST node\r\n         * @param {Object} firstToken First token in the expression\r\n         * @param {Object} secondToken Second token in the expression\r\n         * @returns {void}\r\n         */\r\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\r\n            if (node.prefix) {\r\n                if (isFirstBangInBangBangExpression(node)) {\r\n                    return;\r\n                }\r\n                if (firstToken.range[1] === secondToken.range[0]) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"operator\",\r\n                        data: {\r\n                            operator: firstToken.value\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.insertTextAfter(firstToken, \" \");\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                if (firstToken.range[1] === secondToken.range[0]) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"beforeUnaryExpressions\",\r\n                        data: {\r\n                            token: secondToken.value\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.insertTextBefore(secondToken, \" \");\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\r\n         * @param {ASTnode} node AST node\r\n         * @param {Object} firstToken First token in the expression\r\n         * @param {Object} secondToken Second token in the expression\r\n         * @returns {void}\r\n         */\r\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\r\n            if (node.prefix) {\r\n                if (secondToken.range[0] > firstToken.range[1]) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedAfter\",\r\n                        data: {\r\n                            operator: firstToken.value\r\n                        },\r\n                        fix(fixer) {\r\n                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {\r\n                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\r\n                            }\r\n                            return null;\r\n                        }\r\n                    });\r\n                }\r\n            } else {\r\n                if (secondToken.range[0] > firstToken.range[1]) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unexpectedBefore\",\r\n                        data: {\r\n                            operator: secondToken.value\r\n                        },\r\n                        fix(fixer) {\r\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\r\n         * @param {ASTnode} node AST node\r\n         * @returns {void}\r\n         */\r\n        function checkForSpaces(node) {\r\n            const tokens = node.type === \"UpdateExpression\" && !node.prefix\r\n                ? sourceCode.getLastTokens(node, 2)\r\n                : sourceCode.getFirstTokens(node, 2);\r\n            const firstToken = tokens[0];\r\n            const secondToken = tokens[1];\r\n\r\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\r\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);\r\n                return;\r\n            }\r\n\r\n            const operator = node.prefix ? tokens[0].value : tokens[1].value;\r\n\r\n            if (overrideExistsForOperator(operator)) {\r\n                if (overrideEnforcesSpaces(operator)) {\r\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\r\n                } else {\r\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\r\n                }\r\n            } else if (options.nonwords) {\r\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\r\n            } else {\r\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\r\n            }\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Public\r\n        //--------------------------------------------------------------------------\r\n\r\n        return {\r\n            UnaryExpression: checkForSpaces,\r\n            UpdateExpression: checkForSpaces,\r\n            NewExpression: checkForSpaces,\r\n            YieldExpression: checkForSpacesAfterYield,\r\n            AwaitExpression: checkForSpacesAfterAwait\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}