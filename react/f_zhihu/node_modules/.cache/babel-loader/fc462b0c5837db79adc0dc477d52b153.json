{"ast":null,"code":"/**\r\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce the use of variables within the scope they are defined\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/block-scoped-var\"\n    },\n    schema: [],\n    messages: {\n      outOfScope: \"'{{name}}' used outside of binding context.\"\n    }\n  },\n\n  create(context) {\n    let stack = [];\n    /**\r\n     * Makes a block scope.\r\n     * @param {ASTNode} node A node of a scope.\r\n     * @returns {void}\r\n     */\n\n    function enterScope(node) {\n      stack.push(node.range);\n    }\n    /**\r\n     * Pops the last block scope.\r\n     * @returns {void}\r\n     */\n\n\n    function exitScope() {\n      stack.pop();\n    }\n    /**\r\n     * Reports a given reference.\r\n     * @param {eslint-scope.Reference} reference A reference to report.\r\n     * @returns {void}\r\n     */\n\n\n    function report(reference) {\n      const identifier = reference.identifier;\n      context.report({\n        node: identifier,\n        messageId: \"outOfScope\",\n        data: {\n          name: identifier.name\n        }\n      });\n    }\n    /**\r\n     * Finds and reports references which are outside of valid scopes.\r\n     * @param {ASTNode} node A node to get variables.\r\n     * @returns {void}\r\n     */\n\n\n    function checkForVariables(node) {\n      if (node.kind !== \"var\") {\n        return;\n      } // Defines a predicate to check whether or not a given reference is outside of valid scope.\n\n\n      const scopeRange = stack[stack.length - 1];\n      /**\r\n       * Check if a reference is out of scope\r\n       * @param {ASTNode} reference node to examine\r\n       * @returns {boolean} True is its outside the scope\r\n       * @private\r\n       */\n\n      function isOutsideOfScope(reference) {\n        const idRange = reference.identifier.range;\n        return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n      } // Gets declared variables, and checks its references.\n\n\n      const variables = context.getDeclaredVariables(node);\n\n      for (let i = 0; i < variables.length; ++i) {\n        // Reports.\n        variables[i].references.filter(isOutsideOfScope).forEach(report);\n      }\n    }\n\n    return {\n      Program(node) {\n        stack = [node.range];\n      },\n\n      // Manages scopes.\n      BlockStatement: enterScope,\n      \"BlockStatement:exit\": exitScope,\n      ForStatement: enterScope,\n      \"ForStatement:exit\": exitScope,\n      ForInStatement: enterScope,\n      \"ForInStatement:exit\": exitScope,\n      ForOfStatement: enterScope,\n      \"ForOfStatement:exit\": exitScope,\n      SwitchStatement: enterScope,\n      \"SwitchStatement:exit\": exitScope,\n      CatchClause: enterScope,\n      \"CatchClause:exit\": exitScope,\n      StaticBlock: enterScope,\n      \"StaticBlock:exit\": exitScope,\n      // Finds and reports references which are outside of valid scope.\n      VariableDeclaration: checkForVariables\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/block-scoped-var.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","messages","outOfScope","create","context","stack","enterScope","node","push","range","exitScope","pop","report","reference","identifier","messageId","data","name","checkForVariables","kind","scopeRange","length","isOutsideOfScope","idRange","variables","getDeclaredVariables","i","references","filter","forEach","Program","BlockStatement","ForStatement","ForInStatement","ForOfStatement","SwitchStatement","CatchClause","StaticBlock","VariableDeclaration"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\r\n * @author Matt DuVall <http://www.mattduvall.com>\r\n */\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce the use of variables within the scope they are defined\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/block-scoped-var\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            outOfScope: \"'{{name}}' used outside of binding context.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        let stack = [];\r\n\r\n        /**\r\n         * Makes a block scope.\r\n         * @param {ASTNode} node A node of a scope.\r\n         * @returns {void}\r\n         */\r\n        function enterScope(node) {\r\n            stack.push(node.range);\r\n        }\r\n\r\n        /**\r\n         * Pops the last block scope.\r\n         * @returns {void}\r\n         */\r\n        function exitScope() {\r\n            stack.pop();\r\n        }\r\n\r\n        /**\r\n         * Reports a given reference.\r\n         * @param {eslint-scope.Reference} reference A reference to report.\r\n         * @returns {void}\r\n         */\r\n        function report(reference) {\r\n            const identifier = reference.identifier;\r\n\r\n            context.report({ node: identifier, messageId: \"outOfScope\", data: { name: identifier.name } });\r\n        }\r\n\r\n        /**\r\n         * Finds and reports references which are outside of valid scopes.\r\n         * @param {ASTNode} node A node to get variables.\r\n         * @returns {void}\r\n         */\r\n        function checkForVariables(node) {\r\n            if (node.kind !== \"var\") {\r\n                return;\r\n            }\r\n\r\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\r\n            const scopeRange = stack[stack.length - 1];\r\n\r\n            /**\r\n             * Check if a reference is out of scope\r\n             * @param {ASTNode} reference node to examine\r\n             * @returns {boolean} True is its outside the scope\r\n             * @private\r\n             */\r\n            function isOutsideOfScope(reference) {\r\n                const idRange = reference.identifier.range;\r\n\r\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\r\n            }\r\n\r\n            // Gets declared variables, and checks its references.\r\n            const variables = context.getDeclaredVariables(node);\r\n\r\n            for (let i = 0; i < variables.length; ++i) {\r\n\r\n                // Reports.\r\n                variables[i]\r\n                    .references\r\n                    .filter(isOutsideOfScope)\r\n                    .forEach(report);\r\n            }\r\n        }\r\n\r\n        return {\r\n            Program(node) {\r\n                stack = [node.range];\r\n            },\r\n\r\n            // Manages scopes.\r\n            BlockStatement: enterScope,\r\n            \"BlockStatement:exit\": exitScope,\r\n            ForStatement: enterScope,\r\n            \"ForStatement:exit\": exitScope,\r\n            ForInStatement: enterScope,\r\n            \"ForInStatement:exit\": exitScope,\r\n            ForOfStatement: enterScope,\r\n            \"ForOfStatement:exit\": exitScope,\r\n            SwitchStatement: enterScope,\r\n            \"SwitchStatement:exit\": exitScope,\r\n            CatchClause: enterScope,\r\n            \"CatchClause:exit\": exitScope,\r\n            StaticBlock: enterScope,\r\n            \"StaticBlock:exit\": exitScope,\r\n\r\n            // Finds and reports references which are outside of valid scope.\r\n            VariableDeclaration: checkForVariables\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}