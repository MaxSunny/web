{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag updates of imported bindings.\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nconst {\n  findVariable\n} = require(\"eslint-utils\");\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst WellKnownMutationFunctions = {\n  Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\n  Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\n};\n/**\r\n * Check if a given node is LHS of an assignment node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is LHS.\r\n */\n\nfunction isAssignmentLeft(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"AssignmentExpression\" && parent.left === node || // Destructuring assignments\n  parent.type === \"ArrayPattern\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"RestElement\" || parent.type === \"AssignmentPattern\" && parent.left === node;\n}\n/**\r\n * Check if a given node is the operand of mutation unary operator.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\r\n */\n\n\nfunction isOperandOfMutationUnaryOperator(node) {\n  const argumentNode = node.parent.type === \"ChainExpression\" ? node.parent : node;\n  const {\n    parent\n  } = argumentNode;\n  return parent.type === \"UpdateExpression\" && parent.argument === argumentNode || parent.type === \"UnaryExpression\" && parent.operator === \"delete\" && parent.argument === argumentNode;\n}\n/**\r\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is the iteration variable.\r\n */\n\n\nfunction isIterationVariable(node) {\n  const {\n    parent\n  } = node;\n  return parent.type === \"ForInStatement\" && parent.left === node || parent.type === \"ForOfStatement\" && parent.left === node;\n}\n/**\r\n * Check if a given node is at the first argument of a well-known mutation function.\r\n * - `Object.assign`\r\n * - `Object.defineProperty`\r\n * - `Object.defineProperties`\r\n * - `Object.freeze`\r\n * - `Object.setPrototypeOf`\r\n * - `Reflect.defineProperty`\r\n * - `Reflect.deleteProperty`\r\n * - `Reflect.set`\r\n * - `Reflect.setPrototypeOf`\r\n * @param {ASTNode} node The node to check.\r\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\r\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\r\n */\n\n\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\n  const {\n    parent\n  } = node;\n\n  if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\n    return false;\n  }\n\n  const callee = astUtils.skipChainExpression(parent.callee);\n\n  if (!astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)) {\n    return false;\n  }\n\n  const variable = findVariable(scope, callee.object);\n  return variable !== null && variable.scope.type === \"global\";\n}\n/**\r\n * Check if the identifier node is placed at to update members.\r\n * @param {ASTNode} id The Identifier node to check.\r\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\r\n * @returns {boolean} `true` if the member of `id` was updated.\r\n */\n\n\nfunction isMemberWrite(id, scope) {\n  const {\n    parent\n  } = id;\n  return parent.type === \"MemberExpression\" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);\n}\n/**\r\n * Get the mutation node.\r\n * @param {ASTNode} id The Identifier node to get.\r\n * @returns {ASTNode} The mutation node.\r\n */\n\n\nfunction getWriteNode(id) {\n  let node = id.parent;\n\n  while (node && node.type !== \"AssignmentExpression\" && node.type !== \"UpdateExpression\" && node.type !== \"UnaryExpression\" && node.type !== \"CallExpression\" && node.type !== \"ForInStatement\" && node.type !== \"ForOfStatement\") {\n    node = node.parent;\n  }\n\n  return node || id;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"problem\",\n    docs: {\n      description: \"disallow assigning to imported bindings\",\n      recommended: true,\n      url: \"https://eslint.org/docs/rules/no-import-assign\"\n    },\n    schema: [],\n    messages: {\n      readonly: \"'{{name}}' is read-only.\",\n      readonlyMember: \"The members of '{{name}}' are read-only.\"\n    }\n  },\n\n  create(context) {\n    return {\n      ImportDeclaration(node) {\n        const scope = context.getScope();\n\n        for (const variable of context.getDeclaredVariables(node)) {\n          const shouldCheckMembers = variable.defs.some(d => d.node.type === \"ImportNamespaceSpecifier\");\n          let prevIdNode = null;\n\n          for (const reference of variable.references) {\n            const idNode = reference.identifier;\n            /*\r\n             * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\r\n             * references for the same identifier. This should skip\r\n             * the one of the two in order to prevent redundant reports.\r\n             */\n\n            if (idNode === prevIdNode) {\n              continue;\n            }\n\n            prevIdNode = idNode;\n\n            if (reference.isWrite()) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonly\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\n              context.report({\n                node: getWriteNode(idNode),\n                messageId: \"readonlyMember\",\n                data: {\n                  name: idNode.name\n                }\n              });\n            }\n          }\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-import-assign.js"],"names":["findVariable","require","astUtils","WellKnownMutationFunctions","Object","Reflect","isAssignmentLeft","node","parent","type","left","value","isOperandOfMutationUnaryOperator","argumentNode","argument","operator","isIterationVariable","isArgumentOfWellKnownMutationFunction","scope","arguments","callee","skipChainExpression","isSpecificMemberAccess","variable","object","isMemberWrite","id","getWriteNode","module","exports","meta","docs","description","recommended","url","schema","messages","readonly","readonlyMember","create","context","ImportDeclaration","getScope","getDeclaredVariables","shouldCheckMembers","defs","some","d","prevIdNode","reference","references","idNode","identifier","isWrite","report","messageId","data","name"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag updates of imported bindings.\r\n * @author Toru Nagashima <https://github.com/mysticatea>\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\nconst { findVariable } = require(\"eslint-utils\");\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\nconst WellKnownMutationFunctions = {\r\n    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,\r\n    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u\r\n};\r\n\r\n/**\r\n * Check if a given node is LHS of an assignment node.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is LHS.\r\n */\r\nfunction isAssignmentLeft(node) {\r\n    const { parent } = node;\r\n\r\n    return (\r\n        (\r\n            parent.type === \"AssignmentExpression\" &&\r\n            parent.left === node\r\n        ) ||\r\n\r\n        // Destructuring assignments\r\n        parent.type === \"ArrayPattern\" ||\r\n        (\r\n            parent.type === \"Property\" &&\r\n            parent.value === node &&\r\n            parent.parent.type === \"ObjectPattern\"\r\n        ) ||\r\n        parent.type === \"RestElement\" ||\r\n        (\r\n            parent.type === \"AssignmentPattern\" &&\r\n            parent.left === node\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Check if a given node is the operand of mutation unary operator.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is the operand of mutation unary operator.\r\n */\r\nfunction isOperandOfMutationUnaryOperator(node) {\r\n    const argumentNode = node.parent.type === \"ChainExpression\"\r\n        ? node.parent\r\n        : node;\r\n    const { parent } = argumentNode;\r\n\r\n    return (\r\n        (\r\n            parent.type === \"UpdateExpression\" &&\r\n            parent.argument === argumentNode\r\n        ) ||\r\n        (\r\n            parent.type === \"UnaryExpression\" &&\r\n            parent.operator === \"delete\" &&\r\n            parent.argument === argumentNode\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is the iteration variable.\r\n */\r\nfunction isIterationVariable(node) {\r\n    const { parent } = node;\r\n\r\n    return (\r\n        (\r\n            parent.type === \"ForInStatement\" &&\r\n            parent.left === node\r\n        ) ||\r\n        (\r\n            parent.type === \"ForOfStatement\" &&\r\n            parent.left === node\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Check if a given node is at the first argument of a well-known mutation function.\r\n * - `Object.assign`\r\n * - `Object.defineProperty`\r\n * - `Object.defineProperties`\r\n * - `Object.freeze`\r\n * - `Object.setPrototypeOf`\r\n * - `Reflect.defineProperty`\r\n * - `Reflect.deleteProperty`\r\n * - `Reflect.set`\r\n * - `Reflect.setPrototypeOf`\r\n * @param {ASTNode} node The node to check.\r\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\r\n * @returns {boolean} `true` if the node is at the first argument of a well-known mutation function.\r\n */\r\nfunction isArgumentOfWellKnownMutationFunction(node, scope) {\r\n    const { parent } = node;\r\n\r\n    if (parent.type !== \"CallExpression\" || parent.arguments[0] !== node) {\r\n        return false;\r\n    }\r\n    const callee = astUtils.skipChainExpression(parent.callee);\r\n\r\n    if (\r\n        !astUtils.isSpecificMemberAccess(callee, \"Object\", WellKnownMutationFunctions.Object) &&\r\n        !astUtils.isSpecificMemberAccess(callee, \"Reflect\", WellKnownMutationFunctions.Reflect)\r\n    ) {\r\n        return false;\r\n    }\r\n    const variable = findVariable(scope, callee.object);\r\n\r\n    return variable !== null && variable.scope.type === \"global\";\r\n}\r\n\r\n/**\r\n * Check if the identifier node is placed at to update members.\r\n * @param {ASTNode} id The Identifier node to check.\r\n * @param {Scope} scope A `escope.Scope` object to find variable (whichever).\r\n * @returns {boolean} `true` if the member of `id` was updated.\r\n */\r\nfunction isMemberWrite(id, scope) {\r\n    const { parent } = id;\r\n\r\n    return (\r\n        (\r\n            parent.type === \"MemberExpression\" &&\r\n            parent.object === id &&\r\n            (\r\n                isAssignmentLeft(parent) ||\r\n                isOperandOfMutationUnaryOperator(parent) ||\r\n                isIterationVariable(parent)\r\n            )\r\n        ) ||\r\n        isArgumentOfWellKnownMutationFunction(id, scope)\r\n    );\r\n}\r\n\r\n/**\r\n * Get the mutation node.\r\n * @param {ASTNode} id The Identifier node to get.\r\n * @returns {ASTNode} The mutation node.\r\n */\r\nfunction getWriteNode(id) {\r\n    let node = id.parent;\r\n\r\n    while (\r\n        node &&\r\n        node.type !== \"AssignmentExpression\" &&\r\n        node.type !== \"UpdateExpression\" &&\r\n        node.type !== \"UnaryExpression\" &&\r\n        node.type !== \"CallExpression\" &&\r\n        node.type !== \"ForInStatement\" &&\r\n        node.type !== \"ForOfStatement\"\r\n    ) {\r\n        node = node.parent;\r\n    }\r\n\r\n    return node || id;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"problem\",\r\n\r\n        docs: {\r\n            description: \"disallow assigning to imported bindings\",\r\n            recommended: true,\r\n            url: \"https://eslint.org/docs/rules/no-import-assign\"\r\n        },\r\n\r\n        schema: [],\r\n\r\n        messages: {\r\n            readonly: \"'{{name}}' is read-only.\",\r\n            readonlyMember: \"The members of '{{name}}' are read-only.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        return {\r\n            ImportDeclaration(node) {\r\n                const scope = context.getScope();\r\n\r\n                for (const variable of context.getDeclaredVariables(node)) {\r\n                    const shouldCheckMembers = variable.defs.some(\r\n                        d => d.node.type === \"ImportNamespaceSpecifier\"\r\n                    );\r\n                    let prevIdNode = null;\r\n\r\n                    for (const reference of variable.references) {\r\n                        const idNode = reference.identifier;\r\n\r\n                        /*\r\n                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write\r\n                         * references for the same identifier. This should skip\r\n                         * the one of the two in order to prevent redundant reports.\r\n                         */\r\n                        if (idNode === prevIdNode) {\r\n                            continue;\r\n                        }\r\n                        prevIdNode = idNode;\r\n\r\n                        if (reference.isWrite()) {\r\n                            context.report({\r\n                                node: getWriteNode(idNode),\r\n                                messageId: \"readonly\",\r\n                                data: { name: idNode.name }\r\n                            });\r\n                        } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {\r\n                            context.report({\r\n                                node: getWriteNode(idNode),\r\n                                messageId: \"readonlyMember\",\r\n                                data: { name: idNode.name }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}