{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag adding properties to native object's prototypes.\r\n * @author David Nelson\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\");\n\nconst globals = require(\"globals\"); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow extending native types\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-extend-native\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        exceptions: {\n          type: \"array\",\n          items: {\n            type: \"string\"\n          },\n          uniqueItems: true\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\n    }\n  },\n\n  create(context) {\n    const config = context.options[0] || {};\n    const exceptions = new Set(config.exceptions || []);\n    const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter(builtin => builtin[0].toUpperCase() === builtin[0]).filter(builtin => !exceptions.has(builtin)));\n    /**\r\n     * Reports a lint error for the given node.\r\n     * @param {ASTNode} node The node to report.\r\n     * @param {string} builtin The name of the native builtin being extended.\r\n     * @returns {void}\r\n     */\n\n    function reportNode(node, builtin) {\n      context.report({\n        node,\n        messageId: \"unexpected\",\n        data: {\n          builtin\n        }\n      });\n    }\n    /**\r\n     * Check to see if the `prototype` property of the given object\r\n     * identifier node is being accessed.\r\n     * @param {ASTNode} identifierNode The Identifier representing the object\r\n     * to check.\r\n     * @returns {boolean} True if the identifier is the object of a\r\n     * MemberExpression and its `prototype` property is being accessed,\r\n     * false otherwise.\r\n     */\n\n\n    function isPrototypePropertyAccessed(identifierNode) {\n      return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === \"MemberExpression\" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\");\n    }\n    /**\r\n     * Check if it's an assignment to the property of the given node.\r\n     * Example: `*.prop = 0` // the `*` is the given node.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} True if an assignment to the property of the node.\r\n     */\n\n\n    function isAssigningToPropertyOf(node) {\n      return node.parent.type === \"MemberExpression\" && node.parent.object === node && node.parent.parent.type === \"AssignmentExpression\" && node.parent.parent.left === node.parent;\n    }\n    /**\r\n     * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\r\n     * @param {ASTNode} node The node to check.\r\n     * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\r\n     */\n\n\n    function isInDefinePropertyCall(node) {\n      return node.parent.type === \"CallExpression\" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u);\n    }\n    /**\r\n     * Check to see if object prototype access is part of a prototype\r\n     * extension. There are three ways a prototype can be extended:\r\n     * 1. Assignment to prototype property (Object.prototype.foo = 1)\r\n     * 2. Object.defineProperty()/Object.defineProperties() on a prototype\r\n     * If prototype extension is detected, report the AssignmentExpression\r\n     * or CallExpression node.\r\n     * @param {ASTNode} identifierNode The Identifier representing the object\r\n     * which prototype is being accessed and possibly extended.\r\n     * @returns {void}\r\n     */\n\n\n    function checkAndReportPrototypeExtension(identifierNode) {\n      if (!isPrototypePropertyAccessed(identifierNode)) {\n        return; // This is not `*.prototype` access.\n      }\n      /*\r\n       * `identifierNode.parent` is a MemberExpression `*.prototype`.\r\n       * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\r\n       */\n\n\n      const prototypeNode = identifierNode.parent.parent.type === \"ChainExpression\" ? identifierNode.parent.parent : identifierNode.parent;\n\n      if (isAssigningToPropertyOf(prototypeNode)) {\n        // `*.prototype` -> MemberExpression -> AssignmentExpression\n        reportNode(prototypeNode.parent.parent, identifierNode.name);\n      } else if (isInDefinePropertyCall(prototypeNode)) {\n        // `*.prototype` -> CallExpression\n        reportNode(prototypeNode.parent, identifierNode.name);\n      }\n    }\n\n    return {\n      \"Program:exit\"() {\n        const globalScope = context.getScope();\n        modifiedBuiltins.forEach(builtin => {\n          const builtinVar = globalScope.set.get(builtin);\n\n          if (builtinVar && builtinVar.references) {\n            builtinVar.references.map(ref => ref.identifier).forEach(checkAndReportPrototypeExtension);\n          }\n        });\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-extend-native.js"],"names":["astUtils","require","globals","module","exports","meta","type","docs","description","recommended","url","schema","properties","exceptions","items","uniqueItems","additionalProperties","messages","unexpected","create","context","config","options","Set","modifiedBuiltins","Object","keys","builtin","filter","toUpperCase","has","reportNode","node","report","messageId","data","isPrototypePropertyAccessed","identifierNode","Boolean","parent","object","getStaticPropertyName","isAssigningToPropertyOf","left","isInDefinePropertyCall","arguments","isSpecificMemberAccess","callee","checkAndReportPrototypeExtension","prototypeNode","name","globalScope","getScope","forEach","builtinVar","set","get","references","map","ref","identifier"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,a,CAEA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,mBAAD,CAAxB;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAAvB,C,CAEA;AACA;AACA;;AAEA;;;AACAE,MAAM,CAACC,OAAP,GAAiB;AACbC,EAAAA,IAAI,EAAE;AACFC,IAAAA,IAAI,EAAE,YADJ;AAGFC,IAAAA,IAAI,EAAE;AACFC,MAAAA,WAAW,EAAE,iCADX;AAEFC,MAAAA,WAAW,EAAE,KAFX;AAGFC,MAAAA,GAAG,EAAE;AAHH,KAHJ;AASFC,IAAAA,MAAM,EAAE,CACJ;AACIL,MAAAA,IAAI,EAAE,QADV;AAEIM,MAAAA,UAAU,EAAE;AACRC,QAAAA,UAAU,EAAE;AACRP,UAAAA,IAAI,EAAE,OADE;AAERQ,UAAAA,KAAK,EAAE;AACHR,YAAAA,IAAI,EAAE;AADH,WAFC;AAKRS,UAAAA,WAAW,EAAE;AALL;AADJ,OAFhB;AAWIC,MAAAA,oBAAoB,EAAE;AAX1B,KADI,CATN;AAyBFC,IAAAA,QAAQ,EAAE;AACNC,MAAAA,UAAU,EAAE;AADN;AAzBR,GADO;;AA+BbC,EAAAA,MAAM,CAACC,OAAD,EAAU;AAEZ,UAAMC,MAAM,GAAGD,OAAO,CAACE,OAAR,CAAgB,CAAhB,KAAsB,EAArC;AACA,UAAMT,UAAU,GAAG,IAAIU,GAAJ,CAAQF,MAAM,CAACR,UAAP,IAAqB,EAA7B,CAAnB;AACA,UAAMW,gBAAgB,GAAG,IAAID,GAAJ,CACrBE,MAAM,CAACC,IAAP,CAAYxB,OAAO,CAACyB,OAApB,EACKC,MADL,CACYD,OAAO,IAAIA,OAAO,CAAC,CAAD,CAAP,CAAWE,WAAX,OAA6BF,OAAO,CAAC,CAAD,CAD3D,EAEKC,MAFL,CAEYD,OAAO,IAAI,CAACd,UAAU,CAACiB,GAAX,CAAeH,OAAf,CAFxB,CADqB,CAAzB;AAMA;AACR;AACA;AACA;AACA;AACA;;AACQ,aAASI,UAAT,CAAoBC,IAApB,EAA0BL,OAA1B,EAAmC;AAC/BP,MAAAA,OAAO,CAACa,MAAR,CAAe;AACXD,QAAAA,IADW;AAEXE,QAAAA,SAAS,EAAE,YAFA;AAGXC,QAAAA,IAAI,EAAE;AACFR,UAAAA;AADE;AAHK,OAAf;AAOH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASS,2BAAT,CAAqCC,cAArC,EAAqD;AACjD,aAAOC,OAAO,CACVD,cAAc,IACdA,cAAc,CAACE,MADf,IAEAF,cAAc,CAACE,MAAf,CAAsBjC,IAAtB,KAA+B,kBAF/B,IAGA+B,cAAc,CAACE,MAAf,CAAsBC,MAAtB,KAAiCH,cAHjC,IAIArC,QAAQ,CAACyC,qBAAT,CAA+BJ,cAAc,CAACE,MAA9C,MAA0D,WALhD,CAAd;AAOH;AAED;AACR;AACA;AACA;AACA;AACA;;;AACQ,aAASG,uBAAT,CAAiCV,IAAjC,EAAuC;AACnC,aACIA,IAAI,CAACO,MAAL,CAAYjC,IAAZ,KAAqB,kBAArB,IACA0B,IAAI,CAACO,MAAL,CAAYC,MAAZ,KAAuBR,IADvB,IAEAA,IAAI,CAACO,MAAL,CAAYA,MAAZ,CAAmBjC,IAAnB,KAA4B,sBAF5B,IAGA0B,IAAI,CAACO,MAAL,CAAYA,MAAZ,CAAmBI,IAAnB,KAA4BX,IAAI,CAACO,MAJrC;AAMH;AAED;AACR;AACA;AACA;AACA;;;AACQ,aAASK,sBAAT,CAAgCZ,IAAhC,EAAsC;AAClC,aACIA,IAAI,CAACO,MAAL,CAAYjC,IAAZ,KAAqB,gBAArB,IACA0B,IAAI,CAACO,MAAL,CAAYM,SAAZ,CAAsB,CAAtB,MAA6Bb,IAD7B,IAEAhC,QAAQ,CAAC8C,sBAAT,CAAgCd,IAAI,CAACO,MAAL,CAAYQ,MAA5C,EAAoD,QAApD,EAA8D,2BAA9D,CAHJ;AAKH;AAED;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACQ,aAASC,gCAAT,CAA0CX,cAA1C,EAA0D;AACtD,UAAI,CAACD,2BAA2B,CAACC,cAAD,CAAhC,EAAkD;AAC9C,eAD8C,CACtC;AACX;AAED;AACZ;AACA;AACA;;;AACY,YAAMY,aAAa,GACfZ,cAAc,CAACE,MAAf,CAAsBA,MAAtB,CAA6BjC,IAA7B,KAAsC,iBAAtC,GACM+B,cAAc,CAACE,MAAf,CAAsBA,MAD5B,GAEMF,cAAc,CAACE,MAHzB;;AAKA,UAAIG,uBAAuB,CAACO,aAAD,CAA3B,EAA4C;AAExC;AACAlB,QAAAA,UAAU,CAACkB,aAAa,CAACV,MAAd,CAAqBA,MAAtB,EAA8BF,cAAc,CAACa,IAA7C,CAAV;AACH,OAJD,MAIO,IAAIN,sBAAsB,CAACK,aAAD,CAA1B,EAA2C;AAE9C;AACAlB,QAAAA,UAAU,CAACkB,aAAa,CAACV,MAAf,EAAuBF,cAAc,CAACa,IAAtC,CAAV;AACH;AACJ;;AAED,WAAO;AAEH,uBAAiB;AACb,cAAMC,WAAW,GAAG/B,OAAO,CAACgC,QAAR,EAApB;AAEA5B,QAAAA,gBAAgB,CAAC6B,OAAjB,CAAyB1B,OAAO,IAAI;AAChC,gBAAM2B,UAAU,GAAGH,WAAW,CAACI,GAAZ,CAAgBC,GAAhB,CAAoB7B,OAApB,CAAnB;;AAEA,cAAI2B,UAAU,IAAIA,UAAU,CAACG,UAA7B,EAAyC;AACrCH,YAAAA,UAAU,CAACG,UAAX,CACKC,GADL,CACSC,GAAG,IAAIA,GAAG,CAACC,UADpB,EAEKP,OAFL,CAEaL,gCAFb;AAGH;AACJ,SARD;AASH;;AAdE,KAAP;AAiBH;;AA7JY,CAAjB","sourcesContent":["/**\r\n * @fileoverview Rule to flag adding properties to native object's prototypes.\r\n * @author David Nelson\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\nconst globals = require(\"globals\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow extending native types\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-extend-native\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    exceptions: {\r\n                        type: \"array\",\r\n                        items: {\r\n                            type: \"string\"\r\n                        },\r\n                        uniqueItems: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        messages: {\r\n            unexpected: \"{{builtin}} prototype is read only, properties should not be added.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const config = context.options[0] || {};\r\n        const exceptions = new Set(config.exceptions || []);\r\n        const modifiedBuiltins = new Set(\r\n            Object.keys(globals.builtin)\r\n                .filter(builtin => builtin[0].toUpperCase() === builtin[0])\r\n                .filter(builtin => !exceptions.has(builtin))\r\n        );\r\n\r\n        /**\r\n         * Reports a lint error for the given node.\r\n         * @param {ASTNode} node The node to report.\r\n         * @param {string} builtin The name of the native builtin being extended.\r\n         * @returns {void}\r\n         */\r\n        function reportNode(node, builtin) {\r\n            context.report({\r\n                node,\r\n                messageId: \"unexpected\",\r\n                data: {\r\n                    builtin\r\n                }\r\n            });\r\n        }\r\n\r\n        /**\r\n         * Check to see if the `prototype` property of the given object\r\n         * identifier node is being accessed.\r\n         * @param {ASTNode} identifierNode The Identifier representing the object\r\n         * to check.\r\n         * @returns {boolean} True if the identifier is the object of a\r\n         * MemberExpression and its `prototype` property is being accessed,\r\n         * false otherwise.\r\n         */\r\n        function isPrototypePropertyAccessed(identifierNode) {\r\n            return Boolean(\r\n                identifierNode &&\r\n                identifierNode.parent &&\r\n                identifierNode.parent.type === \"MemberExpression\" &&\r\n                identifierNode.parent.object === identifierNode &&\r\n                astUtils.getStaticPropertyName(identifierNode.parent) === \"prototype\"\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check if it's an assignment to the property of the given node.\r\n         * Example: `*.prop = 0` // the `*` is the given node.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} True if an assignment to the property of the node.\r\n         */\r\n        function isAssigningToPropertyOf(node) {\r\n            return (\r\n                node.parent.type === \"MemberExpression\" &&\r\n                node.parent.object === node &&\r\n                node.parent.parent.type === \"AssignmentExpression\" &&\r\n                node.parent.parent.left === node.parent\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Checks if the given node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\r\n         * @param {ASTNode} node The node to check.\r\n         * @returns {boolean} True if the node is at the first argument of the method call of `Object.defineProperty()` or `Object.defineProperties()`.\r\n         */\r\n        function isInDefinePropertyCall(node) {\r\n            return (\r\n                node.parent.type === \"CallExpression\" &&\r\n                node.parent.arguments[0] === node &&\r\n                astUtils.isSpecificMemberAccess(node.parent.callee, \"Object\", /^definePropert(?:y|ies)$/u)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Check to see if object prototype access is part of a prototype\r\n         * extension. There are three ways a prototype can be extended:\r\n         * 1. Assignment to prototype property (Object.prototype.foo = 1)\r\n         * 2. Object.defineProperty()/Object.defineProperties() on a prototype\r\n         * If prototype extension is detected, report the AssignmentExpression\r\n         * or CallExpression node.\r\n         * @param {ASTNode} identifierNode The Identifier representing the object\r\n         * which prototype is being accessed and possibly extended.\r\n         * @returns {void}\r\n         */\r\n        function checkAndReportPrototypeExtension(identifierNode) {\r\n            if (!isPrototypePropertyAccessed(identifierNode)) {\r\n                return; // This is not `*.prototype` access.\r\n            }\r\n\r\n            /*\r\n             * `identifierNode.parent` is a MemberExpression `*.prototype`.\r\n             * If it's an optional member access, it may be wrapped by a `ChainExpression` node.\r\n             */\r\n            const prototypeNode =\r\n                identifierNode.parent.parent.type === \"ChainExpression\"\r\n                    ? identifierNode.parent.parent\r\n                    : identifierNode.parent;\r\n\r\n            if (isAssigningToPropertyOf(prototypeNode)) {\r\n\r\n                // `*.prototype` -> MemberExpression -> AssignmentExpression\r\n                reportNode(prototypeNode.parent.parent, identifierNode.name);\r\n            } else if (isInDefinePropertyCall(prototypeNode)) {\r\n\r\n                // `*.prototype` -> CallExpression\r\n                reportNode(prototypeNode.parent, identifierNode.name);\r\n            }\r\n        }\r\n\r\n        return {\r\n\r\n            \"Program:exit\"() {\r\n                const globalScope = context.getScope();\r\n\r\n                modifiedBuiltins.forEach(builtin => {\r\n                    const builtinVar = globalScope.set.get(builtin);\r\n\r\n                    if (builtinVar && builtinVar.references) {\r\n                        builtinVar.references\r\n                            .map(ref => ref.identifier)\r\n                            .forEach(checkAndReportPrototypeExtension);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}