{"ast":null,"code":"/**\r\n * @fileoverview Rule to flag no-unneeded-ternary\r\n * @author Gyandeep Singh\r\n */\n\"use strict\";\n\nconst astUtils = require(\"./utils/ast-utils\"); // Operators that always result in a boolean value\n\n\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\nconst OPERATOR_INVERSES = {\n  \"==\": \"!=\",\n  \"!=\": \"==\",\n  \"===\": \"!==\",\n  \"!==\": \"===\" // Operators like < and >= are not true inverses, since both will return false with NaN.\n\n};\nconst OR_PRECEDENCE = astUtils.getPrecedence({\n  type: \"LogicalExpression\",\n  operator: \"||\"\n}); //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow ternary operators when simpler alternatives exist\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        defaultAssignment: {\n          type: \"boolean\",\n          default: true\n        }\n      },\n      additionalProperties: false\n    }],\n    fixable: \"code\",\n    messages: {\n      unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\n      unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const defaultAssignment = options.defaultAssignment !== false;\n    const sourceCode = context.getSourceCode();\n    /**\r\n     * Test if the node is a boolean literal\r\n     * @param {ASTNode} node The node to report.\r\n     * @returns {boolean} True if the its a boolean literal\r\n     * @private\r\n     */\n\n    function isBooleanLiteral(node) {\n      return node.type === \"Literal\" && typeof node.value === \"boolean\";\n    }\n    /**\r\n     * Creates an expression that represents the boolean inverse of the expression represented by the original node\r\n     * @param {ASTNode} node A node representing an expression\r\n     * @returns {string} A string representing an inverted expression\r\n     */\n\n\n    function invertExpression(node) {\n      if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\n        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);\n        const text = sourceCode.getText();\n        return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\n      }\n\n      if (astUtils.getPrecedence(node) < astUtils.getPrecedence({\n        type: \"UnaryExpression\"\n      })) {\n        return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\n      }\n\n      return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\n    }\n    /**\r\n     * Tests if a given node always evaluates to a boolean value\r\n     * @param {ASTNode} node An expression node\r\n     * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\r\n     */\n\n\n    function isBooleanExpression(node) {\n      return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) || node.type === \"UnaryExpression\" && node.operator === \"!\";\n    }\n    /**\r\n     * Test if the node matches the pattern id ? id : expression\r\n     * @param {ASTNode} node The ConditionalExpression to check.\r\n     * @returns {boolean} True if the pattern is matched, and false otherwise\r\n     * @private\r\n     */\n\n\n    function matchesDefaultAssignment(node) {\n      return node.test.type === \"Identifier\" && node.consequent.type === \"Identifier\" && node.test.name === node.consequent.name;\n    }\n\n    return {\n      ConditionalExpression(node) {\n        if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalExpression\",\n\n            fix(fixer) {\n              if (node.consequent.value === node.alternate.value) {\n                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\n                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\n              }\n\n              if (node.alternate.value) {\n                // Replace `foo() ? false : true` with `!(foo())`\n                return fixer.replaceText(node, invertExpression(node.test));\n              } // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\n\n\n              return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\n            }\n\n          });\n        } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n          context.report({\n            node,\n            messageId: \"unnecessaryConditionalAssignment\",\n            fix: fixer => {\n              const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);\n              const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);\n              const testText = astUtils.getParenthesisedText(sourceCode, node.test);\n              return fixer.replaceText(node, `${testText} || ${alternateText}`);\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/no-unneeded-ternary.js"],"names":["astUtils","require","BOOLEAN_OPERATORS","Set","OPERATOR_INVERSES","OR_PRECEDENCE","getPrecedence","type","operator","module","exports","meta","docs","description","recommended","url","schema","properties","defaultAssignment","default","additionalProperties","fixable","messages","unnecessaryConditionalExpression","unnecessaryConditionalAssignment","create","context","options","sourceCode","getSourceCode","isBooleanLiteral","node","value","invertExpression","Object","prototype","hasOwnProperty","call","operatorToken","getFirstTokenBetween","left","right","token","text","getText","slice","range","getParenthesisedText","isBooleanExpression","has","matchesDefaultAssignment","test","consequent","name","ConditionalExpression","alternate","report","messageId","fix","fixer","replaceText","toString","shouldParenthesizeAlternate","isCoalesceExpression","isParenthesised","alternateText","testText"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to flag no-unneeded-ternary\r\n * @author Gyandeep Singh\r\n */\r\n\r\n\"use strict\";\r\n\r\nconst astUtils = require(\"./utils/ast-utils\");\r\n\r\n// Operators that always result in a boolean value\r\nconst BOOLEAN_OPERATORS = new Set([\"==\", \"===\", \"!=\", \"!==\", \">\", \">=\", \"<\", \"<=\", \"in\", \"instanceof\"]);\r\nconst OPERATOR_INVERSES = {\r\n    \"==\": \"!=\",\r\n    \"!=\": \"==\",\r\n    \"===\": \"!==\",\r\n    \"!==\": \"===\"\r\n\r\n    // Operators like < and >= are not true inverses, since both will return false with NaN.\r\n};\r\nconst OR_PRECEDENCE = astUtils.getPrecedence({ type: \"LogicalExpression\", operator: \"||\" });\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow ternary operators when simpler alternatives exist\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/no-unneeded-ternary\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    defaultAssignment: {\r\n                        type: \"boolean\",\r\n                        default: true\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n\r\n        fixable: \"code\",\r\n\r\n        messages: {\r\n            unnecessaryConditionalExpression: \"Unnecessary use of boolean literals in conditional expression.\",\r\n            unnecessaryConditionalAssignment: \"Unnecessary use of conditional expression for default assignment.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const defaultAssignment = options.defaultAssignment !== false;\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        /**\r\n         * Test if the node is a boolean literal\r\n         * @param {ASTNode} node The node to report.\r\n         * @returns {boolean} True if the its a boolean literal\r\n         * @private\r\n         */\r\n        function isBooleanLiteral(node) {\r\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\r\n        }\r\n\r\n        /**\r\n         * Creates an expression that represents the boolean inverse of the expression represented by the original node\r\n         * @param {ASTNode} node A node representing an expression\r\n         * @returns {string} A string representing an inverted expression\r\n         */\r\n        function invertExpression(node) {\r\n            if (node.type === \"BinaryExpression\" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {\r\n                const operatorToken = sourceCode.getFirstTokenBetween(\r\n                    node.left,\r\n                    node.right,\r\n                    token => token.value === node.operator\r\n                );\r\n                const text = sourceCode.getText();\r\n\r\n                return text.slice(node.range[0],\r\n                    operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);\r\n            }\r\n\r\n            if (astUtils.getPrecedence(node) < astUtils.getPrecedence({ type: \"UnaryExpression\" })) {\r\n                return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;\r\n            }\r\n            return `!${astUtils.getParenthesisedText(sourceCode, node)}`;\r\n        }\r\n\r\n        /**\r\n         * Tests if a given node always evaluates to a boolean value\r\n         * @param {ASTNode} node An expression node\r\n         * @returns {boolean} True if it is determined that the node will always evaluate to a boolean value\r\n         */\r\n        function isBooleanExpression(node) {\r\n            return node.type === \"BinaryExpression\" && BOOLEAN_OPERATORS.has(node.operator) ||\r\n                node.type === \"UnaryExpression\" && node.operator === \"!\";\r\n        }\r\n\r\n        /**\r\n         * Test if the node matches the pattern id ? id : expression\r\n         * @param {ASTNode} node The ConditionalExpression to check.\r\n         * @returns {boolean} True if the pattern is matched, and false otherwise\r\n         * @private\r\n         */\r\n        function matchesDefaultAssignment(node) {\r\n            return node.test.type === \"Identifier\" &&\r\n                   node.consequent.type === \"Identifier\" &&\r\n                   node.test.name === node.consequent.name;\r\n        }\r\n\r\n        return {\r\n\r\n            ConditionalExpression(node) {\r\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unnecessaryConditionalExpression\",\r\n                        fix(fixer) {\r\n                            if (node.consequent.value === node.alternate.value) {\r\n\r\n                                // Replace `foo ? true : true` with just `true`, but don't replace `foo() ? true : true`\r\n                                return node.test.type === \"Identifier\" ? fixer.replaceText(node, node.consequent.value.toString()) : null;\r\n                            }\r\n                            if (node.alternate.value) {\r\n\r\n                                // Replace `foo() ? false : true` with `!(foo())`\r\n                                return fixer.replaceText(node, invertExpression(node.test));\r\n                            }\r\n\r\n                            // Replace `foo ? true : false` with `foo` if `foo` is guaranteed to be a boolean, or `!!foo` otherwise.\r\n\r\n                            return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);\r\n                        }\r\n                    });\r\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\r\n                    context.report({\r\n                        node,\r\n                        messageId: \"unnecessaryConditionalAssignment\",\r\n                        fix: fixer => {\r\n                            const shouldParenthesizeAlternate =\r\n                                (\r\n                                    astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE ||\r\n                                    astUtils.isCoalesceExpression(node.alternate)\r\n                                ) &&\r\n                                !astUtils.isParenthesised(sourceCode, node.alternate);\r\n                            const alternateText = shouldParenthesizeAlternate\r\n                                ? `(${sourceCode.getText(node.alternate)})`\r\n                                : astUtils.getParenthesisedText(sourceCode, node.alternate);\r\n                            const testText = astUtils.getParenthesisedText(sourceCode, node.test);\r\n\r\n                            return fixer.replaceText(node, `${testText} || ${alternateText}`);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}