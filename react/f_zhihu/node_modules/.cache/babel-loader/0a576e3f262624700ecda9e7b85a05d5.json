{"ast":null,"code":"/**\r\n * @fileoverview Rule that warns when identifier names are shorter or longer\r\n * than the values provided in configuration.\r\n * @author Burak Yigit Kaya aka BYK\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"enforce minimum and maximum identifier lengths\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-length\"\n    },\n    schema: [{\n      type: \"object\",\n      properties: {\n        min: {\n          type: \"integer\",\n          default: 2\n        },\n        max: {\n          type: \"integer\"\n        },\n        exceptions: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        exceptionPatterns: {\n          type: \"array\",\n          uniqueItems: true,\n          items: {\n            type: \"string\"\n          }\n        },\n        properties: {\n          enum: [\"always\", \"never\"]\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\n      tooShortPrivate: \"Identifier name '#{{name}}' is too short (< {{min}}).\",\n      tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\",\n      tooLongPrivate: \"Identifier name #'{{name}}' is too long (> {{max}}).\"\n    }\n  },\n\n  create(context) {\n    const options = context.options[0] || {};\n    const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\n    const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\n    const properties = options.properties !== \"never\";\n    const exceptions = new Set(options.exceptions);\n    const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\n    const reportedNodes = new Set();\n    /**\r\n     * Checks if a string matches the provided exception patterns\r\n     * @param {string} name The string to check.\r\n     * @returns {boolean} if the string is a match\r\n     * @private\r\n     */\n\n    function matchesExceptionPattern(name) {\n      return exceptionPatterns.some(pattern => pattern.test(name));\n    }\n\n    const SUPPORTED_EXPRESSIONS = {\n      MemberExpression: properties && function (parent) {\n        return !parent.computed && ( // regular property assignment\n        parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" || // or the last identifier in an ObjectPattern destructuring\n        parent.parent.type === \"Property\" && parent.parent.value === parent && parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent);\n      },\n\n      AssignmentPattern(parent, node) {\n        return parent.left === node;\n      },\n\n      VariableDeclarator(parent, node) {\n        return parent.id === node;\n      },\n\n      Property(parent, node) {\n        if (parent.parent.type === \"ObjectPattern\") {\n          const isKeyAndValueSame = parent.value.name === parent.key.name;\n          return !isKeyAndValueSame && parent.value === node || isKeyAndValueSame && parent.key === node && properties;\n        }\n\n        return properties && !parent.computed && parent.key.name === node.name;\n      },\n\n      ImportDefaultSpecifier: true,\n      RestElement: true,\n      FunctionExpression: true,\n      ArrowFunctionExpression: true,\n      ClassDeclaration: true,\n      FunctionDeclaration: true,\n      MethodDefinition: true,\n      PropertyDefinition: true,\n      CatchClause: true,\n      ArrayPattern: true\n    };\n    return {\n      [[\"Identifier\", \"PrivateIdentifier\"]](node) {\n        const name = node.name;\n        const parent = node.parent;\n        const isShort = name.length < minLength;\n        const isLong = name.length > maxLength;\n\n        if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\n          return; // Nothing to report\n        }\n\n        const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\n        /*\r\n         * We used the range instead of the node because it's possible\r\n         * for the same identifier to be represented by two different\r\n         * nodes, with the most clear example being shorthand properties:\r\n         * { foo }\r\n         * In this case, \"foo\" is represented by one node for the name\r\n         * and one for the value. The only way to know they are the same\r\n         * is to look at the range.\r\n         */\n\n        if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {\n          reportedNodes.add(node.range.toString());\n          let messageId = isShort ? \"tooShort\" : \"tooLong\";\n\n          if (node.type === \"PrivateIdentifier\") {\n            messageId += \"Private\";\n          }\n\n          context.report({\n            node,\n            messageId,\n            data: {\n              name,\n              min: minLength,\n              max: maxLength\n            }\n          });\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/id-length.js"],"names":["module","exports","meta","type","docs","description","recommended","url","schema","properties","min","default","max","exceptions","uniqueItems","items","exceptionPatterns","enum","additionalProperties","messages","tooShort","tooShortPrivate","tooLong","tooLongPrivate","create","context","options","minLength","maxLength","Infinity","Set","map","pattern","RegExp","reportedNodes","matchesExceptionPattern","name","some","test","SUPPORTED_EXPRESSIONS","MemberExpression","parent","computed","left","value","AssignmentPattern","node","VariableDeclarator","id","Property","isKeyAndValueSame","key","ImportDefaultSpecifier","RestElement","FunctionExpression","ArrowFunctionExpression","ClassDeclaration","FunctionDeclaration","MethodDefinition","PropertyDefinition","CatchClause","ArrayPattern","isShort","length","isLong","has","isValidExpression","range","toString","add","messageId","report","data"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule that warns when identifier names are shorter or longer\r\n * than the values provided in configuration.\r\n * @author Burak Yigit Kaya aka BYK\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"enforce minimum and maximum identifier lengths\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/id-length\"\r\n        },\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    min: {\r\n                        type: \"integer\",\r\n                        default: 2\r\n                    },\r\n                    max: {\r\n                        type: \"integer\"\r\n                    },\r\n                    exceptions: {\r\n                        type: \"array\",\r\n                        uniqueItems: true,\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    exceptionPatterns: {\r\n                        type: \"array\",\r\n                        uniqueItems: true,\r\n                        items: {\r\n                            type: \"string\"\r\n                        }\r\n                    },\r\n                    properties: {\r\n                        enum: [\"always\", \"never\"]\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            tooShort: \"Identifier name '{{name}}' is too short (< {{min}}).\",\r\n            tooShortPrivate: \"Identifier name '#{{name}}' is too short (< {{min}}).\",\r\n            tooLong: \"Identifier name '{{name}}' is too long (> {{max}}).\",\r\n            tooLongPrivate: \"Identifier name #'{{name}}' is too long (> {{max}}).\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const options = context.options[0] || {};\r\n        const minLength = typeof options.min !== \"undefined\" ? options.min : 2;\r\n        const maxLength = typeof options.max !== \"undefined\" ? options.max : Infinity;\r\n        const properties = options.properties !== \"never\";\r\n        const exceptions = new Set(options.exceptions);\r\n        const exceptionPatterns = (options.exceptionPatterns || []).map(pattern => new RegExp(pattern, \"u\"));\r\n        const reportedNodes = new Set();\r\n\r\n        /**\r\n         * Checks if a string matches the provided exception patterns\r\n         * @param {string} name The string to check.\r\n         * @returns {boolean} if the string is a match\r\n         * @private\r\n         */\r\n        function matchesExceptionPattern(name) {\r\n            return exceptionPatterns.some(pattern => pattern.test(name));\r\n        }\r\n\r\n        const SUPPORTED_EXPRESSIONS = {\r\n            MemberExpression: properties && function(parent) {\r\n                return !parent.computed && (\r\n\r\n                    // regular property assignment\r\n                    (parent.parent.left === parent && parent.parent.type === \"AssignmentExpression\" ||\r\n\r\n                    // or the last identifier in an ObjectPattern destructuring\r\n                    parent.parent.type === \"Property\" && parent.parent.value === parent &&\r\n                    parent.parent.parent.type === \"ObjectPattern\" && parent.parent.parent.parent.left === parent.parent.parent)\r\n                );\r\n            },\r\n            AssignmentPattern(parent, node) {\r\n                return parent.left === node;\r\n            },\r\n            VariableDeclarator(parent, node) {\r\n                return parent.id === node;\r\n            },\r\n            Property(parent, node) {\r\n\r\n                if (parent.parent.type === \"ObjectPattern\") {\r\n                    const isKeyAndValueSame = parent.value.name === parent.key.name;\r\n\r\n                    return (\r\n                        !isKeyAndValueSame && parent.value === node ||\r\n                        isKeyAndValueSame && parent.key === node && properties\r\n                    );\r\n                }\r\n                return properties && !parent.computed && parent.key.name === node.name;\r\n            },\r\n            ImportDefaultSpecifier: true,\r\n            RestElement: true,\r\n            FunctionExpression: true,\r\n            ArrowFunctionExpression: true,\r\n            ClassDeclaration: true,\r\n            FunctionDeclaration: true,\r\n            MethodDefinition: true,\r\n            PropertyDefinition: true,\r\n            CatchClause: true,\r\n            ArrayPattern: true\r\n        };\r\n\r\n        return {\r\n            [[\r\n                \"Identifier\",\r\n                \"PrivateIdentifier\"\r\n            ]](node) {\r\n                const name = node.name;\r\n                const parent = node.parent;\r\n\r\n                const isShort = name.length < minLength;\r\n                const isLong = name.length > maxLength;\r\n\r\n                if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {\r\n                    return; // Nothing to report\r\n                }\r\n\r\n                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];\r\n\r\n                /*\r\n                 * We used the range instead of the node because it's possible\r\n                 * for the same identifier to be represented by two different\r\n                 * nodes, with the most clear example being shorthand properties:\r\n                 * { foo }\r\n                 * In this case, \"foo\" is represented by one node for the name\r\n                 * and one for the value. The only way to know they are the same\r\n                 * is to look at the range.\r\n                 */\r\n                if (isValidExpression && !reportedNodes.has(node.range.toString()) && (isValidExpression === true || isValidExpression(parent, node))) {\r\n                    reportedNodes.add(node.range.toString());\r\n\r\n                    let messageId = isShort ? \"tooShort\" : \"tooLong\";\r\n\r\n                    if (node.type === \"PrivateIdentifier\") {\r\n                        messageId += \"Private\";\r\n                    }\r\n\r\n                    context.report({\r\n                        node,\r\n                        messageId,\r\n                        data: { name, min: minLength, max: maxLength }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}