{"ast":null,"code":"/**\r\n * @fileoverview Rule to enforce spacing before and after keywords.\r\n * @author Toru Nagashima\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nconst astUtils = require(\"./utils/ast-utils\"),\n      keywords = require(\"./utils/keywords\"); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\nconst PREV_TOKEN = /^[)\\]}>]$/u;\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\nconst NEXT_TOKEN_M = /^[{*]$/u;\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]); // check duplications.\n\n(function () {\n  KEYS.sort();\n\n  for (let i = 1; i < KEYS.length; ++i) {\n    if (KEYS[i] === KEYS[i - 1]) {\n      throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\n    }\n  }\n})(); //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\r\n * @param {Token} token A token to check.\r\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\r\n */\n\n\nfunction isOpenParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n/**\r\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\r\n * @param {Token} token A token to check.\r\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\r\n */\n\n\nfunction isCloseParenOfTemplate(token) {\n  return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"layout\",\n    docs: {\n      description: \"enforce consistent spacing before and after keywords\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/keyword-spacing\"\n    },\n    fixable: \"whitespace\",\n    schema: [{\n      type: \"object\",\n      properties: {\n        before: {\n          type: \"boolean\",\n          default: true\n        },\n        after: {\n          type: \"boolean\",\n          default: true\n        },\n        overrides: {\n          type: \"object\",\n          properties: KEYS.reduce((retv, key) => {\n            retv[key] = {\n              type: \"object\",\n              properties: {\n                before: {\n                  type: \"boolean\"\n                },\n                after: {\n                  type: \"boolean\"\n                }\n              },\n              additionalProperties: false\n            };\n            return retv;\n          }, {}),\n          additionalProperties: false\n        }\n      },\n      additionalProperties: false\n    }],\n    messages: {\n      expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\n      expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\n      unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n      unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\n    }\n  },\n\n  create(context) {\n    const sourceCode = context.getSourceCode();\n    const tokensToIgnore = new WeakSet();\n    /**\r\n     * Reports a given token if there are not space(s) before the token.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} pattern A pattern of the previous token to check.\r\n     * @returns {void}\r\n     */\n\n    function expectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextBefore(token, \" \");\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Reports a given token if there are space(s) before the token.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} pattern A pattern of the previous token to check.\r\n     * @returns {void}\r\n     */\n\n\n    function unexpectSpaceBefore(token, pattern) {\n      const prevToken = sourceCode.getTokenBefore(token);\n\n      if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && !tokensToIgnore.has(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {\n        context.report({\n          loc: {\n            start: prevToken.loc.end,\n            end: token.loc.start\n          },\n          messageId: \"unexpectedBefore\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([prevToken.range[1], token.range[0]]);\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Reports a given token if there are not space(s) after the token.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} pattern A pattern of the next token to check.\r\n     * @returns {void}\r\n     */\n\n\n    function expectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: token.loc,\n          messageId: \"expectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.insertTextAfter(token, \" \");\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Reports a given token if there are space(s) after the token.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} pattern A pattern of the next token to check.\r\n     * @returns {void}\r\n     */\n\n\n    function unexpectSpaceAfter(token, pattern) {\n      const nextToken = sourceCode.getTokenAfter(token);\n\n      if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && !tokensToIgnore.has(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {\n        context.report({\n          loc: {\n            start: token.loc.end,\n            end: nextToken.loc.start\n          },\n          messageId: \"unexpectedAfter\",\n          data: token,\n\n          fix(fixer) {\n            return fixer.removeRange([token.range[1], nextToken.range[0]]);\n          }\n\n        });\n      }\n    }\n    /**\r\n     * Parses the option object and determines check methods for each keyword.\r\n     * @param {Object|undefined} options The option object to parse.\r\n     * @returns {Object} - Normalized option object.\r\n     *      Keys are keywords (there are for every keyword).\r\n     *      Values are instances of `{\"before\": function, \"after\": function}`.\r\n     */\n\n\n    function parseOptions() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const before = options.before !== false;\n      const after = options.after !== false;\n      const defaultValue = {\n        before: before ? expectSpaceBefore : unexpectSpaceBefore,\n        after: after ? expectSpaceAfter : unexpectSpaceAfter\n      };\n      const overrides = options && options.overrides || {};\n      const retv = Object.create(null);\n\n      for (let i = 0; i < KEYS.length; ++i) {\n        const key = KEYS[i];\n        const override = overrides[key];\n\n        if (override) {\n          const thisBefore = \"before\" in override ? override.before : before;\n          const thisAfter = \"after\" in override ? override.after : after;\n          retv[key] = {\n            before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n            after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n          };\n        } else {\n          retv[key] = defaultValue;\n        }\n      }\n\n      return retv;\n    }\n\n    const checkMethodMap = parseOptions(context.options[0]);\n    /**\r\n     * Reports a given token if usage of spacing followed by the token is\r\n     * invalid.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} [pattern] Optional. A pattern of the previous\r\n     *      token to check.\r\n     * @returns {void}\r\n     */\n\n    function checkSpacingBefore(token, pattern) {\n      checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\n    }\n    /**\r\n     * Reports a given token if usage of spacing preceded by the token is\r\n     * invalid.\r\n     * @param {Token} token A token to report.\r\n     * @param {RegExp} [pattern] Optional. A pattern of the next\r\n     *      token to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingAfter(token, pattern) {\n      checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\n    }\n    /**\r\n     * Reports a given token if usage of spacing around the token is invalid.\r\n     * @param {Token} token A token to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingAround(token) {\n      checkSpacingBefore(token);\n      checkSpacingAfter(token);\n    }\n    /**\r\n     * Reports the first token of a given node if the first token is a keyword\r\n     * and usage of spacing around the token is invalid.\r\n     * @param {ASTNode|null} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingAroundFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingAround(firstToken);\n      }\n    }\n    /**\r\n     * Reports the first token of a given node if the first token is a keyword\r\n     * and usage of spacing followed by the token is invalid.\r\n     *\r\n     * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\r\n     * Other rules are handling usage of spacing preceded by those keywords.\r\n     * @param {ASTNode|null} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingBeforeFirstToken(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && firstToken.type === \"Keyword\") {\n        checkSpacingBefore(firstToken);\n      }\n    }\n    /**\r\n     * Reports the previous token of a given node if the token is a keyword and\r\n     * usage of spacing around the token is invalid.\r\n     * @param {ASTNode|null} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingAroundTokenBefore(node) {\n      if (node) {\n        const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\n        checkSpacingAround(token);\n      }\n    }\n    /**\r\n     * Reports `async` or `function` keywords of a given node if usage of\r\n     * spacing around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForFunction(node) {\n      const firstToken = node && sourceCode.getFirstToken(node);\n\n      if (firstToken && (firstToken.type === \"Keyword\" && firstToken.value === \"function\" || firstToken.value === \"async\")) {\n        checkSpacingBefore(firstToken);\n      }\n    }\n    /**\r\n     * Reports `class` and `extends` keywords of a given node if usage of\r\n     * spacing around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForClass(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.superClass);\n    }\n    /**\r\n     * Reports `if` and `else` keywords of a given node if usage of spacing\r\n     * around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForIfStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.alternate);\n    }\n    /**\r\n     * Reports `try`, `catch`, and `finally` keywords of a given node if usage\r\n     * of spacing around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForTryStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundFirstToken(node.handler);\n      checkSpacingAroundTokenBefore(node.finalizer);\n    }\n    /**\r\n     * Reports `do` and `while` keywords of a given node if usage of spacing\r\n     * around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForDoWhileStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      checkSpacingAroundTokenBefore(node.test);\n    }\n    /**\r\n     * Reports `for` and `in` keywords of a given node if usage of spacing\r\n     * around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForForInStatement(node) {\n      checkSpacingAroundFirstToken(node);\n      const inToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n      const previousToken = sourceCode.getTokenBefore(inToken);\n\n      if (previousToken.type !== \"PrivateIdentifier\") {\n        checkSpacingBefore(inToken);\n      }\n\n      checkSpacingAfter(inToken);\n    }\n    /**\r\n     * Reports `for` and `of` keywords of a given node if usage of spacing\r\n     * around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForForOfStatement(node) {\n      if (node.await) {\n        checkSpacingBefore(sourceCode.getFirstToken(node, 0));\n        checkSpacingAfter(sourceCode.getFirstToken(node, 1));\n      } else {\n        checkSpacingAroundFirstToken(node);\n      }\n\n      const ofToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n      const previousToken = sourceCode.getTokenBefore(ofToken);\n\n      if (previousToken.type !== \"PrivateIdentifier\") {\n        checkSpacingBefore(ofToken);\n      }\n\n      checkSpacingAfter(ofToken);\n    }\n    /**\r\n     * Reports `import`, `export`, `as`, and `from` keywords of a given node if\r\n     * usage of spacing around those keywords is invalid.\r\n     *\r\n     * This rule handles the `*` token in module declarations.\r\n     *\r\n     *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\r\n     *                               error Expected space(s) before \"as\".\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForModuleDeclaration(node) {\n      const firstToken = sourceCode.getFirstToken(node);\n      checkSpacingBefore(firstToken, PREV_TOKEN_M);\n      checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n      if (node.type === \"ExportDefaultDeclaration\") {\n        checkSpacingAround(sourceCode.getTokenAfter(firstToken));\n      }\n\n      if (node.type === \"ExportAllDeclaration\" && node.exported) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n        checkSpacingAfter(asToken, NEXT_TOKEN_M);\n      }\n\n      if (node.source) {\n        const fromToken = sourceCode.getTokenBefore(node.source);\n        checkSpacingBefore(fromToken, PREV_TOKEN_M);\n        checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n      }\n    }\n    /**\r\n     * Reports `as` keyword of a given node if usage of spacing around this\r\n     * keyword is invalid.\r\n     * @param {ASTNode} node An `ImportSpecifier` node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForImportSpecifier(node) {\n      if (node.imported.range[0] !== node.local.range[0]) {\n        const asToken = sourceCode.getTokenBefore(node.local);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n      }\n    }\n    /**\r\n     * Reports `as` keyword of a given node if usage of spacing around this\r\n     * keyword is invalid.\r\n     * @param {ASTNode} node An `ExportSpecifier` node to check.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForExportSpecifier(node) {\n      if (node.local.range[0] !== node.exported.range[0]) {\n        const asToken = sourceCode.getTokenBefore(node.exported);\n        checkSpacingBefore(asToken, PREV_TOKEN_M);\n        checkSpacingAfter(asToken, NEXT_TOKEN_M);\n      }\n    }\n    /**\r\n     * Reports `as` keyword of a given node if usage of spacing around this\r\n     * keyword is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForImportNamespaceSpecifier(node) {\n      const asToken = sourceCode.getFirstToken(node, 1);\n      checkSpacingBefore(asToken, PREV_TOKEN_M);\n    }\n    /**\r\n     * Reports `static`, `get`, and `set` keywords of a given node if usage of\r\n     * spacing around those keywords is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @throws {Error} If unable to find token get, set, or async beside method name.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForProperty(node) {\n      if (node.static) {\n        checkSpacingAroundFirstToken(node);\n      }\n\n      if (node.kind === \"get\" || node.kind === \"set\" || (node.method || node.type === \"MethodDefinition\") && node.value.async) {\n        const token = sourceCode.getTokenBefore(node.key, tok => {\n          switch (tok.value) {\n            case \"get\":\n            case \"set\":\n            case \"async\":\n              return true;\n\n            default:\n              return false;\n          }\n        });\n\n        if (!token) {\n          throw new Error(\"Failed to find token get, set, or async beside method name\");\n        }\n\n        checkSpacingAround(token);\n      }\n    }\n    /**\r\n     * Reports `await` keyword of a given node if usage of spacing before\r\n     * this keyword is invalid.\r\n     * @param {ASTNode} node A node to report.\r\n     * @returns {void}\r\n     */\n\n\n    function checkSpacingForAwaitExpression(node) {\n      checkSpacingBefore(sourceCode.getFirstToken(node));\n    }\n\n    return {\n      // Statements\n      DebuggerStatement: checkSpacingAroundFirstToken,\n      WithStatement: checkSpacingAroundFirstToken,\n      // Statements - Control flow\n      BreakStatement: checkSpacingAroundFirstToken,\n      ContinueStatement: checkSpacingAroundFirstToken,\n      ReturnStatement: checkSpacingAroundFirstToken,\n      ThrowStatement: checkSpacingAroundFirstToken,\n      TryStatement: checkSpacingForTryStatement,\n      // Statements - Choice\n      IfStatement: checkSpacingForIfStatement,\n      SwitchStatement: checkSpacingAroundFirstToken,\n      SwitchCase: checkSpacingAroundFirstToken,\n      // Statements - Loops\n      DoWhileStatement: checkSpacingForDoWhileStatement,\n      ForInStatement: checkSpacingForForInStatement,\n      ForOfStatement: checkSpacingForForOfStatement,\n      ForStatement: checkSpacingAroundFirstToken,\n      WhileStatement: checkSpacingAroundFirstToken,\n      // Statements - Declarations\n      ClassDeclaration: checkSpacingForClass,\n      ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n      ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\n      ExportAllDeclaration: checkSpacingForModuleDeclaration,\n      FunctionDeclaration: checkSpacingForFunction,\n      ImportDeclaration: checkSpacingForModuleDeclaration,\n      VariableDeclaration: checkSpacingAroundFirstToken,\n      // Expressions\n      ArrowFunctionExpression: checkSpacingForFunction,\n      AwaitExpression: checkSpacingForAwaitExpression,\n      ClassExpression: checkSpacingForClass,\n      FunctionExpression: checkSpacingForFunction,\n      NewExpression: checkSpacingBeforeFirstToken,\n      Super: checkSpacingBeforeFirstToken,\n      ThisExpression: checkSpacingBeforeFirstToken,\n      UnaryExpression: checkSpacingBeforeFirstToken,\n      YieldExpression: checkSpacingBeforeFirstToken,\n      // Others\n      ImportSpecifier: checkSpacingForImportSpecifier,\n      ExportSpecifier: checkSpacingForExportSpecifier,\n      ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n      MethodDefinition: checkSpacingForProperty,\n      PropertyDefinition: checkSpacingForProperty,\n      StaticBlock: checkSpacingAroundFirstToken,\n      Property: checkSpacingForProperty,\n\n      // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`\n      \"BinaryExpression[operator='>']\"(node) {\n        const operatorToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\n        tokensToIgnore.add(operatorToken);\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/keyword-spacing.js"],"names":["astUtils","require","keywords","PREV_TOKEN","NEXT_TOKEN","PREV_TOKEN_M","NEXT_TOKEN_M","TEMPLATE_OPEN_PAREN","TEMPLATE_CLOSE_PAREN","CHECK_TYPE","KEYS","concat","sort","i","length","Error","isOpenParenOfTemplate","token","type","test","value","isCloseParenOfTemplate","module","exports","meta","docs","description","recommended","url","fixable","schema","properties","before","default","after","overrides","reduce","retv","key","additionalProperties","messages","expectedBefore","expectedAfter","unexpectedBefore","unexpectedAfter","create","context","sourceCode","getSourceCode","tokensToIgnore","WeakSet","expectSpaceBefore","pattern","prevToken","getTokenBefore","has","isTokenOnSameLine","isSpaceBetweenTokens","report","loc","messageId","data","fix","fixer","insertTextBefore","unexpectSpaceBefore","start","end","removeRange","range","expectSpaceAfter","nextToken","getTokenAfter","insertTextAfter","unexpectSpaceAfter","parseOptions","options","defaultValue","Object","override","thisBefore","thisAfter","checkMethodMap","checkSpacingBefore","checkSpacingAfter","checkSpacingAround","checkSpacingAroundFirstToken","node","firstToken","getFirstToken","checkSpacingBeforeFirstToken","checkSpacingAroundTokenBefore","isKeywordToken","checkSpacingForFunction","checkSpacingForClass","superClass","checkSpacingForIfStatement","alternate","checkSpacingForTryStatement","handler","finalizer","checkSpacingForDoWhileStatement","checkSpacingForForInStatement","inToken","right","isNotOpeningParenToken","previousToken","checkSpacingForForOfStatement","await","ofToken","checkSpacingForModuleDeclaration","exported","asToken","source","fromToken","checkSpacingForImportSpecifier","imported","local","checkSpacingForExportSpecifier","checkSpacingForImportNamespaceSpecifier","checkSpacingForProperty","static","kind","method","async","tok","checkSpacingForAwaitExpression","DebuggerStatement","WithStatement","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","TryStatement","IfStatement","SwitchStatement","SwitchCase","DoWhileStatement","ForInStatement","ForOfStatement","ForStatement","WhileStatement","ClassDeclaration","ExportNamedDeclaration","ExportDefaultDeclaration","ExportAllDeclaration","FunctionDeclaration","ImportDeclaration","VariableDeclaration","ArrowFunctionExpression","AwaitExpression","ClassExpression","FunctionExpression","NewExpression","Super","ThisExpression","UnaryExpression","YieldExpression","ImportSpecifier","ExportSpecifier","ImportNamespaceSpecifier","MethodDefinition","PropertyDefinition","StaticBlock","Property","operatorToken","add"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule to enforce spacing before and after keywords.\r\n * @author Toru Nagashima\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Requirements\r\n//------------------------------------------------------------------------------\r\n\r\nconst astUtils = require(\"./utils/ast-utils\"),\r\n    keywords = require(\"./utils/keywords\");\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\nconst PREV_TOKEN = /^[)\\]}>]$/u;\r\nconst NEXT_TOKEN = /^(?:[([{<~!]|\\+\\+?|--?)$/u;\r\nconst PREV_TOKEN_M = /^[)\\]}>*]$/u;\r\nconst NEXT_TOKEN_M = /^[{*]$/u;\r\nconst TEMPLATE_OPEN_PAREN = /\\$\\{$/u;\r\nconst TEMPLATE_CLOSE_PAREN = /^\\}/u;\r\nconst CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template|PrivateIdentifier)$/u;\r\nconst KEYS = keywords.concat([\"as\", \"async\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\r\n\r\n// check duplications.\r\n(function() {\r\n    KEYS.sort();\r\n    for (let i = 1; i < KEYS.length; ++i) {\r\n        if (KEYS[i] === KEYS[i - 1]) {\r\n            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);\r\n        }\r\n    }\r\n}());\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\r\n * @param {Token} token A token to check.\r\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\r\n */\r\nfunction isOpenParenOfTemplate(token) {\r\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\r\n}\r\n\r\n/**\r\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\r\n * @param {Token} token A token to check.\r\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\r\n */\r\nfunction isCloseParenOfTemplate(token) {\r\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"layout\",\r\n\r\n        docs: {\r\n            description: \"enforce consistent spacing before and after keywords\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/keyword-spacing\"\r\n        },\r\n\r\n        fixable: \"whitespace\",\r\n\r\n        schema: [\r\n            {\r\n                type: \"object\",\r\n                properties: {\r\n                    before: { type: \"boolean\", default: true },\r\n                    after: { type: \"boolean\", default: true },\r\n                    overrides: {\r\n                        type: \"object\",\r\n                        properties: KEYS.reduce((retv, key) => {\r\n                            retv[key] = {\r\n                                type: \"object\",\r\n                                properties: {\r\n                                    before: { type: \"boolean\" },\r\n                                    after: { type: \"boolean\" }\r\n                                },\r\n                                additionalProperties: false\r\n                            };\r\n                            return retv;\r\n                        }, {}),\r\n                        additionalProperties: false\r\n                    }\r\n                },\r\n                additionalProperties: false\r\n            }\r\n        ],\r\n        messages: {\r\n            expectedBefore: \"Expected space(s) before \\\"{{value}}\\\".\",\r\n            expectedAfter: \"Expected space(s) after \\\"{{value}}\\\".\",\r\n            unexpectedBefore: \"Unexpected space(s) before \\\"{{value}}\\\".\",\r\n            unexpectedAfter: \"Unexpected space(s) after \\\"{{value}}\\\".\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n        const sourceCode = context.getSourceCode();\r\n\r\n        const tokensToIgnore = new WeakSet();\r\n\r\n        /**\r\n         * Reports a given token if there are not space(s) before the token.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} pattern A pattern of the previous token to check.\r\n         * @returns {void}\r\n         */\r\n        function expectSpaceBefore(token, pattern) {\r\n            const prevToken = sourceCode.getTokenBefore(token);\r\n\r\n            if (prevToken &&\r\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\r\n                !isOpenParenOfTemplate(prevToken) &&\r\n                !tokensToIgnore.has(prevToken) &&\r\n                astUtils.isTokenOnSameLine(prevToken, token) &&\r\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\r\n            ) {\r\n                context.report({\r\n                    loc: token.loc,\r\n                    messageId: \"expectedBefore\",\r\n                    data: token,\r\n                    fix(fixer) {\r\n                        return fixer.insertTextBefore(token, \" \");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports a given token if there are space(s) before the token.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} pattern A pattern of the previous token to check.\r\n         * @returns {void}\r\n         */\r\n        function unexpectSpaceBefore(token, pattern) {\r\n            const prevToken = sourceCode.getTokenBefore(token);\r\n\r\n            if (prevToken &&\r\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\r\n                !isOpenParenOfTemplate(prevToken) &&\r\n                !tokensToIgnore.has(prevToken) &&\r\n                astUtils.isTokenOnSameLine(prevToken, token) &&\r\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\r\n            ) {\r\n                context.report({\r\n                    loc: { start: prevToken.loc.end, end: token.loc.start },\r\n                    messageId: \"unexpectedBefore\",\r\n                    data: token,\r\n                    fix(fixer) {\r\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports a given token if there are not space(s) after the token.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} pattern A pattern of the next token to check.\r\n         * @returns {void}\r\n         */\r\n        function expectSpaceAfter(token, pattern) {\r\n            const nextToken = sourceCode.getTokenAfter(token);\r\n\r\n            if (nextToken &&\r\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\r\n                !isCloseParenOfTemplate(nextToken) &&\r\n                !tokensToIgnore.has(nextToken) &&\r\n                astUtils.isTokenOnSameLine(token, nextToken) &&\r\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\r\n            ) {\r\n                context.report({\r\n                    loc: token.loc,\r\n                    messageId: \"expectedAfter\",\r\n                    data: token,\r\n                    fix(fixer) {\r\n                        return fixer.insertTextAfter(token, \" \");\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports a given token if there are space(s) after the token.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} pattern A pattern of the next token to check.\r\n         * @returns {void}\r\n         */\r\n        function unexpectSpaceAfter(token, pattern) {\r\n            const nextToken = sourceCode.getTokenAfter(token);\r\n\r\n            if (nextToken &&\r\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\r\n                !isCloseParenOfTemplate(nextToken) &&\r\n                !tokensToIgnore.has(nextToken) &&\r\n                astUtils.isTokenOnSameLine(token, nextToken) &&\r\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\r\n            ) {\r\n\r\n                context.report({\r\n                    loc: { start: token.loc.end, end: nextToken.loc.start },\r\n                    messageId: \"unexpectedAfter\",\r\n                    data: token,\r\n                    fix(fixer) {\r\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Parses the option object and determines check methods for each keyword.\r\n         * @param {Object|undefined} options The option object to parse.\r\n         * @returns {Object} - Normalized option object.\r\n         *      Keys are keywords (there are for every keyword).\r\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\r\n         */\r\n        function parseOptions(options = {}) {\r\n            const before = options.before !== false;\r\n            const after = options.after !== false;\r\n            const defaultValue = {\r\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\r\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\r\n            };\r\n            const overrides = (options && options.overrides) || {};\r\n            const retv = Object.create(null);\r\n\r\n            for (let i = 0; i < KEYS.length; ++i) {\r\n                const key = KEYS[i];\r\n                const override = overrides[key];\r\n\r\n                if (override) {\r\n                    const thisBefore = (\"before\" in override) ? override.before : before;\r\n                    const thisAfter = (\"after\" in override) ? override.after : after;\r\n\r\n                    retv[key] = {\r\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\r\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\r\n                    };\r\n                } else {\r\n                    retv[key] = defaultValue;\r\n                }\r\n            }\r\n\r\n            return retv;\r\n        }\r\n\r\n        const checkMethodMap = parseOptions(context.options[0]);\r\n\r\n        /**\r\n         * Reports a given token if usage of spacing followed by the token is\r\n         * invalid.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} [pattern] Optional. A pattern of the previous\r\n         *      token to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingBefore(token, pattern) {\r\n            checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);\r\n        }\r\n\r\n        /**\r\n         * Reports a given token if usage of spacing preceded by the token is\r\n         * invalid.\r\n         * @param {Token} token A token to report.\r\n         * @param {RegExp} [pattern] Optional. A pattern of the next\r\n         *      token to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingAfter(token, pattern) {\r\n            checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);\r\n        }\r\n\r\n        /**\r\n         * Reports a given token if usage of spacing around the token is invalid.\r\n         * @param {Token} token A token to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingAround(token) {\r\n            checkSpacingBefore(token);\r\n            checkSpacingAfter(token);\r\n        }\r\n\r\n        /**\r\n         * Reports the first token of a given node if the first token is a keyword\r\n         * and usage of spacing around the token is invalid.\r\n         * @param {ASTNode|null} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingAroundFirstToken(node) {\r\n            const firstToken = node && sourceCode.getFirstToken(node);\r\n\r\n            if (firstToken && firstToken.type === \"Keyword\") {\r\n                checkSpacingAround(firstToken);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports the first token of a given node if the first token is a keyword\r\n         * and usage of spacing followed by the token is invalid.\r\n         *\r\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\r\n         * Other rules are handling usage of spacing preceded by those keywords.\r\n         * @param {ASTNode|null} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingBeforeFirstToken(node) {\r\n            const firstToken = node && sourceCode.getFirstToken(node);\r\n\r\n            if (firstToken && firstToken.type === \"Keyword\") {\r\n                checkSpacingBefore(firstToken);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports the previous token of a given node if the token is a keyword and\r\n         * usage of spacing around the token is invalid.\r\n         * @param {ASTNode|null} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingAroundTokenBefore(node) {\r\n            if (node) {\r\n                const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);\r\n\r\n                checkSpacingAround(token);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `async` or `function` keywords of a given node if usage of\r\n         * spacing around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForFunction(node) {\r\n            const firstToken = node && sourceCode.getFirstToken(node);\r\n\r\n            if (firstToken &&\r\n                ((firstToken.type === \"Keyword\" && firstToken.value === \"function\") ||\r\n                firstToken.value === \"async\")\r\n            ) {\r\n                checkSpacingBefore(firstToken);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `class` and `extends` keywords of a given node if usage of\r\n         * spacing around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForClass(node) {\r\n            checkSpacingAroundFirstToken(node);\r\n            checkSpacingAroundTokenBefore(node.superClass);\r\n        }\r\n\r\n        /**\r\n         * Reports `if` and `else` keywords of a given node if usage of spacing\r\n         * around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForIfStatement(node) {\r\n            checkSpacingAroundFirstToken(node);\r\n            checkSpacingAroundTokenBefore(node.alternate);\r\n        }\r\n\r\n        /**\r\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\r\n         * of spacing around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForTryStatement(node) {\r\n            checkSpacingAroundFirstToken(node);\r\n            checkSpacingAroundFirstToken(node.handler);\r\n            checkSpacingAroundTokenBefore(node.finalizer);\r\n        }\r\n\r\n        /**\r\n         * Reports `do` and `while` keywords of a given node if usage of spacing\r\n         * around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForDoWhileStatement(node) {\r\n            checkSpacingAroundFirstToken(node);\r\n            checkSpacingAroundTokenBefore(node.test);\r\n        }\r\n\r\n        /**\r\n         * Reports `for` and `in` keywords of a given node if usage of spacing\r\n         * around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForForInStatement(node) {\r\n            checkSpacingAroundFirstToken(node);\r\n\r\n            const inToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\r\n            const previousToken = sourceCode.getTokenBefore(inToken);\r\n\r\n            if (previousToken.type !== \"PrivateIdentifier\") {\r\n                checkSpacingBefore(inToken);\r\n            }\r\n\r\n            checkSpacingAfter(inToken);\r\n        }\r\n\r\n        /**\r\n         * Reports `for` and `of` keywords of a given node if usage of spacing\r\n         * around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForForOfStatement(node) {\r\n            if (node.await) {\r\n                checkSpacingBefore(sourceCode.getFirstToken(node, 0));\r\n                checkSpacingAfter(sourceCode.getFirstToken(node, 1));\r\n            } else {\r\n                checkSpacingAroundFirstToken(node);\r\n            }\r\n\r\n            const ofToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\r\n            const previousToken = sourceCode.getTokenBefore(ofToken);\r\n\r\n            if (previousToken.type !== \"PrivateIdentifier\") {\r\n                checkSpacingBefore(ofToken);\r\n            }\r\n\r\n            checkSpacingAfter(ofToken);\r\n        }\r\n\r\n        /**\r\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\r\n         * usage of spacing around those keywords is invalid.\r\n         *\r\n         * This rule handles the `*` token in module declarations.\r\n         *\r\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\r\n         *                               error Expected space(s) before \"as\".\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForModuleDeclaration(node) {\r\n            const firstToken = sourceCode.getFirstToken(node);\r\n\r\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\r\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\r\n\r\n            if (node.type === \"ExportDefaultDeclaration\") {\r\n                checkSpacingAround(sourceCode.getTokenAfter(firstToken));\r\n            }\r\n\r\n            if (node.type === \"ExportAllDeclaration\" && node.exported) {\r\n                const asToken = sourceCode.getTokenBefore(node.exported);\r\n\r\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\r\n                checkSpacingAfter(asToken, NEXT_TOKEN_M);\r\n            }\r\n\r\n            if (node.source) {\r\n                const fromToken = sourceCode.getTokenBefore(node.source);\r\n\r\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\r\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `as` keyword of a given node if usage of spacing around this\r\n         * keyword is invalid.\r\n         * @param {ASTNode} node An `ImportSpecifier` node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForImportSpecifier(node) {\r\n            if (node.imported.range[0] !== node.local.range[0]) {\r\n                const asToken = sourceCode.getTokenBefore(node.local);\r\n\r\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `as` keyword of a given node if usage of spacing around this\r\n         * keyword is invalid.\r\n         * @param {ASTNode} node An `ExportSpecifier` node to check.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForExportSpecifier(node) {\r\n            if (node.local.range[0] !== node.exported.range[0]) {\r\n                const asToken = sourceCode.getTokenBefore(node.exported);\r\n\r\n                checkSpacingBefore(asToken, PREV_TOKEN_M);\r\n                checkSpacingAfter(asToken, NEXT_TOKEN_M);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `as` keyword of a given node if usage of spacing around this\r\n         * keyword is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForImportNamespaceSpecifier(node) {\r\n            const asToken = sourceCode.getFirstToken(node, 1);\r\n\r\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\r\n        }\r\n\r\n        /**\r\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\r\n         * spacing around those keywords is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @throws {Error} If unable to find token get, set, or async beside method name.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForProperty(node) {\r\n            if (node.static) {\r\n                checkSpacingAroundFirstToken(node);\r\n            }\r\n            if (node.kind === \"get\" ||\r\n                node.kind === \"set\" ||\r\n                (\r\n                    (node.method || node.type === \"MethodDefinition\") &&\r\n                    node.value.async\r\n                )\r\n            ) {\r\n                const token = sourceCode.getTokenBefore(\r\n                    node.key,\r\n                    tok => {\r\n                        switch (tok.value) {\r\n                            case \"get\":\r\n                            case \"set\":\r\n                            case \"async\":\r\n                                return true;\r\n                            default:\r\n                                return false;\r\n                        }\r\n                    }\r\n                );\r\n\r\n                if (!token) {\r\n                    throw new Error(\"Failed to find token get, set, or async beside method name\");\r\n                }\r\n\r\n\r\n                checkSpacingAround(token);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Reports `await` keyword of a given node if usage of spacing before\r\n         * this keyword is invalid.\r\n         * @param {ASTNode} node A node to report.\r\n         * @returns {void}\r\n         */\r\n        function checkSpacingForAwaitExpression(node) {\r\n            checkSpacingBefore(sourceCode.getFirstToken(node));\r\n        }\r\n\r\n        return {\r\n\r\n            // Statements\r\n            DebuggerStatement: checkSpacingAroundFirstToken,\r\n            WithStatement: checkSpacingAroundFirstToken,\r\n\r\n            // Statements - Control flow\r\n            BreakStatement: checkSpacingAroundFirstToken,\r\n            ContinueStatement: checkSpacingAroundFirstToken,\r\n            ReturnStatement: checkSpacingAroundFirstToken,\r\n            ThrowStatement: checkSpacingAroundFirstToken,\r\n            TryStatement: checkSpacingForTryStatement,\r\n\r\n            // Statements - Choice\r\n            IfStatement: checkSpacingForIfStatement,\r\n            SwitchStatement: checkSpacingAroundFirstToken,\r\n            SwitchCase: checkSpacingAroundFirstToken,\r\n\r\n            // Statements - Loops\r\n            DoWhileStatement: checkSpacingForDoWhileStatement,\r\n            ForInStatement: checkSpacingForForInStatement,\r\n            ForOfStatement: checkSpacingForForOfStatement,\r\n            ForStatement: checkSpacingAroundFirstToken,\r\n            WhileStatement: checkSpacingAroundFirstToken,\r\n\r\n            // Statements - Declarations\r\n            ClassDeclaration: checkSpacingForClass,\r\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\r\n            ExportDefaultDeclaration: checkSpacingForModuleDeclaration,\r\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\r\n            FunctionDeclaration: checkSpacingForFunction,\r\n            ImportDeclaration: checkSpacingForModuleDeclaration,\r\n            VariableDeclaration: checkSpacingAroundFirstToken,\r\n\r\n            // Expressions\r\n            ArrowFunctionExpression: checkSpacingForFunction,\r\n            AwaitExpression: checkSpacingForAwaitExpression,\r\n            ClassExpression: checkSpacingForClass,\r\n            FunctionExpression: checkSpacingForFunction,\r\n            NewExpression: checkSpacingBeforeFirstToken,\r\n            Super: checkSpacingBeforeFirstToken,\r\n            ThisExpression: checkSpacingBeforeFirstToken,\r\n            UnaryExpression: checkSpacingBeforeFirstToken,\r\n            YieldExpression: checkSpacingBeforeFirstToken,\r\n\r\n            // Others\r\n            ImportSpecifier: checkSpacingForImportSpecifier,\r\n            ExportSpecifier: checkSpacingForExportSpecifier,\r\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\r\n            MethodDefinition: checkSpacingForProperty,\r\n            PropertyDefinition: checkSpacingForProperty,\r\n            StaticBlock: checkSpacingAroundFirstToken,\r\n            Property: checkSpacingForProperty,\r\n\r\n            // To avoid conflicts with `space-infix-ops`, e.g. `a > this.b`\r\n            \"BinaryExpression[operator='>']\"(node) {\r\n                const operatorToken = sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken);\r\n\r\n                tokensToIgnore.add(operatorToken);\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}