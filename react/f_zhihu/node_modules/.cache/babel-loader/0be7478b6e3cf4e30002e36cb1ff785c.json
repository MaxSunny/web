{"ast":null,"code":"/**\r\n * @fileoverview Rule that warns when identifier names that are\r\n * specified in the configuration are used.\r\n * @author Keith Cirkel (http://keithcirkel.co.uk)\r\n */\n\"use strict\"; //------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\r\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is assignment target.\r\n */\n\nfunction isAssignmentTarget(node) {\n  const parent = node.parent;\n  return (// normal assignment\n    parent.type === \"AssignmentExpression\" && parent.left === node || // destructuring\n    parent.type === \"ArrayPattern\" || parent.type === \"RestElement\" || parent.type === \"Property\" && parent.value === node && parent.parent.type === \"ObjectPattern\" || parent.type === \"AssignmentPattern\" && parent.left === node\n  );\n}\n/**\r\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\r\n *\r\n * Examples:\r\n * import { a as b } from 'mod'; // node `a` is renamed import\r\n * export { a as b } from 'mod'; // node `a` is renamed import\r\n * @param {ASTNode} node `Identifier` node to check.\r\n * @returns {boolean} `true` if the node is a renamed import.\r\n */\n\n\nfunction isRenamedImport(node) {\n  const parent = node.parent;\n  return parent.type === \"ImportSpecifier\" && parent.imported !== parent.local && parent.imported === node || parent.type === \"ExportSpecifier\" && parent.parent.source && // re-export\n  parent.local !== parent.exported && parent.local === node;\n}\n/**\r\n * Checks whether the given node is an ObjectPattern destructuring.\r\n *\r\n * Examples:\r\n * const { a : b } = foo;\r\n * @param {ASTNode} node `Identifier` node to check.\r\n * @returns {boolean} `true` if the node is in an ObjectPattern destructuring.\r\n */\n\n\nfunction isPropertyNameInDestructuring(node) {\n  const parent = node.parent;\n  return !parent.computed && parent.type === \"Property\" && parent.parent.type === \"ObjectPattern\" && parent.key === node;\n} //------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/** @type {import('../shared/types').Rule} */\n\n\nmodule.exports = {\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description: \"disallow specified identifiers\",\n      recommended: false,\n      url: \"https://eslint.org/docs/rules/id-denylist\"\n    },\n    schema: {\n      type: \"array\",\n      items: {\n        type: \"string\"\n      },\n      uniqueItems: true\n    },\n    messages: {\n      restricted: \"Identifier '{{name}}' is restricted.\",\n      restrictedPrivate: \"Identifier '#{{name}}' is restricted.\"\n    }\n  },\n\n  create(context) {\n    const denyList = new Set(context.options);\n    const reportedNodes = new Set();\n    let globalScope;\n    /**\r\n     * Checks whether the given name is restricted.\r\n     * @param {string} name The name to check.\r\n     * @returns {boolean} `true` if the name is restricted.\r\n     * @private\r\n     */\n\n    function isRestricted(name) {\n      return denyList.has(name);\n    }\n    /**\r\n     * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n     * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n     * @param {ASTNode} node `Identifier` node to check.\r\n     * @returns {boolean} `true` if the node is a reference to a global variable.\r\n     */\n\n\n    function isReferenceToGlobalVariable(node) {\n      const variable = globalScope.set.get(node.name);\n      return variable && variable.defs.length === 0 && variable.references.some(ref => ref.identifier === node);\n    }\n    /**\r\n     * Determines whether the given node should be checked.\r\n     * @param {ASTNode} node `Identifier` node.\r\n     * @returns {boolean} `true` if the node should be checked.\r\n     */\n\n\n    function shouldCheck(node) {\n      const parent = node.parent;\n      /*\r\n       * Member access has special rules for checking property names.\r\n       * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\r\n       * Write access isn't allowed, because it potentially creates a new property with a restricted name.\r\n       */\n\n      if (parent.type === \"MemberExpression\" && parent.property === node && !parent.computed) {\n        return isAssignmentTarget(parent);\n      }\n\n      return parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\" && !isRenamedImport(node) && !isPropertyNameInDestructuring(node) && !isReferenceToGlobalVariable(node);\n    }\n    /**\r\n     * Reports an AST node as a rule violation.\r\n     * @param {ASTNode} node The node to report.\r\n     * @returns {void}\r\n     * @private\r\n     */\n\n\n    function report(node) {\n      /*\r\n       * We used the range instead of the node because it's possible\r\n       * for the same identifier to be represented by two different\r\n       * nodes, with the most clear example being shorthand properties:\r\n       * { foo }\r\n       * In this case, \"foo\" is represented by one node for the name\r\n       * and one for the value. The only way to know they are the same\r\n       * is to look at the range.\r\n       */\n      if (!reportedNodes.has(node.range.toString())) {\n        const isPrivate = node.type === \"PrivateIdentifier\";\n        context.report({\n          node,\n          messageId: isPrivate ? \"restrictedPrivate\" : \"restricted\",\n          data: {\n            name: node.name\n          }\n        });\n        reportedNodes.add(node.range.toString());\n      }\n    }\n\n    return {\n      Program() {\n        globalScope = context.getScope();\n      },\n\n      [[\"Identifier\", \"PrivateIdentifier\"]](node) {\n        if (isRestricted(node.name) && shouldCheck(node)) {\n          report(node);\n        }\n      }\n\n    };\n  }\n\n};","map":{"version":3,"sources":["C:/Users/2928/Desktop/zhuawa/notes/project_demo/react_project/node_modules/eslint/lib/rules/id-denylist.js"],"names":["isAssignmentTarget","node","parent","type","left","value","isRenamedImport","imported","local","source","exported","isPropertyNameInDestructuring","computed","key","module","exports","meta","docs","description","recommended","url","schema","items","uniqueItems","messages","restricted","restrictedPrivate","create","context","denyList","Set","options","reportedNodes","globalScope","isRestricted","name","has","isReferenceToGlobalVariable","variable","set","get","defs","length","references","some","ref","identifier","shouldCheck","property","report","range","toString","isPrivate","messageId","data","add","Program","getScope"],"mappings":"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","sourcesContent":["/**\r\n * @fileoverview Rule that warns when identifier names that are\r\n * specified in the configuration are used.\r\n * @author Keith Cirkel (http://keithcirkel.co.uk)\r\n */\r\n\r\n\"use strict\";\r\n\r\n//------------------------------------------------------------------------------\r\n// Helpers\r\n//------------------------------------------------------------------------------\r\n\r\n/**\r\n * Checks whether the given node represents assignment target in a normal assignment or destructuring.\r\n * @param {ASTNode} node The node to check.\r\n * @returns {boolean} `true` if the node is assignment target.\r\n */\r\nfunction isAssignmentTarget(node) {\r\n    const parent = node.parent;\r\n\r\n    return (\r\n\r\n        // normal assignment\r\n        (\r\n            parent.type === \"AssignmentExpression\" &&\r\n            parent.left === node\r\n        ) ||\r\n\r\n        // destructuring\r\n        parent.type === \"ArrayPattern\" ||\r\n        parent.type === \"RestElement\" ||\r\n        (\r\n            parent.type === \"Property\" &&\r\n            parent.value === node &&\r\n            parent.parent.type === \"ObjectPattern\"\r\n        ) ||\r\n        (\r\n            parent.type === \"AssignmentPattern\" &&\r\n            parent.left === node\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether the given node represents an imported name that is renamed in the same import/export specifier.\r\n *\r\n * Examples:\r\n * import { a as b } from 'mod'; // node `a` is renamed import\r\n * export { a as b } from 'mod'; // node `a` is renamed import\r\n * @param {ASTNode} node `Identifier` node to check.\r\n * @returns {boolean} `true` if the node is a renamed import.\r\n */\r\nfunction isRenamedImport(node) {\r\n    const parent = node.parent;\r\n\r\n    return (\r\n        (\r\n            parent.type === \"ImportSpecifier\" &&\r\n            parent.imported !== parent.local &&\r\n            parent.imported === node\r\n        ) ||\r\n        (\r\n            parent.type === \"ExportSpecifier\" &&\r\n            parent.parent.source && // re-export\r\n            parent.local !== parent.exported &&\r\n            parent.local === node\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * Checks whether the given node is an ObjectPattern destructuring.\r\n *\r\n * Examples:\r\n * const { a : b } = foo;\r\n * @param {ASTNode} node `Identifier` node to check.\r\n * @returns {boolean} `true` if the node is in an ObjectPattern destructuring.\r\n */\r\nfunction isPropertyNameInDestructuring(node) {\r\n    const parent = node.parent;\r\n\r\n    return (\r\n        (\r\n            !parent.computed &&\r\n            parent.type === \"Property\" &&\r\n            parent.parent.type === \"ObjectPattern\" &&\r\n            parent.key === node\r\n        )\r\n    );\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// Rule Definition\r\n//------------------------------------------------------------------------------\r\n\r\n/** @type {import('../shared/types').Rule} */\r\nmodule.exports = {\r\n    meta: {\r\n        type: \"suggestion\",\r\n\r\n        docs: {\r\n            description: \"disallow specified identifiers\",\r\n            recommended: false,\r\n            url: \"https://eslint.org/docs/rules/id-denylist\"\r\n        },\r\n\r\n        schema: {\r\n            type: \"array\",\r\n            items: {\r\n                type: \"string\"\r\n            },\r\n            uniqueItems: true\r\n        },\r\n        messages: {\r\n            restricted: \"Identifier '{{name}}' is restricted.\",\r\n            restrictedPrivate: \"Identifier '#{{name}}' is restricted.\"\r\n        }\r\n    },\r\n\r\n    create(context) {\r\n\r\n        const denyList = new Set(context.options);\r\n        const reportedNodes = new Set();\r\n\r\n        let globalScope;\r\n\r\n        /**\r\n         * Checks whether the given name is restricted.\r\n         * @param {string} name The name to check.\r\n         * @returns {boolean} `true` if the name is restricted.\r\n         * @private\r\n         */\r\n        function isRestricted(name) {\r\n            return denyList.has(name);\r\n        }\r\n\r\n        /**\r\n         * Checks whether the given node represents a reference to a global variable that is not declared in the source code.\r\n         * These identifiers will be allowed, as it is assumed that user has no control over the names of external global variables.\r\n         * @param {ASTNode} node `Identifier` node to check.\r\n         * @returns {boolean} `true` if the node is a reference to a global variable.\r\n         */\r\n        function isReferenceToGlobalVariable(node) {\r\n            const variable = globalScope.set.get(node.name);\r\n\r\n            return variable && variable.defs.length === 0 &&\r\n                variable.references.some(ref => ref.identifier === node);\r\n        }\r\n\r\n        /**\r\n         * Determines whether the given node should be checked.\r\n         * @param {ASTNode} node `Identifier` node.\r\n         * @returns {boolean} `true` if the node should be checked.\r\n         */\r\n        function shouldCheck(node) {\r\n            const parent = node.parent;\r\n\r\n            /*\r\n             * Member access has special rules for checking property names.\r\n             * Read access to a property with a restricted name is allowed, because it can be on an object that user has no control over.\r\n             * Write access isn't allowed, because it potentially creates a new property with a restricted name.\r\n             */\r\n            if (\r\n                parent.type === \"MemberExpression\" &&\r\n                parent.property === node &&\r\n                !parent.computed\r\n            ) {\r\n                return isAssignmentTarget(parent);\r\n            }\r\n\r\n            return (\r\n                parent.type !== \"CallExpression\" &&\r\n                parent.type !== \"NewExpression\" &&\r\n                !isRenamedImport(node) &&\r\n                !isPropertyNameInDestructuring(node) &&\r\n                !isReferenceToGlobalVariable(node)\r\n            );\r\n        }\r\n\r\n        /**\r\n         * Reports an AST node as a rule violation.\r\n         * @param {ASTNode} node The node to report.\r\n         * @returns {void}\r\n         * @private\r\n         */\r\n        function report(node) {\r\n\r\n            /*\r\n             * We used the range instead of the node because it's possible\r\n             * for the same identifier to be represented by two different\r\n             * nodes, with the most clear example being shorthand properties:\r\n             * { foo }\r\n             * In this case, \"foo\" is represented by one node for the name\r\n             * and one for the value. The only way to know they are the same\r\n             * is to look at the range.\r\n             */\r\n            if (!reportedNodes.has(node.range.toString())) {\r\n                const isPrivate = node.type === \"PrivateIdentifier\";\r\n\r\n                context.report({\r\n                    node,\r\n                    messageId: isPrivate ? \"restrictedPrivate\" : \"restricted\",\r\n                    data: {\r\n                        name: node.name\r\n                    }\r\n                });\r\n                reportedNodes.add(node.range.toString());\r\n            }\r\n        }\r\n\r\n        return {\r\n\r\n            Program() {\r\n                globalScope = context.getScope();\r\n            },\r\n\r\n            [[\r\n                \"Identifier\",\r\n                \"PrivateIdentifier\"\r\n            ]](node) {\r\n                if (isRestricted(node.name) && shouldCheck(node)) {\r\n                    report(node);\r\n                }\r\n            }\r\n        };\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}